<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[置顶-CSP2019游记]]></title>
    <url>%2F9102%2F11%2F13%2F%E7%BD%AE%E9%A1%B6-CSP2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Re-start $Day\ -\infty$又双叒叕感冒了啊,记得 NOIP2018 和 SCOI2019 考前也是感冒来着? 这次考试一定要用虚拟机测一测程序… 考前一天的时候感冒差不多好了,感觉还不错. $Day\ 1$开考后看了看题,感觉不太对劲. T1 还算比较顺利,花了几分钟,写完之后测了测样例就扔着了. T2 感觉十分诡异,自己一直在一个奇奇怪怪的二分 + 主席树和一个更奇奇怪怪的 dfs 乱搞中纠结. 先写了乱搞,改了一会,发现还是过不去样例,跑过去写主席树,写到一半的时候发现它假掉了. 此时已经 10:40 左右,赶紧写了一个 $50$ 分暴力打底,感觉自己差不多已经退役了. 然后开始苦苦挣扎,对着代码一通乱改,此时脑子基本是糊的,乱改了半个小时,它突然把所有样例都过了. 自己随便手捏了几个感觉可能出错的小样例试了试,感觉没问题就扔在那了. 去做 T3 ,自然是喜提 $10$ 分的好成绩,最后开了虚拟机测了下样例,就下机了. 下午时听说 T2 两个大样例都很水,有几个大爷写的和我差不多的做法,在回溯时挂掉了,紧张得不行,感觉自己回溯时也没写对,由于自己都记不清 T2 怎么写的了,就没去自测,下午和晚上都在颓隔膜. $Day\ 2$开考后看了看题,看到了熟悉的 $998244353$ ,感觉稍微对劲了一点. 开 T1 ,很快编出了 $84$ 分的做法,过了样例之后,想到了记差的做法,但感觉不可做,决定先看后面的题. 开 T2 ,很快编出了 $64$ 分的做法,过了样例之后决定先看后面的题. 开 T3 ,很快编出了 $55$ 分的做法,过了样例之后,花了些时间打表找出了完美二叉树的规律,把那 $20$ 分也写了. 此时还剩一个小时左右,结果自己啥也没编出来,感觉像个弱智,用虚拟机测了一下样例,就下机了. 感觉考场降智挺严重的. 后记考完的那天下午就回家了,第二天吃午饭的时候突然收到了源代码,发现自己 D1T2 没挂,真是虚惊一场. 似乎拿了个大众分,在家里颓了几天隔膜,然后就投入文化课的怀抱了. 12.2 终于出分了,没有挂分,发现和昨年 noip 考完时的估分一样,只不过昨年挂了 100 多分.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1100 对称轴]]></title>
    <url>%2F2019%2F12%2F07%2Fbzoj-1100-%E5%AF%B9%E7%A7%B0%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[计算几何 + Manacher . 沿着多边形转一圈,把经过的边和角存下来,形成了一个环. 在这个环上断掉一个位置,若形成的序列是回文的,说明断掉的那个边的中点/角处有一条对称轴. 把环倍长成链,一条对称轴会在两端都被统计,用 Manacher 找有多少个长度为 $n$ 的回文串,它的一半就是答案. 判断边是否相同可以直接判长度,判断角是否相同,需要判形成它的两条边的叉积. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=4e5+10;struct v2&#123; int x,y; v2(int x=0,int y=0):x(x),y(y) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x+rhs.x,y+rhs.y); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x-rhs.x,y-rhs.y); &#125; v2 operator * (const double &amp;k) const &#123; return v2(k*x,k*y); &#125; ll modulus() &#123; return 1LL*x*x+1LL*y*y; &#125;&#125;;ll Cross(v2 A,v2 B)&#123; return 1LL*A.x*B.y-1LL*A.y*B.x;&#125;int n,m,tot,ans,r[N];ll s[N],buf[N];void Manacher()&#123; int p=0,mx=0; for(int i=0;i&lt;m;++i) &#123; if(i&gt;mx) r[i]=1; else r[i]=min(mx-i,r[2*p-i]); while(s[i-r[i]]==s[i+r[i]]) ++r[i]; if(i+r[i]-1&gt;mx) mx=i+r[i]-1,p=i; ans+=(r[i]&gt;n); &#125;&#125;v2 p[N];ll Edge(int x)&#123; return (p[x]-p[(x+1)%n]).modulus();&#125;ll Angle(int x)&#123; int y=(x+1)%n; int z=(y+1)%n; return Cross(p[y]-p[x],p[z]-p[y]);&#125;void solve()&#123; memset(r,0,sizeof r); ans=tot=0; n=read(); for(int i=0;i&lt;n;++i) &#123; p[i].x=read(); p[i].y=read(); &#125; for(int i=0;i&lt;n;++i) &#123; s[2*i]=Edge(i); s[2*i+1]=Angle(i); &#125; for(int i=2*n;i&lt;4*n;++i) s[i]=s[i-2*n]; m=4*n; Manacher(); printf("%d\n",ans&gt;&gt;1);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1039 无序运动]]></title>
    <url>%2F2019%2F12%2F07%2Fbzoj-1039-%E6%97%A0%E5%BA%8F%E8%BF%90%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[计算几何 + AC 自动机. 考虑如果给出两个长度相同的点列,如何判断它们能否匹配. 若点数 $=2$ ,则通过平移,旋转,放缩一定可以匹配. 若点数 $&gt;2$ ,先不考虑翻转,只考虑平移,旋转,放缩这三种操作. 如果任意两条相邻的边的边长之比和夹角都相等,就可以匹配. 为了避免精度问题,边长比可以用边长平方比来表示,夹角可以用叉积与点积之比来表示. 将分子分母,化成既约分数保存,注意夹角比值的分子分母都要保留符号. 将这些信息离散化,就变成了数字串的匹配,用 AC 自动机来计算匹配次数. 再考虑翻转操作,若一个点列不是所有点共线,则它翻转后不能和原来的点列通过平移,旋转,放缩匹配. 将它翻转后再做一次上面的匹配. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=2e5+10,M=1.6e6+10,U=(1&lt;&lt;22)-1;int sgn(int x)&#123; return x&gt;0?1:-1;&#125;struct v2&#123; double x,y; v2(double x=0,double y=0):x(x),y(y) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x+rhs.x,y+rhs.y); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x-rhs.x,y-rhs.y); &#125; v2 operator * (const double &amp;k) const &#123; return v2(k*x,k*y); &#125; int modulus() &#123; return x*x+y*y; &#125;&#125;;int Dot(v2 A,v2 B)&#123; return A.x*B.x+A.y*B.y;&#125;int Cross(v2 A,v2 B)&#123; return A.x*B.y-A.y*B.x;&#125;int n,m,ans[M],len[M],l[M],cnt,all[M];struct Info&#123; int a,b,c,d; Info() &#123;&#125; Info(int A,int B,int C,int D) &#123; int g=__gcd(A,B); a=A/g,b=B/g; if(!C) c=0,d=sgn(D); else if(!D) d=0,c=sgn(C); else &#123; g=__gcd(abs(C),abs(D)); c=C/g,d=D/g; &#125; &#125; bool operator &lt;= (const Info &amp;rhs) const &#123; if(a!=rhs.a) return a&lt;rhs.a; if(b!=rhs.b) return b&lt;rhs.b; if(c!=rhs.c) return c&lt;rhs.c; return d&lt;=rhs.d; &#125; bool operator &lt; (const Info &amp;rhs) const &#123; if(a!=rhs.a) return a&lt;rhs.a; if(b!=rhs.b) return b&lt;rhs.b; if(c!=rhs.c) return c&lt;rhs.c; return d&lt;rhs.d; &#125; bool operator != (const Info &amp;rhs) const &#123; return (a!=rhs.a) || (b!=rhs.b) || (c!=rhs.c) || (d!=rhs.d); &#125;&#125; pool[M];bool cmp(const int &amp;x,const int &amp;y)&#123; return pool[x]&lt;pool[y];&#125;int calc(const Info &amp;x)&#123; int l=1,r=cnt,mid,t=0; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(pool[all[mid]]&lt;=x) t=mid,l=mid+1; else r=mid-1; &#125; if(!t) return 0; if(pool[all[t]]!=x) return 0; return t;&#125;int tot,f[M],q[M],tag[M];int head[U+1],G[M],ecnt;struct E&#123; int x,y,z,nx; E() &#123;&#125; E(int _x,int _y,int _z,int _nx) &#123; x=_x,y=_y,z=_z,nx=_nx; &#125;&#125; e[M];struct S&#123; int y,z,nx; S() &#123;&#125; S(int _y,int _z,int _nx) &#123; y=_y,z=_z,nx=_nx; &#125;&#125; s[M];int son(int x,int y)&#123; int u=(x&lt;&lt;8|y)&amp;U; for(int p=head[u]; p; p=e[p].nx) if(e[p].x==x &amp;&amp; e[p].y==y) return e[p].z; e[++ecnt]=E(x,y,++tot,head[u]); head[u]=ecnt; s[ecnt]=S(y,tot,G[x]); G[x]=ecnt; return tot;&#125;int ask(int x,int y)&#123; int u=(x&lt;&lt;8|y)&amp;U; for(int p=head[u]; p; p=e[p].nx) if(e[p].x==x&amp;&amp;e[p].y==y) return e[p].z; return 0;&#125;void solve()&#123; int h=0,t=0,x,y,z,k; f[0]=-1; while(h&lt;=t) for(int i=G[x=q[h++]]; i; i=s[i].nx) &#123; y=s[i].y,q[++t]=z=s[i].z; if(x) for(int j=f[x]; ~j; j=f[j]) if((k=ask(j,y))) &#123; f[z]=k; break; &#125; &#125;&#125;bool oneline[M];v2 a[N];int b[N],c[N];int main()&#123; n=read(),m=read(); for(int i=1; i&lt;=m; ++i) &#123; int k=read(); len[i]=k; for(int j=1; j&lt;=k; ++j) a[j].x=read(),a[j].y=read(); if(k&lt;=2) continue; l[i]=cnt+1; oneline[i]=true; for(int j=2; j&lt;k; ++j) &#123; v2 A=a[j]-a[j-1],B=a[j+1]-a[j]; oneline[i]&amp;=(Cross(A,B)==0); pool[++cnt]=Info(A.modulus(),B.modulus(),Cross(A,B),Dot(A,B)); &#125; &#125; for(int i=1; i&lt;=cnt; ++i) all[i]=i; if(cnt&gt;1) sort(all+1,all+cnt+1,cmp); for(int i=1; i&lt;=n; ++i) a[i].x=read(),a[i].y=read(); for(int i=2; i&lt;n; ++i) &#123; v2 A=a[i]-a[i-1],B=a[i+1]-a[i]; b[i]=calc(Info(A.modulus(),B.modulus(),Cross(A,B),Dot(A,B))); c[i]=calc(Info(A.modulus(),B.modulus(),-Cross(A,B),Dot(A,B))); &#125; for(int i=1; i&lt;=m; ++i) if(l[i]) &#123; int en=l[i]+len[i]-2; int x,j; for(x=0,j=l[i]; j&lt;en; ++j) x=son(x,calc(pool[j])); l[i]=x; &#125; solve(); for(int x=0,i=2; i&lt;n; ++i) &#123; while(x &amp;&amp; !ask(x,b[i])) x=f[x]; tag[x=ask(x,b[i])]++; &#125; for(int i=tot; i; --i) tag[f[q[i]]]+=tag[q[i]]; for(int i=1; i&lt;=m; ++i) if(l[i]) ans[i]+=tag[l[i]]; for(int i=0; i&lt;=tot; ++i) tag[i]=0; for(int x=0,i=2; i&lt;n; ++i) &#123; while(x &amp;&amp; !ask(x,c[i])) x=f[x]; tag[x=ask(x,c[i])]++; &#125; for(int i=tot; i; --i) tag[f[q[i]]]+=tag[q[i]]; for(int i=1; i&lt;=m; ++i) if(l[i] &amp;&amp; !oneline[i]) ans[i]+=tag[l[i]]; for(int i=1; i&lt;=m; ++i) if(!l[i]) printf("%d\n",n-len[i]+1); else printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1094 粒子运动]]></title>
    <url>%2F2019%2F12%2F06%2Fbzoj-1094-%E7%B2%92%E5%AD%90%E8%BF%90%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[计算几何的一些基础操作. 为了后续处理起来方便,可以先将坐标系平移,使得圆心成为坐标系的原点. 考虑枚举两个点,计算它们在移动过程中出现的最近距离来更新答案. 每个点的运动路径是 $k$ 条线段组成的折线,考虑先把这 $k$ 条线段的起止位置,时间都算出来. 尝试去模拟点的运动,通过解方程可以确定在哪里撞上边界,撞上后需要更新速度. 假设交点是 $B$ ,先找到 $A$ 满足 $\vec{AB}=\vec v$ ,求出交点处的法线,把 $A$ 沿着它对称过去得到 $A’$ ,则新的速度为 $\vec{BA’}$ . 点关于直线 $y=\tan\theta \cdot x$ 的对称可以通过角度的运算实现,用 $\alpha,\beta$ 分别表示对称前后的极角,则 $\beta=2\theta-\alpha​$ . 这样可以求出一个点的 $k$ 条线段的信息. 考虑两个点的最近距离,每个点有 $k$ 个关键时间点,所以最多需要考虑 $2k$ 个时间段. 每个时间段内两个点的方向都不会变,设 $t$ 表示「当前时刻 - 该时间段开始的时刻」,则距离的平方是 $t$ 的二次函数. 用二次函数在区间内求最小值的方法,就可以求出该时间段内两点的最近距离,注意可能有退化成一次函数的情况. 时间复杂度 $O(n^2\cdot k)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double inf=2e9,Pi=acos(-1.0),eps=1e-8;const int N=100+10;int n,k;struct v2&#123; double x,y; v2(double x=0,double y=0):x(x),y(y) &#123;&#125; v2 operator + (const v2 &amp;rhs) const &#123; return v2(x+rhs.x,y+rhs.y); &#125; v2 operator - (const v2 &amp;rhs) const &#123; return v2(x-rhs.x,y-rhs.y); &#125; v2 operator * (const double &amp;k) const &#123; return v2(k*x,k*y); &#125; double modulus() &#123; return sqrt(x*x+y*y); &#125;&#125;p[N],v[N];double sqr(double x)&#123; return x*x;&#125;double R,cx,cy,ans=inf;void report(double x)&#123; ans=min(ans,x);&#125;v2 st[N][N],vec[N][N];double t[N][N];double solve(double x,double y,double vx,double vy)// (x+t*vx)^2+(y+t*vy)^2=R^2&#123; double a,b,c; a=vx*vx+vy*vy; b=2*x*vx+2*y*vy; c=x*x+y*y-R*R; double delta=b*b-4*a*c; // assert(delta&gt;0); return (-b+sqrt(delta))/(2*a);&#125;v2 reflect(v2 vel,v2 pos)&#123; v2 A=pos-vel; double dist=A.modulus(); double alpha=atan2(A.y,A.x); double theta=atan2(pos.y,pos.x); double beta=2*theta-alpha; if(beta&gt;2*Pi) beta-=2*Pi; return v2(dist*cos(beta),dist*sin(beta))-pos;&#125;void init(int i)&#123; v2 pos=p[i],vel=v[i]; double tim=0; for(int j=1;j&lt;=k+1;++j) &#123; st[i][j]=pos,t[i][j]=tim,vec[i][j]=vel; if(j&gt;k) break; double tc=solve(pos.x,pos.y,vel.x,vel.y); tim+=tc; pos=pos+vel*tc; vel=reflect(vel,pos); &#125;&#125;double MinDist(double T,v2 pa,v2 pb,v2 va,v2 vb)// t \in [0,T] , Dist^2=at^2+bt+c&#123; double a=sqr(va.x-vb.x)+sqr(va.y-vb.y); double b=2*(va.x-vb.x)*(pa.x-pb.x)+2*(va.y-vb.y)*(pa.y-pb.y); double c=sqr(pa.x-pb.x)+sqr(pa.y-pb.y); double x; if(fabs(a)&lt;eps) &#123; if(b&gt;0) x=0; else x=T; &#125; double mid=-b/(2*a); if(0&lt;=mid &amp;&amp; mid&lt;=T) x=mid; else &#123; if(mid&lt;0) x=0; else x=T; &#125; return sqrt(a*x*x+b*x+c);&#125;void calc(int i,int j)&#123; int k1=1,k2=1; while(k1&lt;=k &amp;&amp; k2&lt;=k) &#123; double Tmin=max(t[i][k1],t[j][k2]); double Tmax=min(t[i][k1+1],t[j][k2+1]); v2 pa=st[i][k1]+vec[i][k1]*(Tmin-t[i][k1]); v2 pb=st[j][k2]+vec[j][k2]*(Tmin-t[j][k2]); report(MinDist(Tmax-Tmin,pa,pb,vec[i][k1],vec[j][k2])); if(t[i][k1+1]&lt;t[j][k2+1]) ++k1; else ++k2; &#125;&#125;int main()&#123; scanf("%lf%lf%lf",&amp;cx,&amp;cy,&amp;R); n=read(),k=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%lf%lf%lf%lf",&amp;p[i].x,&amp;p[i].y,&amp;v[i].x,&amp;v[i].y); p[i].x-=cx; p[i].y-=cy; &#125; for(int i=1;i&lt;=n;++i) init(i); for(int i=1;i&lt;n;++i) for(int j=i+1;j&lt;=n;++j) calc(i,j); printf("%.3f\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2288 大葱的神力]]></title>
    <url>%2F2019%2F12%2F05%2FLoj-2288-%E5%A4%A7%E8%91%B1%E7%9A%84%E7%A5%9E%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[提交答案题. 需要大力观察数据的特点. 测试点 1~2$n,m$ 比较小,爆搜 + 最优化剪枝. 测试点 3只有 $1$ 个抽屉,变成了 01 背包问题. 测试点 4~5每个物品的体积是一样的,那么每个抽屉能容纳的物品数目是确定的,与放哪些物品无关. 建出费用流模型,从源点 $S$ 向每个物品连边,流量为 $1$ ,费用为 $0$ . 从每个物品 $i$ 向每个抽屉 $j$ 连边,流量为 $1$ ,费用为 $w_{ij}$ . 从每个抽屉向汇点 $T$ 连边,流量为它能容纳的物品数目,即 $\lfloor \frac b a\rfloor$ ,费用为 $0$ . 跑一遍最大费用最大流即可求出最优解,为了输出方案,只需在最后检查物品向抽屉连的边中,哪些边有流量. 测试点 6每个物品的体积差别不大,通过验证发现每个抽屉能容纳的物品数目仍是确定的. 于是和上两个测试点做法相同. 测试点 7只有第 $1$ 个物品的体积和其他物品的体积不同,枚举它放在哪个抽屉里面,对剩余的物品,像测试点 4~5 那样做. 测试点 8~10数据没有什么特点,由于这个问题是 NPC 的,并没有什么高论. 可以尝试贪心,或者模拟退火搞一搞,得分各凭本事.]]></content>
      <tags>
        <tag>提交答案</tag>
        <tag>网络流</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191205]]></title>
    <url>%2F2019%2F12%2F05%2Ftest20191205%2F</url>
    <content type="text"><![CDATA[被虐了. $split$ $pal$ $rev$ 如果是 01 序列,可以分治来做,每次从中间剖开,把左边的 $1$ 和右边的 $0$ 换过来. 考虑从高到低区分权值的每个二进制位,代价为 $O(\log a\cdot n\log n)​$ .]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态点分治学习笔记]]></title>
    <url>%2F2019%2F12%2F03%2F%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己根本不会动态点分治,于是来学一学. 在做点分治的时候,把每个重心和它下一层的重心连起来,就形成了一棵新树. 称它为点分树,根据点分治的性质,这棵树的根是原树的重心,且它的树高是 $O(\log n)$ 的. 对于点分树上的每个点,维护它作为重心时管辖的那个连通块的信息. 单点修改某个点的点权时,就在点分树上暴力向上跳,把跳到的点的信息更新一遍,只会修改到 $O(\log n)$ 个点. 于是我们通过在点分树上维护信息,就实现了支持单点修改权值的点分治,这就是动态点分治. 大概可以把点分树维护信息的模式看成线段树维护信息的模式,单点修改时向上不断 pushup 即可. bzoj 1095 捉迷藏如果没有修改操作,直接点分治,在分治中心处用不在一棵子树内的深度最大的两个黑色节点更新一下答案. 现在增加了修改颜色的操作,对每个点开两个 multiset . 第一个 multiset 维护它管辖的所有黑点中到它的父亲的所有距离. 第二个 multiset 维护它在点分树中每个儿子的第一个 multiset 中的最大值,用其中最大的两个数更新答案. 若自己是黑点,那么第二个 multiset 里面还要放入一个 $0$ . 还需要开一个 multiset 维护全局的答案. 有修改操作时,就在点分树上暴力跳,并更新跳到的 multiset 以及维护答案的 multiset. 修改时,把原来的贡献删掉,修改之后,再把新的贡献加进去. 时间复杂度 $O(n\log^2 n)$ . 注意点分树的形态与原树不一样,算距离时要在原树上求出 lca 来算. code bzoj 3730 震波考虑建出点分树,每次询问与 $x$ 距离 $\le k$ 的点权和时,就在点分树上跳. 若从重心 $a$ 跳到了重心 $b$ ,那么 $b$ 所管辖的连通块中,去掉 $a$ 的那一部分,剩下的点到 $x$ 的路径都会经过 $b$ . 那么将 $b$ 所管辖的连通块中,与 $b$ 距离 $\le k-dis(x,b)$ 的点权和计入答案. 再减去 $a$ 所管辖的连通块中,与 $b$ 距离 $\le k-dis(x,b)$ 的点权和. 用动态分配内存,给每个点开 $2$ 个树状数组,都以距离为下标,分别维护到自己的,到父亲的点权前缀和. 修改时就在点分树上跳,把 $O(\log n)$ 个祖先的树状数组都改一遍. 时间复杂度 $O(n\log^2 n)$ ,空间复杂度 $O(n\log n)$ . code bzoj 4372 烁烁的游戏这个题和震波几乎是一样的. 用树状数组去维护以深度为下标的点权差分值就可以了. code SCOI2018 D1T1 树 有一棵 $n$ 个点的无根树,每个点有点权. 需要支持以下两种操作: 询问: 给出一个点 $u$ ,询问从 $u$ 出发的简单路径中,最大的点权和. 修改:将一个点 $u$ 的点权修改为 $v$ . 操作总次数为 $m$ . $n,m\le 10^5$ ,时间限制 3s ,空间限制 64MB . 建出点分树,以 $u$ 出发的简单路径可以看成这样的形式. 从 $u$ 出发,先到 $u$ 在点分树上的某个祖先 $w$ (可以是自己),再到 $w$ 管辖的某个点 $v$ . 对每个点开两个 multiset . 第一个 muliset 维护所有它管辖的点到它在点分树上的父亲的路径权值. 第二个 multiset 维护它在点分树上所有儿子的,第一个 multiset 中的最大值. 询问时,在点分树上往上跳,从 $a$ 跳到 $b$ 时,将 $a$ 对 $b$ 的第二个 multiset 的贡献临时去掉,再查询 $b$ 的第二个 multiset 中的最大值,就一定是从不被 $a$ 管辖的点来的,再加上 $b\to u$ 的点权和 (不算 $b$ ) 来更新答案. 修改时,在点分树上往上跳,把影响到的祖先全部修改过来,并在树状数组上更新重链点权前缀和. 需要一些高超的卡空间技巧. short + char 可以拼出 $\frac 3 4$ 个 int . code]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THUSC2017 选做]]></title>
    <url>%2F2019%2F12%2F02%2FTHUSC2017-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[老张觉得比较简单,但我一道都不会做. 巧克力如果颜色数目比较少,可以暴力枚举是哪 $k$ 种颜色作为连通块中必须包含的颜色. 二分一个美味度作为中位数,大于它的赋值为 $1001$ ,小于等于它的赋值为 $999$ . 这样就达到了一个二元组的效果,会优先个数最少,再尽量让选出的 $999$ 尽量多. 用斯坦纳树进行检验,判一下最优解中, $999​$ 的个数是否 $\ge​$ $1001​$ 的个数. 用随机化乱搞加速,每次将每种颜色随机染成 $[0,k)$ 内的一种颜色,算一遍答案,这样算出来的答案肯定是合法的. 若染色时,将最优解中的 $k$ 种颜色染成了两两不同的颜色,就能求出这个最优解. 即,最劣情况下,只有一种颜色组合是最优解,此时做一次随机化求出正确答案的概率是 $\frac{k!}{k^k}​$ . 当 $k=5$ 时,做 $300$ 次随机化,求不出最优解的概率就只有 $1-(\frac{k}{k!})^{300}\approx 8\times 10^{-6}$ 了. 注意用斯坦纳树处理点权将集合 $S$ 拆成 $S1,S-S1$ 时,会将根节点的点权多算一次,需要减掉. code 杜老师把 $[L,R]$ 内的数可能含有的 $m$ 个质因数找出来,若选了 $x$ ,则 $x$ 含有的奇数次方的质因子出现次数会异或上 $1$ . 于是可以把每个数看成一个 $m$ 位的二进制数,现在要选出一些数,让它们异或起来为 $0$ . 方案数显然为 $2^k$ ,其中 $k$ 表示自由元的个数. 由于是异或方程,所以可以用线性基来代替高斯消元,最后的 $k$ 就是 $R-L+1$ 减去线性基的大小. 异或运算可以用 bitset 进行优化. 直接这样做,时间复杂度是 $O((R-L+1)\cdot \frac{R}{32})$ ,可以获得 $50$ 分. 优化一下,注意到每个数最多会有一个大于 $\sqrt R$ 的质因子,所以一个 $&gt; \sqrt R$ 的质因子一旦出现,线性基里就肯定有它. 于是线性基只需要维护 $\le \sqrt R$ 的质因子. 对于最大质因子相同且 $&gt;\sqrt R$ 的一堆数,只需要把第一个插到线性基里面,后面的异或上它再插进去. 时间复杂度优化到了 $O((R-L+1)\cdot \frac{\sqrt R}{32})$ ,可以获得 $70$ 分. 正解比较神仙,由于 $R\le 10^7$ ,所以当 $R-L&gt;6000$ 时,就认为线性基的大小就是 $[L,R]$ 内所有质数的个数. 当 $R-L\le 6000​$ 时,就用上面那个算法来做. 官方题解的证明 code 换桌考虑先建出一个费用流的模型. 从源点 $S$ 向每个人所在的点连边,流量为 $1$ ,费用为 $0$ . 把同一张桌子的所有点连成一个环,每条边流量为 $\inf$ ,费用为 $0$ . 每个人所在的点向每张桌子对应的点连边,流量为 $1$ ,费用为换桌子需要的代价. 每个点向汇点 $T$ 连边,流量为 $1$ ,费用为 $0$ . 这个图的点数 $|V|$ 是 $O(nm)$ 的,但边数 $|E|$ 是 $O(n^2m)$ 的,可以获得 $70$ 分. 注意到每个人可以去的桌子是一段区间,可以用线段树来优化建边. 因为换桌子的花费有绝对值,所以可以拆成左右两边来做. 开 $2m$ 棵线段树,每个位置有 $2$ 棵线段树,一棵表示向左换桌子的,另一棵表示向右换桌子的. 向左换桌子的线段树,第 $i​$ 个叶子的出边有个额外费用 $-2i​$ ,向右的线段树额外费用为 $2i​$ . 注意要限制对应的两个叶子总流量 $\le 1​$ . 在第 $j​$ 张桌子时,往左边连的边有额外费用 $2j​$ ,往右边连的边有额外费用 $-2j​$ . 仍然把同一张桌子上的叶子节点连成一个环,每条边流量为 $\inf$ ,费用为 $0$ ,这样就考虑了换位置的贡献. 边数被优化到了 $O(m\cdot n\log n)​$ ,跑个 zkw 费用流就可以过了. code 大魔法师用线段树给每段区间维护一个列向量$$\begin{bmatrix}\sum A\\ \sum B \\ \sum C \\ len \end{bmatrix}$$其中 $len$ 表示这个区间的长度. 修改标记可以统一成一个 $4\times 4$ 的转移矩阵,然后就变成线段树的一些基本操作了. 时间复杂度 $O(n\log n\cdot k^3)$ ,其中 $k=4$ . code 如果奇迹有颜色考虑 $Burnside$ 引理,记 $f(i)$ 表示不考虑同构时长度为 $i$ 的合法环的方案数. 则答案为$$ans=\frac{\sum_{i=1}^n f(\gcd(i,n))}{n}=\frac{\sum_{d|n}\varphi(\frac n d)\cdot f(d)}{n}$$于是需要快速求出 $f(d)$ . 考虑暴力状压 $dp$ ,先枚举一个 $s$ 表示开头 $m-1$ 个点的颜色状态. 记 $g(i,t)$ 表示已经给 $i$ 个点染了色,最后 $m-1$ 个点的颜色状态用 $t$ 表示的方案数. 最后判断每个 $g(i,t)$ 的尾部是否能和首部的 $s$ 接在一起,若合法,就计入 $f(i)$ . 每次转移需要枚举当前的点染哪个颜色,每次转移的复杂度是 $O(m)$ . 于是得出状压 $dp$ 的总时间复杂度 $O(n\cdot m^{2m-1})$ . 直接 $dp$ 复杂度显然爆炸,可以在本地把每个 $m$ 对应的前 $1000$ 项 $f(i)$ 打出来,用 $BM$ 求线性递推式. 发现当 $m=7$ 时,线性递推式的长度为 $k=410$ . 于是需要写一个 $O(k^2\log n)$ 的线性递推. 将 $n$ 质因子分解后, $O(\frac {\sqrt n}{\ln n})$ 枚举所有 $d$ ,总时间复杂度 $O(k^2\sqrt n)$ . 最后一个点要特判一下,因为 $n$ 的因数比较多,常数大. code 宇宙广播 不懂为啥要出成提答题,方便调精度? 设公切面为 $\sum_{i=0}^{K-1} a_i\cdot x_i=d​$ ,并保证 $\sum_{i=0}^{K-1} a_i^2=1​$ . 考虑 $K​$ 维空间中一个点 $(x_0,x_1,\dots,x_{K-1})​$ 到这个公切面的距离$$dis=\frac{|d-\sum_{i=0}^{K-1} a_i\cdot x_i|}{\sqrt{\sum_{i=0}^{K-1} a_i^2}}$$保证了分母为 $1$ ,所以这个点到公切面的距离就是 $|d-\sum_{i=0}^{K-1} a_i\cdot x_i|$ . 每个球的球心到公切面的距离都是这个球的半径. 所以对于第 $j$ 个球,可以得到方程 $|d-\sum_{i=0}^{K-1} a_i\cdot x_{j,i}|=r_j$ . 共有 $K$ 个这样的方程,暴力枚举每个方程绝对值取正号还是负号. 确定符号后高斯消元解出每个 $k_i,b_i$ ,表示 $a_i=k_i\cdot d+b_i$ 将所有的 $a_i$ 代入 $\sum_{i=0}^{K-1} a_i^2=1$ 就可以解出 $d$ 了. 解出 $d$ 后,这个公切面也就确定了,只需要再对每个球,求出公切面与这个球的切点. 用高斯消元解一个法向量 $\vec {n}$ 出来,把球心沿着/逆着这个法向量移动 $r$ 的距离,检验一下哪个在平面上,它就是切点了. 时间复杂度 $O(2^K\cdot K^3)​$ . code]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>BM</tag>
        <tag>常系数线性递推</tag>
        <tag>状压dp</tag>
        <tag>提交答案</tag>
        <tag>随机化</tag>
        <tag>斯坦纳树</tag>
        <tag>费用流</tag>
        <tag>线段树连边</tag>
        <tag>burnside</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3878 奇怪的计算器]]></title>
    <url>%2F2019%2F12%2F02%2Fbzoj-3878-%E5%A5%87%E6%80%AA%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[线段树. 注意到每次修改后,所有数的相对大小关系不会发生改变. 于是先将所有数排好序,每次修改时,会有一段前缀被改成 $L$ ,一段后缀被改成 $R$ ,中间的正常修改. 用线段树维护这些数即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int a[MAXN],b[MAXN];struct node&#123; int val,x,addtag,multag,sxtag,settag; node() &#123; addtag=sxtag=settag=0; multag=1; &#125;&#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]void BuildTree(int o,int l,int r)&#123; root.val=root.x=0; if(l==r) &#123; root.val=root.x=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r);&#125;void modify_add(int o,int c)&#123; root.val+=c; root.addtag+=c;&#125;void modify_mul(int o,int c)&#123; root.val*=c; root.addtag*=c; root.multag*=c; root.sxtag*=c;&#125;void modify_sx(int o,int c)&#123; root.val+=root.x*c; root.sxtag+=c;&#125;void modify_set(int o,int c)&#123; root.val=c; root.addtag=root.sxtag=0; root.multag=1; root.settag=c;&#125;void pushdown(int o)&#123; if(root.settag) &#123; modify_set(o&lt;&lt;1,root.settag); modify_set(o&lt;&lt;1|1,root.settag); root.settag=0; &#125; if(root.multag!=1) &#123; modify_mul(o&lt;&lt;1,root.multag); modify_mul(o&lt;&lt;1|1,root.multag); root.multag=1; &#125; if(root.addtag) &#123; modify_add(o&lt;&lt;1,root.addtag); modify_add(o&lt;&lt;1|1,root.addtag); root.addtag=0; &#125; if(root.sxtag) &#123; modify_sx(o&lt;&lt;1,root.sxtag); modify_sx(o&lt;&lt;1|1,root.sxtag); root.sxtag=0; &#125;&#125;void upd_add(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_add(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_add(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_add(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void upd_mul(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_mul(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_mul(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_mul(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void upd_sx(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_sx(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_sx(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_sx(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void upd_set(int o,int l,int r,int L,int R,int c)&#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) return modify_set(o,c); pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd_set(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd_set(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;int query(int o,int l,int r,int pos)&#123; if(l==r) return root.val; pushdown(o); int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query(o&lt;&lt;1,l,mid,pos); else return query(o&lt;&lt;1|1,mid+1,r,pos);&#125;int n,m,lb,rb;struct opt&#123; int op,x;&#125;q[MAXN];char buf[MAXN];int main()&#123; m=read(),lb=read(),rb=read(); for(int i=1;i&lt;=m;++i) &#123; scanf("%s %d",buf,&amp;q[i].x); if(buf[0]=='+') q[i].op=1; else if(buf[0]=='-') q[i].op=1,q[i].x*=-1; else if(buf[0]=='*') q[i].op=2; else q[i].op=3; &#125; n=read(); for(int i=1;i&lt;=n;++i) a[i]=b[i]=read(); sort(a+1,a+1+n); BuildTree(1,1,n); for(int i=1;i&lt;=m;++i) &#123; int op=q[i].op,x=q[i].x,L,R,pre,suf; if(op==1) &#123; L=1,R=n,pre=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(v+x&lt;lb) pre=mid,L=mid+1; else R=mid-1; &#125; L=1,R=n,suf=n+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(v+x&gt;rb) suf=mid,R=mid-1; else L=mid+1; &#125; upd_set(1,1,n,1,pre,lb); upd_set(1,1,n,suf,n,rb); upd_add(1,1,n,pre+1,suf-1,x); &#125; else if(op==2) &#123; L=1,R=n,pre=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*v*x&lt;1LL*lb) pre=mid,L=mid+1; else R=mid-1; &#125; L=1,R=n,suf=n+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*v*x&gt;1LL*rb) suf=mid,R=mid-1; else L=mid+1; &#125; upd_set(1,1,n,1,pre,lb); upd_set(1,1,n,suf,n,rb); upd_mul(1,1,n,pre+1,suf-1,x); &#125; else &#123; L=1,R=n,pre=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*x*a[mid]+v&lt;1LL*lb) pre=mid,L=mid+1; else R=mid-1; &#125; L=1,R=n,suf=n+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int v=query(1,1,n,mid); if(1LL*x*a[mid]+v&gt;1LL*rb) suf=mid,R=mid-1; else L=mid+1; &#125; upd_set(1,1,n,1,pre,lb); upd_set(1,1,n,suf,n,rb); upd_sx(1,1,n,pre+1,suf-1,x); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; int pos=lower_bound(a+1,a+1+n,b[i])-a; printf("%d\n",query(1,1,n,pos)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5006 随机二分图]]></title>
    <url>%2F2019%2F12%2F02%2Fbzoj-5006-%E9%9A%8F%E6%9C%BA%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 考虑如果只有单独的边,可以用状压 $dp$ 来做. 设 $f(S,T)$ 表示左边已经匹配的集合为 $S$ ,右边已经匹配的集合为 $T$ 的期望方案数. 为了避免重复计数,规定加入边的顺序为按照左边点的编号从小到大排序. 现在有边组,考虑仍然把它们看成独立的两条边. 可以发现边组二少算了 $\frac 1 4$ 的贡献,边组三多算了 $\frac 1 4$ 的贡献,把边强行绑在一起形成新边,把这些贡献调整过来. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7,inv2=(P+1)&gt;&gt;1,inv4=(P+1)&gt;&gt;2;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int N=15,M=N*N*3;int n,k,m,U;struct Edge&#123; int l,r,w; Edge(int l=0,int r=0,int w=0):l(l),r(r),w(w) &#123;&#125;&#125;E[M];int lowbit(int x)&#123; return x&amp;(-x);&#125;bool intersect(int S,int T)&#123; return S&amp;T;&#125;map&lt;pair&lt;int,int&gt;,int&gt; f;int dfs(int S,int T)&#123; if(S==U &amp;&amp; T==U) return 1; pair&lt;int,int&gt; tmp=make_pair(S,T); if(f.count(tmp)) return f[tmp]; int ans=0; for(int i=0;i&lt;m;++i) &#123; int l=E[i].l,r=E[i].r,w=E[i].w; if(!intersect(S,l) &amp;&amp; !intersect(T,r) &amp;&amp; intersect(l,lowbit(U-S))) inc(ans,mul(dfs(S^l,T^r),w)); &#125; return f[tmp]=ans;&#125;int main()&#123; n=read(),k=read(); for(int i=0;i&lt;k;++i) &#123; int tp=read(),a=read()-1,b=read()-1; E[m++]=Edge(1&lt;&lt;a,1&lt;&lt;b,inv2); if(tp) &#123; int c=read()-1,d=read()-1; E[m++]=Edge(1&lt;&lt;c,1&lt;&lt;d,inv2); if(a==c || b==d) continue; E[m++]=Edge((1&lt;&lt;a)+(1&lt;&lt;c),(1&lt;&lt;b)+(1&lt;&lt;d),tp==1?inv4:P-inv4); &#125; &#125; U=(1&lt;&lt;n)-1; int ans=mul(1&lt;&lt;n,dfs(0,0)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5019 遗失的答案]]></title>
    <url>%2F2019%2F12%2F01%2Fbzoj-5019-%E9%81%97%E5%A4%B1%E7%9A%84%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[状压 $dp$ + $FWT$ . 若将每个数分解质因数,则 $\rm gcd,lcm$ 的限制等价于给出了每个质因子次数的 $\min,\max$ . 注意到 $n$ 的不同质因子个数 $\omega(n)\le 8$ ,比较少. 用一个 $16$ 位的二进制数 $S$ 表示各个质因子的 $\min,\max$ 是否被取到. 只有那些既是 $\rm gcd$ 倍数,又是 $\rm lcm$ 约数的数才有用,把它们全部爆搜出来,记这样的数共有 $m​$ 个. 记 $f(i,S)​$ 表示考虑了第 $1\sim i​$ 个数,是否被取到的状态为 $S​$ 的方案数. 记 $g(i,S)$ 表示考虑了第 $i\sim m$ 个数,是否被取到的状态为 $S$ 的方案数. 那么强制要求选第 $i$ 个数时,就把 $f(i-1)$ 和 $g(i+1)$ 用 $FWT​$ 做个或卷积. 将那些与第 $i$ 个数的状态 $S_i$ 或起来后为全集 $U$ 的位置上的值加起来,就是答案. $m$ 并不会太大,可以将每次询问的答案记忆化下来,时间复杂度 $O(Q+m\cdot 4^{\omega(n)} \omega(n))$ . 实测发现 $m&lt; 800$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void FWT(int *a,int n)&#123; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(int *p=a;p!=a+n;p+=l) for(int i=0;i&lt;m;++i) inc(p[i+m],p[i]); &#125;&#125;void IFWT(int *a,int n)&#123; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; for(int *p=a;p!=a+n;p+=l) for(int i=0;i&lt;m;++i) inc(p[i+m],P-p[i]); &#125;&#125;const int N=800,M=1&lt;&lt;16;int tot=0,factor[N],l[N],r[N];int n,Gcd,Lcm,m=0;struct info&#123; int a,s; info(int a=0,int s=0):a(a),s(s) &#123;&#125; bool operator &lt; (const info &amp;rhs) const &#123; return a&lt;rhs.a; &#125;&#125;p[N];void dfs(int k,int prod,int st)&#123; if(k==tot) &#123; ++m; p[m].a=prod; p[m].s=st; return; &#125; for(int i=1;i&lt;=l[k];++i) prod*=factor[k]; for(int i=l[k];i&lt;=r[k];++i) &#123; int t=st; if(i==l[k]) t|=1&lt;&lt;k; if(i==r[k]) t|=1&lt;&lt;(k+tot); dfs(k+1,prod,t); if(n/prod&lt;factor[k]) return; prod*=factor[k]; &#125;&#125;int f[N][M],g[N][M],ans[N],tmp[M];int main()&#123; n=read(),Gcd=read(),Lcm=read(); if(Lcm%Gcd) &#123; int Q=read(); while(Q--) puts("0"); return 0; &#125; for(int i=2;i*i&lt;=Lcm;++i) if(Lcm%i==0) &#123; factor[tot]=i; while(Gcd%i==0) ++l[tot],Gcd/=i; while(Lcm%i==0) ++r[tot],Lcm/=i; tot++; &#125; if(Lcm&gt;1) &#123; factor[tot]=Lcm; r[tot]=1; if(Gcd==Lcm) l[tot]=1; tot++; &#125; int N=(1&lt;&lt;(2*tot)); dfs(0,1,0); sort(p+1,p+m+1); f[0][0]=1; for(int i=0;i&lt;m;++i) for(int S=0;S&lt;N;++S) if(f[i][S]) &#123; inc(f[i+1][S],f[i][S]); inc(f[i+1][S|p[i+1].s],f[i][S]); &#125; g[m+1][0]=1; for(int i=m+1;i&gt;1;--i) for(int S=0;S&lt;N;++S) if(g[i][S]) &#123; inc(g[i-1][S],g[i][S]); inc(g[i-1][S|p[i-1].s],g[i][S]); &#125; memset(ans,-1,sizeof ans); int Q=read(); while(Q--) &#123; int c=read(); int x=lower_bound(p+1,p+1+m,info(c,0))-p; if(c!=p[x].a) &#123; puts("0"); continue; &#125; if(ans[x]!=-1) &#123; printf("%d\n",ans[x]); continue; &#125; ans[x]=0; FWT(f[x-1],N); FWT(g[x+1],N); for(int i=0;i&lt;N;++i) tmp[i]=mul(f[x-1][i],g[x+1][i]); IFWT(tmp,N); IFWT(f[x-1],N); IFWT(g[x+1],N); for(int S=0;S&lt;N;++S) if((S|p[x].s)==(N-1)) inc(ans[x],tmp[S]); printf("%d\n",ans[x]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>状压dp</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3684 大朋友和多叉树]]></title>
    <url>%2F2019%2F12%2F01%2Fbzoj-3684-%E5%A4%A7%E6%9C%8B%E5%8F%8B%E4%B8%8E%E5%A4%9A%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[生成函数 + 拉格朗日反演 + 多项式操作. 设 $f(x)$ 表示权值为 $x$ 的神犇多叉树的个数,边界为 $f(1)=1$ . 转移时,枚举根节点有 $k$ 个孩子,转移是将他们全部卷积起来. 设 $F(x)$ 是答案的生成函数,则$$F(x)=\sum_{k\in D} F^k(x) + x$$可以找出它的复合逆 $G(x)=x-\sum_{k\in S} x^k$ . 保证了 $S$ 中的元素 $\ge 2$ ,所以 $F,G$ 的常数项都为 $0$ , $1$ 次项系数都为 $1$ . 于是可以用拉格朗日反演求出 $[x^n] F(x)$ .$$[x^n] F(x)=[x^{n-1}] \frac 1 n (\frac{x}{G(x)})^n$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=950009857,G=7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn;void init(int n)&#123; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; if(curn!=n) init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int a[MAXN],b[MAXN]; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) a[i]=A[i]; for(int i=lenA;i&lt;n;++i) a[i]=0; for(int i=0;i&lt;lenB;++i) b[i]=B[i]; for(int i=lenB;i&lt;n;++i) b[i]=0; DFT(a,n,false); DFT(b,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; B[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;void PolyDiff(int *A,int n)&#123; for(int i=0;i&lt;n-1;++i) A[i]=mul(A[i+1],i+1); A[n-1]=0;&#125;void PolyInt(int *A,int n)&#123; for(int i=n;i&gt;=1;--i) A[i]=mul(A[i-1],fpow(i,P-2)); A[0]=0;&#125;void PolyLn(int *A,int *B,int n)&#123; static int tmp[MAXN],Inv[MAXN]; copy(A,A+n,tmp); PolyDiff(tmp,n); PolyInverse(A,Inv,n); NTT(tmp,Inv,B,n,n); PolyInt(B,n);&#125;void PolyExp(int *A,int *B,int N)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; B[0]=1; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; PolyLn(B,tmp,i); for(int j=0;j&lt;i;++j) tmp[j]=add(A[j],P-tmp[j]); tmp[0]=add(tmp[0],1); NTT(tmp,B,B,i,i); &#125;&#125;void PolyPower(int *A,int *B,int k,int n)&#123; static int tmp[MAXN]; PolyLn(A,tmp,n); for(int i=0;i&lt;n;++i) tmp[i]=mul(tmp[i],k); PolyExp(tmp,B,n);&#125;int n,m,g[MAXN],Invg[MAXN],f[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int k=read(); g[k-1]=P-1; &#125; g[0]=add(g[0],1); PolyInverse(g,Invg,n+1); PolyPower(Invg,f,n,n+1); cout&lt;&lt;mul(f[n-1],fpow(n,P-2))&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>拉格朗日反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日反演学习笔记]]></title>
    <url>%2F2019%2F12%2F01%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[若两个多项式 $F(x),G(x)$ ,都满足常数项为 $0$ , $1$ 次项不为 $0$ ,且两者互为复合逆,即, $G(F(x))=x$ ,则有 $$[x^n] F(x)=\frac 1 n [x^{-1}] \frac{1}{G^n(x)} \\[x^n] F(x)=\frac 1 n [x^{n-1}] (\frac{x}{G(x)})^n$$ 两个式子是等价的,在计算中常用第二个式子. 得到 $G(x)$ 后,用多项式求逆 + 多项式快速幂,可以在 $O(n\log n)$ 的时间复杂度内求出 $F(x)​$ . 证明: 设 $F(x)$ 的各项系数为 $a_i$ ,即 $F(x)=\sum_{i} a_ix^i​$ . 由于 $F(x),G(x)​$ 互为复合逆,代入 $F(G(x))=x​$ ,得到$$\sum_{i} a_i G^i(x) =x$$两边同时对 $x​$ 求导,得到$$\sum_{i} a_i\cdot i\cdot G^{i-1}(x)\cdot G’(x)=1$$两边同时除以 $G^n(x)$ ,得到$$\sum_{i} a_i\cdot i\cdot G^{i-n-1}(x)\cdot G’(x)=\frac{1}{G^n(x)}$$取 $x$ 的 $-1$ 次项,$$[x^{-1}] \sum_{i} a_i\cdot i\cdot G^{i-n-1}(x)\cdot G’(x)=[x^{-1}]\frac{1}{G^n(x)}$$对于那些 $i\neq n$ 的项,注意到 $G^{i-n-1}(x)\cdot G’(x)=\frac{1}{i-n} (G^{i-n})’(x)$ ,是个多项式. 而任何一个多项式求导后 $x^{-1}$ 系数都为 $0$ ,所以这些项对 $x^{-1}$ 的系数没有贡献. 只需要考虑 $i=n​$ 的那一项,即$$[x^{-1}] a_n\cdot n\cdot G^{-1}(x)\cdot G(x)=[x^{-1}]\frac{1}{G^n(x)}$$ 当 $i=n$ 时,$$\begin{aligned}G^{-1}(x)\cdot G’(x)&amp;=\frac{a_1+2a_2x+3a_3x^2+\dots}{a_1x+a_2x^2+a_3x^3+\dots} \\&amp;=\frac{a_1+2a_2x+3a_3x^2+\dots}{a_1 x} \cdot \frac{1}{1+\frac{a_2}{a_1}x+\frac{a_3}{a_1}x^2+\dots}\end{aligned}$$对于 $1+\frac{a_2}{a_1}x+\frac{a_3}{a_1}x^2+\dots$ 这个多项式来说,它的常数项为 $1$ ,所以一定可逆,且求逆后常数项也为 $1$ . 而对于前面那个分数,将它拆开后,只有第一项的次数为 $-1$ ,且这一项的系数为 $1$ . 于是将两者乘起来,得到 $[x^{-1}] F^{-1}(x)\cdot F’(x)=1$ . 代入 $[x^{-1}] a_n\cdot n\cdot G^{-1}(x)\cdot G’(x)=[x^{-1}]\frac{1}{G^n(x)}$ 中,就得到了 $a_n=\frac {1}{n} [x^{-1}] \frac{1}{G^n(x)}$ . 即$$[x^n] F(x)=\frac 1 n [x^{-1}] \frac{1}{G^n(x)}$$由于 $G(x)$ 的常数项为 $0$ ,而一次项不为 $0$ ,所以 $\frac {x}{G(x)}​$ 是可以求的,上面的式子就可以变成$$[x^n] F(x)=\frac 1 n [x^{n-1}] (\frac{x}{G(x)})^n$$]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
        <tag>拉格朗日反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3625 小朋友和二叉树]]></title>
    <url>%2F2019%2F11%2F30%2Fbzoj-3625-%E5%B0%8F%E6%9C%8B%E5%8F%8B%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[生成函数 + 多项式操作. 设 $F(i)$ 表示权值为 $i$ 的二叉树数目, $C(i)$ 表示 $i$ 这个数字是否在集合中出现过. 边界有 $F(0)=1$ ,转移时枚举根节点权值为 $i$ ,左子树权值为 $j$ . $$F(n)=\sum_{i=0}^n C(i)\sum_{j=0}^{n-i} F(j)F(n-i-j)$$ 这个式子和卡特兰数的递推式很像. 利用类似的做法求通项,把 $F,C​$ 都看成多项式,得到$$F=CF^2+[n=0] \\F=CF^2+1 \\F=\frac{1\pm \sqrt{1-4C}}{2C}$$考虑到边界条件 $C(0)=0,\lim _{x\to 0} F(x)=1$ ,可以发现此处应该取 $-$ . 于是得到$$F=\frac{2}{1+\sqrt{1-4C}}$$用多项式开根 + 多项式求逆处理,时间复杂度 $O(n\log n)$ ,多项式开根可以直接套牛顿迭代来做. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3,inv2=(P+1)&gt;&gt;1;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=4e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn;void DFTInit(int n)&#123; if(n==curn) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; DFTInit(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int a[MAXN],b[MAXN]; int lenC=lenA+lenB-1; int n=1; while(n&lt;lenC) n&lt;&lt;=1; copy(A,A+lenA,a); fill(a+lenA,a+n,0); copy(B,B+lenB,b); fill(b+lenB,b+n,0); DFT(a,n,false); DFT(b,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N) // B=A^(-1)&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; B[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;void PolySqrt(int *A,int *B,int N) &#123; int n=1; while(n&lt;N) n&lt;&lt;=1; B[0]=1; static int tmp[MAXN]; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; PolyInverse(B,tmp,i); NTT(tmp,A,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=mul(inv2,add(B[j],tmp[j])); &#125;&#125;int n,m,C[MAXN],tmp[MAXN],F[MAXN];int main()&#123; n=read(),m=read()+1; C[0]=1; for(int i=1;i&lt;=n;++i) &#123; int x=read(); C[x]=P-4; &#125; PolySqrt(C,tmp,m); tmp[0]=add(tmp[0],1); PolyInverse(tmp,F,m); for(int i=1;i&lt;m;++i) printf("%d\n",mul(F[i],2)); return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1263]]></title>
    <url>%2F2019%2F11%2F30%2FCF1263%2F</url>
    <content type="text"><![CDATA[$Div.2$ A. Sweet Problem假设从小到大依次是 $a,b,c$ ,则先把 $a$ 用完,用的时候让 $b,c$ 尽可能接近,最后再加上剩下的 $b$ . B. PIN Codes遇到一个已经出现过的串时,就把它改成一个在全局中都没有出现过的串. 可以改的有 $36$ 种串,而 $n\le 10$ ,所以每次一定都能选出. C. Everyone is a Winner!整除分块裸题.记得把 $0$ 加上. D. Secret Passwords给 $26$ 种字符各自建一个虚拟节点,对于每个串,若它含有字符 $x$ ,就将它向 $x$ 的虚拟节点连边. 用并查集实现上面的过程,最后答案就是含有字符串节点的连通块数目. E. Editor左,右括号分别视作 $+1,-1$ ,用线段树维护每个前缀的权值,以及区间内前缀的最大值,最小值. 修改时是给一段前缀 $+1$ 或者 $-1$ . 询问时,若所有前缀最小值为 $0$ ,且最后一个前缀权值为 $0$ ,则合法. 此时询问的颜色种数,可以发现就是括号的最大深度,即所有前缀的最大值. 光标移到左边就不能移了,没写这个却 pp 了,喜提 FST . F. Economic Difficulties考虑删掉一条边 $u\to v$ 时,子树 $v$ 里面的边就没有任何影响了. 为了让删去的边最多,就把子树 $v$ 里面的边也全部删掉. 从节点 $v$ 来看,可以删掉子树 $v$ 里面的所有边,以及它的父亲边 (如果有) ,这样会覆盖掉一段叶子 $[l,r]$ . 当每个叶子恰好被覆盖一次时,一定是最优的,而且容易发现这一定可以做到. 于是将每个节点看成一条线段 $[l,r]​$ ,并且有一个收益 $c​$ ,要求不重叠地覆盖 $[1,n]​$ 时能获得的最大收益. 设 $f(i)$ 表示不重叠地覆盖 $[1,i]$ 时能获得的最大收益,每条线段 $[l,r]$ 只能去转移 $f(l-1)$ ,时间复杂度 $O(a+b)$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>并查集</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5093 图的价值]]></title>
    <url>%2F2019%2F11%2F29%2Fbzoj-5093-%E5%9B%BE%E7%9A%84%E4%BB%B7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[第二类斯特林数 + $NTT$ . 每个点的贡献可以单独考虑,答案是 $1$ 个点的贡献 $\times n$ ,而 $1$ 个点的贡献可以通过枚举其度数计算. 公式不知道为啥炸了,只好贴图片了. 只用算后面那个 $s=\sum_{i=0}^{n-1} {n-1\choose i}\cdot i^k​$ . 为了方便,把这里的 $n$ 变成 $n-1$ ,即 $s=\sum_{i=0}^{n} {n\choose i}\cdot i^k$ . 套路地,考虑 $i^k$ 的组合意义,它表示将 $k$ 个不同的球放进 $i$ 个不同盒子中的方案数,盒子可以为空. 枚举有 $j$ 个盒子不为空. 而第二类斯特林数 $S(k,j) $ 表示将 $k$ 个球放入 $j$ 个相同的盒子中,盒子不能为空的方案数,于是得到$$i^k=\sum_{j=0}^{i-1}{i\choose j}\cdot S(k,j)\cdot j!$$代入 $s$ 的计算式,得到$$\begin{aligned}s&amp;=\sum_{i=0}^{n} \sum_{j=0}^{i-1} {i\choose j}\cdot j!\cdot S(k,j)\cdot {n\choose i} \\&amp;=\sum_{j=0}^{k} S(k,j)\cdot j!\cdot \sum_{i=0}^{n} {n\choose i}\cdot {i\choose j} \\&amp;=\sum_{j=0}^k S(k,j)\cdot j!\cdot {n\choose j} \cdot 2^{n-j}\end{aligned}$$考虑利用容斥原理计算一行的斯特林数,$$S(n,m)=\frac{1}{m!}\sum_{i=0}^m (-1)^i {m\choose i}(m-i)^n \\=\sum_{i=0}^m \frac{(-1)^i}{i!} \cdot \frac{(m-i)^n}{(m-i)!}$$用 $NTT$ 求出所有的 $S(k,j)$ ,直接带进去计算即可,时间复杂度 $O(k\log k)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3,inv2=(P+1)&gt;&gt;1;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn;void init(int n)&#123; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; if(curn!=n) init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int a[MAXN],b[MAXN]; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) a[i]=A[i]; for(int i=lenA;i&lt;n;++i) a[i]=0; for(int i=0;i&lt;lenB;++i) b[i]=B[i]; for(int i=lenB;i&lt;n;++i) b[i]=0; DFT(a,n,false); DFT(b,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;int fac[MAXN],invfac[MAXN],Inv[MAXN];void InitFac(int k)&#123; fac[0]=1; for(int i=1;i&lt;=k;++i) &#123; fac[i]=mul(fac[i-1],i); Inv[i]=(i==1)?1:mul(Inv[P%i],add(P,-P/i)); &#125; invfac[k]=fpow(fac[k],P-2); for(int i=k-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int S[MAXN],A[MAXN],B[MAXN];int calc(int n,int k)&#123; for(int i=0;i&lt;=k;++i) &#123; A[i]=(i&amp;1)?add(P,-invfac[i]):invfac[i]; B[i]=mul(fpow(i,k),invfac[i]); &#125; NTT(A,B,S,k+1,k+1); int s=0,binom=1,pw=fpow(2,n); for(int i=0;i&lt;=k;++i) &#123; int tmp=mul(S[i],fac[i]); tmp=mul(tmp,mul(binom,pw)); inc(s,tmp); pw=mul(pw,inv2); binom=mul(binom,Inv[i+1]); binom=mul(binom,add(n,P-i)); &#125; return s;&#125;int main()&#123; int n=read(),k=read(); if(n==1) return puts("0")&amp;0; InitFac(k); int ans=calc(n-1,k); ans=mul(ans,n); ans=mul(ans,fpow(2,1LL*(n-1)*(n-2)/2%(P-1))); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3160 万径人踪灭]]></title>
    <url>%2F2019%2F11%2F29%2Fbzoj-3160-%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD%2F</url>
    <content type="text"><![CDATA[$Manacher+FFT$ . 考虑去掉第 $2$ 个限制,即允许选出的位置连续,算出所有的数目后再减去连续的数目. 连续的数目即回文串的数目,可以利用 $Manacher$ 求出,顺便填充间隔字符,便于下面的处理. 为了计算前者,可以考虑每个位置作为回文中心的贡献,若有 $x$ 对字符关于 $i$ 对称,则 $i$ 的贡献为 $2^x-1$ . 而两个相同的字符,若位置分别为 $j,k$ ,则它们关于 $(j+k)/2$ 对称. 分别计算字符 $a,b$ 的贡献,而贡献是一个卷积的形式,模数是 $P-1$ ,但系数不会超过 $n^2$ ,用 $FFT$ 优化. 注意当 $j\neq k$ 时,这对会贡献两次,需要简单处理一下. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double Pi=acos(-1.0);const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;struct Complex&#123; double r,i; Complex(double r=0,double i=0):r(r),i(i) &#123;&#125; Complex operator + (const Complex &amp;rhs) const &#123; return Complex(r+rhs.r,i+rhs.i); &#125; Complex operator - (const Complex &amp;rhs) const &#123; return Complex(r-rhs.r,i-rhs.i); &#125; Complex operator * (const Complex &amp;rhs) const &#123; return Complex(r*rhs.r-i*rhs.i,r*rhs.i+i*rhs.r); &#125; Complex conj() &#123; return Complex(r,-i); &#125; ll out() &#123; return ((ll)(r+0.5)); &#125;&#125;;int rev[MAXN],curn;Complex omega[MAXN],inv[MAXN];void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=Complex(cos(2*Pi/l),sin(2*Pi/l)); inv[l]=omega[l].conj(); &#125; curn=n;&#125;void DFT(Complex *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; Complex gi=omega[l]; if(invflag) gi=inv[l]; for(Complex *p=a;p!=a+n;p+=l) &#123; Complex g=Complex(1,0); for(int i=0;i&lt;m;++i) &#123; Complex t=g*p[i+m]; p[i+m]=p[i]-t; p[i]=p[i]+t; g=g*gi; &#125; &#125; &#125; if(invflag) &#123; Complex invn=Complex(1.0/n,0); for(int i=0;i&lt;n;++i) a[i]=a[i]*invn; &#125;&#125;void FFT(Complex *A,Complex *B,Complex *C,int lenA,int lenB)&#123; static Complex FFT_A[MAXN],FFT_B[MAXN]; int lenC=lenA+lenB-1; int n=1; while(n&lt;lenC) n&lt;&lt;=1; copy(A,A+lenA,FFT_A); fill(FFT_A+lenA,FFT_A+n,Complex(0,0)); copy(B,B+lenB,FFT_B); fill(FFT_B+lenB,FFT_B+n,Complex(0,0)); DFT(FFT_A,n,false); DFT(FFT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=FFT_A[i]*FFT_B[i]; DFT(C,n,true);&#125;int n,tot=0,ans=0,R[MAXN];char buf[MAXN],s[MAXN];void Manacher()&#123; s[++tot]='$'; for(int i=1;i&lt;=n;++i) &#123; s[++tot]='#'; s[++tot]=buf[i]; &#125; s[++tot]='#'; s[++tot]='@'; int p=0,mx=0; for(int i=1;i&lt;=tot;++i) &#123; int j=2*p-i; if(i&gt;mx) R[i]=1; else if(mx-i&gt;R[j]) R[i]=R[j]; else R[i]=mx-i+1; while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; inc(ans,P-(R[i]&gt;&gt;1)); &#125;&#125;ll f[MAXN];Complex A[MAXN];void solve(char ch)&#123; A[0]=Complex(0,0); for(int i=1;i&lt;=tot;++i) &#123; A[i]=Complex(s[i]==ch?1:0,0); if(s[i]==ch) f[2*i]++; &#125; FFT(A,A,A,tot+1,tot+1); for(int i=1;i&lt;=2*tot+1;++i) f[i]+=A[i].out();&#125;int main()&#123; scanf("%s",buf+1); n=strlen(buf+1); Manacher(); solve('a'); solve('b'); for(int i=1;i&lt;=2*tot+1;++i) &#123; f[i]&gt;&gt;=1; inc(ans,add(fpow(2,f[i]%(P-1)),P-1)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 选做]]></title>
    <url>%2F2019%2F11%2F29%2FBJOI2018-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[老张觉得比较简单,但我一道都不会做. 求和把每个点到根的 $k$ 种权值和全部预处理出来,每次求出 $lca​$ 回答询问. 时间复杂度 $O(nk+m\log n)$ . code 二进制考虑给定一个二进制串,如何判断能否重排成 $3$ 的倍数. 这显然只和 $0,1$ 的个数有关,注意到,当 $k$ 为偶数时, $2^k\bmod 3=1$ ,当 $k$ 为奇数时, $2^k\bmod 3=2$ . 于是当 $1$ 的个数为偶数时,一定有解,将 $1$ 都放在后面, $0$ 全部弄成前导 $0$ . 当 $1$ 的个数为奇数时,需要放一个 $10101$ ,剩下的 $1$ 依次放在前面, $0$ 弄成前导 $0$ . 这要求 $1$ 的个数 $\ge 3$ , $0$ 的个数 $\ge 2$ . 整理一下,即,不合法的情况只有两种: $1$ 的个数为奇数,且 $0$ 的数目不超过 $1$ ,或者 $1$ 的个数为 $1$ . 这些区间要么只有一个 $1$ ,要么只有 $1$ 个 $0$ ,或者没有 $0$ ,用 $set$ 维护所有 $0,1$ 的位置,用树状数组维护答案. 时间复杂度 $O(n\log n)​$ . code 染色若不是二分图,显然可以被卡掉.若有度数 $\le 1$ 的节点,显然可以直接去掉. 于是只用考虑每个点的度数 $\ge 2$ 的二分图,不同的连通块可以分开做. 对于完全二分图 $K_{3,3}$ ,样例已经给出了卡掉的方法. 对于完全二分图 $K_{2,4}$ ,一边是 $(AB),(CD)$ ,另一边是 $(AC),(AD),(BC),(BD)$ ,就可以卡掉了. 如果有两个偶环,它们有公共点,且各自独有的点数目 $\ge 2$ ,也可以卡掉. 在一个偶环上构造出 $(AC),(AB),(BC)$ ,之后的点就不能染 $C$ 了. 再换一种颜色在另一个偶环上进行类似的构造,另一种颜色也没法染了. 当一个点的度数 $&gt;3$ 时,一定可以找出两个这样的偶环,于是只考虑最大度数为 $2,3$ 的情况. 当所有点的度数为 $2$ 时,一定是个偶环,显然顺着环染色,是卡不掉的. 于是只剩下了有 $2$ 个点度数为 $3$ ,其余点度数为 $2$ 的情况. 这两个度数为 $3$ 的点之间有 $3$ 条边不相交的路径,只有它们的长度为 $2,2,k$ ,其中 $k$ 为偶数时,是卡不掉的. 而对于 $2,4,4$ 或者 $1,3,3$ 都有卡掉的办法. 整理一下,先把所有度数为 $\le 1$ 的点剥掉. 再对于每个连通块判断其是否为偶环,或恰有两个度数为 $3$ 的点,且两者间的路径长度为 $2,2,k$ ,其中 $k$ 为偶数. 时间复杂度 $O(m)$ . code 双人猜数游戏 手玩了两个小时,喜提 $4$ 分. 按照题目中给的优先级枚举 $a,b$ 作为答案,尝试检验. 设 $f(i,a,b)$ 表示询问了 $i$ 次,若 $m=a,n=b$ ,则它们是否会被猜出来. $i=1$ 时是边界情况,分情况讨论一下. 如果第一次问的是 Alice ,那么能猜出来,当且仅当把 $ab$ 拆成两个 $\ge s$ 的数字之积时方案唯一. 如果第一次问的是 Bob,那么能猜出来,当且仅当把 $a+b$ 拆成两个 $\ge s$ 的数字之和时方案唯一. 对于 $i&gt;1$ 的情况,根据奇偶性判断这次是问的谁. 从可能的数对 $(x,y)$ 中找出 $f(i-1,x,y)$ 为 $0$ 的个数,若只有 $1$ 个,就可以把它猜出来了. 同时,若另一个人在第 $i+1​$ 回合也能猜出这个数对,那么它就是答案了. code 链上二次游戏询问长度在 $[L,R]$ 内的链的权值和时,用长度 $\le R$ 的答案减去长度 $\le L-1$ 的答案. 于是只需要考虑如何计算长度 $\le k$ 的链的权值和. 考虑每个点的贡献,分情况讨论一下每个点会被算多少次,显然用线段树维护 $\sum a_i,\sum a_i\cdot i,\sum a_i \cdot i^2​$ 即可. 时间复杂度 $O(n+m\log n)$ . code 治疗之雨 这个是暗影打击装甲被削之前出的题. 先特判答案为 $-1$ 的情况. 当 $k=0$ 时,答案为 $-1$ . 当 $m=0$ 时,若血量上限 $n&gt;1$ ,且每次扣血 $k=1$ ,答案也为 $-1$ . 对于剩下的情况,设 $E(i)$ 表示当前有 $i$ 点血,被暗影打击装甲打死期望需要的回合数. 由于 $E(0)=0$ ,所以可以不用考虑转移到 $E(0)$ ,也不用处理血量被打成负数的问题. 设 $f(i)$ 表示 $k$ 个暗影打击装甲攻击后,恰好对英雄造成 $i$ 点伤害的概率,容易预处理出来.$$f(i)=\frac{ {k\choose i}\cdot m^{k-i} } { (m+1)^k }$$设 $g(i,j)​$ 表示当前血量为 $i​$ ,一轮后血量变成 $j​$ 的概率,讨论一下 $i​$ 是否为 $n​$ ,就可以根据 $f(i-j)​$ 算出它. 于是对于血量 $i&lt;n$ 的 $E(i)$ ,有转移$$E(i)=\sum_{j=1}^i E(j)\cdot g(i,j)+E(i+1)\cdot g(i,i+1)+1$$对于 $i=n$ 的情况,有转移$$E(i)=\sum_{j=1}^{i} E(j)\cdot g(i,j)+1$$直接做高斯消元,复杂度是 $O(n^3)$ 的. 它虽然不是稀疏矩阵,但注意到每次最多回 $1$ 点血,即, $E(i)$ 要转移到 $j&gt;i$ 的 $E(j)$ ,只可能是 $E(i+1)$ . 于是就可以像树上高斯消元那样搞一搞,将每个 $E(i)$ 都表示成 $k\cdot E(1)+b$ 的形式. 根据转移方程$$E(i)=\sum_{j=1}^i E(j)\cdot g(i,j)+E(i+1)\cdot g(i,i+1)+1$$可以从前往后依次求出每个 $E(i)$ 的 $k,b$ . 而 $E(n)$ 的转移方程还没有用,把所有 $E(i)$ 代入到 $E(n)$ 的转移方程中,就可以解出 $E(1)$ ,代入求得 $E(p)$ . 时间复杂度 $O(T\cdot n^2)$ . code]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>概率/期望</tag>
        <tag>STL</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3456 城市规划]]></title>
    <url>%2F2019%2F11%2F28%2Fbzoj-3456-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[多项式求逆. 要求的是带标号的 $n$ 个点的无向连通图数目. 设 $f(i)$ 表示 $i$ 个点时的答案,可以用图的总数减去不连通的图的数目. 枚举 $1$ 号节点所在连通块的大小为 $i$ 进行转移.$$f(n)=2^{n\choose 2}-\sum_{i=1}^{n-1} {n-1\choose i-1}\cdot f(j)\cdot 2^{n-i\choose 2}$$边界有 $f(1)=1​$ . 为了进行优化,考虑将 $f(n)$ 这一项也弄到 $\sum$ 里面去.可以两边乘上 $\frac {1}{(n-1)!}$ ,整理得到,$$\frac{f(n)}{(n-1)!}+\sum_{i=1}^{n-1} \frac{f(i)\cdot 2^{n-i\choose 2}}{(i-1)!(n-i)!}=\frac{2^{n\choose 2}}{(n-1)!}$$规定 $f(0)=0$ ,就可以把 $f(n)$ 也弄进去了,对比可以验证正确性.$$\sum_{i=0}^{n} \frac{f(i)\cdot 2^{n-i\choose 2}}{(i-1)!(n-i)!}=\frac{2^{n\choose 2}}{(n-1)!}$$等式左边是一个卷积的形式,设三个多项式 $A,B,C$ 分别为$$A(x)=\sum_{i} \frac{f(i)}{(i-1)!} \cdot x^i \\B(x)=\sum_{i}\frac{2^{i\choose 2}}{i!} \cdot x^i \\C(x)=\sum_{i} \frac{2^{i\choose 2}}{(i-1)!} \cdot x^i$$则有 $A(x)B(x)=C(x)$ ,而 $C(x)$ 的最高次数为 $n$ . 于是$$A(x)\equiv B^{-1}(x)\cdot C(x) \pmod {x^{n+1}}$$用多项式求逆解决,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P=1004535809,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL *a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=8e5+10;int rev[MAXN],omega[MAXN],inv[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(p[i+m],g); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; static int NTT_A[MAXN],NTT_B[MAXN]; int lenC=lenA+lenB-1; int n=1; while(n&lt;lenC) n&lt;&lt;=1; copy(A,A+lenA,NTT_A); fill(NTT_A+lenA,NTT_A+n,0); copy(B,B+lenB,NTT_B); fill(NTT_B+lenB,NTT_B+n,0); DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true);&#125;void PolyInverse(int *A,int *B,int N) // A^(-1)=B mod x^N&#123; int n=1; while(n&lt;N) n&lt;&lt;=1; static int tmp[MAXN]; fill(B,B+2*n,0); B[0]=fpow(A[0],P-2); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;int n;int fac[MAXN],invfac[MAXN];int A[MAXN],B[MAXN],invB[MAXN],C[MAXN];int main()&#123; n=read(); fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=fpow(fac[n],P-2); for(int i=n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); B[0]=1,C[0]=0; for(int i=1;i&lt;=n;++i) &#123; B[i]=mul(fpow(2,1LL*i*(i-1)/2%(P-1)),invfac[i]); C[i]=mul(fpow(2,1LL*i*(i-1)/2%(P-1)),invfac[i-1]); &#125; PolyInverse(B,invB,n+1); NTT(invB,C,A,n+1,n+1); int ans=mul(A[n],fac[n-1]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC035 Skolem XOR Tree]]></title>
    <url>%2F2019%2F11%2F26%2FAGC035C-Skolem-XOR-Tree%2F</url>
    <content type="text"><![CDATA[构造题. 当 $n=2^k$ 时,显然无解,因为那两个权值为 $n$ 的点路径上权值异或和一定会 $&lt;n$ . 否则,若 $n$ 为奇数, $n$ 至少为 $3$ ,可以做如下构造: 即,将两组 $1,2,3$ 串在一起,从 $4$ 开始,将 $k,k+1$ 串在一起,分别正着,反着挂在中间那个 $1$ 下面. 容易验证这样做是合法的. 若 $n$ 为偶数,只需要先构造出 $n-1$ 的解,再将两个 $n$ 挂上去. 和中间那个 $1$ 直接相连的点中,包含了 $2\sim n-1$ 的所有权值. 当 $n​$ 不为 $2​$ 的幂的时候,总能在 $2\sim n-1 ​$ 中选出 $2​$ 个数 $x,y​$ ,使得 $x\oplus y\oplus 1=n​$ ,将这两个 $n​$ 挂在上面即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void report(int x,int y)&#123; printf("%d %d\n",x,y);&#125;int N;void solve(int n)&#123; report(1,2); report(2,3); report(3,1+N); report(1+N,2+N); report(2+N,3+N); for(int i=4;i&lt;=n;i+=2) &#123; report(1+N,i+N); report(i+N,i+1+N); report(1+N,i+1); report(i+1,i); &#125;&#125;int main()&#123; int n=read(); N=n; if(__builtin_popcount(n)==1) puts("No"); else &#123; puts("Yes"); if(n&amp;1) solve(n); else &#123; solve(n-1); for(int i=2;i&lt;n;++i) &#123; int j=(n+1)^i; if(1&lt;j &amp;&amp; j&lt;n &amp;&amp; i!=j) &#123; report(n,i&amp;1?i:i+N); report(n+N,j&amp;1?j:j+N); break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tarjan算法学习笔记]]></title>
    <url>%2F2019%2F11%2F25%2Ftarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[发现自己根本不会 $tarjan​$ ,于是来学一学. $tarjan$ 算法的几个不同应用中,都有建出 $dfs$ 树的过程. 若无特殊说明, $dfn$ 表示每个点的 $dfs$ 序, $low$ 表示这个点以及它的所有子孙连的所有点中 $dfn​$ 的最小值. 在无向图中,由父亲走来的那条边不被用作更新 $low​$ ,也不用判断点是否已经入队. 强连通分量对于一个有向图的子图,若子图中的任意两个点可以互相到达,则称这个子图为强连通子图. 强连通分量, $SCC$ ,是极大的强连通子图,即无法通过拓展得到更大的强连通子图. 可以利用 $tarjan​$ 算法求出每个点所在的强连通分量. $dfs$ 时不断将当前节点入栈. 回溯时,若当前节点 $u$ 满足 $dfn(u)=low(u)$ ,则不断弹栈.将这些点都归入一个新的 $SCC$ 中,直到将 $u$ 也弹出. 割点无向图中,若去掉节点 $u$ 以及所有与它关联的边后,连通块的数目增加,则称 $u$ 为割点. 可以利用 $tarjan$ 算法求出所有割点. $dfs$ 时,若节点 $u$ 为其所在连通块的根,则当它的度数 $&gt;1$ 时, $u$ 是割点. 若节点 $u$ 不为根,则当存在一个儿子 $v$ ,满足 $low(v)\ge dfn(u)$ 时, $u$ 是割点. 桥无向图中,若去掉边 $(u,v)​$ 后,连通块的数目增加,则称边 $(u,v)​$ 为桥. 可以利用 $tarjan$ 算法求出所有桥. $dfs$ 回溯时,若 $dfn(u)=low(u)$ ,则边 $(u,fa_u)$ 是桥. 边双连通分量对于一个无向图的连通子图,若任意两点间存在两条边不相交的路径,则称这个子图为边的双连通子图. 这也等价于删掉这个子图中的任意一条边后,这个子图仍然连通,即子图内部不存在桥. 边双连通分量, $e-DCC$ ,简称边双,是极大的边的双连通子图,即无法通过拓展得到边更多的边的双联通子图. 每个点只会属于一个边双,除了桥之外,其他每条边也只会属于一个边双. 可以利用 $tarjan$ 算法求出每个点所在的边双. 若先将所有桥求出,则把所有桥删掉后,剩下的每个连通块就是边双了. 这个过程可以不显式的进行,在 $dfs$ 时,不断将点入栈,若 $dfn(u)=low(u)$ ,说明 $u$ 的父亲边是桥. 不断弹栈,将这些点归入一个新的边双,直到 $u$ 也被弹出. bzoj 1718 Redundant Paths将每个边双缩点,由于原图连通,最后会形成一棵树. 若这棵无向树有 $k$ 个叶子,则只需要将这些叶子两两连一条边,答案为 $\lceil \frac k 2\rceil$ . 由于有重边,所以在跑 $tarjan$ 时不记录父亲节点,而是记录从父亲节点来的边的编号. 时间复杂度 $O(m)​$ . code bzoj 4435 Juice Junctions由于每个点的度数不超过 $3$ ,所以两个点之间的流量只可能是 $0,1,2,3$ ,依次进行判断. 若 $S,T$ 不在同一个连通块,流量为 $0$ . 若 $S,T$ 在一个连通块,但不在一个边双中,流量为 $1$ . 只需要区分 $2$ 和 $3$ ,其实它们分别表示了 $S,T$ 之间有 $2/3$ 条边不相交的路径. 暴力枚举断掉一条边,求出断掉这条边后每个点所在的边双. 若所有的 $m+1$ 种情况下, $S,T$ 所在的边双都一样,则答案为 $3$ ,否则为 $2$ ,这可以利用 $hash$ 进行判断. 时间复杂度 $O(m^2)$ . code bzoj 3590 Quare要用最小的代价把整张图连成一个边双,考虑边双的形成方式,可以这样进行理解. 单独的一个点是一个边双,在一个边双上加入一条链,满足链的首尾都在这个边双中,可以得到更大的边双. 于是可以用状压 $dp$ 来处理这个过程. 设 $f(S)$ 表示将集合 $S$ 中的点连成一个边双的最小花费. 设 $g(S,i,j)$ 表示将集合 $S$ 中的点连成一条首尾是 $i,j$ 的链的最小花费. 转移时枚举这条链,还需要把这条链接进当前的边双中. 设 $h(S,i,0)$ 表示从 $i$ 向 $S$ 中的某一个点连一条边的最小花费. 由于这条链可能只有 $1$ 个点,所以还要设 $h(S,i,1)$ 表示次小花费. 转移时,枚举链的首尾以及链包含的所有点,枚举它接进的边双含有的点.$$f(S)+g(T,i,j)+h(S,i)+h(S,j)\to f(S+T),i\neq j,S\cup T=\emptyset \\f(S)+g(T,i,i)+h(S,i)+g(S,i)\to f(S+T),S\cup T=\emptyset$$需要预处理出 $g,h$ ,瓶颈在 $g$ 的预处理上,时间复杂度 $O(3^n\cdot n^4)$ ,但显然跑不满. code bzoj 4229 选择把所有操作离线下来,倒着做,就变成了加边的同时动态维护边双信息. 利用 $LCT$ 维护边双森林,加边时,若两点未连通,就直接连起来,否则就把这两点路径上的所有点缩成一个边双. 每次要用到一个点时,都改成用它所在边双的那个超级点,这样能够保证 $dfs$ 总复杂度为 $O(n)$ . 用并查集维护每个点所在的边双以及原图的连通性. 时间复杂度 $O(n\log n)​$ . code bzoj 2959 长跑把每个边双缩成一个点,这个超级点的点权为原来所有的点点权之和. 可以发现,答案就是两个点所在边双路径上的超级点权值之和. 由于要支持加边操作,需要用 $LCT$ 动态维护边双,时间复杂度 $O(n\log n)​$ . code 点双连通分量对于一个无向图的连通子图,若任意两点间存在两条除起点终点外点不相交的路径,则称这个子图为点的双连通子图. 这也等价于删掉这个子图中的任意一个点后,这个子图仍然连通,即子图内部不存在割点. 点双连通分量, $v-DCC$ ,简称点双,是极大的点的双连通子图,即无法通过拓展得到点更多的点的双联通子图. 原图中的每个割点可能属于多个点双,但每条边只会属于一个点双. 可以利用 $tarjan$ 算法求出每条边所在的点双. 在 $dfs$ 时不断将边入栈,当通过边 $(u,v)$ 发现 $low(v)\ge dfn(u)$ ,就找到了一个割点 $u$ . 不断弹栈,将弹出的边归入一个新的点双,直到边 $(u,v)$ 也被弹出. bzoj 2730 矿场搭建用 $tarjan$ 算法求出所有点双和割点. 对于一个点双,记它包含的点数为 $x$ ,分以下 $3$ 种情况讨论. 点双内没有割点,那么要在点双中建两个救援点,贡献分别为 $2,{x\choose 2}$ . 点双内有 $1$ 个割点,那么在点双中选一个不是割点的点作为救援点就可以了,贡献分别为 $1,x-1$ . 点双内有 $2$ 个或更多的割点,那么不用在这个点双内建救援点,贡献分别为 $0,1$ . 由于救援点不会建在割点上,所以统计的贡献不会重复. code 广义圆方树在无向图中利用 $tarjan$ 算法求出所有点双,对于每个点双建一个方点,原来的点是圆点. 每个方点向这个点双中所有圆点连边,在圆点上维护这个点的信息,方点上维护这个点双的信息. 这样就可以处理一些与无向图路径,或点双有关的问题了.贴一张网上找来的图. 严格来说,这样形成的新图其实是一个森林,树的数目是原图中连通块的数目. 显然,圆点只会与方点相邻,方点只会与圆点相邻,若两个方点有公共的相邻圆点,则这个圆点代表这两个点双的割点. 注意有圆点和方点,要开两倍的空间. bzoj 1123 BLO把圆方树建出来,去掉一个圆点 $u$ ,增加的不能互通的点对数目就是两端都是圆点,且经过 $u$ 的路径数目. code bzoj 3331 压力考虑把圆方树建出来,那么两个圆点之间的必经点,就是圆方树上两点路径上的所有圆点. 用树上差分打下标记就可以处理了. code bzoj 5138 Push a Box枚举第一步怎么推之后,状态数只有 $O(nm)$ ,只用记录箱子的位置以及人在箱子的哪一个相邻块上. 转移时,有两种决策,一种是推一步箱子,另一种是不移动箱子,走到另一个与箱子相邻的块上. 如下图,当前箱子在黑色格子 $w$ ,人在红色格子 $u$ ,要走到绿色格子 $v$ . 障碍的位置是不变的,一开始就可以直接处理掉,只建出有用的边. 而箱子的位置是可以变化的,这等价于每次询问断掉箱子所在的点 $w$ 后 $u$ 与 $v$ 是否连通. 当没有断掉 $w$ 时, $u\to w\to v$ 是一条合法路径,所以断掉 $w$ 后两者连通,等价于原来 $u,v$ 在一个点双中. 建出圆方树,则等价于询问在树上是否有 $dis(u,v)= 2$ ,这只可能是祖孙或者兄弟关系,简单判一下即可. 时间复杂度 $O(nm)​$ . code bzoj 5463 铁人两项考虑建出圆方树,若枚举 $s,f$ ,则合法的 $c$ 的数目就是 $s$ 到 $f$ 经过的所有点双的点数和减去 $s,f$ 这两个点. 将方点权值设为其代表点双的点数,圆点权值设为 $-1$ ,则合法的 $c$ 的数目就是圆方树上 $s$ 到 $f$ 路径的点权和. 考虑枚举每个点作为 $c​$ 的贡献,就是它的权值与经过它的两端都是圆点的路径数目之积. code 仙人掌和圆方树仙人掌是一种特殊的无向连通图,满足任意一条边最多会在一个简单环上. 仙人掌的圆方树构造,和一般无向图的圆方树构造略有不同. 对于每一个环(点双)建一个方点,这个方点向环内所有圆点连边,不在一个环上的两个圆点之间的边保留. 方点只会和圆点相连,圆点可以与方点相连,也可以与圆点相连. 对于很多仙人掌的题,可以先考虑在树上怎么做,再额外考虑方点怎么处理,尝试将做法搬到圆方树上来. bzoj 4316 小C的独立集在遇到环时,把环的最后一条边断掉,强制第一个点选/不选,对这个环额外做两次 $dp​$ . 其余部分和普通的树形 $dp$ 一样. code bzoj 1023 cactus设 $f(i)$ 表示从节点 $i$ 往下走,能走出的最长路径. 遇到环的时候,把这个环拿出来单独做一次 $dp$ . 假设 $i,j$ 是环上不同的两点,那么可以用 $f(i)+f(j)+dis(i,j)$ 去更新答案. 把这个环上所有点存在一个序列中,还要复制一半接在后面,就可以直接用后面的编号减去前面的编号作为 $dis$ 了. 只有距离不超过环的一半的点才能更新答案,这可以用一个单调队列进行优化转移. 最后还要更新这个环的入点的 $f​$ 值. code bzoj 2125 最短路把圆方树建出来,定义一个环的根为方点的父亲,这相当于在环中取出了一个点作为代表点. 对于圆方边,将权值设为这个圆点到方点的根的最短距离. 询问时,就像在树上询问最短路一样,先求出 $lca$ ,但这里要分情况讨论. 若 $lca$ 是圆点,则可以直接回答. 若 $lca$ 是方点,那么就不能算接在 $lca$ 的那两条边的贡献,而是改成与 $lca$ 相邻的两个圆点的最短距离. 考虑当询问在同一个环上,但都不是代表点的两个点的距离时,不特判 $lca$ 是方点就会出错. code Uoj 189 火车司机出秦川把圆方树建出来,对于每次询问,建出所有关键点的虚树. 需要考虑的贡献分为两部分. 对于虚树上的每条边,代表了圆方树上的一条链,考虑计算出这条链的贡献. 对于虚树上的每个方点,需要算出对应的环上有哪些连续段被计入了贡献. 用树状数组维护每个点到根的树边长度总和 $f$ ,到根的最短路长度 $g$ ,到根的最长路长度 $h$ . 每个环的权值前缀和也需要用树状数组进行维护,这里可以用指针分配内存来实现开多个树状数组. 考虑通过树上差分打标记的方式,判断虚树上每条边有没有被计入最短路/最长路的贡献. 如果只计入了其中一者,则贡献为对应的 $g$ 或 $h$ ,如果两者都被计入,则贡献为 $g+h-f$ . 对于每条路径 $(x,y)$ ,先求出它们的 $lca$ ,若 $lca$ 是圆点,则直接打标记. 否则,把进入 $lca$ 的那两个圆点 $p_x,p_y$ 拿出来,对于路径 $(x,p_x),(y,p_y)$ 打标记,而对 $lca​$ 这个方点特殊处理. 根据询问是最短路/最长路,可以求出这个方点上的 $1$ 或 $2​$ 段区间有贡献,将区间记在这个方点上. 最后对每个方点,将这个方点上的区间排序取并,通过维护的环的权值前缀和计算贡献. 对于修改操作,分树边和环边两种情况讨论. 若修改的是树边,则会影响子树内的 $f,g,h$ . 若修改的是环边,则会影响环的权值前缀和,环上某一段子树的 $f,g$ ,另一段子树的 $f,h$ . 在对应的树状数组上进行修改即可. 时间复杂度 $O(S\log n)$ . code]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>tarjan</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1261]]></title>
    <url>%2F2019%2F11%2F24%2FCF1261%2F</url>
    <content type="text"><![CDATA[$Div.1$ A Messy容易发现在不改变左括号,右括号个数的情况下,把这个序列变成任意一个序列都是可以的. 考虑把括号序列搞成 $()()()()\dots()((()))$ ,即前面放了 $k-1$ 对括号,剩下的括号全部嵌起来,显然是合法的. 对于每个位置 $i$ ,找到从 $i$ 往后第一个需要的括号的位置 $x$ ,把 $[i,x]$ 这一段翻一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e3+10;char s[MAXN];int n,k,val[MAXN],tmp[MAXN];set&lt;int&gt; lp,rp;void rev(int L,int R)&#123; for(int i=L;i&lt;=R;++i) &#123; tmp[i]=val[i]; if(val[i]==1) lp.erase(i); else rp.erase(i); &#125; for(int i=L;i&lt;=R;++i) &#123; val[i]=tmp[R+L-i]; if(val[i]==1) lp.insert(i); else rp.insert(i); &#125;&#125;void fl(int i)&#123; while(1) &#123; int x=*lp.begin(); if(x&lt;i) lp.erase(x); else break; &#125; int x=*lp.begin(); printf("%d %d\n",i,x); rev(i,x);&#125;void fr(int i)&#123; while(1) &#123; int x=*rp.begin(); if(x&lt;i) rp.erase(x); else break; &#125; int x=*rp.begin(); printf("%d %d\n",i,x); rev(i,x);&#125;void solve()&#123; n=read(),k=read(); lp.clear(),rp.clear(); scanf("%s",s+1); for(int i=1; i&lt;=n; ++i) &#123; if(s[i]=='(') val[i]=1,lp.insert(i); else val[i]=-1,rp.insert(i); &#125; printf("%d\n",n); for(int i=1; i&lt;=2*(k-1); ++i) &#123; if(i&amp;1) fl(i); else fr(i); &#125; int L=2*(k-1)+1,R=n; int mid=(L+R)&gt;&gt;1; for(int i=L;i&lt;=mid;++i) fl(i); for(int i=mid+1;i&lt;=R;++i) fr(i);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; B Optimal Subsequences对于每个数定义一个优先度,数字越大,优先度越高,若数字相同,则位置靠前的优先度更高. 那么长度为 $k$ 的最优子序列就是由优先度最大的 $k$ 个数字构成的. 把所有询问离线下来,按照优先度从高到低加入每个数,加入了 $k$ 个数时,就回答所有 $k_i=k$ 的询问. 需要用一颗平衡树,或者权值线段树,来支持插入和求第 $pos$ 个数字. 比赛时没离线询问,写了主席树. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,k,pos,a[MAXN];struct info&#123; int val,pos; bool operator &lt; (const info &amp;rhs) const &#123; if(val!=rhs.val) return val&gt;rhs.val; return pos&lt;rhs.pos; &#125;&#125;p[MAXN];struct node&#123; int ls,rs,siz; node() &#123; ls=rs=siz=0; &#125;&#125;Tree[MAXN*20];int idx=0,rt[MAXN];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void upd(int &amp;o,int pre,int l,int r,int pos)&#123; o=++idx; root=Tree[pre]; ++root.siz; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[pre].ls,l,mid,pos); else upd(root.rs,Tree[pre].rs,mid+1,r,pos);&#125;int query(int o,int l,int r,int k)&#123; if(l==r) return a[l]; int mid=(l+r)&gt;&gt;1; if(lson.siz&gt;=k) return query(root.ls,l,mid,k); else return query(root.rs,mid+1,r,k-lson.siz);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); p[i].val=a[i]; p[i].pos=i; &#125; sort(p+1,p+1+n); for(int i=1;i&lt;=n;++i) upd(rt[i],rt[i-1],1,n,p[i].pos); m=read(); for(int i=1;i&lt;=m;++i) &#123; k=read(),pos=read(); printf("%d\n",query(rt[k],1,n,pos)); &#125; return 0;&#125; C Arson In Berland Forest需要先观察到,每个初始起火的点,最后会形成一个以它为中心,每条边上有 $2T+1$ 个点的正方形. 因为这些正方形可以重叠,所以答案显然是可以二分的. 预处理一个二维前缀和,二分答案后检查是否能用这样的正方形覆盖住所有着火点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;char buf[MAXN];vector&lt;int&gt; a[MAXN],s[MAXN],tmp[MAXN],ans[MAXN];int n,m;bool check(int x)&#123; x=x*2+1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) ans[i][j]=tmp[i][j]=0; for(int i=1;i+x-1&lt;=n;++i) for(int j=1;j+x-1&lt;=m;++j) &#123; int tot=s[i+x-1][j+x-1]-s[i-1][j+x-1]-s[i+x-1][j-1]+s[i-1][j-1]; if(tot==x*x) ans[i][j]=1; &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) tmp[i][j]=tmp[i-1][j]+tmp[i][j-1]-tmp[i-1][j-1]+ans[i][j]; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(a[i][j]) // 判断这个点是否被覆盖 &#123; int tot=tmp[i][j]; if(i&gt;x) tot-=tmp[i-x][j]; if(j&gt;x) tot-=tmp[i][j-x]; if(i&gt;x &amp;&amp; j&gt;x) tot+=tmp[i-x][j-x]; if(!tot) return false; &#125; return true;&#125;int main()&#123; n=read(),m=read(); s[0].resize(m+1),tmp[0].resize(m+1); for(int i=1;i&lt;=n;++i) &#123; a[i].resize(m+1); s[i].resize(m+1); tmp[i].resize(m+1); ans[i].resize(m+1); scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) &#123; a[i][j]=(buf[j]=='X'); s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]; &#125; &#125; int L=0,R=(min(n,m)-1)&gt;&gt;1,res; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) res=mid,L=mid+1; else R=mid-1; &#125; check(res); printf("%d\n",res); for(int i=1;i&lt;=n;++i,puts("")) for(int j=1;j&lt;=m;++j) if(i-res&gt;0 &amp;&amp; j-res&gt;0 &amp;&amp; ans[i-res][j-res]) putchar('X'); else putchar('.'); return 0;&#125; D Wrong Answer on test 233考虑利用生成函数,将 “变换后的答案与变换前的答案之差” 看做 $x$ 的次数. 若位置 $i​$ 与位置 $(i\bmod n)+1​$ 上的数相同,则无论怎样取,这个差都不会变,记这样的位置有 $a​$ 个. 若位置 $i$ 与位置 $(i\bmod n)+1$ 上的数不同,则各有 $1$ 种选法让差 $+1,-1$ ,其余的不变,记这样的位置有 ​$b$ 个. 记 $p=k-2$ ,则这个生成函数为 $k^a\cdot (x+x^{-1}+p)^b$ ,只有次数 $&gt;0​$ 的项的系数会被计入答案. 把后面的式子乘上 $x^b$ ,后面就变成了 $(x^2+px+1)^b$ ,只有次数 $&gt;b$ 的项的系数会被计入答案. 直接用多项式快速幂乘出来,常数太大,不可取. 枚举 $px$ 选了 $i$ 个,则$$k^a\cdot (x^2+px+1)^b=k^a\cdot \sum_{i=0}^b {b\choose i}p^{b-i}x^{b-i}\cdot \sum_{j=0}^i {i\choose j}x^{2j}$$由于只算次数 $&gt;b$ 的项的系数和,对于后面那个 $\sum$ ,只有 $2j&gt;i$ 的 $i\choose j$ 会产生贡献. 当 $i$ 为奇数时,这个贡献是 $2^{i-1}$ ,当 $i$ 为偶数时,这个贡献是 $\frac{2^i-{i\choose i/2}}{2}$ . 时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,inv2=(P+1)&gt;&gt;1;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=2e5+10;int fac[MAXN],invfac[MAXN],pw2[MAXN],pw[MAXN];int binom(int M,int N)&#123; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int n,k,p,a=0,b=0,val[MAXN];int main()&#123; n=read(),k=read(); p=k-2; for(int i=1;i&lt;=n;++i) val[i]=read(); for(int i=1;i&lt;=n;++i) if(val[i]==val[i%n+1]) ++a; else ++b; fac[0]=pw2[0]=pw[0]=1; for(int i=1;i&lt;=b;++i) &#123; fac[i]=mul(fac[i-1],i); pw2[i]=mul(pw2[i-1],2); pw[i]=mul(pw[i-1],p); &#125; invfac[b]=fpow(fac[b],P-2); for(int i=b-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); int ans=0; for(int i=0;i&lt;=b;++i) &#123; int tmp=mul(binom(b,i),pw[b-i]); if(i&amp;1) tmp=mul(tmp,pw2[i-1]); else tmp=mul(tmp,mul(inv2,add(pw2[i],P-binom(i,i&gt;&gt;1)))); inc(ans,tmp); &#125; ans=mul(ans,fpow(k,a)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Not Same先把所有元素从小到大排序,考虑一列一列地去构造出这个解. 这里的 $n$ 指还需要构造的元素的数目. 如果最大的元素 $x&lt;n$ ,则可以从前往后递归构造解. 即,先求出后 $n-1$ 个元素的解,记第一个元素为 $y$ ,再将前 $y$ 个操作加上第一个元素. 如果最大的元素 $=n$ ,这样做时,最后一步就会出现问题. 此时应该构造出一个解,有 $n$ 次操作都包含了最后那个元素,最多有 $1$ 次操作没有包含. 如果次大的元素也 $=n$ ,就将所有除了最后一个元素的 $=n$ 的元素减去 $1$ ,递归构造前 $n-1$ 个元素的解. 次大元素现在是 $n-1$ ,所以前面只可能构造出 $n-1$ 或者 $n$ 个操作. 将这些操作全部加上最后一个元素,若操作数是 $n-1$ ,则还需要加上一个只包含最后一个元素的操作. 如果次大的元素 $&lt;n$ ,记它为 $x$ ,则可以先将开头的 $n-x-1$ 个数全部操作 $1$ 次,. 然后递归构造前 $n-1$ 个元素的解,这样也会得到 $n-1$ 或者 $n$ 个操作. 将这些操作全部加上最后一个元素,若操作数是 $n-1$ ,则还需要加上一个只包含最后一个元素的操作. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define val first#define pos secondvoid solve(vector&lt;pii&gt; A,vector&lt;vector&lt;int&gt;&gt; &amp;ops)&#123; int n=A.size(); if(n==1) &#123; if(A[0].val) ops.push_back(&#123;A[0].pos&#125;); return; &#125; if(A[n-1].val&lt;n) &#123; auto B=A; B.erase(B.begin()); solve(B,ops); for(int i=0;i&lt;A[0].val;++i) ops[i].push_back(A[0].pos); return; &#125; else &#123; auto B=A; B.pop_back(); if(A[n-2].val==n) &#123; vector&lt;int&gt; op; for(int i=0;i&lt;n-1;++i) if(B[i].val==n) &#123; B[i].val--; op.push_back(B[i].pos); &#125; solve(B,ops); for(int i=0;i&lt;ops.size();++i) ops[i].push_back(A[n-1].pos); if(ops.size()&lt;n) ops.push_back(&#123;A[n-1].pos&#125;); ops.push_back(op); &#125; else &#123; int x=A[n-2].val; for(int i=0;i&lt;n-x-1;++i) B[i].val--; solve(B,ops); for(int i=0;i&lt;n-x-1;++i) ops.push_back(&#123;A[i].pos&#125;); for(int i=0;i&lt;ops.size();++i) ops[i].push_back(A[n-1].pos); if(ops.size()&lt;n) ops.push_back(&#123;A[n-1].pos&#125;); &#125; &#125;&#125;int main()&#123; int n=read(); vector&lt;pii&gt; A(n); for(int i=0;i&lt;n;++i) &#123; A[i].val=read(); A[i].pos=i; &#125; sort(A.begin(),A.end()); vector&lt;vector&lt;int&gt;&gt; ops; solve(A,ops); cout&lt;&lt;ops.size()&lt;&lt;endl; for(int i=0;i&lt;ops.size();++i) &#123; string ans(n,'0'); for(int x:ops[i]) ans[x]='1'; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; F Xor-Set考虑建出一颗管辖区间 $[0,2^{60}-1]$ 的线段树,把 $A,B$ 集合的线段各自在这棵线段树上划分出来. 那么这个线段树上一个深度为 $x$ 的节点,代表前 $x$ 位固定后,后面的 $60-x​$ 位任意取,这样的数集合中都有. 那么 $A$ 集合中的一个线段树节点与 $B$ 集合中的一个线段树节点异或,贡献是容易计算的. 由于 $C$ 是集合,所以相同的数只会被算一次,那么把两者固定的长度(红色部分)取个 $\min$ ,贡献不变. 即把黑色部分也看成可以任意取. 在线段树上的意义就是,把深度较深的那个节点向上跳,跳到两者深度相同,贡献不变. 于是可以对集合 $A$ ,只给划分出来的线段树节点打标记,对集合 $B$ ,给划分出来的线段树节点的所有祖先打上标记. 利用线段树的性质可以证明,$A,B$ 各自标记的线段数目不会超过 $4n$ . 枚举每个深度,只计算深度相同的,有标记的节点之间产生的贡献,时间复杂度 $O(n^2\log 10^{18})​$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>平衡树</tag>
        <tag>codeforces</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3159 决战]]></title>
    <url>%2F2019%2F11%2F23%2Fbzoj-3159-%E5%86%B3%E6%88%98%2F</url>
    <content type="text"><![CDATA[树链剖分 + 非旋 treap. 考虑树剖,维护每条重链信息时,由于线段树无法支持翻转操作,把它换成非旋 treap . 给每个重链开一棵非旋 treap ,以深度作为下标. 前面四种操作可以直接做,对于翻转操作,可以把操作到的所有点合成一个 treap ,打完标记后再放回去. 修改操作保证了起点和终点有祖先后代关系,处理起来就简单一些了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10,inf=1e9;char op[10];int n,m,Root;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int idx=0,rt[MAXN];struct node&#123; int ls,rs,fa,rev,tag,mx,mi,siz,info,weight; ll sum; node() &#123; ls=rs=fa=rev=tag=info=0; mx=-inf,mi=inf; siz=0; &#125;&#125;treap[MAXN];#define root treap[o]#define lson treap[root.ls]#define rson treap[root.rs]int newnode(int val)&#123; int o=++idx; root.weight=rand(),root.siz=1; root.info=root.sum=root.mx=root.mi=val; return idx;&#125;void pushup(int o)&#123; root.sum=lson.sum+root.info+rson.sum; root.siz=lson.siz+1+rson.siz; root.mx=max(root.info,max(lson.mx,rson.mx)); root.mi=min(root.info,min(lson.mi,rson.mi));&#125;void reverse(int o)&#123; if(!o) return; root.rev^=1; swap(root.ls,root.rs);&#125;void modify(int o,int c)&#123; if(!o) return; root.tag+=c; root.mx+=c,root.mi+=c; root.info+=c,root.sum+=root.siz*c;&#125;void pushdown(int o)&#123; if(root.rev) &#123; reverse(root.ls); reverse(root.rs); root.rev=0; &#125; if(root.tag) &#123; modify(root.ls,root.tag); modify(root.rs,root.tag); root.tag=0; &#125;&#125;void split(int &amp;x,int &amp;y,int k,int o)&#123; if(!o) x=y=0; else &#123; pushdown(o); if(lson.siz&lt;k) &#123; x=o; split(root.rs,y,k-lson.siz-1,root.rs); &#125; else &#123; y=o; split(x,root.ls,k,root.ls); &#125; pushup(o); &#125; &#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; pushdown(x),pushdown(y); if(treap[x].weight&lt;treap[y].weight) &#123; treap[x].rs=merge(treap[x].rs,y); pushup(x); return x; &#125; else &#123; treap[y].ls=merge(x,treap[y].ls); pushup(y); return y; &#125;&#125;void ins(int id,int val)&#123; rt[id]=merge(rt[id],newnode(val));&#125;ll query_sum(int id,int l,int r)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); ll ans=treap[y].sum; y=merge(y,z); rt[id]=merge(x,y); return ans;&#125;int query_mx(int id,int l,int r)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); int ans=treap[y].mx; y=merge(y,z); rt[id]=merge(x,y); return ans;&#125;int query_mi(int id,int l,int r)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); int ans=treap[y].mi; y=merge(y,z); rt[id]=merge(x,y); return ans;&#125;void upd(int id,int l,int r,int c)&#123; int x,y,z; split(x,y,l-1,rt[id]); split(y,z,r-l+1,y); modify(y,c); y=merge(y,z); rt[id]=merge(x,y);&#125;int siz[MAXN],mxson[MAXN],dep[MAXN],top[MAXN],fa[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;int cnt=0,tot[MAXN],rnk[MAXN],bel[MAXN];void dfs2(int u,int tp)&#123; top[u]=tp,bel[u]=bel[tp]; rnk[u]=++tot[bel[u]]; ins(bel[u],0); if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; bel[v]=++cnt; dfs2(v,v); &#125;&#125;void Increase(int x,int y,int c)&#123; if(dep[x]&lt;dep[y]) swap(x,y); while(top[x]!=top[y]) &#123; upd(bel[x],1,rnk[x],c); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); upd(bel[x],rnk[y],rnk[x],c);&#125;void Invert(int x,int y)&#123; int tx=x,ty=y; if(dep[x]&lt;dep[y]) swap(x,y); int tmp=0,a,b,c,d; while(top[x]!=top[y]) &#123; split(d,rt[bel[x]],rnk[x],rt[bel[x]]); tmp=merge(d,tmp); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); int l=rnk[y],r=rnk[x]; split(a,b,l-1,rt[bel[x]]); split(b,c,r-l+1,b); tmp=merge(b,tmp); reverse(tmp); x=tx,y=ty; if(dep[x]&lt;dep[y]) swap(x,y); while(top[x]!=top[y]) &#123; split(tmp,d,treap[tmp].siz-rnk[x],tmp); rt[bel[x]]=merge(d,rt[bel[x]]); x=fa[top[x]]; &#125; rt[bel[x]]=merge(a,merge(tmp,c));&#125;int t=0;ll Sum(int x,int y)&#123; ll res=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=query_sum(bel[x],1,rnk[x]); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); res+=query_sum(bel[x],rnk[y],rnk[x]); return res;&#125;int Major(int x,int y)&#123; int res=-inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=max(res,query_mx(bel[x],1,rnk[x])); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); res=max(res,query_mx(bel[x],rnk[y],rnk[x])); return res;&#125;int Minor(int x,int y)&#123; int res=inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=min(res,query_mi(bel[x],1,rnk[x])); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); res=min(res,query_mi(bel[x],rnk[y],rnk[x])); return res;&#125;int main()&#123; n=read(),m=read(),Root=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(Root,0); bel[Root]=++cnt; dfs2(Root,Root); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); int x=read(),y=read(); if(op[0]=='I') &#123; if(op[2]=='c') // Increase &#123; int c=read(); Increase(x,y,c); &#125; else // Invert Invert(x,y); &#125; else if(op[0]=='S') // Sum printf("%lld\n",Sum(x,y)); else if(op[0]=='M') &#123; if(op[1]=='a') // Major printf("%d\n",Major(x,y)); else // Minor printf("%d\n",Minor(x,y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>平衡树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3874 宅男计划]]></title>
    <url>%2F2019%2F11%2F22%2Fbzoj-3874-%E5%AE%85%E7%94%B7%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[三分 + 贪心. 乍一看有点像网络流,但天数太大了,没法处理. 先将那些没用的食物扔掉,即,若存在 $i,j$ 满足 $S_i\le S_j,P_i\ge P_j$ ,则 $i$ 这种食物就可以扔掉了. 考虑将外卖小哥来的次数记为 $x​$ ,则在最优策略下,能宅的时间 $f(x)​$ 是一个关于 $x​$ 的先增后减的单峰函数. 这可以感性理解?如果来的次数少,则每次会买贵的,但运费少,若来的次数多,则每次会买便宜的,但运费多. 于是可以三分 $x$ ,考虑在给定 $x$ 时如何计算 $f(x)$ . 每次送外卖时都选择当前最便宜的食物,如果保质期过了,就考虑次便宜的食物,直到买不起了,就退出. 时间复杂度 $O(n\cdot \log S)$ . 注意需要先算一个不算太大的上界. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e2+10;int n,cnt=0;ll f,m;struct node&#123; ll p,s; bool operator &lt; (const node &amp;rhs) const &#123; return s&lt;rhs.s; &#125;&#125;a[MAXN],b[MAXN];ll calc(ll x)&#123; ll money=m-x*f; if(money&lt;=0) return 0; ll res=0,tmp=0; for(int i=1;i&lt;=cnt;++i) &#123; ll d=min(b[i].s-tmp,money/(b[i].p*x)); // 买的个数 tmp+=d,res+=d*x,money-=d*b[i].p*x; if(tmp&lt;b[i].s) &#123; res+=money/b[i].p; break; &#125; &#125; return res;&#125;int main()&#123; m=read(),f=read(),n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].p=read(); a[i].s=read()+1; &#125; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) &#123; while(cnt &amp;&amp; a[i].p&lt;=b[cnt].p) --cnt; b[++cnt]=a[i]; &#125; ll L=1,R=m/(f+b[1].p),ans=0; while(L&lt;=R) &#123; ll k=(R-L+1),l=L+k/3,r=L+k*2/3; ll vl=calc(l),vr=calc(r); if(vl&lt;vr) &#123; L=l+1; ans=vr; &#125; else &#123; R=r-1; ans=vl; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3995 道路修建]]></title>
    <url>%2F2019%2F11%2F21%2Fbzoj-3995-%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[线段树维护区间信息. 利用线段树维护每个区间的答案. 合并两个区间时,把连接处的两条横边都连上,会和两边的竖边形成一个矩形的环,再把这个环的最大边断掉. 对于一个区间,需要维护它的答案,这棵生成树的最左/右的竖边,竖边内横边的最大值,所有横边的最大值. 合并时大力讨论删掉的是哪条边,把参数转移一下,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=6e4+10;int n,m;int rval[2][MAXN],cval[MAXN];struct node&#123; int l,r,ans,lc,rc,lmx,rmx,mx; node()&#123;ans=lmx=rmx=0;&#125; friend node operator + (const node &amp;lson,const node &amp;rson) &#123; node root; root.l=lson.l,root.r=rson.r; root.mx=max(max(lson.mx,rson.mx),max(rval[0][lson.r],rval[1][lson.r])); root.ans=lson.ans+rval[0][lson.r]+rval[1][lson.r]+rson.ans; int mx=max(max(rval[0][lson.r],rval[1][lson.r]),max(lson.rmx,rson.lmx)); if(cval[lson.rc]&lt;mx &amp;&amp; cval[rson.lc]&lt;mx) &#123; root.ans-=mx; root.lc=lson.lc,root.lmx=lson.lmx; root.rc=rson.rc,root.rmx=rson.rmx; &#125; else &#123; root.ans-=max(cval[lson.rc],cval[rson.lc]); if(cval[lson.rc]&lt;cval[rson.lc]) &#123; if(rson.lc==rson.rc) &#123; root.rc=lson.rc; root.rmx=max(max(lson.rmx,rson.mx),max(rval[0][lson.r],rval[1][lson.r])); &#125; else &#123; root.rc=rson.rc; root.rmx=rson.rmx; &#125; root.lc=lson.lc; root.lmx=lson.lmx; &#125; else &#123; if(lson.lc==lson.rc) &#123; root.lc=rson.lc; root.lmx=max(max(lson.mx,rson.lmx),max(rval[0][lson.r],rval[1][lson.r])); &#125; else &#123; root.lc=lson.lc; root.lmx=lson.lmx; &#125; root.rc=rson.rc; root.rmx=rson.rmx; &#125; &#125; return root; &#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root=lson+rson;&#125;void BuildTree(int o,int l,int r)&#123; if(l==r) &#123; root.ans=cval[l]; root.l=root.r=l; root.lc=root.rc=l; root.mx=root.lmx=root.rmx=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void upd(int o,int l,int r,int pos)&#123; if(l==r) &#123; root.ans=cval[l]; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,l,mid,pos); else upd(o&lt;&lt;1|1,mid+1,r,pos); pushup(o);&#125;node query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query(o&lt;&lt;1|1,mid+1,r,L,R); return query(o&lt;&lt;1,l,mid,L,R)+query(o&lt;&lt;1|1,mid+1,r,L,R);&#125;char op[10];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) rval[0][i]=read(); for(int i=1;i&lt;n;++i) rval[1][i]=read(); for(int i=1;i&lt;=n;++i) cval[i]=read(); BuildTree(1,1,n); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); if(op[0]=='C') &#123; int x0=read(),y0=read(),x1=read(),y1=read(),w=read(); if(y0&gt;y1) &#123; swap(x0,x1); swap(y0,y1); &#125; if(y0==y1) &#123; cval[y0]=w; upd(1,1,n,y0); &#125; else if(x0==x1) &#123; rval[x0-1][y0]=w; upd(1,1,n,y0); upd(1,1,n,y1); &#125; &#125; else &#123; int L=read(),R=read(); node tmp=query(1,1,n,L,R); printf("%d\n",tmp.ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191112]]></title>
    <url>%2F2019%2F11%2F12%2Ftest20191112%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+nMciHk18GVFPkiAKreaB8BBDQns4g4Dkf15Qi2B4H4mOaD86QIbK0zz0q7N/efBJJXKwSs2AbfJtvjmf6EHXtAbvdhRa7CV7MOxXbLkenv2r/EA8qKm/M/x3uMD/vBZhFDHbKI5WE/JboCx23DPkPgFT20ayMqbsF+l85KsG33EP8Lz+2aUlbdqNeB34UC6h7e/2nfjMhSz+OChw/2QP+gfniLR++la88h+gk5gx7eGIrBnANoknNNPne0di47OpuC94qTjagbNtHkdlDlv0bV1pFCxSsIrTJ2IxnmA4KJHSamS0GpUpfVGMF1Lkil+UbxCUMtx8nA5nf9xm1QaYFjeABBCbYM7wBuhAqOy7N4KNJNkOMbpqQmVci340x6geVVIUSwVooQH4vZOgRVwSAesN9NVRwkjVCAC5TOhTvEzy64Szg6jBqOPFMsKQHwxvgkWeQgsdlFopIHELZvN49wfKE8Q4KPBXZZyPhSOOQYaszc/a3vNHR8FewuwhsF7WP0ry2RNVPwA7t45b/fbTBjRnl1CMR7hr5ftjpMZqJENdopLWI3xSmXbkJkVhNLLkKvU0ukj+ZfwFn2aDjovZy8TBpZjKuU0hc4v3niCQwNHqMY2TseBfbuAT0CcX8g97f1ROma3/IPjnuzeptTPnpbCLeBEDysGv8kyIo3F2ke5feQ34wSINF+4CB2SDjFx+aSAEJSU1qz9A4iN/tu9+trr3o4H2S6xlGhAT+KR31ZauNjl5kkjYurL2uxHIj3pKlnD/1VSSJGTYMxPb6EAi5kON1eC+nljlnyhs111S8Wxn7oZ1A00aV0GFNzlUmlL1hXDxSX/l5FzHCexq69eJkEPF53kgzps8Qaq9XdyuueTHKmFwIYNt682jC7LgSHaZ5w/Z6VsYRNGrE2lYYv4FqnJcx56EWub0nCvqzjsLQWpUsmBrS4YJPB9ZaTpyZ+cA1vI2TO308/vkuuLGalhIatPbobdrhsqBCLc1DIANo1kxtkCQ912pPJQUVhRoagn5F2+U6Lv+AIqlF3bSpQHZeVMGwK5kjBGxRo8G/z+cTnemcNXSND6oKYV7ZJLsdPXt8oUva+bd7MUOuATmORA9CpeIK3YgJdc1gFbzQiI2iBK5Z+RCfUbf53Bdixo9B3D8B6+9da9rQFEuUi4CD5AqkyXVoJ4c40J141s2bwa72fWD8YwVh0rBuoSDHVfwpivpLakev1NmAv5D+ltoV00OHE3MhaYf2q9acXdbInmlqV0WU/u47x/Zl/ly0+ts78hYZdZW6ihWIa7gOQ36pBM6tbmPyg/zNN2y27KfPN8sxulcRa2zSGS5XJ1xAg/7oqmbAWXXNpvRo2X7tk1IJAu8pv7RDLA7kaDsDUsf+ZyoG2TnbhScj7xwQ3y8kHQkXnob3On8XcFkNTIMW2DCKB4/K95XWHjbxxVnbhYTRYhKn14J19ILhDcIc+W6xoluIfyeVnNm6cISqmuz+hehONARLxkL6A9zldnAoSiRjaF0ZGiPBs9nLOpr0vV8narpjQ5rwoLqYRcA21ydg7nip/NyTUYv56u5mXtYM4mREDNwv8YCIXseX7k1zG99wLqDOArL0pyyhYwZXlpgcWP7CzQbRnFYSHQFvS7c= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3709 Bohater]]></title>
    <url>%2F2019%2F11%2F11%2Fbzoj-3709-Bohater%2F</url>
    <content type="text"><![CDATA[贪心. 首先可以对于 $d\le a$ 的怪物,按照 $d$ 从小到大的顺序,能打的都打掉. 对于剩下的怪,如果能打完,那么最后剩下的血量是确定的,与顺序无关. 倒着看,相当于是撤销掉血药的恢复,再撤销掉受到怪物的伤害,即先 $-a$ ,再 $+d$ . 那么把剩下的怪按照 $a$ 从大到小排序,能打的都打掉就可以了,前后两个阶段其实是对称的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,p=0,q=0;ll cur;struct Monster&#123; int a,d,id; bool type; bool operator &lt; (const Monster &amp;rhs) const &#123; return type?d&lt;rhs.d:a&gt;rhs.a; &#125;&#125;x[MAXN],y[MAXN];int ans[MAXN];bool check()&#123; sort(x+1,x+1+p); sort(y+1,y+1+q); for(int i=1;i&lt;=p;++i) if(cur&lt;=x[i].d) return false; else cur+=x[i].a-x[i].d,ans[i]=x[i].id; for(int i=1;i&lt;=q;++i) if(cur&lt;=y[i].d) return false; else cur+=y[i].a-y[i].d,ans[i+p]=y[i].id; return true;&#125;int main()&#123; n=read(),cur=read(); for(int i=1;i&lt;=n;++i) &#123; Monster tmp; tmp.d=read(),tmp.a=read(),tmp.id=i; if(tmp.d&lt;=tmp.a) tmp.type=true,x[++p]=tmp; else tmp.type=false,y[++q]=tmp; &#125; bool f=check(); puts(f?"TAK":"NIE"); if(f) for(int i=1;i&lt;=n;++i) printf("%d ",ans[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191111]]></title>
    <url>%2F2019%2F11%2F11%2Ftest20191111%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3990 排序]]></title>
    <url>%2F2019%2F11%2F09%2Fbzoj-3990-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[爆搜乱搞. 首先可以注意到,操作的顺序是没有影响的. 从小到大考虑每个操作,若操作了 $k$ 次,且最后合法,则这种方案对答案的贡献为 $k!$ . 在第 $i$ 次操作时,我们把序列分成 $2^{n-i}$ 段,每段长度为 $2^i$ ,则可以交换两个 “半段” . 考虑那些不是连续递增的段,必须在当前这次操作处理,否则之后就被合在一起,无法处理了. 若没有这样的段,则不执行操作. 若有 $1$ 个这样的段,就将该段的前后两部分交换,若合法则继续,否则这种情况没有贡献. 若有 $2$ 个这样的段,则一共有 $4$ 个 “半段” 可以用于交换,枚举 $4$ 种交换情况,若合法,则继续 $dfs$ . 若这样的段 $&gt;2$ 个,则一定没有贡献. 最坏情况下每次都要枚举 $4$ 种交换情况,时间复杂度 $O(4^n\cdot n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=(1&lt;&lt;12)+10,K=12+1;ll fac[K],pw[K],ans=0;int n,a[MAXN];bool invalid(int p,int k)&#123; for(int i=1;i&lt;pw[k];++i) if(a[p+i]!=a[p+i-1]+1) return true; return false;&#125;void swap_part(int x,int y,int k)&#123; for(int i=0;i&lt;pw[k];++i) swap(a[x+i],a[y+i]);&#125;void dfs(int k,int cnt)&#123; if(k&gt;n) return (void)(ans+=fac[cnt]); int t1=0,t2=0; // invalid parts for(int i=1;i&lt;=pw[n];i+=pw[k]) if(invalid(i,k)) &#123; if(!t1) t1=i; else if(!t2) t2=i; else // more than 2 invalid parts return; &#125; if(!t1) // 0 invalid part dfs(k+1,cnt); else if(!t2)// 1 invalid part &#123; swap_part(t1,t1+pw[k-1],k-1); if(!invalid(t1,k)) dfs(k+1,cnt+1); swap_part(t1,t1+pw[k-1],k-1); &#125; else // 2 invalid parts &#123; for(int a=0;a&lt;2;++a) for(int b=0;b&lt;2;++b) &#123; swap_part(t1+a*pw[k-1],t2+b*pw[k-1],k-1); if(!invalid(t1,k) &amp;&amp; !invalid(t2,k)) dfs(k+1,cnt+1); swap_part(t1+a*pw[k-1],t2+b*pw[k-1],k-1); &#125; &#125;&#125;int main()&#123; n=read(); fac[0]=pw[0]=1; for(int i=1;i&lt;=n;++i) &#123; fac[i]=fac[i-1]*i; pw[i]=pw[i-1]*2; &#125; for(int i=1;i&lt;=(1&lt;&lt;n);++i) a[i]=read(); dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XJOI 开放模拟赛Day2 paint]]></title>
    <url>%2F2019%2F11%2F09%2FXJOI-%E5%BC%80%E6%94%BE%E6%A8%A1%E6%8B%9F%E8%B5%9BDay2-paint%2F</url>
    <content type="text"><![CDATA[min-max 容斥 + 树形背包. 有一棵 $n$ 个节点的树,初始每个节点都是白色的. 每次操作会从 $n$ 个节点中等概率随机选出一个点,将这个点以及与它相邻的点染为黑色. 问期望多少次操作后所有点都变成黑色.在模 $998244353$ 意义下求解. $n\le 1000$ . 记 $\max(S)$ 表示集合 $S$ 中的点都变成黑色的期望需要的时间. 记 $\min(S)​$ 表示集合 $S​$ 中的点至少有一个变成黑色的期望需要的时间. 则根据 min-max 容斥,有$$\max(S)=\sum_{T\subseteq S,T\neq \emptyset }(-1)^{|T|-1} \cdot \min(T)$$点数比较大,暴力去算每个 $\min(S)​$ 不可取,但可以注意到 $\min(S)​$ 只与集合 $S​$ 中的点覆盖的点的数目有关. 即,若记 $p(S)=\sum_{i} [\exists j\in S,dis(i,j)\le 1]$ 表示集合 $S$ 能覆盖的点的数目,则 $\min(S)=\frac{n}{p(S)}$ . 而 $p(S)$ 有效的取值只会有 $n$ 种,尝试对于每个 $x$ 求出 $p(S)=x$ 的方案数,再统计答案. 可以用树形背包来求,具体地,设 $f(i,j,0/1,0/1,0/1)$ 表示考虑了子树 $i$ 内的点,覆盖了 $j$ 个点,集合 $S$ 的大小是偶数/奇数,根节点 $i$ 在 $S$ 中/不在 $S$ 中,根节点 $i$ 被覆盖了/没被覆盖 时的方案数. 合并 $u$ 和它的某个儿子 $v$ 的信息后,被覆盖的点数是两棵子树中被覆盖的点数之和,还可能加上 $u$ 或者 $v$ .$$f(u,x,a,b,c)\times f(v,y,A,B,C)\\\to f(u,x+y+[c=0\land B=1]+[C=0\land b=1],a\oplus A,b,c\lor B)$$时间复杂度 $O(n^2)$ .]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>概率/期望</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191108]]></title>
    <url>%2F2019%2F11%2F08%2Ftest20191108%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1++Iq78qLDD8IQFaI1iqZqC4lNjJZ7D9xSszMvjeoBORGDu7M6dGmJ2T3Ua7Ru8f+M2cQR61ovzMLD925S0alSev0OPm8GPUDK4es5wAsPyMI1RSonC/d4d4UrUsFGO14qph0qXh6IYPWlaeeApDAnZjxH+PWvKFokybwQ5GH0vvBbSr1twr9DEkCw3j+aoP8K3CsR7g7nCMZdHkmS9uvO2hWFGso4MQWords/QB/PKl9OuX+XNKEL+TjglhE976txJL3/2nZ5KezA82yEeSXjwICQHEIKetO3gvpOa8Ait2Y5/24TfOqd5nJ5ZYOzPsRS/PFfnMa+0H51ct6mFkzBU3cnkwnAVq3ZQOLlGqXZ/COIvqhjAGyKIf9UPe841i14XugVF/Uv1JDU04nPWdPIYpcfMRqN4GxpxyrLl/aU64htBR1jiHs+ERXa7716F7RkQiqdN2g944tQQn7/zDgNlvBBBLohdes69kcAa5gKXG0WH0lalrHE7/QVTcrx5WYyjz4nAIKvM0seK2sfF5qmbptdyJwmW3ZgI0VO+h5pKA2Ix++N9kGlNL7BoukPVZJaJALTvxIBVQsvwDK195gP7yRoz929a9pGBTTWdL7SwGWH0Ay8DTq7fuigkMPrIEmamd8SjMRCJCgw04UMUsq75bUuTOKc8q5GpMtg6gxan+H7neQDe+QdpPZ32CX3Va1dBAHcRQEvo5hylI79j7eUyH9eGBTX9Whh7KOXzMkiSze6OdG9DvPUlH5hsTcspPrpj6ee4n0USNpqgZvrxrwea58UOdqQLudSdQRL9UpQafc2QwZ85yr1QMkzh7TD2slINn8/xZOVds2cPWnFg0VWa5aeoY5IKpVLG0XazclWDNPjvFMold8jh3/G7l+NlxnIu2tNJFTlaebs4nIBavC0k09Qe8ZCFaJ06ZOAK66oUJbgl61RmnutR8CSi9F3mvMfRVG3ec2q3h45O7mWax88JwM1O/j4FPjvnKH102ygXuSt9r5ynLy3Ft4FA3pwoxykgC36+LMdyflW+C3vY//uUoCivpt16B60uMiLxBBHLsp6VntLjkyJnHPfybH7hLLxIXqMMXD4tPHmJSZ1j0ULXq2Uua/QpZ61aq9kD7vvirzFFoG9V+Dzt01FDBuxsNVmTfIqzFe4chgTH+ca8rIA020AmedijBUwwAPe70U1xviCOuJJ3OPXYt87bSYSy9MPAu8XE4LD3PVWC/bDcvtqvnFzuPjHYy6H9Jc8ZpAi1jZkbh7Pqy7TLZuMsKvbIRenGSHGR7ZNTnyCSJahC1KjKrw4lX2hFf0rw23ilWFiWV5Ua6gBzv6WxqYF2nZxQpvMiEFcGHKmA5QqctMzvlN9qqob8Ncp/D6g0gBajOUWGitLoqN6j1h1gdvo0SYncW4X5/DVyzapBOTKUv6fpB0vyIrS8HhCiXJ21RDCdGKzXAewLAiD8nUytvLz8pY44y13y1i8FkucCp2wgC/pTlkyg3SvZiWQjP0Q5LZOVQWZM+VNjpopJino/7di7igqcjYvpMneH23aUJQW03NdwswmklAYgPfbpshkdi4zm8AxRZoYJnPXvsTbWpNduS0tq1dnIDWe27Cc7TcYXpQNq5xC1Bak3KE4PUiapovstAYVreYDg6Lvv15g2W7mR8E+rUjNk1SVT9h/N7EIIy5AJL5h2CgxWLJfd5ZOPTptclstXrPgHd+1KKzjSivrttvVXGkqvLf/E8IwUKeHzdFHRbErCT7z/u8iHPA9dx35/dS6kXaA8B8Qxok1uXnhBsmE7V9TDvmMPQiBmAg== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>二分</tag>
        <tag>test</tag>
        <tag>启发式合并</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF888G Xor-MST]]></title>
    <url>%2F2019%2F11%2F07%2FCF888G-Xor-MST%2F</url>
    <content type="text"><![CDATA[$Boruvka$ 算法求解最小生成树. 有一张 $n$ 个点的完全图,其中第 $i$ 个点有一个权值 $a_i$ ,两个点 $i,j$ 之间的边权为 $a_i\oplus a_j$ . 需要求出这张完全图的最小生成树的权值. $n\le 2\times 10^5,0\le a_i&lt;2^{30}$ . 利用 $Boruvka​$ 算法求解. 这个算法需要进行若干轮,初始时每个点是一个独立的连通块. 每一轮中,对于每个连通块,找到边权 $w$ 最小的边 $e=(u,v,w)$ ,满足 $u$ 在该块内,而 $v​$ 不在该块内. 将这些边都加入图中,利用并查集维护连通性. 当加入了 $n-1$ 条边后,就得到了一棵最小生成树. 每轮暴力枚举每条边,而每做一轮,连通块数目至少减少为原来的一半,所以时间复杂度为 $O((m+n)\log n)$ . 这个算法的瓶颈在于对于每个连通块找出连出去的边中,边权最小的那条边. 可以利用 $Trie$ 树优化这个找边过程,时间复杂度优化到 $O(n\log a\log n)$ . 这类套路题大概是每个点有点权,任意两点之间的边权由二者的点权决定,需要求最小生成树. 做法大致都和这道题类似,尝试去优化找最优边的过程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,K=30;const int inf=0x7fffffff;struct Trie&#123; int idx; Trie()&#123;idx=1;&#125; int ch[MAXN*K][2],val[MAXN*K],id[MAXN*K]; void ins(int x,int v,int k) &#123; int u=1; for(int i=K-1;i&gt;=0;--i) &#123; int c=(x&gt;&gt;i)&amp;1; if(!ch[u][c]) ch[u][c]=++idx; u=ch[u][c]; val[u]+=v; &#125; id[u]=k; &#125; int query(int x) &#123; int u=1; for(int i=K-1;i&gt;=0;--i) &#123; int c=(x&gt;&gt;i)&amp;1; if(val[ch[u][c]]) u=ch[u][c]; else u=ch[u][c^1]; &#125; return id[u]; &#125;&#125;T;int n,m=0,a[MAXN],fa[MAXN],p[MAXN];int Find(int x)&#123; return fa[x]==x?x:fa[x]=Find(fa[x]);&#125;bool cmp(int x,int y)&#123; return fa[x]&lt;fa[y];&#125;void init()&#123; for(int i=1;i&lt;=n;++i) &#123; p[i]=fa[i]=i; T.ins(a[i],1,i); &#125;&#125;pair&lt;int,int&gt; mi[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); n=unique(a+1,a+1+n)-a-1; init(); ll ans=0; while(m&lt;n-1) &#123; for(int i=1;i&lt;=n;++i) fa[i]=Find(i); sort(p+1,p+1+n); for(int i=1;i&lt;=n;++i) mi[i]=make_pair(i,inf); int Fa; for(int l=1,r;l&lt;=n;++l) &#123; Fa=fa[p[l]]; r=l; while(r+1&lt;n &amp;&amp; fa[p[r+1]]==Fa) ++r; for(int i=l;i&lt;=r;++i) T.ins(a[p[i]],-1,p[i]); for(int i=l;i&lt;=r;++i) &#123; int x=p[i]; int y=T.query(a[x]); if((a[x]^a[y])&lt;mi[Fa].second) mi[Fa]=make_pair(y,a[x]^a[y]); &#125; for(int i=l;i&lt;=r;++i) T.ins(a[p[i]],1,p[i]); l=r; &#125; for(int i=1;i&lt;=n;++i) &#123; int x=Find(i),y=Find(mi[i].first); if(x==y) continue; fa[x]=y; ans+=mi[i].second; ++m; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Trie</tag>
        <tag>Boruvka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191106]]></title>
    <url>%2F2019%2F11%2F06%2Ftest20191106%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>博弈论</tag>
        <tag>高斯消元</tag>
        <tag>虚树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1246]]></title>
    <url>%2F2019%2F11%2F05%2FCF1246%2F</url>
    <content type="text"><![CDATA[$Div.1$ A p-binary考虑从小到大枚举答案 $k$ ,则需要满足$$n-k\cdot p=\sum_{i=1}^{k} 2^{b_i}$$其中每个 $b_i$ 表示选择了数字 $2^{b_i}+p$. 判断这个 $k$ 是否有解,只需要判断 $popcount(n-kp)\le k$ 是否成立. 若 $n-kp$ 二进制下的 $1$ 的个数比 $k$ 大,则这个 $k$ 无解. 否则,当 $n-kp$ 二进制下的 $1$ 的个数 $\le k$ 时,总可以把 $2^i$ 拆成 $2^{i-1}+2^{i-1}$ ,而凑够 $k$ 个数,即找到一组解. 当 $n\le kp$ 时,就可以退出了,若此时仍未找到解,则一定无解. 1234567891011121314151617181920212223242526272829303132333435363738//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;#define lowbit(x) x&amp;(-x)int popc(int x)&#123; int s=0; while(x) ++s,x-=lowbit(x); return s;&#125;int n,p;int solve()&#123; for(int k=1;k&lt;=31;++k) if(n-k*p&gt;=k &amp;&amp; popc(n-k*p)&lt;=k) return k; return -1;&#125;int main()&#123; n=read(),p=read(); cout&lt;&lt;solve()&lt;&lt;endl; return 0;&#125; B Power Products把每个数质因数分解,得到$$x=\prod p_i^{b_i}$$这个指数 $b_i$ 可以对 $k$ 取模. 那么对于一个 $a_j$ 来说,找到的 $a_i$ 需要满足,对于每个质因子 $p_i$ ,两者的指数相加在模 $k$ 意义下为 $0$ . 用 $hash$ 去压缩每个数的每个质因子的次数. 在 CF 上写 hash 一定要写双进制模数啊. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k;typedef pair&lt;int,int&gt; pii;#define mp make_pairmap&lt;pii,int&gt; cnt;struct Hash&#123; int P,Base; int add(int a,int b) &#123; return (a+b&gt;=P)?(a+b-P):(a+b); &#125; int mul(int a,int b) &#123; return 1LL * a * b % P; &#125; int pw[MAXN]; void init(int p,int base) &#123; P=p,Base=base; pw[0]=1; for(int i=1;i&lt;=100000;++i) pw[i]=mul(pw[i-1],Base); &#125; pii calc(int x) // (x,-x) &#123; int a=0,b=0; for(int i=2;i*i&lt;=x;++i) if(x%i==0) &#123; int t=0; while(x%i==0) x/=i,++t; t%=k; a=add(a,mul(pw[i],t)); t=(k-t)%k; b=add(b,mul(pw[i],t)); &#125; if(x&gt;1) &#123; int t=1,i=x; a=add(a,mul(pw[i],t)); t=(k-t)%k; b=add(b,mul(pw[i],t)); &#125; return mp(a,b); &#125;&#125;A,B;int main()&#123; A.init(1e9+7,137); B.init(998244353,37); n=read(),k=read(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; int x=read(); pii upd,query; pii t=A.calc(x); upd.first=t.first,query.first=t.second; t=B.calc(x); upd.second=t.first,query.second=t.second; ans+=cnt[query]; ++cnt[upd]; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Rock Is Push 从那几张样例解释的 GIF 图中大概就能看出做法了. 每次进行 $dp$ 转移时考虑连续移动一段,直到改变移动方向. 设 $f(i,j,k=0/1)$ 表示从 $(1,1)$ 出发,走到 $(i,j)​$ ,且当前应该向 右/下 走的方案数. 由于每次移动之后都会切换方向,所以 一行/一列 只会被走一次,那么每次移动之间就不会互相影响了. 当 $k=0$ 时,往右边走,若 $(i,j+1)\sim (i,m)$ 这些位置共有 $x$ 个空位,那么往右最多可以走 $t$ 步. 当 $k=1$ 时,往下面走,若 $(i+1,j)\sim (n,j)$ 这些位置共有 $y$ 个空位,那么往下最多可以走 $t$ 步. 转移需要优化,如果直接上二维树状数组,时间复杂度是 $O(n^2\log^2 n)$ 的,不是很优. 可以利用前缀和的方式进行优化. 计算 $f(i,j,1)$ 时,考虑在 $f(i,j-1,1)$ 的基础上,减掉那些恰好只能到达 $j-1$ 这个位置的贡献,这可以用桶存起来. 如果合法,还需要加上 $f(i,j-1,0)$ 对 $f(i,j,1)$ 的贡献. 计算 $f(i,j,0)$ 同理. 时间复杂度 $O(n^2)$ . 特判 $n=m=1$ 的情况,否则因为根本上没有移动,导致 $f(1,1,0)$ 和 $f(1,1,1)$ 都被算入答案了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;char buf[MAXN];int n,m,Free[MAXN][MAXN];int x[MAXN][MAXN],y[MAXN][MAXN],f[MAXN][MAXN][2];void init()&#123; for(int i=1; i&lt;=n; ++i) &#123; scanf("%s",buf+1); for(int j=1; j&lt;=m; ++j) Free[i][j]=(buf[j]=='.'); &#125; for(int i=1; i&lt;=n; ++i) &#123; int tmp=0; for(int j=m; j&gt;=1; --j) &#123; x[i][j]=tmp; tmp+=Free[i][j]; &#125; &#125; for(int j=1; j&lt;=m; ++j) &#123; int tmp=0; for(int i=n; i&gt;=1; --i) &#123; y[i][j]=tmp; tmp+=Free[i][j]; &#125; &#125;&#125;int sum[2][MAXN][MAXN];int solve()&#123; if(n==1 &amp;&amp; m==1) return Free[n][m]; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) &#123; if(i==1 &amp;&amp; j==1) f[i][j][0]=f[i][j][1]=1; else &#123; if(j==1) f[i][j][1]=0; else if(i==1) f[i][j][1]=(x[1][1]&gt;=j-1); else &#123; f[i][j][1]=f[i][j-1][1]; inc(f[i][j][1],P-sum[1][i][j-1]); if(x[i][j-1]&gt;=1) inc(f[i][j][1],f[i][j-1][0]); &#125; if(i==1) f[i][j][0]=0; else if(j==1) f[i][j][0]=(y[1][1]&gt;=i-1); else &#123; f[i][j][0]=f[i-1][j][0]; inc(f[i][j][0],P-sum[0][i-1][j]); if(y[i-1][j]&gt;=1) inc(f[i][j][0],f[i-1][j][1]); &#125; &#125; if(y[i][j]) inc(sum[0][i+y[i][j]][j],f[i][j][1]); if(x[i][j]) inc(sum[1][i][j+x[i][j]],f[i][j][0]); &#125; return add(f[n][m][0],f[n][m][1]);&#125;int main()&#123; n=read(),m=read(); init(); cout&lt;&lt;solve()&lt;&lt;endl; return 0;&#125; D Tree Factory考虑倒着来实现这个过程,即从给出的树开始,不断操作,用最少的操作次数将它变成一条链. 若一个节点 $u$ 有 $v,w$ 两个儿子,则操作一次可以将子树 $v$ 接在子树 $w$ 下面. 不难发现,每次选择可操作的子树中,最大深度最大的那一颗,将它接在其他子树下面,会使最大深度 $+1​$ . 而当最大深度 $=n-1$ 时,就成了一条链了. 那么总操作次数一定是 $n-1-maxdep$ ,其中 $maxdep$ 表示初始时树中节点最大的深度. 对操作过程进行模拟即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//%std#include&lt;bits/stdc++.h&gt;#define endl '\n'using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;vector&lt;int&gt; G[MAXN];int n,dep[MAXN],fa[MAXN],mxson[MAXN];vector&lt;int&gt; ans,op;void dfs(int u)&#123; if(u) &#123; int cnt=dep[ans.back()]-dep[fa[u]]; while(cnt--) op.push_back(u); &#125; ans.push_back(u); for(auto v:G[u]) if(v^mxson[u]) dfs(v); if(mxson[u]) dfs(mxson[u]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; fa[i]=read(); G[fa[i]].push_back(i); dep[i]=dep[fa[i]]+1; &#125; int p=max_element(dep,dep+n)-dep; while(p) &#123; mxson[fa[p]]=p; p=fa[p]; &#125; dfs(0); for(auto x:ans) printf("%d ",x); puts(""); printf("%llu\n",op.size()); for(auto x:op) printf("%d ",x); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191105]]></title>
    <url>%2F2019%2F11%2F05%2Ftest20191105%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>状压dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3999 旅游]]></title>
    <url>%2F2019%2F11%2F04%2Fbzoj-3999-%E6%97%85%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[树链剖分 + 线段树. 先写一个树链剖分. 再用线段树维护信息,每个区间需要维护最大值,最小值,前面某个数减后面某个数的最大值,最小值. 修改操作比较简单,对于询问操作,先用分割出的线段树区间的最值更新答案,再将所有分割出的区间按照经过的顺序排序,暴力枚举两个区间,用前一个区间的最小值减去后一个区间的最大值更新答案. 在线段树上处理时,需要注意移动的方向. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf=1e9;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int val[MAXN],dfn[MAXN],rnk[MAXN],idx=0;int siz[MAXN],dep[MAXN],mxson[MAXN],fa[MAXN],top[MAXN];void dfs1(int u,int f)&#123; siz[u]=1; fa[u]=f; for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;struct node&#123; ll tag; ll v[2],delta[2]; int tim; bool operator &lt; (const node &amp;rhs) const &#123; return tim&lt;rhs.tim; &#125;&#125; Tree[MAXN&lt;&lt;2];int lt,rt,tot;ll ans;node tmp[MAXN];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root.v[0]=max(lson.v[0],rson.v[0]); root.v[1]=min(lson.v[1],rson.v[1]); root.delta[0]=max(lson.delta[0],rson.delta[0]); root.delta[0]=max(root.delta[0],rson.v[0]-lson.v[1]); root.delta[1]=max(lson.delta[1],rson.delta[1]); root.delta[1]=max(root.delta[1],lson.v[0]-rson.v[1]);&#125;void BuildTree(int o,int l,int r)&#123; root.tag=0; if(l==r) &#123; root.v[0]=root.v[1]=val[rnk[l]]; root.delta[0]=root.delta[1]=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void modify(int o,int c)&#123; root.tag+=c; root.v[0]+=c; root.v[1]+=c;&#125;void pushdown(int o)&#123; if(root.tag) &#123; modify(o&lt;&lt;1,root.tag); modify(o&lt;&lt;1|1,root.tag); root.tag=0; &#125;&#125;void query(int o,int l,int r,int L,int R,int dir,int c) // dir=0 left-&gt;right dir=1 right-&gt;left&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; ans=max(ans,root.delta[dir]); tmp[++tot]=root; if(!dir) tmp[tot].tim=rt--; else tmp[tot].tim=lt++; modify(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(R&gt;mid) query(o&lt;&lt;1|1,mid+1,r,L,R,dir,c); if(L&lt;=mid) query(o&lt;&lt;1,l,mid,L,R,dir,c); pushup(o);&#125;ll solve(int x,int y,int c)&#123; ans=tot=0; lt=0,rt=inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&gt;dep[top[y]]) //jump x &#123; query(1,1,n,dfn[top[x]],dfn[x],1,c); x=fa[top[x]]; &#125; else //jump y &#123; query(1,1,n,dfn[top[y]],dfn[y],0,c); y=fa[top[y]]; &#125; &#125; if(dep[x]&gt;dep[y]) //jump x query(1,1,n,dfn[y],dfn[x],1,c); else //jump y query(1,1,n,dfn[x],dfn[y],0,c); sort(tmp+1,tmp+1+tot); for(int i=1; i&lt;tot; ++i) for(int j=i+1; j&lt;=tot; ++j) ans=max(ans,tmp[j].v[0]-tmp[i].v[1]); return ans;&#125;int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) val[i]=read(); for(int i=1; i&lt;n; ++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(1,0); dfs2(1,1); BuildTree(1,1,n); m=read(); for(int i=1; i&lt;=m; ++i) &#123; int x=read(),y=read(),c=read(); printf("%lld\n",solve(x,y,c)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191104]]></title>
    <url>%2F2019%2F11%2F04%2Ftest20191104%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/KmZSRs0NIYFhZjRYj4N8XvRESLUhDP3F7flO0Vkt7frwmpDiXOouswmOi2+8WHti/nDorkXj5rdUeM+JDqLRPpfyNUNV2zFM9jxl/Wd1ALfWD0nbI1o2xtln0pugbqtunna+RFjXmLL7oIsYRaKZTVUwi0fsZc93zB8J6eMaJk4pPDZ6MchGoXGptG4OSntzwmR3J+bJbFiKvXggk68E0/FyfPboICaY/KmLtM0VOh5FGiBlNWzlUUkAdwZVmZkk0+agpBR14zNjd3NxQLL6mNpx+IVJ9b756KAx8Vqs4mBrlaPG2jwrWXdT4ghnRIzzZNHI+bu5KuMOBzOAq6JygWJbY9aZQDu2y341IQZDDOu7C4PJB2xCHVwtMGUWfHs2obMYxodu+8rS3u+JJAdjqhzRK5qRv30k0+m8zyDR38m0CKn9hAUJViI9GFjtxRBPakQdQAiOETEkvvvr3QOCED8/p2Ryj80OZZxJvQ0zVZbE1aUjKlwmfhIonQz6A46Wp2NqlRZzFKjP76Vx6Rqh2bqX7Itr7y8nXmZ32lVG4FgOGKVP476WgIk31UYQ82nwJ+CxgA54G9POAx4Iz6FUG7TbLLvgnUDaKT/Z6aIDCXFphM5bEdxbsl9SLgCvTw6mf4RnA4MKuf2HHTVe4tD7FirESvKSbc0D0XNXB6sx8RTR8qVjslBQaJYFLv/IkggjLaoQMtH/bcG7J3XMewe1sbf5ob2Bpl4sZiYFcIYAzK557qqqOii5X08p3hbnR7He3gSsR2uwy8mix4RBP+N3F0LlvZqx7uayJuU6VVmjVmOatLl/6OiKqJoTgx7MI8Qx3Anl/opembEiIS1xZlpZ1vdIgJ0bhFcVa0DXsvpPZEjGEgoUFEMSikkXBqz+AhCc4JKk07RIvOOQXy9x3pI2N4Euh1n9JBpQ7FNxEY92by5bSXzARAOfkTULP9UEuP8bSlG3VInofvyoANB9uI/VdfKw3BXirDA6OJcND1HSo1sP0gjFXHQRKG5Bmx32muBc/+AhJDvMgz44qclRB20sb2obMhYJIiJosoVOGQgUg7Z2rIrIo3zRq6HHchABYy2tyHB8Vqgyk+6NQ5tM9GA6XvEXljaipLlSl8zl30Rs+Wl3Cnqgqb93hdRXHg3fQ9dKYGeQcSuEkExfi8kZWhmRWZdCADvVVDFcy7Lthq6KItKsCg9sN+8k+XojeJyh9mBstxg8QUJFU83+y9oLRO+LI8tuvTlKtaN2GxzUw3R3mqWJMd+uJi0erdNDMBbye9DSUxHbik9WKWnZNoa91NzFO5vv/to61BG3vRDu/xBpjKm9E+Cx8HOLBxWC6e3j1s23F6FEzbyPBvg4zUdp0eYKZdoatq2pPXPfY7egWeN4PYmeNqi7uizpELHNE0XK4MydZIW737sB+ybuvxuVrf3gRcB70tA3PvQ/eBZ3rrIBuEQWNxi6SY43m/BkILZanb3IfpXCssjXVhlTCkPZNILM9HVlwkMeUCT2AADOgUAp+AhB1Ptk9R32DUlNPQuRiP1BTSBw649k7vi+HOeY0Pit9y34mogOdBy5RkqTNvGS5cprP76RzEf+HzEDbxpGR2XvaaVyyHIYhKID5uNmg7Fem4Vjj9nkYsf2aOsB1gl4lcY/ASS1VuaP3YKKAXNwnq+w+ElrOHMkmMC+BET3EXtxuciGBP97Sjo0fbUp+jfS00mYyPYlM805xD/gjK7QHEjx3S5rfjaYn8TgwPSY13T5KRocaI7kzibCKrtSKLqQsLqlYJYRKuOXqtBUgKxFb+tfMu3kc36xz+mE1dVTgoKsWU5ZtM75wRoQi20YpkTvbq7blw71YNgbA2RNO0H1NcP3e3TDfSKHXMzAY3baJnAbcPY9jBAQM+19czvs7ln+AGjelPHIz255xC5LHrBLcuvpBcFMz+V33azFzWriSNJtobNyV4JZJcnVeCrB/sximPSfOOE+qQUt1oNHQOPUoGPq5bh/+G04DEIr4U8yaWMX1+qEmRovDAyMPm7aaoqN1KTxX/kd3UnwA/D6lFbx/CNSMHPASvBBuzBcywkG26dmElE98o5nHvtmmvVRGFQEagqFiHROaVoiQOqzP1DjXDis+yx/Bowof3w== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>计算几何</tag>
        <tag>概率/期望</tag>
        <tag>博弈论</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1050 旅行]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-1050-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[并查集. 边的数目比较小,可以尝试枚举每一条边作为最小权值的边时的答案. 先将所有边按照权值大小从小到大排序. 假设一条边 $(u,v,w)$ 是路径上权值最小的边. 用并查集维护图的连通性,按权值从小到大不断加入权值 $\ge w$ 的边. 当 $s$ 与 $t$ 连通时,得到当 $(u,v,w)​$ 作为权值最小的边的最优解. 时间复杂度 $O(m^2\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m,fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:fa[x]=Find(fa[x]);&#125;void init()&#123; for(int i=1;i&lt;=n;++i) fa[i]=i;&#125;struct Edge&#123; int u,v,w; bool operator &lt; (const Edge &amp;rhs) const &#123; return w&lt;rhs.w; &#125;&#125;E[MAXN];typedef pair&lt;int,int&gt; pii;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; E[i].u=read(); E[i].v=read(); E[i].w=read(); &#125; sort(E+1,E+1+m); int s=read(),t=read(); pii ans; ans.first=0,ans.second=1; // max/min for(int i=1;i&lt;=m;++i) &#123; init(); pii tmp; tmp.first=0; tmp.second=E[i].w; for(int j=i;j&lt;=m;++j) &#123; int u=Find(E[j].u),v=Find(E[j].v); if(u==v) continue; fa[u]=v; if(Find(s)==Find(t)) &#123; tmp.first=E[j].w; break; &#125; &#125; if(!tmp.first) break; if(!ans.first || tmp.first*ans.second&lt;tmp.second*ans.first) ans=tmp; &#125; if(!ans.first) puts("IMPOSSIBLE"); else &#123; int g=__gcd(ans.first,ans.second); if(g==ans.second) printf("%d\n",ans.first/ans.second); else printf("%d/%d\n",ans.first/g,ans.second/g); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2140 稳定婚姻]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-2140-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%2F</url>
    <content type="text"><![CDATA[$tarjan$ 求 $scc$ . 考前复习板子. 用大写字母代表女性,小写字母代表男性. 当 $A-a$ 的感情不和时,若能找到一条路径 $A\to a\to B\to b\to \dots\to K\to k\to A$ ,则这对婚姻不安全. 可以发现,女性向男性连的边都是夫妻关系,男性向女性连的边都是情人关系. 于是只把这两种有向边建出来,用 $tarjan$ 求出强连通分量,判断每对夫妻是否在同一个强连通分量中. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2.5e4+10;map&lt;string,int&gt; mp;int n,m,tot=0;int id(string s)&#123; if(mp.find(s)!=mp.end()) return mp[s]; return mp[s]=++tot;&#125;string female,male;int a[MAXN],b[MAXN],ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dfn[MAXN],low[MAXN],idx=0,in[MAXN],stk[MAXN],tp=0,scc[MAXN],t=0;void dfs(int u)&#123; dfn[u]=low[u]=++idx; stk[++tp]=u; in[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; dfs(v); low[u]=min(low[u],low[v]); &#125; else if(in[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v=-1; ++t; while(u!=v) &#123; v=stk[tp--]; scc[v]=t; in[v]=0; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;female&gt;&gt;male; a[i]=id(female); b[i]=id(male); addedge(a[i],b[i]); &#125; m=read(); for(int i=1;i&lt;=m;++i) &#123; cin&gt;&gt;female&gt;&gt;male; addedge(id(male),id(female)); &#125; for(int i=1;i&lt;=tot;++i) if(!dfn[i]) dfs(i); for(int i=1;i&lt;=n;++i) &#123; if(scc[a[i]]==scc[b[i]]) puts("Unsafe"); else puts("Safe"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2054 疯狂的馒头]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-2054-%E7%96%AF%E7%8B%82%E7%9A%84%E9%A6%92%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[并查集. 线段树的做法不够优秀. 只询问一次,每个点只受最后一次染色影响,考虑倒着做,将一段区间染色后,就将这些位置全部删掉. 用并查集维护从每个位置开始,右边第一个还没有被删掉的位置. 123456789101112131415161718192021222324252627282930313233343536373839404142//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e7+10;int n,m,p,q,fa[MAXN],col[MAXN];int Find(int x)&#123; return fa[x]==x?x:fa[x]=Find(fa[x]);&#125;int main()&#123; n=read(),m=read(),p=read(),q=read(); for(int i=1;i&lt;=n+1;++i) fa[i]=i; for(int i=m;i&gt;=1;--i) &#123; int l=(i*p+q)%n+1,r=(i*q+p)%n+1; if(l&gt;r) swap(l,r); for(int j=Find(l);j&lt;=r;j=Find(j)) &#123; col[j]=i; fa[j]=j+1; &#125; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",col[i]); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3895 取石子]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-3895-%E5%8F%96%E7%9F%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[博弈论. 对于若干堆石子来说,能操作的次数为 石子数目 + 堆的数目 - 1. 如果这些石子中不存在单独一个石子一堆的情况,则答案只与操作次数的奇偶性有关. 证明:当操作次数为 $0$ 时,当前的先手就败了. 若先手从数目 $=2$ 的堆中拿了一个石子,后手可以把剩下那个石子与其他的合并. 若先手从数目 $\ge 3$ 的堆中拿了一个石子,后手可以再从那个堆中拿一个石子,或是将这堆与其他的合并. 操作次数的奇偶性不会变化,最后一定会变成只有一堆石子的情况,正确性就显然了. 而总堆数 $n$ 比较小,可以暴力把单独一个石子的数目记在状态里面. 设 $f(i,j)$ 表示当前有 $i$ 个单独的石子,其余石子的操作次数为 $j$ 时的胜负情况, $1$ 表示先手必胜, $0$ 表示先手必败. 边界为 $i=0$ ,此时可以直接判断胜负情况.转移时,可以进行以下几种操作: 拿走一个单独的石子,会使 $i$ 减少 $1$ . 从石子数目 $&gt;1$ 的堆中拿走一个石子,或者合并两个石子数目 $&gt;1$ 的堆,都只会使 $j$ 减少 $1$ . 合并一个单独的石子和一个石子数目 $&gt;1$ 的堆, 会使 $i$ 减少 $1$ ,而 $j$ 增加 $1$ . 合并两个单独的石子,会使 $i$ 减少 $2$ , $j$ 增加 $3​$ . 注意特判全都是单独的石子的情况,此时合并两个单独的石子, $j$ 只会增加 $2$ . 利用记忆化搜索实现,不同组数据也可以共用记录的 $f$ . 时间复杂度 $O(n\cdot \sum a_i)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=51,MAXM=1e3+10;int f[MAXN][MAXN*MAXM];int dfs(int i,int j)&#123; if(i==0) return j&amp;1; if(j==1) return dfs(i+1,0); if(f[i][j]!=-1) return f[i][j]; int &amp;res=f[i][j]; if(!dfs(i-1,j)) res=1; else if(j&gt;0 &amp;&amp; !dfs(i,j-1)) res=1; else if(j&gt;0 &amp;&amp; !dfs(i-1,j+1)) res=1; else if(i&gt;=2 &amp;&amp; !dfs(i-2,j+(j?3:2))) res=1; else res=0; return res;&#125;int main()&#123; memset(f,-1,sizeof f); int T=read(); while(T--) &#123; int n=read(); int x=0,y=-1; for(int i=1;i&lt;=n;++i) &#123; int v=read(); if(v==1) ++x; else y+=v+1; &#125; if(y==-1) y=0; puts(dfs(x,y)?"YES":"NO"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3894 文理分科]]></title>
    <url>%2F2019%2F11%2F03%2Fbzoj-3894-%E6%96%87%E7%90%86%E5%88%86%E7%A7%91%2F</url>
    <content type="text"><![CDATA[最小割. 最小割经典模型,一个集合中的元素全选时会产生一个额外收益. 先把所有的收益和额外收益都加入答案,然后对于每个人 $x$ ,连边 $S\to x,x\to T$ ,权值分别为选文,选理的收益. 对于每个人,再新建一个点 $y$ ,将自己以及与它四连通的点向 $y$ 连边,权值为 $\infty$ . 将 $y$ 向 $T$ 连边,权值为这些人都选理的收益,表示这些人中只要有一个人选了文,都选理的收益就没有了. 都选理的处理方法同理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e3+10;int art[MAXN][MAXN],sci[MAXN][MAXN],same_art[MAXN][MAXN],same_sci[MAXN][MAXN],id[MAXN][MAXN];int n,m,tot=0,ans=0;void Read(int a[MAXN][MAXN])&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) ans+=(a[i][j]=read());&#125;const int N=3e4+10,M=2e6+10;int head[N],ecnt=1;struct Edge&#123; int nx,to,flow; Edge(int nx=0,int to=0,int flow=0):nx(nx),to(to),flow(flow) &#123;&#125;&#125;E[M];void addedge(int u,int v,int w)&#123; E[++ecnt]=Edge(head[u],v,w); head[u]=ecnt;&#125;void ins(int u,int v,int w)&#123; addedge(u,v,w); addedge(v,u,0);&#125;int cur[N],dep[N];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=tot;++i) dep[i]=-1,cur[i]=head[i]; dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dep[v]==-1) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,flow=0; for(int &amp;i=cur[u];i;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dep[v]==dep[u]+1 &amp;&amp; (f=dfs(E[i].to,T,min(limit,E[i].flow)))) &#123; E[i].flow-=f; E[i^1].flow+=f; flow+=f; limit-=f; &#125; if(!limit) break; &#125; return flow;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) id[i][j]=++tot; Read(art); Read(sci); Read(same_art); Read(same_sci); int S=++tot,T=++tot; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; int x=id[i][j],y=++tot; ins(S,x,art[i][j]); ins(x,T,sci[i][j]); ins(y,T,same_sci[i][j]); ins(x,y,inf); if(i&gt;1) ins(id[i-1][j],y,inf); if(i&lt;n) ins(id[i+1][j],y,inf); if(j&gt;1) ins(id[i][j-1],y,inf); if(j&lt;m) ins(id[i][j+1],y,inf); y=++tot; ins(S,y,same_art[i][j]); ins(y,x,inf); if(i&gt;1) ins(y,id[i-1][j],inf); if(i&lt;n) ins(y,id[i+1][j],inf); if(j&gt;1) ins(y,id[i][j-1],inf); if(j&lt;m) ins(y,id[i][j+1],inf); &#125; while(bfs(S,T)) ans-=dfs(S,T,inf); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191103]]></title>
    <url>%2F2019%2F11%2F03%2Ftest20191103%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>概率/期望</tag>
        <tag>test</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191102]]></title>
    <url>%2F2019%2F11%2F02%2Ftest20191102%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>test</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1245]]></title>
    <url>%2F2019%2F11%2F02%2FCF1245%2F</url>
    <content type="text"><![CDATA[$Div.2$ 感觉这场的 E,F 都偏简单了啊. A Good ol’ Numbers Coloring只需要判断 $a,b$ 是否互质. 证明可以参考小凯的疑惑. 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int T=read(); while(T--) &#123; int a=read(),b=read(); if(__gcd(a,b)==1) puts("Finite"); else puts("Infinite"); &#125; return 0;&#125; B Restricted RPS先判断能否赢,若能,就先把需要赢的位置确定好,剩下的随便放即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;char buf[MAXN],ans[MAXN];int main()&#123; int T=read(); while(T--) &#123; int n=read(),r=read(),p=read(),s=read(); int x=(n+1)&gt;&gt;1,R=0,P=0,S=0; scanf("%s",buf); for(int i=0;i&lt;n;++i) &#123; if(buf[i]=='R') ++R; else if(buf[i]=='P') ++P; else ++S; &#125; x-=min(R,p)+min(P,s)+min(S,r); if(x&gt;0) puts("NO"); else &#123; puts("YES"); for(int i=0;i&lt;n;++i) ans[i]='#'; for(int i=0;i&lt;n;++i) &#123; if(buf[i]=='R' &amp;&amp; p) ans[i]='P',--p; else if(buf[i]=='P' &amp;&amp; s) ans[i]='S',--s; else if(buf[i]=='S' &amp;&amp; r) ans[i]='R',--r; &#125; for(int i=0;i&lt;n;++i) if(ans[i]=='#') &#123; if(p) ans[i]='P',--p; else if(s) ans[i]='S',--s; else ans[i]='R',--r; &#125; for(int i=0;i&lt;n;++i) putchar(ans[i]); puts(""); &#125; &#125; return 0;&#125; C Constanze’s Machine先特判掉存在字符 $w$ 或 $m$ 的情况,答案为 $0$ . 剩余情况,对于各段连续的 $u$ 串, $n$ 串,方案数是互不影响的,可以用乘法原理乘起来. 设计一个 $dp$ 计算长度为 $i$ 的 $u​$ 串的方案数,可以发现它就是斐波那契数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;char buf[MAXN];int n,f[MAXN];int main()&#123; scanf("%s",buf); n=strlen(buf); f[0]=f[1]=1; for(int i=2;i&lt;=n;++i) f[i]=add(f[i-1],f[i-2]); int ans=1; for(int i=0,j;i&lt;n;++i) &#123; if(buf[i]=='m' || buf[i]=='w') ans=0; j=i; while(j+1&lt;n &amp;&amp; buf[j+1]==buf[i]) ++j; if(buf[i]=='n' || buf[i]=='u') ans=mul(ans,f[j-i+1]); i=j; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Shichikuji and Power Grid设置一个虚拟节点 $n+1$ ,每个点与这个虚拟节点之间连边,权值为向这个点直接供电的花费,即 $c_i$ . 任意两个点之间连边,权值为在它们之间修电线的花费,跑一颗最小生成树即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll inf=9e18;const int MAXN=2019;struct node&#123; int c,k,x,y,id; bool operator &lt; (const node &amp;rhs) const &#123; return c&gt;rhs.c; &#125;&#125;p[MAXN];ll calc(node i,node j)&#123; return 1LL*(i.k+j.k)*(abs(i.x-j.x)+abs(i.y-j.y));&#125;struct Edge&#123; int u,v; ll c; Edge(int u=0,int v=0,ll c=0):u(u),v(v),c(c)&#123;&#125; bool operator &lt; (const Edge &amp;rhs) const &#123; return c&lt;rhs.c; &#125;&#125;E[MAXN*MAXN+MAXN];int n,m=0,s=0,t[MAXN],e=0,ea[MAXN],eb[MAXN];int fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:fa[x]=Find(fa[x]);&#125;ll ans=0;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].id=i; p[i].x=read(); p[i].y=read(); &#125; for(int i=1;i&lt;=n;++i) p[i].c=read(); for(int i=1;i&lt;=n;++i) p[i].k=read(); for(int i=1;i&lt;=n;++i) &#123; fa[i]=i; E[++m]=Edge(i,n+1,p[i].c); for(int j=i+1;j&lt;=n;++j) E[++m]=Edge(i,j,calc(p[i],p[j])); &#125; fa[n+1]=n+1; sort(E+1,E+1+m); int tot=0; for(int i=1;i&lt;=m &amp;&amp; tot&lt;=n;++i) &#123; int u=E[i].u,v=E[i].v; if(Find(u)!=Find(v)) &#123; fa[Find(u)]=Find(v); if(v==n+1) t[++s]=u; else &#123; ++e; ea[e]=u; eb[e]=v; &#125; ++tot; ans+=E[i].c; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; printf("%d\n",s); for(int i=1;i&lt;=s;++i) printf("%d ",t[i]); printf("\n%d\n",e); for(int i=1;i&lt;=e;++i) printf("%d %d\n",ea[i],eb[i]); return 0;&#125; E Hyakugoku and Ladders设 $f(x,y)$ 表示当前在位置 $(x,y)$ ,走到终点的最小期望步数. 终点处的 $f$ 值为 $0$ ,对于距离终点的步数 $&lt;6$ 的位置, $f$ 值为 $6$ . 其余位置直接枚举转移到哪个位置即可,记忆化搜索时还要记录上一步是不是用了梯子,因为不能连续用两次. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=11;double f[MAXN][MAXN][2];typedef pair&lt;int,int&gt; pii;#define mp make_pairpii nxt(int x,int y)&#123; if(y==10 &amp;&amp; x%2==0) return mp(x-1,y); if(y==1 &amp;&amp; x%2) return mp(x-1,y); if(x%2==0) return mp(x,y+1); return mp(x,y-1);&#125;int h[MAXN][MAXN];double dfs(int x,int y,bool ladder)&#123; if(x==1 &amp;&amp; y==1) return 0.0; if(x==1 &amp;&amp; y&lt;=6) return 6.0; if(f[x][y][ladder]&gt;0) return f[x][y][ladder]; double &amp;res=f[x][y][ladder]; res=0; int a=x,b=y; for(int i=1;i&lt;=6;++i) &#123; pii tmp=nxt(a,b); a=tmp.first,b=tmp.second; res+=dfs(a,b,true); &#125; res/=6.0; res+=1.0; if(ladder &amp;&amp; h[x][y]) res=min(res,dfs(x-h[x][y],y,false)); return res;&#125;int main()&#123; for(int i=1;i&lt;=10;++i) for(int j=1;j&lt;=10;++j) h[i][j]=read(); printf("%.10f\n",dfs(10,1,true)); return 0;&#125; F Daniel and Spring Cleaning设 $f(x,y)$ 表示 $0\le a\le x,0\le b\le y$ 时的合法方案数. 在二维平面上简单容斥,可以发现答案为 $f(r,r)-2\cdot f(l-1,r)+f(l-1,l-1)$ . 而 $a\oplus b=a+b$ 的充要条件为 $a\&amp;b=0$ ,所以直接数位 $dp$ 计算方案数即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int K=32;ll f[K][2][2];int x,y;int kp(int s,int i)&#123; return (s&gt;&gt;i)&amp;1;&#125;ll dfs(int k,bool lx,bool ly)&#123; if(k&lt;0) return 1LL; if(f[k][lx][ly]!=-1) return f[k][lx][ly]; ll &amp;res=f[k][lx][ly]; res=0; int maxx=lx?kp(x,k):1; int maxy=ly?kp(y,k):1; for(int i=0;i&lt;=maxx;++i) for(int j=0;j&lt;=maxy;++j) if(i+j&lt;2) res+=dfs(k-1,lx&amp;&amp;i==maxx,ly&amp;&amp;j==maxy); return res;&#125;ll calc(int l,int r)&#123; memset(f,-1,sizeof f); x=l,y=r; if(x&lt;0 || y&lt;0) return 0; return dfs(31,true,true);&#125;void solve()&#123; int l=read(),r=read(); ll ans=calc(r,r)-2LL*calc(r,l-1)+calc(l-1,l-1); cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191101]]></title>
    <url>%2F2019%2F11%2F01%2Ftest20191101%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191031]]></title>
    <url>%2F2019%2F10%2F31%2Ftest20191031%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+4LUv0qxxRTb7ippgpGe6QGH4qQe2/nLpgSMOnB4i5I75hFKVuYn5/5Vnn6BscQVrkHUmY2Vo3T1a2x457cTSXSrolb826ejPGglx34oKOuIj1Bu/IgYXnV/C+D0MAgI/R+LAYI+OV2nJywPqm+4XwkvwuhB6NpsJdjM1TktOrfyOurPSlpilFkrIzYYtnUkCu9BAPwZ0GtdlPpgQGL/oupG8prNrU5Ga0fJRCuLTNlOtGbkUA0dx0JzlXh8tkm7dQ1iXhnRJxkfcMDkx0xu7yqW7hveFvR3HOL/JrpwL2D3WEflJbIZqDt/0DDBsx7He97dRfCbcOhfkZqeqJtb13dzAZcdcZNAwFT/6fiKL+iHMqc9AIbUtsySWNVUvBzlkwDKZ+LJX5hQyEkaYpuoodXEtpDTqH8U7/1KP1/+55C2z/C9gdRSi57A/ivvSq1AR3XB2heneHf/mpx1oshnA7M5DvCksXhWW1jrk9yH+wiWwzwMh4xZJfpHfAymjuVragA8g2Jt9n2rKijqi9A08Kz//mdBVJcWmJVUFp/fG6GfvI460qoKIJMLEbnsS8XsmjyDHDIh0PiC2t4k6EEHWbuKjTd5NYfPvV7jW1Puh7LJg+TII11IwxAZLZH0JW69i56zwT396qJzS074yFTztxkOWxGWLQOADDSOaeXEZcg/4/VGhrtIFE7ppqWou65a3laogLIn4w/YW5Xofh8zNan6uOKjG8mxO406KHv2PW4YrU0QyGTyYUQ7snhbyTCAL4/gmzMuDJQj5vTARhbzyatKKgAwO6yHdlqcAbcazlIcwLLT5xbOQqggDRbSrWZtzHAE6NkiiVGVnBmNvYkdcQgOitP3xmcfI67MGb1FRn2MnBePFGhgPw9DzeRdw96pRZFH72njG7/t23GVdsTJR0S3RiosfSPiIXF8B2qglDbjFwHWV5PCbnntoKCdYRPaBiidpuGVYNdRh+FUtUyIIMvxRnCDRsev+DbO1OoiTef3krQxg7ExXfulJuoNQ/5rYsFkCtR/g4iWCZZmu5X8bRMOLYuuBK6armv/0eVgV+iTiGZc5aUelta/2uUKxVJal6K8kmBdteEM6yENjgiZy+bwAJr1LbykeU4bTr1ksg7ZJcC2nac7l9H/36UMXAS3jvH4hmcIuurPObqBPvTbLNIFt8QHGdGCEDG3iL/V6WeJIpqMbT4FMIfC08wqYcY+pitRGjeY/yvWe9QC84QCrj+DGp5Y3pBpYs0fzXDjhTRuq2hNGkbGCI++eWgNMvu4DcflSg7SJebu6WHQDMtP9sqAN1FA8Qmu7mySW0AmDZzTz9oPzMkFQpv1W5GhaDQy+4Gb/468aytiN1mv61CqKddrs2cqIvO9U9OL+ynQyktffl760qAzRC7nN2ypReslTJQbvPx1uMVGGjiJYOWuAL3i8QRRN7zZ0h3u97bYk6ysh1sdbuH0hqYCJprqvfD2ZSWysMpbjUL/u+7GRT/CvQiiBi+gYzKPZu1iXxi4nBnEt1npXmVPUi3wVNoMdufDOSCoeVWjjgLMV7IIWokrqB1qqaytpGA4i4LmNIVkrheQnOmriAYvi019Cdeg9ulVVpN50wYCzHCp4xgOm0eAeSWTUrpf2zVOJkFBccV32MZ5HIh22AKRrD var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4566 找相同字符]]></title>
    <url>%2F2019%2F10%2F30%2Fbzoj-4566-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[$SAM$ . 对一个串建 $SAM$ ,把第二个串放到 $SAM$ 上去匹配. 到达一个状态 $x$ 时, $x$ 和它的所有祖先的匹配次数都会 $+1$ ,最后从下到上去更新就可以了. 匹配成功时,对每个祖先贡献为 $cnt\cdot |Right|\cdot (maxlen-minlen)​$ . 但需要注意对自己的贡献,串长不一定能取到 $maxlen$ ,需要记录当前的串长. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e5+10,S=26;int idx=1,lst=1,ch[MAXN][S],fa[MAXN],len[MAXN],siz[MAXN];int cnt[MAXN],f[MAXN];void Extend(int c)&#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int t[MAXN],A[MAXN];void topsort()&#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; for(int i=idx;i&gt;=1;--i) siz[fa[A[i]]]+=siz[A[i]];&#125;char buf[MAXN];int n;int main()&#123; scanf("%s",buf+1); n=strlen(buf+1); for(int i=1;i&lt;=n;++i) Extend(buf[i]-'a'); topsort(); scanf("%s",buf+1); n=strlen(buf+1); int u=1,tmp=0; ll ans=0; for(int i=1;i&lt;=n;++i) &#123; int c=buf[i]-'a'; if(ch[u][c]) ++tmp,u=ch[u][c]; else &#123; while(u &amp;&amp; !ch[u][c]) u=fa[u]; if(!u) u=1,tmp=0; else tmp=len[u]+1,u=ch[u][c]; &#125; ++cnt[u]; ans+=1LL*siz[u]*(tmp-len[fa[u]]); &#125; for(int i=idx;i&gt;=1;--i) &#123; int x=A[i]; f[fa[x]]+=f[x]+cnt[x]; ans+=1LL*siz[x]*f[x]*(len[x]-len[fa[x]]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191030]]></title>
    <url>%2F2019%2F10%2F30%2Ftest20191030%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19jyGJc0ONHuyo/hA9EseRk+L9Z/EMiMF9EShZKESUuRnALKeWORQZos0JyjY7wTgrIYmV2cPEheLf0o+FHSsq1nw0BHFIpdgcxqCygiVLnUaeB65DfY409RbKar/3TDns6WJ4DGWYjYYLmwOOwZxb32DgQuw5pmpE0SVc1hmq73+cevbPjaaI4NJ8LVZ0rNb6ouzUKaJhOJiZqsW34W2F0LTnP4TgierBfrDNrgNrx29f6q0gR4r8cPyNyDJ/VxPwuZ+ow0JlXYyZ+FBU232Xafm/+o/KU9O4gabGVJs9PG43FfLjJTGCVNU24BjmzhmjTD6Z0/a9lJ0FGrue/qfUKmwNnTBSkcylVAE+Wa+Vjx34zsc/uFYMKp0l8CrP1Ck75uKwXae8Cqo9tCwnLFhHNR21YmJFoBFnvFFUY8PJAlug8MNkDz+odACy54uxg+2WTEL+h8UdmBoUiR06sRshNdQcoNPyfXKIf886zk2w71EGNE6865k7IdeMf52sgMt3ivus9l9j85E/v5c/X2lYHQBnCpeCSwv7ODKbmKZpPs0zZXsekoKzhmaarS+LZdHzP49GJGWPCVzvf8IpOyvXl1A+qrres/RHWBPPnF4Nu0iCYco+yQj6vm560Ymxrkn7XRWQFSR8OrgAHh6izxSnXcT6q7y/na14jZlYVl6vJaDHyzkbj77xL+0ELgNXmM78k2WSBGfBzVNwgCxBdMQyDd/DqiphsePRLQsplqjhc2WazmnrpixTzQ1OFKZT2WlbKv+xH32jbNu/+0GkG6PTayF36u431TQsW6lT/PFmdzog0WgYaYCAithDWlMBHznfJnsXkTUbA8eCB/g87t/Ns8DQIObDYwF9qhrtHc/2nAutUolP6EjCq17mvhzcl7RHi8/71L03cK+zfMhq/dqmWbJ5GWLqWpluVxtrbmS9xetS3kxpawTZYY23DE2wRSoIOl9EaZBfAwS4CbAm19wV3Q8beoK4RELEpERwnWRhE7LGXCeI+NaIyQr944GUOr+wvEPZ3C9VWBeCxdYZShxqK+uiai7ojvuNd/UhXllCdCG9IhsczhftaCMc5AHgG2RE22CWkdDweKRC8/uDs0m4/m/nfHjujI9yvNYy45e2T9G5uj2jXpt/zpcz+YTsLhAcDlQi8LerKDRDEfyxysJE4gDNKjnOU/nzz+ZstAxOfa/01J6Qqo5rpvlbsftE1GyEp0eLTtJsDnEjWMgqpVyPwYH5eVxL08PBUBkW0uKKXJjwa/hiKmOk0s7vwFY4/iAQQsyRFAORJRlC65zyZ+Oj+GoK1bogwbNjaTdYH8BnmuNhjAvG7LRX31wezAaKDlS/96Srm4KUlTsQN2/OPgeDLYvvRvI4A2s0JTOZA1Wzxlvw72X1k2V7osJp102Gl6EnkGWFgvxnLXMBSj4vI8Jo+1cZWcYLakhk= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4032 最短不公共子串]]></title>
    <url>%2F2019%2F10%2F30%2Fbzoj-4032-%E6%9C%80%E7%9F%AD%E4%B8%8D%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 子序列自动机. 对于两个串,建出它们各自的后缀自动机和子序列自动机. 对于每种询问,就将两个对应的自动机取出来,跑 $bfs$ . 某个状态 $(a,b)$ ,接受了一个字符 $c$ 后,若 $A$ 的自动机上有出边,而 $B$ 没有,则当前状态的深度 $+1$ 就是答案. 若两者都有出边,就将转移到的新的状态入队. 记忆化一下,时间复杂度 $O(n^2|S|)$ ,其中 $S$ 表示字符集大小. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e3+10,S=26;struct AutoMaton&#123; int ch[MAXN][S],fa[MAXN],len[MAXN],idx,lst; int st; AutoMaton()&#123;idx=lst=1;&#125; void init_seq(char *buf,int n) &#123; st=0; int cur[S]=&#123;0&#125;; for(int i=n;i&gt;=1;--i) &#123; memcpy(ch[i],cur,sizeof ch[i]); cur[buf[i]-'a']=i; &#125; memcpy(ch[0],cur,sizeof ch[0]); &#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[nq]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void init_SAM(char *buf,int n) &#123; st=1; for(int i=1;i&lt;=n;++i) &#123; int c=buf[i]-'a'; Extend(c); &#125; &#125;&#125;A[2],B[2];struct node&#123; int a,b,dep; node(int a=0,int b=0,int dep=0):a(a),b(b),dep(dep) &#123;&#125;&#125;;queue&lt;node&gt; q;bool vis[MAXN][MAXN];int solve(const AutoMaton &amp;A,const AutoMaton &amp;B)&#123; while(!q.empty()) q.pop(); memset(vis,0,sizeof vis); q.push(node(A.st,B.st,0)); vis[A.st][B.st]=1; while(!q.empty()) &#123; node tmp=q.front(); q.pop(); int a=tmp.a,b=tmp.b; for(int i=0;i&lt;S;++i) &#123; if(A.ch[a][i] &amp;&amp; !B.ch[b][i]) return tmp.dep+1; else if(A.ch[a][i] &amp;&amp; B.ch[b][i] &amp;&amp; !vis[A.ch[a][i]][B.ch[b][i]]) &#123; q.push(node(A.ch[a][i],B.ch[b][i],tmp.dep+1)); vis[A.ch[a][i]][B.ch[b][i]]=1; &#125; &#125; &#125; return -1;&#125;char buf[MAXN];int main()&#123; scanf("%s",buf+1); int n=strlen(buf+1); A[0].init_SAM(buf,n); A[1].init_seq(buf,n); scanf("%s",buf+1); n=strlen(buf+1); B[0].init_SAM(buf,n); B[1].init_seq(buf,n); for(int i=0;i&lt;2;++i) for(int j=0;j&lt;2;++j) printf("%d\n",solve(A[i],B[j])); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2746 旅行问题]]></title>
    <url>%2F2019%2F10%2F30%2Fbzoj-2746-%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$AC$ 自动机. 插入串的时候同时记录一下每个前缀在自动机上的编号以及 $Hash$ 值. 询问时,要求的公共后缀就是那两个前缀在 $fail$ 树上的 $LCA$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e6+10,S=26,K=22;int n,ch[MAXN][S],fail[MAXN],Hash[MAXN],idx=0;int fa[MAXN][K],dep[MAXN];vector&lt;int&gt; pos[MAXN];char buf[MAXN];queue&lt;int&gt; q;void getfail()&#123; for(int i=0;i&lt;S;++i) if(ch[0][i]) &#123; q.push(ch[0][i]); dep[ch[0][i]]=1; &#125; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0;i&lt;S;++i) if(ch[u][i]) &#123; q.push(ch[u][i]); int x=ch[u][i],y=ch[fail[u]][i]; fail[x]=fa[x][0]=y; dep[x]=dep[y]+1; for(int j=1;(1&lt;&lt;j)&lt;=dep[x];++j) fa[x][j]=fa[fa[x][j-1]][j-1]; &#125; else ch[u][i]=ch[fail[u]][i]; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x] &amp;&amp; fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; &#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=scanf("%s",buf); pos[i].push_back(0); int u=0,m=strlen(buf); for(int j=0;j&lt;m;++j) &#123; int c=buf[j]-'a'; if(!ch[u][c]) ch[u][c]=++idx; Hash[ch[u][c]]=add(mul(Hash[u],S),c); u=ch[u][c]; pos[i].push_back(u); &#125; &#125; getfail(); int m=read(); for(int i=1;i&lt;=m;++i) &#123; int x=read(),px=read(),y=read(),py=read(); px=pos[x][px],py=pos[y][py]; int pz=LCA(px,py); printf("%d\n",Hash[pz]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3991 寻宝游戏]]></title>
    <url>%2F2019%2F10%2F29%2Fbzoj-3991-%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$set$ . 考虑如果已经给出了所有有宝物的点,如何计算总距离. 可以将这些点按照 $dfs$ 序排序,按照这个顺序不断去走,总距离为相邻两点距离的总和(首尾也算) . 现在需要支持加点和删点,用一个 $set$ 维护所有有宝物的点,每次更新点时也更新答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,K=17;int n,m,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll dist[MAXN];int dep[MAXN],dfn[MAXN],rnk[MAXN],fa[MAXN][K],idx=0;void dfs(int u,int f)&#123; fa[u][0]=f; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1]; dfn[u]=++idx; rnk[idx]=u; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dist[v]=dist[u]+val[i]; dfs(v,u); &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x]-dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=K-1;i&gt;=0;--i) if((1&lt;&lt;i)&lt;=dep[x] &amp;&amp; fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;ll dis(int x,int y)&#123; int z=LCA(x,y); return dist[x]+dist[y]-2*dist[z];&#125;bool vis[MAXN];set&lt;int&gt; s;typedef set&lt;int&gt;::iterator sit;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs(1,0); ll ans=0; for(int i=1;i&lt;=m;++i) &#123; int x=dfn[read()]; if(!vis[x]) // insert &#123; if(!s.empty()) &#123; sit r=s.lower_bound(x); if(r==s.end()) r=s.begin(); sit l; if(r==s.begin()) &#123; l=s.end(); --l; &#125; else &#123; l=--r; ++r; &#125; ans-=dis(rnk[*l],rnk[*r]); ans+=dis(rnk[*l],rnk[x]); ans+=dis(rnk[x],rnk[*r]); &#125; s.insert(x); &#125; else //delete &#123; s.erase(x); if(!s.empty()) &#123; sit r=s.lower_bound(x); if(r==s.end()) r=s.begin(); sit l; if(r==s.begin()) &#123; l=s.end(); --l; &#125; else &#123; l=--r; ++r; &#125; ans+=dis(rnk[*l],rnk[*r]); ans-=dis(rnk[*l],rnk[x]); ans-=dis(rnk[x],rnk[*r]); &#125; &#125; vis[x]^=1; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3925 地震后的幻想乡]]></title>
    <url>%2F2019%2F10%2F28%2Fbzoj-3925-%E5%9C%B0%E9%9C%87%E5%90%8E%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 只需要对于每个 $k$ ,算出从小到大加入第 $k$ 条边后图仍未连通的概率 $p_k$ ,则答案为 $\frac 1 {m+1}\sum_{i=1}^m p_k$ . 设 $cnt(S)$ 表示两端都在点集 $S$ 中的边的数目. 设 $f(S,i)$ 表示点集为 $i$ ,在点集中选了 $i$ 条边,使得这个点集不连通的方案数, $g(S,i)$ 表示连通的方案数. 显然有 $f(S,i)+g(S,i)={cnt(S)\choose i}$ . 计算 $f(S,i)$ 的做法相当经典,枚举 $S$ 中包含某个定点 $p$ 所在的连通块的点集 $T$ 进行转移. 为了方便,可以规定 $p$ 表示 $S$ 中编号最小的点.$$f(S,i+j)=\sum_{T\subset S,p\in T} g(T,i)\cdot {cnt(S-T)\choose j}$$概率就是合法的方案数除以总方案数. 通过枚举子集即可做到 $O(3^n\cdot m)$ 的复杂度. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;bool in(int S,int x)&#123; return (S&gt;&gt;x)&amp;1;&#125;#define lowbit(x) x&amp;(-x)const int MAXN=10,MAXM=45+1;int n,m,cnt[1&lt;&lt;MAXN];double C[MAXM][MAXM],f[1&lt;&lt;MAXN][MAXM],g[1&lt;&lt;MAXN][MAXM];int main()&#123; n=read(),m=read(); for(int i=0;i&lt;=m;++i) C[i][0]=1; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=i;++j) C[i][j]=C[i-1][j-1]+C[i-1][j]; for(int i=0;i&lt;m;++i) &#123; int a=read()-1,b=read()-1; for(int S=0;S&lt;(1&lt;&lt;n);++S) if(in(S,a) &amp;&amp; in(S,b)) ++cnt[S]; &#125; for(int S=1;S&lt;(1&lt;&lt;n);++S) &#123; int p=lowbit(S); for(int T=(S-1)&amp;S;T;T=(T-1)&amp;S) if(T&amp;p) for(int i=0;i&lt;=m;++i) &#123; g[T][i]=C[cnt[T]][i]-f[T][i]; if(g[T][i]) for(int j=0;i+j&lt;=m;++j) f[S][i+j]+=g[T][i]*C[cnt[S-T]][j]; &#125; &#125; double ans=0; for(int i=0;i&lt;=m;++i) ans+=f[(1&lt;&lt;n)-1][i]/C[cnt[(1&lt;&lt;n)-1]][i]; ans/=m+1; printf("%.6f\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>概率/期望</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3993 星际战争]]></title>
    <url>%2F2019%2F10%2F28%2Fbzoj-3993-%E6%98%9F%E9%99%85%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[二分答案 + 最大流. 二分答案 $t$ ,则每个武器最多输出 $t​$ 秒,需要对这些输出进行恰当分配,可以利用网络流. 建出源点 $S$ ,汇点 $T$ , $S$ 向每个武器 $i$ 连边,流量为 $t\cdot B_i$ . 每个武器向它可以攻击的机器人连边,流量为 $\infty$ . 每个机器人 $i$ 向汇点 $T$ 连边,流量为 $A_i$ . 若最大流恰好等于所有机器人的血量之和,则说明 $t$ 秒内能将它们全部打死,否则不能. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-8,inf=1e9;const int MAXN=1e3+10;int n,m,ecnt=1,head[MAXN],a[MAXN],b[MAXN],tot,G[MAXN][MAXN];double sum;struct Edge&#123; int to,nx; double flow; Edge(int to=0,int nx=0,double flow=0):to(to),nx(nx),flow(flow)&#123;&#125;&#125;E[MAXN&lt;&lt;4];void addedge(int u,int v,double val)&#123; ++ecnt; E[ecnt]=Edge(v,head[u],val); head[u]=ecnt;&#125;void ins(int u,int v,double val)&#123; addedge(u,v,val); addedge(v,u,0);&#125;int dep[MAXN],cur[MAXN];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=tot;++i) &#123; cur[i]=head[i]; dep[i]=-1; &#125; dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow&gt;0) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;double dfs(int u,int T,double limit)&#123; if(u==T || limit&lt;=eps) return limit; double f,flow=0; for(int &amp;i=cur[u];i;i=E[i].nx) if(E[i].flow&gt;0) &#123; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; E[i].flow-=f; E[i^1].flow+=f; flow+=f; limit-=f; &#125; if(!limit) return flow; &#125; return flow;&#125;bool check(double t)&#123; int S=n+m+1,T=n+m+2; ecnt=1; for(int i=1;i&lt;=tot;++i) head[i]=0; for(int i=1;i&lt;=m;++i) &#123; ins(S,i,t*(double)(b[i])); for(int j=1;j&lt;=n;++j) if(G[i][j]) ins(i,j+m,inf); &#125; for(int i=1;i&lt;=n;++i) ins(i+m,T,(double)a[i]); double maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return fabs(sum-maxflow)&lt;=eps;&#125;int main()&#123; n=read(),m=read(); double L=0,R=0,res; for(int i=1;i&lt;=n;++i) R+=(a[i]=read()); sum=R; for(int i=1;i&lt;=m;++i) b[i]=read(); for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j) G[i][j]=read(); tot=n+m+2; for(int i=1;i&lt;=50;++i) &#123; double mid=(L+R)/2.0; if(check(mid)) R=mid,res=mid; else L=mid; &#125; printf("%f\n",res); return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3992 序列统计]]></title>
    <url>%2F2019%2F10%2F28%2Fbzoj-3992-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[原根 + $NTT$ . $M$ 是奇质数,可以先求出它的一个原根 $g_M$ ,将 $S$ 中的每个元素以及 $x$ 都转化为以 $g_M$ 为底的对数. 找 $M$ 的原根时,先预处理出 $M-1$ 的每个质因数 $p_i$ . 从 $2​$ 开始枚举每个数,检验它是否为原根. 只需要对于每个 $i$ ,依次算出 $g^{(M-1)/p_i}$ ,若这些数中有 $1$ ,则 $g​$ 不是原根,否则是原根. 于是 $\prod a_i\bmod M=x$ 就变成了 $\sum a_i’\bmod (M-1)=x’$ . 利用生成函数计算,就是要求多项式 $A(x)^n \bmod x^{M-1}$ 第 $x’$ 项的系数. 系数模数是 $NTT$ 模数,由于 $m$ 比较小,用不着多项式快速幂,可以直接写倍增快速幂. 时间复杂度 $O(m\log n\log m)$ . 注意 $x$ 不可以为 $0$ ,要将集合中为 $0$ 的元素忽略掉. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3.3e4+10;const ll P=1004535809,G=3;ll add(ll a,ll b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;ll mul(ll a,ll b)&#123; ll res=a*b-(ll)((long double)a/P*b+1e-8)*P; return res&lt;0?res+P:res;&#125;ll fpow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;ll omega[MAXN],inv[MAXN];int rev[MAXN],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(ll *a,int n,bool invflag)&#123; init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(ll *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;ll NTT_A[MAXN],NTT_B[MAXN];int n,m,x,s,gm,Log[MAXN];void NTT(ll *A,ll *B,ll *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) NTT_A[i]=A[i]; for(int i=lenA;i&lt;n;++i) NTT_A[i]=0; for(int i=0;i&lt;lenB;++i) NTT_B[i]=B[i]; for(int i=lenB;i&lt;n;++i) NTT_B[i]=0; DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true); for(int i=m;i&lt;2*m;++i) &#123; C[i-m]=add(C[i-m],C[i]); C[i]=0; &#125;&#125;int fpow_m(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=res*a%m; a=a*a%m; b&gt;&gt;=1; &#125; return res;&#125;int pr[MAXN],pcnt=0;int Find_gm()&#123; int t=m-1; for(int i=2;i*i&lt;=t;++i) if(t%i==0) &#123; pr[++pcnt]=i; while(t%i==0) t/=i; &#125; if(t!=1) pr[++pcnt]=t; for(int i=2;i&lt;m;++i) &#123; bool flag=true; for(int j=1;j&lt;=pcnt &amp;&amp; flag;++j) if(fpow_m(i,(m-1)/pr[j])==1) flag=false; if(flag) return i; &#125; return -1;&#125;ll a[MAXN],b[MAXN];void fpow_poly()&#123; while(n) &#123; if(n&amp;1) NTT(b,a,b,m,m); NTT(a,a,a,m,m); n&gt;&gt;=1; &#125;&#125;int main()&#123; n=read(),m=read(),x=read(),s=read(); gm=Find_gm(); int pw=1; Log[1]=0; for(int i=1;i&lt;m-1;++i) &#123; pw=pw*gm%m; Log[pw]=i; &#125; --m; x=Log[x]; for(int i=1;i&lt;=s;++i) &#123; int k=read(); if(k) ++a[Log[k]]; &#125; b[0]=1; fpow_poly(); printf("%lld\n",b[x]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC031B Reversi]]></title>
    <url>%2F2019%2F10%2F28%2FAGC031B-Reversi%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 设 $f(i)$ 表示前 $i$ 个位置的方案数. 转移时,若能找到上一个与 $i$ 颜色相同的位置 $j$ ,并且 $i,j$ 中间还有数,那么将这段染色是有贡献的. 注意此时应当加上 $f(j)$ 而不是 $f(j-1)$ ,因为 $i,j$ 同色,将 $j\sim i$ 这段染色不会影响以 $j$ 为右端点向前面染色.$$f(i)=f(i-1)+f(j)\cdot [i-j&gt;1]$$ 123456789101112131415161718192021222324252627282930313233343536373839404142//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e5+10;int n,f[MAXN],lst[MAXN];int main()&#123; n=read(); f[0]=1; for(int i=1;i&lt;=n;++i) &#123; f[i]=f[i-1]; int c=read(); if(lst[c] &amp;&amp; i-lst[c]&gt;1) f[i]=add(f[i],f[lst[c]]); lst[c]=i; &#125; cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 144]]></title>
    <url>%2F2019%2F10%2F28%2FAtcoder-Beginner-Contest-144%2F</url>
    <content type="text"><![CDATA[被 $D$ 卡了一会. D Water Bottle分两种情况做. 第一种情况,初始的水没有达到容器体积的一半. 第二种情况,初始的水达到了容器体积的一半. 利用反三角函数求出角度. 1234567891011121314151617181920212223242526272829303132//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double pi=acos(-1.0);int main()&#123; double a=(double)(read()),b=(double)(read()),x=(double)(read()); if(x/a/a/b&lt;0.5) &#123; double s=x/a; printf("%.10lf\n",atan(b*b/2/s)/pi*180.0); &#125; else &#123; double s=a*b-x/a; printf("%.10lf\n",atan(2*s/a/a)/pi*180.0); &#125; return 0;&#125; E Gluttony可以二分一个答案 $mx$ . 检验时,贪心去匹配,让 $a$ 最小的人去吃 $f$ 最大的食物. 限定 $a\cdot f\le mx$ ,可以算出每个人的权值至少要减少几次,判断这个总和是否超过 $k$ 即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;ll n,k,a[MAXN],f[MAXN];bool check(ll mx)&#123; ll t=k; for(int i=1;i&lt;=n;++i) &#123; int j=n+1-i; ll x=mx/f[j]; t-=max(0LL,a[i]-x); if(t&lt;0) return false; &#125; return true;&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) f[i]=read(); ll L=0,R=(ll)(1e12),res; sort(a+1,a+1+n); sort(f+1,f+1+n); while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) res=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; F Fork in the Road设 $f(i)$ 表示点 $i$ 到 $n$ 的期望步数,设 $S_i={j|(i,j)\in E }$ ,则转移有$$f(n)=0,f(i)=\frac{1}{|S_i|} \sum_{j\in S_i} f(j)$$暴力做法是枚举每条边,计算出删掉它之后的答案,时间复杂度是 $O(m^2)$ 的. 其实对于所有以 $i$ 为起点的边 $(i,j)$ ,只需要贪心删去 $f(j)$ 最大的那条边去更新答案即可. 这样只用删 $O(n)$ 次边,时间复杂度 $O(nm)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double inf=1e18;const int MAXN=601;vector&lt;int&gt; G[MAXN];int n,m;double f[MAXN];double calc(int x)&#123; f[n]=0; for(int i=n-1;i&gt;=1;--i) &#123; f[i]=0; int siz=G[i].size(); double mx=0; for(auto j:G[i]) &#123; f[i]+=f[j]; mx=max(mx,f[j]); &#125; if(i==x &amp;&amp; siz&gt;1) --siz,f[i]-=mx; f[i]/=(double)siz; f[i]+=1; &#125; return f[1];&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); G[u].push_back(v); &#125; double ans=calc(n); for(int i=1;i&lt;n;++i) ans=min(ans,calc(i)); printf("%.10lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>概率/期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 409]]></title>
    <url>%2F2019%2F10%2F27%2FProject-Euler-409%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 记 $p(i)=\prod_{j=2^n-i}^{2^n-1} j$ ,即不考虑胜负情况的所有合法方案. 记 $f(i)=p(i)-W(i)$ ,即先手必败的状态数,考虑如何求出 $f(i)$ . 让前 $i-1​$ 个数随便选,共有 $p(i-1)​$ 种情况,最后一个数通过恰当的选法使得所有数的异或和为 $0​$ . 考虑将不合法的情况减掉,由于不能选 $0​$ ,所以前 $i-1​$ 个数异或和为 $0​$ 时,就不合法. 由于不能选相同的元素,所以当前 $i-1​$ 个数中,有 $i-2​$ 个数异或和为 $0​$ 时,剩下一个数怎么选都不合法. 剩下的这个数有 $i-1$ 个的可能的位置,由于前面的数没有重复,所以每个位置有 $2^n-i+1$ 个可能的值. 将这两种情况减掉,得到$$f(i)=p(i-1)-f(i-1)-(i-1)\cdot (2^n-i+1) \cdot f(i-2)$$边界有 $f(1)=f(2)=0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e7+10;int n=10000000,m,p[MAXN],f[MAXN];int main()&#123; m=add(fpow(2,n),P-1); p[1]=m,p[2]=mul(m,add(m,P-1)); f[1]=f[2]=0; for(int i=3;i&lt;=n;++i) &#123; f[i]=add(p[i-1],P-f[i-1]); inc(f[i],P-mul(mul(i-1,add(m+2,P-i)),f[i-2])); p[i]=mul(p[i-1],add(m+1,P-i)); &#125; cout&lt;&lt;add(p[n],P-f[n])&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>Project Euler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Euler 638]]></title>
    <url>%2F2019%2F10%2F27%2FProject-Euler-638%2F</url>
    <content type="text"><![CDATA[算两次的思想. 一条路径的权值定义为 $k^s​$ ,其中 $s​$ 表示路径下方的面积. 设 $f(i,j)$ 表示从 $(0,0)$ 走到 $(i,j)$ 的所有路径的权值和,边界有 $f(i,0)=f(0,j)=1$ . 若上一步是从下方走过来的,面积不会变,若是从左边走过来的,面积就会加上 $i$ . 即$$f(i,j)=f(i-1,j)+f(i,j-1)\cdot k^i$$而从另一个方向上来考虑,这个面积 $s$ 也可以看做是路径右边的面积. 那么同理可以得到$$f(i,j)=f(i-1,j)\cdot k^j+f(i,j-1)$$比较两个方程,可以得出,当 $k\neq 1$ 时,$$f(i-1,j)=\frac{k^i-1}{k^j-1}\cdot f(i,j-1) \\f(i,j)=\frac{k^{i+1}-1}{k^j-1}\cdot f(i+1,j-1)$$用这个式子递归下去算,直到 $j=0$ . 当 $k=1$ 时,求的就是路径条数,即 ${i+j\choose j}$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int calc(int a,int b,int k)&#123; int res=1; if(k==1) &#123; for(int i=a+1;i&lt;=a+b;++i) res=mul(res,i); for(int i=1;i&lt;=b;++i) res=mul(res,fpow(i,P-2)); &#125; else &#123; for(int i=a+1;i&lt;=a+b;++i) res=mul(res,add(fpow(k,i),P-1)); for(int j=1;j&lt;=b;++j) res=mul(res,fpow(add(fpow(k,j),P-1),P-2)); &#125; return res;&#125;int main()&#123; int ans=0,pw=1; for(int k=1;k&lt;=7;++k) &#123; pw*=10; inc(ans,calc(pw+k,pw+k,k)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>Project Euler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191026]]></title>
    <url>%2F2019%2F10%2F26%2Ftest20191026%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+8GQG8Wr9q6A6fnIBp6k2wtdfzCShMaUDH28yQg5l2n/UR6n1E5t0iQoaF9LnUoolznyA1lD4pQinLX7R7QpIds5NSqx6J1CqkGpgHV3l3WZ9/JGBEoLtDR/EWgNQ2Bm5RID9VesLibxERViu8G8BlEPg9MB/lFrNi3rMokZvyCcNJYUllYMJ7VvXXsQeXsV0GxlLLnejyH7mBvtaxMvaZMwGWRMQo6kJmObzAc8b6U12ZCGDrXmFVIszAfcIC/mQ5SNxnPbtQM5gHdxWK0XijSHqt2rUPt5YgAQwLzeAVnJYebAFSRpkisEAkP6kU/Ac+vG9WYlqX3a0D9/P5k79teogylazk3iubs2O+ZvtfBgPOJFKdIN45mTc2Y8QK3ZcFAerlXNCLywahO4UeSPGp6eJEsU/YPOMHMxzsQ0muT690blgA2p5727IkYAPxagjiDRm0wnF2sdFuS9j/XcZs8V8GTnRK0/6RBE1Q+kJW8BcEi6J/xNQl4WVIhBF5mJASeddrIwDSqGktCom/J110dHi+ST4RWfHNBXlQaQODtraDoe11HGeLALoMGewhTKLg8hFQrST98VrK0UTsDIbExsI+Yea1RSVIby0pPXubqDtHD0UhtXA2U6oNIhSDEipC6BwgDQom52IIJJwLLZA9JWOzq7b8pEfiuC47kUdJjwUHyxobQ5SDoBpgdyJQoijXcv7tBEAKYfcAue6cor4kQnTwWCOgYm8SAdCH+a466K1GUPprCs7X9t5oX5jIsVrWoSko7G2D9nzw424/zeomXjgS7YQqMipWuVx9Dp1Z7a9euOZFY0rL+mj0bAycnSykvb09zQyxNH+MQsWdj8E4VImgij6kxTSukTlpS13rl5VH9g8M7pVLgCghmoy03Geven7lD4MCoX4GgkWRuEQrBYQR48hGcsgyRjEZfU0KiRg/0kshynyKrTfsNL/bYRgLwe0Cdp7k8IKbgNsu4ancLDSlchDpHSiPZRj3oL2L8G/AL74wwyAHVzC6K8udf9HAJxGflpnQczb6A38PuQg+tIcQj5laqjhXYjRsd7tNPmN2eI2Q3c7uDNMtz4PEleJHk1/wdQfESxOn4bZd4lhaDZ0Lb1y0rIUmG2YR8zpfAUKmQsoNdKvFoYLpDjH7GIMh5Rz8ttyKaOTbZH8rO3DC9hB5CmozsmWApvp/pZStukZSqyYC00oDUMQ1Y1xwu22akO5SX49CaXtJQypDbYuMlZBLehN8ydt2+pgPoUft2j0faRs5m6zxEBMdXhFQIP2lV09Vwy1FH63zTqluUVY7rv+MaAcEa8FTQ6TEQIvjpb3TaOQE2WniYg742Oxr2gWvrbXbTbDoLGmPwnYx6BSouT5DHqSbtwfqXT4rlga2jATg5hsMouLgQr9832N1v80NkKvhcQYrXQ== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>树链剖分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1251]]></title>
    <url>%2F2019%2F10%2F25%2FCF1251%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Broken Keyboard若某段连续出现这个字符 $c$ 的次数为奇数,则字符 $c$ 一定没有坏掉. 时间复杂度 $O(n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=512;char buf[MAXN];int n,t,ans[26];void solve()&#123; scanf("%s",buf); n=strlen(buf); memset(ans,0,sizeof ans); for(int l=0,r;l&lt;n;l=r+1) &#123; r=l; while(r+1&lt;n &amp;&amp; buf[r+1]==buf[r]) ++r; if((r-l+1)&amp;1) ans[buf[l]-'a']=1; &#125; for(int i=0;i&lt;26;++i) if(ans[i]) putchar('a'+i); puts("");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; B Binary Palindromes由于对交换的次数不作限制,那么任意一个 $0,1$ 个数都不变的方案,都可以得到. 于是答案只与 $0,1$ 的个数,以及每个串的长度有关. 统计出 $0,1​$ 的个数后,对于每个长度确定的字符串,依次构造. 这里可以贪心来放,若串长为偶,就任意选出 $\frac {len} {2}$ 个对子放入. 若串长为奇,此时若 $0,1$ 的个数有一个为奇,就让它去作为中心的数,否则就任意选一个填在中心. 剩下的部分仍然任意选对子放入,时间复杂度 $O(n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=51;int n,len[MAXN],cnt[2];char buf[MAXN];int solve()&#123; n=read(); cnt[0]=cnt[1]=0; for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf); len[i]=strlen(buf); for(int j=0;j&lt;len[i];++j) ++cnt[buf[j]-'0']; &#125; for(int i=1;i&lt;=n;++i) &#123; if(len[i]&amp;1) &#123; if(cnt[0]+cnt[1]==0) return i-1; else if(cnt[0]==0) --cnt[1]; else if(cnt[1]==0) --cnt[0]; else if(cnt[0]&amp;1) --cnt[0]; else --cnt[1]; &#125; len[i]&gt;&gt;=1; if((cnt[0]&gt;&gt;1)&gt;=len[i]) cnt[0]-=len[i]&lt;&lt;1; else &#123; len[i]-=cnt[0]&gt;&gt;1; cnt[0]&amp;=1; if((cnt[1]&gt;&gt;1)&gt;=len[i]) cnt[1]-=len[i]&lt;&lt;1; else return i-1; &#125; &#125; return n;&#125;int main()&#123; int T=read(); while(T--) printf("%d\n",solve()); return 0;&#125; C Minimize The Integer从前往后考虑每一位,根据数的比较方式,只需要贪心地让当前这一位尽可能的小. 注意到一个奇数往前换,如果它的前面还有奇数,则它一定会被挡住,不能来到当前的这位,偶数同理. 于是当前的这位就只能取剩下的第一个奇数或者第一个偶数. 这就是一个归并排序的过程,时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;char buf[MAXN];int n,pos[2][MAXN],t[2];void solve()&#123; scanf("%s",buf); n=strlen(buf); for(int i=n-1;i&gt;=0;--i) &#123; int x=buf[i]-'0'; pos[x&amp;1][++t[x&amp;1]]=x; &#125; while(t[0]+t[1]) &#123; if(!t[0]) putchar(pos[1][t[1]--]+'0'); else if(!t[1]) putchar(pos[0][t[0]--]+'0'); else if(pos[0][t[0]]&lt;pos[1][t[1]]) putchar(pos[0][t[0]--]+'0'); else putchar(pos[1][t[1]--]+'0'); &#125; puts("");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; D Salary Changing二分答案 $k$ ,则需要算出至少有 $\frac{n+1}{2}$ 个人的薪水 $\ge k$ 时,最小的总薪水是否 $\le s$ . 每个人的薪水区间 $[l,r]$ 要么满足 $l&gt;k$ ,要么满足 $r&lt;k$ ,要么满足 $l\le k\le r$ . 对于前两种区间,显然都选它们的左端点作为薪水. 若薪水 $\ge k$ 的人数还不够,则还要将一部分 $l\le k\le r$ 的区间选取的薪水从 $l$ 调整为 $k$ . 实现时,可以先将所有区间按照 $l,r$ 为两个关键字排序,从后往前扫一遍即可验证. 时间复杂度 $O(n\log n+n\log \max r)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int inf=1e9;int n,m;ll s;struct Interval&#123; int l,r; bool operator &lt; (const Interval &amp;rhs) const &#123; return l==rhs.l?r&lt;rhs.r:l&lt;rhs.l; &#125;&#125;p[MAXN];bool check(int k)&#123; ll tot=0; int cnt=0; for(int i=n;i&gt;=1;--i) &#123; if(cnt==m) &#123; tot+=p[i].l; continue; &#125; if(p[i].l&gt;k) tot+=p[i].l,++cnt; else if(p[i].r&gt;=k) tot+=k,++cnt; else tot+=p[i].l; &#125; return cnt==m &amp;&amp; tot&lt;=s;&#125;void solve()&#123; n=read(),s=read(); m=(n+1)&gt;&gt;1; for(int i=1;i&lt;=n;++i) p[i].l=read(),p[i].r=read(); sort(p+1,p+1+n); int L=1,R=inf,res; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) res=mid,L=mid+1; else R=mid-1; &#125; printf("%d\n",res);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; E Voting将所有人按照 $m_i$ 从小到大排序,依次考虑. 记录一个 $cnt$ ,表示当前已经投了票的人数,到第 $i$ 个人时,若 $n-i+cnt&lt;m_i$ ,则在 $[1,i]$ 中必须有人要投票. 用一个小根堆维护还没有投票的所有人的 $p$ ,需要投票时,就弹出堆顶,更新答案和 $cnt$ . 一个人最多只会被弹出一次,时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n;struct node&#123; int m,p; bool operator &lt; (const node &amp;rhs) const &#123; return m&gt;rhs.m; &#125;&#125;a[MAXN];priority_queue&lt;int&gt; q;void solve()&#123; while(!q.empty()) q.pop(); n=read(); for(int i=1;i&lt;=n;++i) a[i].m=read(),a[i].p=read(); sort(a+1,a+1+n); ll ans=0; int cnt=0; for(int i=1;i&lt;=n;++i) &#123; q.push(-a[i].p); while(cnt+(n-i)&lt;a[i].m) &#123; ++cnt; ans-=q.top(); q.pop(); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125; F Red-White Fence容易得出一个图形的周长为 $2(mx+1+w)$ ,其中 $w$ 表示使用的白色板子数目. $k$ 很小,可以直接去枚举用的红色板子的高度 $mx$ ,尝试将每个 $w$ 的方案数都算出来,加入对应贡献. 从高到低考虑每种长度的白色板子,从高度 $&lt;mx$ 的白色板子开始计算. 若这种长度只有 $1$ 块,则只能选择不加,或者加在某一边,生成函数表示为 $(1+2x)$ . 若 $&gt;1$ 块,则可以选择不加,或者加在某一边,或者两边都加,生成函数表示为 $(1+2x+x^2)=(x+1)^2$ . 那么这些生成函数之积就是 $(1+2x)^a\cdot (x+1)^{2b}$ 的形式,用二项式定理算出两个多项式,再用 $NTT$ 将它们乘起来. 最后利用维护的贡献 $O(1)$ 回答每个询问. 时间复杂度 $O(kn\log n+q)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1.8e6+10;int omega[MAXN],inv[MAXN],rev[MAXN],curn;void NTT_init(int n)&#123; if(curn==n) return; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((n&gt;&gt;1)*(i&amp;1)); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; NTT_init(n); for(int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],invn); &#125;&#125;int NTT_A[MAXN],NTT_B[MAXN];void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) NTT_A[i]=A[i]; for(int i=lenA;i&lt;n;++i) NTT_A[i]=0; for(int i=0;i&lt;lenB;++i) NTT_B[i]=B[i]; for(int i=lenB;i&lt;n;++i) NTT_B[i]=0; DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0;i&lt;n;++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true);&#125;int n,k,fac[MAXN],invfac[MAXN],pw2[MAXN];void init()&#123; int m=n&lt;&lt;1; fac[0]=pw2[0]=1; for(int i=1;i&lt;=m;++i) &#123; fac[i]=mul(fac[i-1],i); pw2[i]=mul(pw2[i-1],2); &#125; invfac[m]=fpow(fac[m],P-2); for(int i=m-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int binom(int M,int N)&#123; if(M&lt;N || N&lt;0 || M&lt;0) return 0; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int h[MAXN],ans[MAXN];int A[MAXN],B[MAXN],tmp[MAXN];void solve(int mx)&#123; int a=0,b=0; //(1+2x)^a \cdot (1+2x+x^2)^b for(int l=0,r;l&lt;n &amp;&amp; h[l]&lt;mx;l=r+1) &#123; r=l; while(r+1&lt;n &amp;&amp; h[r+1]==h[r]) ++r; if(l==r) ++a; else ++b; &#125; for(int i=0;i&lt;=a;++i) A[i]=mul(binom(a,i),pw2[i]); for(int i=0;i&lt;=2*b;++i) B[i]=binom(2*b,i); NTT(A,B,tmp,a+1,2*b+1); int len=a+2*b+1; for(int i=0;i&lt;len;++i) ans[i+1+mx]=add(ans[i+1+mx],tmp[i]);&#125;int main()&#123; n=read(),k=read(); init(); for(int i=0;i&lt;n;++i) h[i]=read(); sort(h,h+n); for(int i=0;i&lt;k;++i) &#123; int x=read(); solve(x); &#125; int q=read(); while(q--) printf("%d\n",ans[read()&gt;&gt;1]); return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>codeforces</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191025]]></title>
    <url>%2F2019%2F10%2F25%2Ftest20191025%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX18r15ckYRAzXHSIBM0SP0LQ1gshOXa5UYN0GexHnGF87sgN0GXLAb32sPiAeRPi3y2l5I6VGoZqEiQxj4SqkJK4aMFAQ0j6e3aRc/ajEky5pjWbVXEke0T3ZGX4CITR6IT9gq2aiv6eF06wOnPuuUWEnygdQauKvbrbBmj4+4B45/BBsVNVW8fZVObFq6shZcLzEgNaCTQD02qILGOLhKKnVP+43NA4NHcRTjl3YdWR7UXG9CCk8CVi+rmnFAj+WT1xGK2GbJIJOyNkTIm6txT9CzKIJFbQeuTV6SWYd9mH+eDflorzvVlTGV6dZr+Gu88u6pNyi+2gxMbQZyIGLuXCj5GXKgzZXmJPVZ7bu9DpskDd0V9TeSXqEdMAnKzpx5yXIfMFXXZzUx3MGgyJR+nJeHSVY388pILxyycsf3p/Eeqga3dziQS9J1f2qXJo+lo0oIQffa+n2tYcPzMZkhkjY236aXU9amML6Ww0RH6rF9S/3MOFF6LHL6zHHy6EFfhHE0C593augFXHq0bi7epx0OVVLxVaAqT36N//nBBcwNgoqE6XfUTV74UJDjloT01TzlNcwpYn96W+SFT5RxO0Nrul+XZbXPWv+5WG43RGGzJphx0dJiGBGiR3PSP8p32CoaY3fgkHKlwOsuKKtyvaLirLRNVIRJ2NTWzWZpx4KHBd3OUXZyBRmqcBqbOAYKL1iJHi2zy9UzEXzBxeunEhxCE2D1am1keTrNZxAtRNKzxiMgoBpMknH48A1AC/khQyhb2YgJKnBgl3rbtBUXj6MqhyxYnmpUaO06Zev4WpvBtk4paWi+mJa51/p8/Sg3m7ZzT/kq+c8mQuz5KTv1E7Ge2F1PAYp++Wf6TY3f2q/6zWDpD7m8G/F84GiBGx/mXk0R7Zzr5ZpelnwlJxTXOfguLz7rrT3Z26HmzwB0waWqAVzhwB9rSMyEKlRF4bU3O+idRs/o4j5SR1Zq41rS/QBnFr7kAdK3ZeXG9Xjq/oY6kA+RZ+bXcyyJC6aESlbQurIMpFRD87043+W7zrHTybPGQCNfQItAwkySh/brlTlgKLBPNVdbyNZDdBfajLOXJ4i4GGOPK+urU3cgi3bHXa1YnrteqkTz4oJKPtIG1TMX7zQNjnK6pszc3g7B6QVbYqDGcLW8Z8yxeJQh4vLHdfvI/+4TohDQOjelNyv0a1mBqYXKd0NyMzeBlwKVPBRAC+7g21TLzOhj04+UO9EgWUm0vfUtYD/FZbmCZdxg1unhsZkW9uY/mQ/oabM0kXxN9bmM3IhB3hwvOSkGu6147qmfnMIfvJRolwXIlEVzIN6cvbPGr5/Tof6gNOPh31mATHzBR9nw28adyUoqfG09dcAWPJ8NXAZd/A6J+j2i3oT9fkiYkv2lqpDO4O2pTKiTrhfCTtzVS9LHS/zJq1+k8sA8tw15agr6UwhKyo1QhG9kv0a83yEtZmOW/D1IBg8QBSOCSSWtJuct3LJ18XPqOr5UTkIbzhSho= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>STL</tag>
        <tag>test</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191024]]></title>
    <url>%2F2019%2F10%2F24%2Ftest20191024%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191023]]></title>
    <url>%2F2019%2F10%2F23%2Ftest20191023%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>STL</tag>
        <tag>博弈论</tag>
        <tag>test</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191022]]></title>
    <url>%2F2019%2F10%2F22%2Ftest20191022%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19CWiyTvW621PiieSINXVZUGYK7vMnOooLjwcibvrNPAlGhobis13h5rc6RR/Bj4QYUOD/uyafDaeMCKuQpJE8siqrcupx2PwpE9AHrc52LmZ/fCHMai4QIZt0RiEQvyzizLOIxQsfL6t6nVGaajhicPIo6U24fwP6tRbeXBmPT4w87Ge0pci4nsNHdX9x02XSXcNeWHWOoBgX30sKntgH9txQqpcQ4ctHuIAhZi1KXLpgPqYXZY2kGFxttaZEaFoASO0c67QQtX37Pdj8GmLNVl4wcM5pl2lGTiKNtKcbwOWj3bvVE3R8RZSgScDieZ3cr2r1dcxf7/L2zIeVB35UTDoqxG9vID/GEYiKUkDeqiOmrG86FBKquij/GACN/3vKoz1z1gt49QSz16yIykSnTkA94RiktkgeCFnjp7TNZ5UXjiMfR+JcXArS+6KHxHCN8Dg5wj8XdwRsS3nMWxZKpgEsxlp1doLw+Ujw4LM2G5At/h2keXc2Imzwees8s4f9xBQzsLcKvqMNAYLDoHjIP43vgypFhND6yj8/tR84nVcee6U6eHOoImFPz18EJYDGzYGnTyFdAvwHdb4O7+fyr8bhPsGLLhU+4qyXpcOYbtvvtHus38/NBONpwf8imfLNKfZftwXJMGO804D28u3QX7P0/summF67SNNY0o1ANA7FaGcmtLWualBLu7lASX41DVVFqTmJeFaOx9aCcLwS9Zw+6zn1X6tuobpDIDSqssY3pwXfDsfjZDtG7GYvRCgHIWnwW15e24Oy0sBv6KOPRuJHBqHv++IuzGL1Sl7nNh7Yc5m376qDUmxpI3v1hM4zVJgeThzyRq+8ZazbECxqPejG2iHKEImuy8cGV+yD+7gjC/QlqMSfoHak/2I95jorUYoi8uAQ0sSjIrGB1GaH3r9Lz9f2KZRqXQN7LoEMPBGzlyZqXgkbvVrT6TDAO5BjVSkQSUWki3yaDufjjh0Dviw43bV2uY02YtCSKK58zN9XI3hjXwag4UF8zoc8CzTGLNil6f39VeEIB1StUR1we/cYXCh07iQ2fEiLJ/jeEEq0fsUq/7jj2vP+7VvfEQb4G+FGEZ030ZX/NeIb6ZsAkfNojgJkJWk+nDj2EEBd0i6CTydTU+hOAeq/N0y8/tMGVLb29h5Q9B9eX72a52OmcP8kB6MdX3F2wv5lVV1JX1PEIPTJ/80e4xtBH22mdTby7gMlyYbiz2mkjLGbGFisA790Hj1oiennZPgURkIgd+zyczco/4HApqt8ZMBKCFM6taQk9vxqQq6C2Tv63+wGAmKWPS8eVc5IJXTp3cdfHKvrrFxuQhq333BloWB91KHQESIJq/aHGs9EhJx1OdkBz/Ah5GjGS0RC7HPywi0iUtihArAHlNjWzzctYdSFY6FCO4mdLuXCXUw== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3932 任务查询系统]]></title>
    <url>%2F2019%2F10%2F21%2Fbzoj-3932-%E4%BB%BB%E5%8A%A1%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[主席树. 将每个任务视作在时刻 $S_i$ 插入,时刻 $T_i+1$ 删除. 用主席树维护每个时刻存在的所有任务,查询时在主席树上二分. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,val[MAXN],tot=0;struct opt&#123; int pos,c,tp; opt(int pos=0,int c=0,int tp=0):pos(pos),c(c),tp(tp) &#123;&#125; bool operator &lt; (const opt &amp;rhs) const &#123; return pos&lt;rhs.pos; &#125;&#125;p[MAXN&lt;&lt;1];int rt[MAXN],idx=0;struct node&#123; int ls,rs,cnt; ll sum;&#125;Tree[MAXN*40];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void upd(int &amp;o,int lst,int l,int r,int pos,int tp)&#123; o=++idx; root=Tree[lst]; root.cnt+=tp,root.sum+=1LL*tp*val[pos]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[lst].ls,l,mid,pos,tp); else upd(root.rs,Tree[lst].rs,mid+1,r,pos,tp);&#125;ll query(int o,int l,int r,int k)&#123; if(root.cnt&lt;=k) return root.sum; if(l==r) return 1LL*val[l]*k; int mid=(l+r)&gt;&gt;1; if(lson.cnt&gt;=k) return query(root.ls,l,mid,k); else return query(root.rs,mid+1,r,k-lson.cnt)+lson.sum;&#125;int main()&#123; m=read(),n=read(); for(int i=1;i&lt;=m;++i) &#123; int L=read(),R=read(),c=read(); val[++tot]=c; p[2*i-1]=opt(L,c,1); p[2*i]=opt(R+1,c,-1); &#125; sort(val+1,val+1+tot); tot=unique(val+1,val+1+tot)-val-1; sort(p+1,p+1+2*m); for(int i=1,j=0;i&lt;=n;++i) &#123; int tmp=rt[i-1],nxt; while(j&lt;2*m &amp;&amp; p[j+1].pos==i) &#123; ++j; p[j].c=lower_bound(val+1,val+1+tot,p[j].c)-val; upd(nxt,tmp,1,tot,p[j].c,p[j].tp); tmp=nxt; &#125; rt[i]=tmp; &#125; ll lastans=1; for(int i=1;i&lt;=n;++i) &#123; int x=read(); int k=1+(lastans*read()+read())%read(); lastans=query(rt[x],1,n,k); printf("%lld\n",lastans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3931 网络吞吐量]]></title>
    <url>%2F2019%2F10%2F21%2Fbzoj-3931-%E7%BD%91%E7%BB%9C%E5%90%9E%E5%90%90%E9%87%8F%2F</url>
    <content type="text"><![CDATA[最大流. 先跑最短路,求出可以用的边. 边没有流量限制,但点有流量限制,可以将每个点拆成入点和出点,两者间连流量为原来那个点的流量的边. 对于可以用的边 $(u,v)$ ,就将 $u$ 的入点和 $v$ 的出点连起来, $u$ 的出点和 $v$ 的入点连起来,容量均为 $\infty$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const ll INF=1e18;const int MAXN=1024,MAXM=3e5+10;int n,m,vis[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairpriority_queue&lt;pli&gt; q;queue&lt;int&gt; Q;struct Graph&#123; struct Edge &#123; int u,v,w; Edge(int u=0,int v=0,int w=0):u(u),v(v),w(w) &#123;&#125; &#125;E[MAXM&lt;&lt;1]; int tot,ecnt,cur[MAXN],head[MAXN],to[MAXM&lt;&lt;1],nx[MAXM&lt;&lt;1],flow[MAXM&lt;&lt;1]; Graph()&#123;tot=0;ecnt=1;&#125; void addedge(int u,int v,int w) &#123; E[++tot]=Edge(u,v,w); ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; flow[ecnt]=w; head[u]=ecnt; &#125; void ins(int u,int v,int w) &#123; addedge(u,v,w); addedge(v,u,0); &#125; void Dijkstra(ll *dis,int S) &#123; for(int i=1;i&lt;=n;++i) dis[i]=INF,vis[i]=0; dis[S]=0; q.push(mp(-dis[S],S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;flow[i]) &#123; dis[v]=dis[u]+flow[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125; &#125; int dep[MAXN]; bool bfs(int S,int T) &#123; for(int i=1;i&lt;=2*n;++i) dep[i]=-1,cur[i]=head[i]; dep[S]=0; Q.push(S); while(!Q.empty()) &#123; int u=Q.front(); Q.pop(); for(int i=head[u];i;i=nx[i]) if(flow[i]&gt;0) &#123; int v=to[i]; if(dep[v]==-1) &#123; dep[v]=dep[u]+1; Q.push(v); &#125; &#125; &#125; return dep[T]!=-1; &#125; ll dfs(int u,int T,int limit) &#123; if(u==T || !limit) return limit; int f,Flow=0; for(int &amp;i=cur[u];i;i=nx[i]) &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,flow[i])))) &#123; Flow+=f; limit-=f; flow[i]-=f; flow[i^1]+=f; if(!limit) break; &#125; &#125; return Flow; &#125; ll Maxflow(int S,int T) &#123; ll res=0; while(bfs(S,T)) res+=dfs(S,T,inf); return res; &#125;&#125;G1,G2;ll ds[MAXN],dt[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); G1.addedge(u,v,w); G1.addedge(v,u,w); &#125; G1.Dijkstra(ds,1); G1.Dijkstra(dt,n); int S=1,T=n+n; for(int i=1;i&lt;=n;++i) &#123; int c=read(); G2.ins(i+n,i,c); G2.ins(i,i+n,c); &#125; for(int i=1;i&lt;=2*m;++i) &#123; int u=G1.E[i].u,v=G1.E[i].v,w=G1.E[i].w; if(ds[u]+w+dt[v]==ds[n]) G2.ins(u,v+n,inf); &#125; ll ans=G2.Maxflow(S,T); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191021]]></title>
    <url>%2F2019%2F10%2F21%2Ftest20191021%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3930 选数]]></title>
    <url>%2F2019%2F10%2F20%2Fbzoj-3930-%E9%80%89%E6%95%B0%2F</url>
    <content type="text"><![CDATA[$\gcd$ 的性质. 首先可以转化为在 $[\lceil \frac L k\rceil,\lfloor \frac R k\rfloor]$ 中取出 $n$ 个数,满足它们的 $\gcd$ 为 $1$ . 接下来的 $L,R$ 都是转化后的. 若取的 $n$ 个数不完全相同,那么它们的 $\gcd$ 一定会 $\le R-L$ . 计算出 $f(i)$ 表示取出 $n$ 个数,它们的 $\gcd$ 是 $i$ 的倍数的方案数,这个 $i$ 只用枚举到 $R-L$ . 再从大到小将 $f(2i),f(3i)\dots$ 减掉,得到的 $f(i)$ 就表示 $\gcd$ 恰好是 $i$ 的方案数了. 时间复杂度 $O((R-L+1)\cdot \log (R-L+1))$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int n,k,l,r;int f[MAXN];int main()&#123; n=read(),k=read(),l=read(),r=read(); l+=k-1,l/=k,r/=k; for(int i=1;i&lt;=r-l;++i) &#123; int x=r/i-(l-1)/i; f[i]=add(fpow(x,n),P-x); &#125; for(int i=r-l;i&gt;=1;--i) &#123; for(int j=2*i;j&lt;=r-l;j+=i) f[i]=add(f[i],P-f[j]); &#125; if(l==1) f[1]=add(f[1],1); cout&lt;&lt;f[1]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4036 按位或]]></title>
    <url>%2F2019%2F10%2F20%2Fbzoj-4036-%E6%8C%89%E4%BD%8D%E6%88%96%2F</url>
    <content type="text"><![CDATA[min-max 容斥. 记 $\max(S)$ 表示集合 $S$ 中的位置全部变成 $1$ 的期望次数,即每一位变成 $1$ 的期望次数的最大值. $\min(S)$ 表示集合 $S$ 中至少有一个位置变成 $1$ 的期望次数,即每一位变成 $1$ 的期望次数的最小值. 记 $U$ 为全集. 则根据 min-max 容斥,有$$ans=\max(U)=\sum_{S\neq \emptyset} (-1)^{|S|-1}\cdot \min(S)$$ 考虑 $S$ 中每个元素对 $\min(S)$ 的贡献,有$$\min(S)=\frac{1}{\sum_{T\cap S= \emptyset}p(T)}$$其中 $p(T)$ 表示每次选中 $T$ 中某个元素的概率. 而$$\sum_{T\cap S= \emptyset}p(T)=1-\sum_{T\subseteq(U-S)} p(T)$$暴力预处理每个集合的所有子集贡献之和是 $O(3^n)$ 的. 利用 ​$\rm FWT$ 处理,时间复杂度优化到 $O(n\cdot 2^n)$ . 注意判断无解的情况. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-6;#define lowbit(x) (x&amp;(-x))const int MAXN=20;int n,conf[1&lt;&lt;MAXN];double p[1&lt;&lt;MAXN];int main()&#123; n=read(); int U=0; for(int i=0; i&lt;(1&lt;&lt;n); ++i) &#123; scanf("%lf",&amp;p[i]); if(p[i]&gt;eps) U|=i; &#125; if(U!=(1&lt;&lt;n)-1) return puts("INF")&amp;0; conf[0]=-1; for(int i=1; i&lt;(1&lt;&lt;n); ++i) conf[i]=-conf[i-lowbit(i)]; for(int i=1; i&lt;(1&lt;&lt;n); i&lt;&lt;=1) //FWT or &#123; for(int j=0; j&lt;(1&lt;&lt;n); j+=(i&lt;&lt;1)) for(int k=j; k&lt;j+i; ++k) p[k+i]+=p[k]; &#125; double ans=0; for(int i=0; i&lt;(1&lt;&lt;n); ++i) &#123; double tmp=1-p[U^i]; if(tmp&gt;eps) tmp=1/tmp; else tmp=0; ans+=tmp*(double)conf[i]; &#125; printf("%.10lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min-max 容斥</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[min-max 容斥学习笔记]]></title>
    <url>%2F2019%2F10%2F20%2Fmin-max%E5%AE%B9%E6%96%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[$$\max(S)=\sum_{T\subseteq S,T\neq \emptyset} (-1)^{|T|-1}\cdot \min(T) \\\min(S)=\sum_{T\subseteq S,T\neq \emptyset} (-1)^{|T|-1}\cdot \max(T)$$ 其中 $\min(S)$ 表示非空集合 $S$ 中元素的最小值, $\max(S)$ 表示非空集合 $S$ 中元素的最大值. 只用证第一个等式,将所有元素取反即可得到第二个等式. 假设这个容斥系数是 $f(|T|)$ ,则需要证明 $f(x)=(-1)^{x-1}​$ . 考虑集合 $S$ 中第 $x+1​$ 大的元素,它对等式左右两边的贡献应当是相等的.$$[x=0]=\sum_{i=0}^{x}{x\choose i}\cdot f(i+1)$$对这个等式二项式反演.$$\begin{aligned}f(x+1)&amp;=\sum_{i=0}^x(-1)^{x-i}{x\choose i}\cdot [i=0]\\&amp;=(-1)^x\end{aligned}$$得证. 这个式子对于概率/期望同样成立,常用于将期望中的 $\max$ 转化为 $\min​$ 进行处理.]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191020]]></title>
    <url>%2F2019%2F10%2F20%2Ftest20191020%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+VRSd9Vx9hfNS74o4kaTPwILRbT4PtsYyaY08zKFk4c8f/SJ84GvS1pDPVG9Ojhi3vO5aIJZvO7BL5e96mN/h7xDNPj0czDjnlob9xLkgGB4Xlf7+64sD21SXQKOj0wkzWl75Z2fSbS1POtmS/mr2qlF91aeyrzo67NhjfKN91MV0dgSLcmR2vNuSObjhnw/pLLGS9v5fFz0OJ3nMI8QodVpJeTzRjak7imB1S8IEdPI9Ea3l/1Tild+H18SDx2qvdqW2NGIKgN05ZBj0rQ89e5/jcmJymGsqWjpE6LCWoSNNcLlwb7JfJ2XQdhJNsQvlMgHIU526Snnr2rFhRoJ4BLAx3Fcz/UgITXH2IRf/0Njw4f+glN6k3sajEqgULGN7HyBwLg80d38aQVyGGtf8mE3kZISGRePx7Axgp0KpEmzpFTBTya9ol1vFyh20V5l0ojEgUCBQ+VQA3kvmhz+qcS0U7Zux1xSudB5T2+2Pc+0F8cUNsGMrI+2ncxdq459xf9oNYN3b2+rO0++Gva3o4TMAX16eu6JYDCOiN77xbIyfmBK4SdkTRFeLf3Iu+8EOCmKGffPVLr6dLHaUCGvvqz7POgo3MhLbskTWfJBzbRkO+1hXAntEuX7t4du+CYaL9Ts+5TCRsN84eZE15eh9EY09kzcqZZ9zjekfKpuds48SDfzKTToVEohpgXfqEFcYv9wNGNZib+hp8Qy9peiO3fnlT41SPaXXVaz9/pJe4BpyL2fQrCxte3sXWF5jEeJEdbsPrBjvteyi/3uaBxDtE6qS+yjVXdJj/Wpw/0x5Hy8xGp/z9nraGqn6buIHrikt4021/t8v4VdqKvY4VtEdQydUZYrg1mGOVMw2arwfSGSxjrJsg6hnG0/bkMufBaIZVozfbFLSfp5/Iu7XCcKDCM0UkDBy0cMKiRBuWHEQ0vtgyvHnid3qIKPT+rsBoR73VyVul0+cdgDpuuZ33GKmJyFbSjcHYxxM0wKXBaKLl94lmxf8XDmemgNkIM3rNGvxizXCUC96Ly8KgwrKp2XztGw+lOVeR/XkAGxyly4QiTV5s0KvVIY5jeAxvVO216sWUoDJWdVdKukM2HPqVmXMArvX/u2QS/ohxpZAjvGZMUmho6WZ6C81w4/a3Dk9x0NAvkncIBDwMs7EHbYNyXDn/8qJShL47vk1A4Hwhp+IFZrWqSkJCefOMLfsH4yBI8f6Ph1WME+wHo5EwnADauegeTSk45WBhGY41pC1L+8g/cBYx08b5QXAzXolg6VuhIb5LhLEvtUcaGMqKKL5XDhJNu8HViSGKS+uaKHqnhoSkv80bg5IWkmG4WjY4H50u8BwR5JpsbCAtDarHw/166BLihoo2ZciVGD/obu00LPre7/dpPJM3uqrhHca4uiihoAiIkXXz1xAB3J6J8Po3nf8emUDeCj0ViCoXxZ3BzLn6/ileILrSdndG1P6gQp7N98dzEDOqWFhu4O8wdchR9PMNeLFh87lVyF+y6s8eQ+UWH7LL49J8nc+YlNNvDlQKbMj0tCpCM0x7jlebF1JCzKu22sbeOibHemgv3jkDSwCxUF1Yr58aZZthQzo8p9Ev3rY50JwAF9xz5FzXw7D6MTW2DaA6px9YxmjOjONdDiypAluJPQnigj5Z/0gDchibXeUOZG6v/zFji6vY0seftLZpgYOa13qlVG9AsGAjWrkv3tSIfxG6aBkAot4JcVr1+QWeaX4x4u7Irs+XkZBFoIl8AWUPr78SKDQkFamCtfEOuxfeQY+XGoKXd+Kj8QSfGQ7eKIEJmSvnBg== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>STL</tag>
        <tag>test</tag>
        <tag>打表</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3884 上帝与集合的正确用法]]></title>
    <url>%2F2019%2F10%2F19%2Fbzoj-3884-%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[拓展欧拉定理. 拓展欧拉定理 $a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)} \bmod p$ ,并不要求 $b$ 与 $p$ 互质. 则 $2^{2^{2^{\dots}}}\equiv (2)^{2^{2^{2^{\dots}}}}\equiv (2)^{2^{2^{2^{\dots}}}\bmod \varphi(p)+\varphi(p)}\bmod p$ . 求出 $\varphi(p)$ 后递归求解,边界是当 $p=1$ 时,答案为 $0$ . 打表发现,对于 $10^7$ 之内的任何 $p$ ,最多递归 $3$ 次后就会变成 $1$ ,这样做速度是有保证的. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e7+1;int mul(int a,int b,int P)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b,int P)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a,P); a=mul(a,a,P); b&gt;&gt;=1; &#125; return res;&#125;int getphi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;++i) if(x%i==0) &#123; res/=i; res*=(i-1); while(x%i==0) x/=i; &#125; if(x!=1) res/=x,res*=(x-1); return res;&#125;int calc(int p)&#123; if(p==1) return 0; int x=getphi(p); return fpow(2,calc(x)+x,p);&#125;/*int prime[MAXN],cnt=0,phi[MAXN],f[MAXN],ism[MAXN];void init(int n)&#123; int ans=0; f[1]=0; phi[1]=ism[1]=1; for(int i=2;i&lt;=n;++i) &#123; f[i]=f[phi[i]]+1; ans=max(ans,f[i]); if(!ism[i]) &#123; prime[++cnt]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; n/i&gt;=prime[j];++j) &#123; int x=prime[j]*i; if(i%prime[j]==0) &#123; phi[x]=phi[i]*prime[j]; break; &#125; phi[x]=phi[i]*(j-1); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;*/int main()&#123;// init(MAXN-1); int T=read(); while(T--) &#123; int p=read(); int ans=calc(p); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4001 概率论]]></title>
    <url>%2F2019%2F10%2F18%2Fbzoj-4001-%E6%A6%82%E7%8E%87%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[小水题. 感觉和那次考试的题差不多啊. 答案等于所有情况的叶子数目之和 除以 不同构的二叉树数目. 后者显然是卡特兰数 $C_n$ . 前者的计算也很简单,考虑有 $n-1$ 个点的时候,剩下的一个点可以有 $n$ 个位置插入作为叶子. 于是答案为$$ans=\frac{nC_{n-1}}{C_n}=\frac{n(n+1)}{2(2n-1)}$$ 1234567891011121314151617181920212223//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; double n=(double)read(); double ans=n*(n+1)/2/(2*n-1); printf("%.9lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4066 简单题]]></title>
    <url>%2F2019%2F10%2F18%2Fbzoj-4066-%E7%AE%80%E5%8D%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$kd$ 树 + 定期重构. 由于这道题强制在线 + 卡空间,其它时间效率上比较优秀的二维数点方法不太适用. 利用 $kd$ 树维护所有点, $kd​$ 树的本质是高维的二叉搜索树,所以插入的时候就在上面选方向走. 需要定期重构保证树的形态平衡一些,也可以像替罪羊树一样,维护一个因子判断是否需要重构. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=2e5+10;int n,lastans,D;struct node&#123; int ch[2],v[2],mx[2],mi[2]; node() &#123; ch[0]=ch[1]=0,mx[0]=mx[1]=-inf,mi[0]=mi[1]=inf; val=sum=0; &#125; bool operator &lt; (const node &amp;rhs) const &#123; return v[D]==rhs.v[D]?v[D^1]&lt;rhs.v[D^1]:v[D]&lt;rhs.v[D]; &#125; int val,sum;&#125; Tree[MAXN];#define root Tree[o]#define lson Tree[root.ch[0]]#define rson Tree[root.ch[1]]void pushup(int o)&#123; root.sum=lson.sum+rson.sum+root.val; for(int i=0; i&lt;2; ++i) &#123; root.mx[i]=max(root.mx[i],max(lson.mx[i],rson.mx[i])); root.mi[i]=min(root.mi[i],min(lson.mi[i],rson.mi[i])); &#125;&#125;int xl,xr,yl,yr;void ins(int o,int d)&#123; int k=Tree[n].v[d]&gt;root.v[d]; if(root.ch[k]) ins(root.ch[k],d^1); else root.ch[k]=n; pushup(o);&#125;int BuildTree(int l,int r,int d)&#123; D=d; int mid=(l+r)&gt;&gt;1; int o=mid; nth_element(Tree+l,Tree+mid,Tree+r+1); for(int i=0;i&lt;2;++i) root.mx[i]=root.mi[i]=root.v[i]; if(l&lt;=mid-1) root.ch[0]=BuildTree(l,mid-1,d^1); else root.ch[0]=0; if(mid+1&lt;=r) root.ch[1]=BuildTree(mid+1,r,d^1); else root.ch[1]=0; pushup(o); return o;&#125;bool check(int o)&#123; if(!o || root.mx[0]&lt;xl || root.mi[0]&gt;xr || root.mx[1]&lt;yl || root.mi[1]&gt;yr) return 0; return 1;&#125;int query(int o)&#123; if(xl&lt;=root.mi[0] &amp;&amp; root.mx[0]&lt;=xr &amp;&amp; yl&lt;=root.mi[1] &amp;&amp; root.mx[1]&lt;=yr) return root.sum; int res=0; if(xl&lt;=root.v[0] &amp;&amp; root.v[0]&lt;=xr &amp;&amp; yl&lt;=root.v[1] &amp;&amp; root.v[1]&lt;=yr) res+=root.val; if(check(root.ch[0])) res+=query(root.ch[0]); if(check(root.ch[1])) res+=query(root.ch[1]); return res;&#125;int main()&#123; read(); int rt=0; while("RLDAKIOI") &#123; int tp=read(); if(tp==1) &#123; ++n; Tree[n].v[0]=Tree[n].mx[0]=Tree[n].mi[0]=read()^lastans; Tree[n].v[1]=Tree[n].mx[1]=Tree[n].mi[1]=read()^lastans; Tree[n].val=Tree[n].sum=read()^lastans; if(n==1) rt=n; else ins(rt,0); if(n%5000==0) rt=BuildTree(1,n,0); &#125; else if(tp==2) &#123; xl=read()^lastans; yl=read()^lastans; xr=read()^lastans; yr=read()^lastans; if(check(rt)) lastans=query(rt); else lastans=0; printf("%d\n",lastans); &#125; else if(tp==3) break; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4031 小Z的房间]]></title>
    <url>%2F2019%2F10%2F18%2Fbzoj-4031-%E5%B0%8FZ%E7%9A%84%E6%88%BF%E9%97%B4%2F</url>
    <content type="text"><![CDATA[矩阵树定理. 把每个房间看成一个点,每堵可以打的墙看成一条边,不难发现就是要求这张无向图的生成树个数. 使用矩阵树定理计算,但模数不是质数,需要用辗转相除法来消元. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=100;int n=0,a[MAXN][MAXN],id[MAXN][MAXN];void addrow(int x,int y,int k)&#123; for(int i=1;i&lt;=n;++i) inc(a[x][i],mul(a[y][i],k));&#125;int ans=1;void Euclid(int x,int y)//最后使x不为0,y为0 &#123; if(!a[y][x]) return; else if(!a[x][x]) &#123; swap(a[x],a[y]); ans=add(P,-ans); return; &#125; if(a[x][x]&gt;a[y][x]) addrow(x,y,P-a[x][x]/a[y][x]); else addrow(y,x,P-a[y][x]/a[x][x]); Euclid(x,y);&#125;void Det()&#123; for(int i=1;i&lt;=n;++i) &#123; for(int j=i+1;j&lt;=n;++j) Euclid(i,j); ans=mul(ans,a[i][i]); if(!ans) return; &#125; &#125;int N,M;char buf[MAXN];int main()&#123; N=read(),M=read(); for(int i=1;i&lt;=N;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=M;++j) if(buf[j]=='.') &#123; id[i][j]=++n; if(id[i-1][j]) &#123; int x=id[i-1][j],y=id[i][j]; a[x][y]=a[y][x]=P-1; ++a[x][x],++a[y][y]; &#125; if(id[i][j-1]) &#123; int x=id[i][j-1],y=id[i][j]; a[x][y]=a[y][x]=P-1; ++a[x][x],++a[y][y]; &#125; &#125; &#125; --n; Det(); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1236]]></title>
    <url>%2F2019%2F10%2F18%2FCF1236%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Stones贪心地拿,先拿 $b,c$ 组合的,不能拿时再拿 $a,b$ 组合. B Alice and the List of Presents显然答案为 $(2^m-1)^n$ . C Labs进行 $n$ 轮填数,第 $i$ 轮将 $(i-1)\cdot n+1\sim i\cdot n$ 这 $n$ 个数分配给 $n$ 组. 每轮中,若给某组填入该轮的第 $x$ 个数,则该组的 $sum$ 加上 $x$ . 每轮填数前将所有组按照 $sum$ 从大到小排序,依次从小到大填入 $n$ 个数. D Alice and the Doll模拟走的过程,只有撞上障碍点或者边界时才拐弯. 用 $set$ 将所有障碍点和边界存下来,每次根据当前方向,二分出下个拐弯的位置,走的时候记录访问过的格子数目. 若某个时刻,走过的格子数目达到了 $n\cdot m-k$ ,就说明找到了一组合法解. E Alice and the Unfair Game可以发现,以某个确定的起点出发,可能的终点一定是一段连续的区间. 只需要找出这段区间的左,右端点. 若能向左走,就走,否则留在原地,可以找出左端点,同理可找出右端点,但这样暴力找是 $O(n^2)$ 的. 考虑遍历数组 $a$ ,当前的第一个元素只会对某个位置的起点有影响,将它们全部移开. 若当前在找左端点,就移到右边,否则移到左边,用并查集实现. 需要特判 $n=1$ 以及 $a_i=1$ 或 $a_i=n$ 的情况. F Alice and the Cactus对于一棵仙人掌,每个点最多在一个环上,删掉某些点后,每个点仍然在最多一个环上. 记点数为 $a$ ,边数为 $b$ ,环的数目为 $c$ ,于是连通块数目 $X=a-b+c$ . 方差可以看做 $E(X^2)-E(X)^2$ ,而 $X^2$ 可以拆成 $a^2+b^2+c^2-2ab-2bc+2ac$ . 根据期望的线性性,答案为$$E(a^2)+E(b^2)+E(c^2)-E(2ab)-E(2bc)+2E(ac)-(E(a)+E(b)-E(c))^2$$把这 $9​$ 种情况的贡献都统计进去,需要计算逆元,时间复杂度 $O(n\log P)​$ .]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1237]]></title>
    <url>%2F2019%2F10%2F17%2FCF1237%2F</url>
    <content type="text"><![CDATA[$Global\ Round\ 5$ A Balanced Rating Changes只需要保证向上取整的次数和向下取整的次数相同就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int n,t=0,sum=0;int trans(double x,bool f)&#123; int k=x&lt;0?-1:1; f^=(x&lt;0); x=fabs(x); return (f?k*floor(x):k*ceil(x));&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); if(x%2==0) &#123; printf("%d\n",x&gt;&gt;1); continue; &#125; if(t) &#123; printf("%d\n",trans((double)(x)/2.0,0)); --t; &#125; else &#123; printf("%d\n",trans((double)(x)/2.0,1)); ++t; &#125; &#125; return 0;&#125; B Balanced Tunnel按照进入的顺序依次遍历,判断一下有没有先进入的车在它之后出去. 123456789101112131415161718192021222324252627282930313233343536373839//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN],pos[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); pos[x]=i; &#125; int mx=0,ans=0; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; if(mx&gt;pos[x]) ++ans; mx=max(mx,pos[x]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Balanced Removals把所有点以 $x,y,z$ 坐标分别为第一,二,三关键字排序. 构造方案时,对于 $x$ 坐标相同的一段,递归进去通过比较 $y,z$ ,将它们删到只剩一个点或者没有点. 于是剩下所有点的 $x$ 都互不相同,从前往后,相邻的作为一对删掉即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;struct node&#123; int v[3],id; bool operator &lt; (const node &amp;rhs) const &#123; for(int i=0;i&lt;3;++i) if(v[i]!=rhs.v[i]) return v[i]&lt;rhs.v[i]; return false; &#125;&#125;p[MAXN];int solve(int L,int R,int k)&#123; if(L==R) return p[L].id; int head=L,cur=0; for(int i=L;i&lt;=R+1;++i) &#123; if(i==R+1 || p[i].v[k]!=p[head].v[k]) &#123; int x=solve(head,i-1,k+1); if(x &amp;&amp; !cur) cur=x; else if(x &amp;&amp; cur) &#123; printf("%d %d\n",cur,x); cur=0; &#125; head=i; &#125; &#125; return cur;&#125;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].id=i; for(int j=0;j&lt;3;++j) p[i].v[j]=read(); &#125; sort(p+1,p+1+n); solve(1,n,0); return 0;&#125; D Balanced Playlist可以将链复制两份,接在后面. 复制两份而不是一份,是为了方便判断答案为无穷大的情况. 只考虑这 $3n$ 个点,若某个点答案 $&gt;2n$ ,则实际答案一定为无穷大,否则就是该答案. 考虑第 $i$ 个点对前面哪些点有贡献,这可以在线段树上二分出来,还要和所有前缀的限制取 $\max$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,a[MAXN];struct Segtree&#123; int mx[MAXN&lt;&lt;2];#define root mx[o]#define lson mx[o&lt;&lt;1]#define rson mx[o&lt;&lt;1|1] void pushup(int o) &#123; root=max(lson,rson); &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) return (void)(root=a[l]); int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) res=max(res,query(o&lt;&lt;1|1,mid+1,r,L,R)); return res; &#125;&#125;T;#define lowbit(x) x&amp;(-x)int bit[MAXN];void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c;&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s;&#125;int main()&#123; m=n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=n+1;i&lt;=2*n;++i) a[i]=a[i-n]; for(int i=2*n+1;i&lt;=3*n;++i) a[i]=a[i-n]; n*=3; T.BuildTree(1,1,n); int lst=0; for(int i=1;i&lt;=n;++i) &#123; int L=1,R=i,pos; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; int mx=T.query(1,1,n,mid,i); if(2*a[i]&gt;=mx) R=mid-1,pos=mid; else L=mid+1; &#125; pos=max(pos,lst); add(pos,1); add(i+1,-1); lst=pos; &#125; for(int i=1;i&lt;=m;++i) &#123; int ans=sum(i); if(ans&gt;2*m) ans=-1; printf("%d ",ans); &#125; puts(""); return 0;&#125; E Balanced Binary Search TreesF Balanced Domino PlacementsG Balanced DistributionH Balanced Reversals]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初赛试题选做]]></title>
    <url>%2F2019%2F10%2F17%2F%E5%88%9D%E8%B5%9B%E8%AF%95%E9%A2%98%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[马上初赛了,假装准备一下. 主定理假设有递推关系式 $T(n)=aT(\frac n b)+f(n)$ . 三种情况分别对应了 $f(n)=O(n^d)$ 的 $d$ 较小,适中,与较大的情况. Case 1若 $f(n)=O(n^{\log_b a-\epsilon}),\epsilon &gt;0$ ,则 $T(n)=\Theta(n^{\log_b a})$ . 此时复杂度由 $a,b$ 决定. Case 2若 $f(n)=\Theta(n^{\log_b a}\log^k n)$ ,则 $T(n)=\Theta(n^{\log_b a}\log^{k+1} n)$ . 此时两者均衡,复杂度在共同决定的基础上还要乘上一个 $\log n$ . Case 3若 $f(n)=\Omega(n^{\log_b a+\epsilon}),\epsilon&gt;0$ ,对于某个常数 $c&lt;1$ 和所有充分大的 $n$ 有 $af(\frac n b)&lt;cf(n)$ ,则 $T(n)=\Theta(f(n))$ . 此时复杂度由 $f(n)$ 决定. 例一若某算法的计算时间表示为递推关系式 $T(n)=2T(\frac n 2)+n\log n,T(1)=1$ ,求解该算法的时间复杂度. 观察发现是 Case 2 ,其中 $a=b=2,k=1$ . 于是时间复杂度为 $T(n)=\Theta(n\log^2 n)$ . 例二若某算法的计算时间表示为递推关系式 $T(n)=2T(\frac n 4)+\sqrt n,T(1)=1​$ ,求解该算法的时间复杂度. 观察发现是 Case 2 ,其中 $a=2,b=4,k=0$ . 于是时间复杂度为 $T(n)=\Theta(\sqrt n\log n)$ . 例三若某算法的计算时间表示为递推关系式 $T(n)=9T(\frac n 3)+n,T(1)=1$ ,求解该算法的时间复杂度. 观察发现是 Case 1 ,其中 $a=9,b=3$ . 于是时间复杂度为 $T(n)=\Theta(n^2)$ . 例四若某算法的计算时间表示为递推关系式 $T(n)=T(\frac n 2)+n,T(1)=1$ ,求解该算法的时间复杂度. 观察发现是 Case 3 ,其中 $a=1,b=2$ ,常数 $c$ 可取 $(\frac 1 2,1)$ 中的任意实数. 于是时间复杂度为 $T(n)=\Theta(n)$ . 杂题整理NOIP2018 提高组初赛 T17求出当 $a, b$ 都取 $[0, 31]$ 中的整数时,方程 a*b = (a or b) * (a and b) 一共有多少组解. 首先可以注意到 (a or b) + (a and b) = a + b . 证明方式是把每个二进制位分开考虑. 若两个都是 $1$ ,贡献为 $2$ ,只有一个 $1$ ,贡献为 $1$ ,都是 $0$ ,贡献为 $0$ ,不难发现等式两边都满足以上性质. 记 x = (a or b),y = (a and b) ,则有 $a+b=x+y,ab=xy$ . 而 $x\ge y$ ,所以只可能是 $x=\max(a,b),y=\min(a,b)$ . 那么也就是求满足 (a and b) = b 或者 (a and b) = a 的数对个数. 先假设 $a&gt;b$ ,求出答案后 $\times 2$ ,再加上 $a=b$ 的 $32​$ 组解,就是答案. 枚举 $a$ 有几个二进制位是 $1$ 即可求出 $a&gt;b​$ 部分的答案. $$ans=32+2\times \sum_{i=0}^5 {5\choose i}\cdot(2^i-1)=454$$ NOIP2017 提高组初赛 T8求出由 $4​$ 个有标号的点构成的无向简单连通图的数目. 这个就是 bzoj 3456 城市规划 ,于是可以手算 NTT . 用那个暴力 $dp$ 手算一下. 设 $f(i)$ 表示 $i$ 个有标号的点构成的无向简单连通图的数目,边界有 $f(1)=1$ . 转移时用所有图的数目减去不连通的图的数目, 为了计算不连通的图的数目,可以枚举 $1$ 号点所在连通块的大小为 $j$ . 其它的点内部任意连边,但不与这个连通块内的点连边,这样就不连通了.$$f(i)=2^{i\choose 2} -\sum_{j=1}^{i-1}{i-1\choose j-1}\cdot f(j)\cdot 2^{i-j\choose 2}$$前 $3$ 项可以口算, $f(1)=1,f(2)=1,f(3)=4$ ,代入得到 $f(4)=38$ . NOIP2017 提高组初赛 T9将 $7$ 个名额分给 $4$ 个不同的班级,允许有的班级没有名额,求分配方案的数目. 设 $f(i,j)$ 表示 $i$ 个班级分 $j$ 个名额的方案数. 转移时枚举最后一个班级得到了 $k$ 个名额.$$f(i,j)=\sum_{k=0}^j f(i-1,j-k)$$用前缀和优化一下,得到 $f(i,j)=f(i,j-1)+f(i-1,j)$ ,边界有 $f(i,0)=1,f(0,j)=0$ . 这等价于从 $(1,0)$ 出发,每次向右或向上走一步,走到 $(4,7)$ 的方案数. 则答案为 ${4-1+7\choose 4-1}=120$ . NOIP2017 提高组初赛 T22删除一条细边代价是 $1$ ,删除一条粗边代价是 $2$ . 需要以最小的代价使得 $A$ 与 $B$ 不连通,求出这个代价,以及有多少种删边方案的代价是最小的. 平面图转对偶图,对偶图中的最短路长度以及最短路数目就是答案.]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4007 战争调度]]></title>
    <url>%2F2019%2F10%2F16%2Fbzoj-4007-%E6%88%98%E4%BA%89%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 设 $f(i,j,S)$ 表示考虑了前 $i$ 个平民,其中有 $j$ 个人去打仗,且第 $i$ 个人所有祖先去打仗/管理的状态为 $S$ 时最大收益. 转移时需要限制当前的节点与上一个节点的 $LCA​$ 到根的部分状态相同. 需要把第一维滚掉来优化空间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=9;int n,m,val[(1&lt;&lt;MAXN)+1][1&lt;&lt;MAXN][2],tmp[MAXN];int f[2][(1&lt;&lt;MAXN)+1][1&lt;&lt;MAXN];int dep(int x,int y)&#123; int s=-1; while(x^y) ++s,x&gt;&gt;=1,y&gt;&gt;=1; return s;&#125;void upd(int &amp;x,int y)&#123; x=max(x,y);&#125;int main()&#123; n=read(),m=read(); for(int k=1;k&gt;=0;--k) &#123; for(int i=1;i&lt;=1&lt;&lt;(n-1);++i) &#123; for(int j=0;j&lt;n-1;++j) tmp[j]=read(); for(int S=0;S&lt;1&lt;&lt;(n-1);++S) for(int j=0;j&lt;n-1;++j) if(((S&gt;&gt;j)&amp;1)==k) val[i][S][k]+=tmp[j]; &#125; &#125; int id=0; for(int k=0;k&lt;=1;++k) for(int S=0;S&lt;1&lt;&lt;(n-1);++S) f[id][k][S]=val[1][S][k]; int ans=0,base=(1&lt;&lt;(n-1))-1; for(int i=2;i&lt;=1&lt;&lt;(n-1);++i) &#123; id^=1; memset(f[id],0,sizeof f[id]); int d=dep(base+i-1,base+i); for(int k=0;k&lt;=1;++k) for(int l=0;l&lt;=i &amp;&amp; l+k&lt;=m;++l) &#123; for(int a=0;a&lt;(1&lt;&lt;(n-1-d));++a) for(int b=0;b&lt;(1&lt;&lt;d);++b) for(int c=0;c&lt;(1&lt;&lt;d);++c) &#123; upd(f[id][l+k][c^(a&lt;&lt;d)],f[id^1][l][b^(a&lt;&lt;d)]+val[i][c^(a&lt;&lt;d)][k]); if(i==(1&lt;&lt;(n-1))) upd(ans,f[id][l+k][c^(a&lt;&lt;d)]); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191016]]></title>
    <url>%2F2019%2F10%2F16%2Ftest20191016%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>博弈论</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4005 骗我呢]]></title>
    <url>%2F2019%2F10%2F15%2Fbzoj-4005-%E9%AA%97%E6%88%91%E5%91%A2%2F</url>
    <content type="text"><![CDATA[$dp$ 计数 + 容斥原理. 容易发现,每一行填的数都是从 $0\sim m$ 这 $m+1$ 个数中去掉一个数,将剩下的从小到大依次填进去形成的. 设 $f(i,j)$ 表示考虑了前 $i$ 行,第 $i$ 行去掉的数是 $j​$ 的方案数. 为了满足第二个条件,观察可以得出 $f$ 的转移$$f(i,j)=\sum_{k=0}^{j+1} f(i-1,k)$$则答案为 $\sum_{j=0}^m f(n,m)= f(n+1,m-1)$ . 考虑将 $f(i,j)$ 与 $f(i,j-1)$ 做差,可以得出递推式$$f(i,j)=f(i,j-1)+f(i-1,j+1)$$直接 $dp$ 是 $O(n^2)$ 的,不能接受. 发现 $f$ 的转移形式与组合数比较像,尝试转化到坐标系中. $f(n+1,m-1)$ 就表示从 $(0,0)$ 出发,每次可以向右走一步,或者向上与左走一步,走到 $(n+1,m-1)$ 方案数. 向上与左走的步数是确定的,要走 $n+1$ 步,那么向右走的步数就是 $n+m$ 步. 再转化一步,就变成从 $(0,0)$ 出发,只能向右走一步,或向上走一步,走到 $(n+1,n+m)$ 的方案数. 但现在向上走一步,对应的是原来向上,左各走一步,若原来的 $j&lt;0$ 或者 $j&gt;m$ 了,就不合法了. 也就是说,从 $(0,0)$ 走到 $(n+1,n+m)$ 时,还不能穿过直线 $y=x$ 和 $y=x-m$ . 记穿过 $y=x$ 再穿回来的事件为 $A$ ,穿过 $y=x-m$ 再穿回来的事件为 $B$ . 考虑容斥,考虑交错子序列 $ABABAB\dots$ ,则至少发生了前 $i$ 次事件的方案数 $s_i$ 对答案的贡献就是 $(-1)^i\cdot s_i$ . 将终点 $(n+1,n+m)$ 不断沿着两条直线对称,每对称一次就更新答案. 对另一个交错子序列 $BABABA\dots$ 也同样计算一遍贡献. 不断对称的时间复杂度是 $O(\log n)$ ,瓶颈在预处理阶乘及其逆元,时间复杂度 $O(n)$ .]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4004 装备购买]]></title>
    <url>%2F2019%2F10%2F15%2Fbzoj-4004-%E8%A3%85%E5%A4%87%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[求解最小权值极大线性无关组. 根据拟阵的那套理论,只需要将所有向量按照权值从小到大排序. 然后依次尝试加入,能加入就加入,维护一个上三角矩阵来进行判断. 精度上可能会有问题.可以开 long double 并加入 eps 进行判断,也可以用 $\gcd$ 消元法,会多一个 $\log$. 写的时候比较偷懒,就模了个大质数来做. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void inc(int &amp;a,int b)&#123; a=add(a,b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=512;int n,m;struct Vector&#123; int v[MAXN],cost; bool operator &lt; (const Vector &amp;rhs) const &#123; return cost&lt;rhs.cost; &#125;&#125;a[MAXN];int tot=0,matrix[MAXN][MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) a[i].v[j]=read(); for(int i=1;i&lt;=n;++i) a[i].cost=read(); sort(a+1,a+1+n); int cnt=0,ans=0; for(int t=1;t&lt;=n;++t) &#123; for(int i=1;i&lt;=m;++i) &#123; if(!a[t].v[i]) continue; if(!matrix[i][i]) &#123; for(int j=i;j&lt;=n;++j) matrix[i][j]=a[t].v[j]; ++cnt; ans+=a[t].cost; break; &#125; int tmp=mul(a[t].v[i],fpow(matrix[i][i],P-2)); for(int j=i;j&lt;=m;++j) inc(a[t].v[j],mul(P-tmp,matrix[i][j])); &#125; &#125; cout&lt;&lt;cnt&lt;&lt;' '&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191015]]></title>
    <url>%2F2019%2F10%2F15%2Ftest20191015%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
        <tag>Pollard-Rho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4003 城池攻占]]></title>
    <url>%2F2019%2F10%2F14%2Fbzoj-4003-%E5%9F%8E%E6%B1%A0%E6%94%BB%E5%8D%A0%2F</url>
    <content type="text"><![CDATA[可并堆. 如果对于每个骑士,我们都求出他在哪个城池牺牲,那么两个问题都可以解决. 对于树上的每个节点,开一个可并堆,维护当前这个点上所有骑士的战斗力. 对树进行 $dfs$ . 先将堆中的战斗力修改,然后弹出在当前节点牺牲的骑士,更新答案,再将剩余的骑士合并到父亲上去. 加或者乘一个正数是不会改变战斗力的大小关系的,所以修改时在根节点处打标记就可以了,堆的形态不会变化. 最后还要处理攻占根节点后仍未牺牲的骑士. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dep[MAXN],st[MAXN],a[MAXN];ll h[MAXN],v[MAXN];struct node&#123; int ls,rs; ll addtag,multag,val; node()&#123;addtag=0,multag=1;ls=rs=0;&#125;&#125;Heap[MAXN];int rt[MAXN];void upd_mul(int x,ll c)&#123; Heap[x].val*=c; Heap[x].multag*=c; Heap[x].addtag*=c;&#125;void upd_add(int x,ll c)&#123; Heap[x].val+=c; Heap[x].addtag+=c;&#125;void pushdown(int x)&#123; if(Heap[x].multag!=1) &#123; if(Heap[x].ls) upd_mul(Heap[x].ls,Heap[x].multag); if(Heap[x].rs) upd_mul(Heap[x].rs,Heap[x].multag); Heap[x].multag=1; &#125; if(Heap[x].addtag) &#123; if(Heap[x].ls) upd_add(Heap[x].ls,Heap[x].addtag); if(Heap[x].rs) upd_add(Heap[x].rs,Heap[x].addtag); Heap[x].addtag=0; &#125;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; if(Heap[x].val&gt;Heap[y].val) swap(x,y); pushdown(x); Heap[x].rs=merge(Heap[x].rs,y); swap(Heap[x].ls,Heap[x].rs); return x;&#125;void pop(int &amp;x)&#123; pushdown(x); x=merge(Heap[x].ls,Heap[x].rs);&#125;int ans1[MAXN],ans2[MAXN];void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v); rt[u]=merge(rt[u],rt[v]); &#125; while(rt[u] &amp;&amp; Heap[rt[u]].val&lt;h[u]) &#123; ++ans1[u]; ans2[rt[u]]=dep[st[rt[u]]]-dep[u]; pop(rt[u]); &#125; if(a[u]==0) upd_add(rt[u],v[u]); else upd_mul(rt[u],v[u]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) h[i]=read(); for(int i=2;i&lt;=n;++i) &#123; int f=read(); addedge(f,i); a[i]=read(); v[i]=read(); &#125; for(int i=1;i&lt;=m;++i) &#123; Heap[i].val=read(); st[i]=read(); rt[st[i]]=merge(rt[st[i]],i); &#125; dfs(1); while(rt[1]) &#123; ans2[rt[1]]=dep[st[rt[1]]]+1; pop(rt[1]); &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",ans1[i]); for(int i=1;i&lt;=m;++i) printf("%d\n",ans2[i]); return 0;&#125;]]></content>
      <tags>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191014]]></title>
    <url>%2F2019%2F10%2F14%2Ftest20191014%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191013]]></title>
    <url>%2F2019%2F10%2F13%2Ftest20191013%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
        <tag>crt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4002 有意义的字符串]]></title>
    <url>%2F2019%2F10%2F13%2Fbzoj-4002-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[数学套路题. 考虑将 $\frac {b+\sqrt d}{2}$ 写成某个递推数列的特征方程的根. 设数列 $a_i=A\cdot (\frac{b+\sqrt d}{2})^i+B\cdot (\frac{b-\sqrt d}{2})^i$ . 可以根据韦达定理得出该数列的递推式 $a_i=b\cdot a_{i-1}+\frac{d-b^2}{4}\cdot a_{i-2}$ . 令 $A=B=1$ ,得到这个数列的前两项 $a_1=b,a_2=\frac{b^2+d}{2}$ . 由于 $b\bmod 2=1,d\bmod 4=1$ ,所以 $\frac {d-b^2}{4},\frac{b^2+d}{2}$ 一定是个整数. 于是可以用矩阵快速幂求出 $a_n$ . 而 $(\frac{b+\sqrt d}{2})^n=a_n-(\frac{b-\sqrt d}{2})^n$ ,答案需要向下取整. 有限制 $0&lt;b^2\leq d&lt;(b+1)^2$ ,所以有 $(\frac {b-\sqrt d}{2})^n\in(-1,0]$ . 于是当且仅当 $b^2&lt;d,n\bmod 2=0​$ 时,答案为 $a_n-1​$ ,其余情况为 $a_n​$ . 时间复杂度 $O(\log n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll P=7528443412579576937;ll add(ll a,ll b)&#123; return (P-a&lt;=b)?(a-P+b):(a+b);&#125;ll mul(ll a,ll b)&#123; ll res=a*b-(ll)((long double)a/P*b+1e-8)*P; return res&lt;0?res+P:res%P;&#125;struct Matrix&#123; ll v[2][2]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int i=0;i&lt;2;++i) for(int k=0;k&lt;2;++k) if(v[i][k]) for(int j=0;j&lt;2;++j) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;st,trans,I;Matrix fpow(Matrix a,ll b)&#123; Matrix res=I; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; I.v[0][0]=I.v[1][1]=1; ll b=read(),d=read(),n=read(); if(n==0) return printf("1\n")&amp;0; if(n==1) return printf("%lld\n",floor((double)((b+sqrt(d))/2)))&amp;0; st.v[0][0]=((b*b+d)/2)%P,st.v[1][0]=b; trans.v[0][0]=b,trans.v[0][1]=((d-b*b)/4)%P,trans.v[1][0]=1; st=fpow(trans,n-2)*st; ll ans=st.v[0][0]; if(n%2==0 &amp;&amp; b*b&lt;d) --ans; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191012]]></title>
    <url>%2F2019%2F10%2F12%2Ftest20191012%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191011]]></title>
    <url>%2F2019%2F10%2F11%2Ftest20191011%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+3AHezstawTPE8FD9rOYt2troC63rbnMmUHlI9BZCPz0RZoQTyDVmIZVbDxaf65RfOAnwwK4G4Hfow2M2EfaHAdUxFHzXzNmj+r0d/uTn7Rxji4LIcOQdiihgswlS6mEFY/jefb9CIwW8qt26GwTgKLVGu4qvLDlNDAgjyVAqmMDlibL91KQ4kBXH6kAPbiXcsuoxAo1gK/DwoT3WmaakkFpGAKX/obv0TqcfM55B76KWCPKgXlh3Sa2n6BjUOsKwIDcsjMDkN+rkymLh+gVNPZlqPeUlUtt60uW6pgQfJMFZ1159aWbnlzvWs0+XHBZZ1fshL+ugyiG3FE3uaicTfY3LPs4LYJjpk/Ler9h+rk32f4ym+1ZH7vLwRr30qjjuAAI9EmxFBzhp0hYSDL9n18pVLEjVz7/S9df30XGuynStc2LnVLYdRAWobz9G5zpO5H12ORMiKQo15gm9MdUf8XlfdhU8HAeVZs9C9G9/0dC1HeeRrIBufMpeUA9yxpvbmnxBZ6O8+QPYEKD+XzP9DTi9aOyXIo7aXed7sZfW/r4X8Toy0pDj0ymsFlckAn+i06syNKL6tgG8z2ZaOIec1pInRxzqN/wM2bsz78y4dtCM4qBVOvp6FEvZLticSa8tdmRdQorcIZqjeYug/0htf2TqR4xEbZHyiv2DBl6IutZzVs2Fz4muiMeQt02nSSPkv+g6EL/l9a+Zm+Gp1ED+LSTwDR+KBVISgJnAX/FKaqBoKgJpqlt7GArxt39bYtR7SL6rvcLudlfM+0eIlhLwSRWf++4coU4lj+9FrOD2HGfAw3i0GDnQYaG1JLrRNp7jpM21mHelfB26M/9kQt9udr1pGx+sAaeosoA07DEirMPnqUtB/0xssLKaxQPLDfKu976/9uJeGrfUph++OqGrOsRveywtZB93bRPBTGI3MwaZVoNmtixgci9zWnWVPq3NT+TuGyb2PJN06+xx3ZGegG4EEsNWHeuJLAXBma/9d7W8ZOcesIS0umC/TCSWTSRIZJVI3ADn8Eah+5ZjjUx+jV/EcsteCub2Is+aVLfmmypE3ca3JzEhbqV1AiJdvx1k6uVot4zO9vbmxR8nUKZkpbZD8gtKU3CgAX0Wc7K4FNkH07EnKwFZTvA40J7zqy+2yuYkWLg5vfG9Jn7OwQsgJqKl+/wpSXLg= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>test</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF985D Sand Fortress]]></title>
    <url>%2F2019%2F10%2F10%2FCF985D-Sand-Fortress%2F</url>
    <content type="text"><![CDATA[二分答案. 把 $n$ 个物品摆成一排,一个位置上可以放多个物品,但要满足两个限制. 第一个位置上放的物品数目不能超过 $H$ . 任意两个相邻位置上放的物品数目之差必须 $\le 1$ ,这个规则对于最后一个位置也适用,即最后一个位置必须恰好放 $1​$ 个物品. 求出摆下这 $n$ 个物品至少需要的位置数目. 首先需要注意到答案是可以二分的,因为差值可以为 $0$ ,所以多出来的位置总可以通过调整得到合法解. 考虑二分一个答案 $k$ ,于是需要求出 $k$ 个位置最多能放下的物品数目. 由于最后一个位置必须是 $1$ ,且第一个位置的所以 $k$ 个位置最优的方案一定是先上升,再下降到 $1$ . 感性理解一下. 判断一下直接这样放,第一个元素的位置是不是 $\le H$ 的,否则就只能从 $H$ 开始依次递减摆放. 如果二分答案的上界设为 $n$ ,对等差数列求和时会爆掉 $\rm long\ long$ . 可以对称的放,即高度从 $1$ 到某个 $x$ ,再到 $1$ .于是可以将上界设到 $2\sqrt n$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll n,H;ll sum(ll l,ll r)&#123; if(l&gt;r) swap(l,r); return (l+r)*(r-l+1)/2;&#125;bool check(ll k)&#123; if(k&lt;=H) return sum(1,k)&gt;=n; ll tot=sum(1,H-1); k-=H; if(k&amp;1) tot+=2*sum(H,H+k/2); else tot+=sum(H,H+k/2)+sum(H+k/2-1,H); return tot&gt;=n;&#125;int main()&#123; n=read(),H=read(); ll L=1,R=2*sqrt(n),ans; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3997 组合数学]]></title>
    <url>%2F2019%2F10%2F10%2Fbzoj-3997-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[$Dilworth$ 定理. 图是一张 $DAG$ ,根据 $Dilworth$ 定理,它的最小链覆盖数就等于最长反链长度. 一条反链中的任意两点间都不存在边,所以一定是从左下到右上的一条链. 设 $f(i,j)$ 表示用了以 $(i,j)$ 为右上角的矩阵中的点,最长反链的长度. 从左下到右上进行 $dp$ 即可. 1234567891011121314151617181920212223242526272829303132333435363738394041//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int n,m,val[MAXN][MAXN];ll f[MAXN][MAXN];int main()&#123; int T=read(); while(T--) &#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) val[i][j]=read(); memset(f,0,sizeof f); for(int i=n;i&gt;=1;--i) for(int j=1;j&lt;=m;++j) &#123; f[i][j]=0; f[i][j]=max(f[i][j],f[i+1][j]); f[i][j]=max(f[i][j],f[i][j-1]); f[i][j]=max(f[i][j],f[i+1][j-1]+val[i][j]); &#125; printf("%lld\n",f[1][m]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1168A Increasing by Modulo]]></title>
    <url>%2F2019%2F10%2F10%2FCF1168A-Increasing-by-Modulo%2F</url>
    <content type="text"><![CDATA[二分答案 + 贪心. 给出一个长度为 $n$ 的自然数序列 $a$ ,满足 $a_i\in [0,m)$ . 每次操作可以选出任意个元素进行修改,元素 $x$ 在修改后会变为 $(x+1)\bmod m$ . 需要求出至少操作几次,可以使得整个序列单调不降. 可以二分一个答案 $k$ ,则只需判断在 $k$ 次操作内能否达到要求. 贪心一下,如果一个数能在 $k​$ 次操作内变成上一个数,就把它变过去. 否则不变,若此时它比上个数小,就不合法了. 一个比较显然的答案上界是 $m$ ,因为操作 $m$ 次一定可以让所有数变成 $0$ . 时间复杂度 $O(n\log m)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,a[MAXN];bool check(int k)&#123; int lst=0; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; if((x&lt;=lst &amp;&amp; x+k&gt;=lst) || (x&gt;lst &amp;&amp; x+k-m&gt;=lst)) continue; else &#123; if(x&lt;lst) return false; lst=x; &#125; &#125; return true;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); int L=0,R=m,ans; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF360E Levko and Game]]></title>
    <url>%2F2019%2F10%2F10%2FCF360E-Levko-and-Game%2F</url>
    <content type="text"><![CDATA[最短路 + 贪心. 有一张 $n$ 个点, $m+k$ 条边的有向图,可能存在重边与自环. 前 $m$ 条边的长度是给定的,你需要为后 $k$ 条边分别钦定长度,其中第 $i$ 条边的长度必须在区间 $[l_i,r_i]$ 中. 给出三个点 $s_1,s_2,f$ ,求一种钦定的方案,使得 $s_1\to f$ 的最短路长度小于 $s_2\to f$ 的最短路长度. 如果不能达到上述要求,就给出一种使两者相等的钦定方案. 若两个要求都无法达到,输出 LOSE . 首先可以确定,对于这 $k$ 条边,每条边的权值只可能是 $l_i$ 或者 $r_i$ . 因为权值取在中间时,可以往两边调整,至少有一边不会更劣. 于是可以先将它们的权值都设为 $r_i$ ,分别以 $s_1,s_2$ 作为起点跑一遍 $Dijkstra$ . 对于一条可以改的边 $u\to v$ ,若 $dis(s_1,u)\le dis(s_2,u)$ ,就把它的权值改为 $l_i$ . 因为它更可能出现在 $s_1\to f$ 的最短路上. 最简单的想法是,每次改了一条边之后,重新计算一遍距离,再去找需要改的边. 但实际上可以一次将所有的边改完,再去重新计算距离,这样做是等价的. 用三角形不等式,可以证明每次修改后,没有 $dis(s_1,u)\le dis(s_2,u)$ 变成 $dis(s_1,u)&gt;dis(s_2,u)$ 的情况. 时间复杂度 $O(k(m+k)\log n)$. 用链表删掉已经改过的边,否则复杂度会退化. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll inf=9e18;const int MAXN=1e4+10;int n,m,k,s1,s2,f;typedef pair&lt;ll,int&gt; pli;#define mp make_pairpriority_queue&lt;pli&gt; q;struct Graph&#123; int ecnt,to[MAXN],nx[MAXN],head[MAXN],val[MAXN]; void addedge(int u,int v,int w) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt; &#125; int vis[MAXN]; ll dis[MAXN]; void Dijkstra(int S) &#123; for(int i=1;i&lt;=n;++i) dis[i]=inf,vis[i]=0; dis[S]=0; q.push(mp(-dis[S],S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125; &#125;&#125;G1,G2;int id[MAXN],x[MAXN],y[MAXN],l[MAXN],r[MAXN];int ans[MAXN];int pre[MAXN],nxt[MAXN];void del(int x)&#123; int l=pre[x],r=nxt[x]; pre[r]=l; nxt[l]=r;&#125;int main()&#123; n=read(),m=read(),k=read(); s1=read(),s2=read(),f=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); G1.addedge(u,v,w); G2.addedge(u,v,w); &#125; nxt[0]=1; for(int i=1;i&lt;=k;++i) &#123; pre[i]=i-1,nxt[i]=i+1; x[i]=read(),y[i]=read(); l[i]=read(),r[i]=read(); G1.addedge(x[i],y[i],r[i]); G2.addedge(x[i],y[i],r[i]); id[i]=G1.ecnt; ans[i]=r[i]; &#125; pre[k+1]=k; while("RLDAKIOI") &#123; G1.Dijkstra(s1); G2.Dijkstra(s2); bool flag=false; for(int i=nxt[0];i!=k+1;i=nxt[i]) if(G1.val[id[i]]!=l[i] &amp;&amp; G1.dis[x[i]]&lt;=G2.dis[x[i]]) &#123; G1.val[id[i]]=l[i]; G2.val[id[i]]=l[i]; ans[i]=l[i]; flag=true; del(i); &#125; if(!flag) break; &#125; G1.Dijkstra(s1); G2.Dijkstra(s2); if(G1.dis[f]&lt;=G2.dis[f]) &#123; if(G1.dis[f]&lt;G2.dis[f]) puts("WIN"); else puts("DRAW"); for(int i=1;i&lt;=k;++i) printf("%d ",ans[i]); puts(""); &#125; else puts("LOSE"); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2289 在美妙的数学王国中畅游]]></title>
    <url>%2F2019%2F10%2F09%2FLoj-2289-%E5%9C%A8%E7%BE%8E%E5%A6%99%E7%9A%84%E6%95%B0%E5%AD%A6%E7%8E%8B%E5%9B%BD%E4%B8%AD%E7%95%85%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[$LCT$ + 泰勒展开. 如果只有类型 $3$ 的函数,就直接用 $LCT$ 维护路径上的 $\sum a,\sum b$ . 对于前两种函数,题面都明示你了,进行麦克劳林展开,就变成多项式函数了.$$\sin(ax+b)=\sin (b)+\frac{a\cos(b)\cdot x}{1!}-\frac{a^2\sin(b)\cdot x^2}{2!}-\frac{a^3\cos(b)\cdot x^3}{3!}+\frac{a^4\sin(b)x^4}{4!}+\dots \\e^{ax+b}=e^b+\frac{ae^b\cdot x}{1!}+\frac{a^2e^b\cdot x^2}{2!}+\frac{a^3e^b\cdot x^3}{3!}+\frac{a^4e^b\cdot x^4}{4!}$$拆到 $12$ 项,精度差不多就够用了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,L=12;double fac[L];struct node&#123; int fa,ch[2]; double poly[L],a,b; int rev,f;&#125;Tree[MAXN];#define root Tree[x]#define lson Tree[root.ch[0]]#define rson Tree[root.ch[1]]bool isroot(int x)&#123; return Tree[root.fa].ch[0]!=x &amp;&amp; Tree[root.fa].ch[1]!=x;&#125;void reverse(int x)&#123; if(!x) return; swap(root.ch[0],root.ch[1]); root.rev^=1;&#125;void pushup(int x)&#123; for(int i=0;i&lt;L;++i) root.poly[i]=lson.poly[i]+rson.poly[i]; if(root.f==1) &#123; double Sinb=sin(root.b),Cosb=cos(root.b),pw=1.0; for(int i=0;i&lt;L;i+=4) &#123; root.poly[i]+=Sinb*pw/fac[i],pw*=root.a; root.poly[i+1]+=Cosb*pw/fac[i+1],pw*=root.a; root.poly[i+2]+=-Sinb*pw/fac[i+2],pw*=root.a; root.poly[i+3]+=-Cosb*pw/fac[i+3],pw*=root.a; &#125; &#125; else if(root.f==2) &#123; double Expb=exp(root.b),pw=1.0; for(int i=0;i&lt;L;++i) &#123; root.poly[i]+=Expb*pw/fac[i]; pw*=root.a; &#125; &#125; else if(root.f==3) &#123; root.poly[1]+=root.a; root.poly[0]+=root.b; &#125;&#125;void pushdown(int x)&#123; if(root.rev) &#123; reverse(root.ch[0]); reverse(root.ch[1]); root.rev=0; &#125;&#125;void rotate(int x)&#123; int y=Tree[x].fa; int z=Tree[y].fa; int k=(Tree[y].ch[1]==x); if(!isroot(y)) Tree[z].ch[Tree[z].ch[1]==y]=x; Tree[x].fa=z; Tree[y].ch[k]=Tree[x].ch[k^1]; Tree[Tree[x].ch[k^1]].fa=y; Tree[x].ch[k^1]=y; Tree[y].fa=x; pushup(y);&#125;int stk[MAXN],tp=0;void Splay(int x)&#123; stk[++tp]=x; for(int pos=x;!isroot(pos);pos=Tree[pos].fa) stk[++tp]=Tree[pos].fa; while(tp) pushdown(stk[tp--]); while(!isroot(x)) &#123; int y=Tree[x].fa,z=Tree[y].fa; if(!isroot(y)) (Tree[y].ch[0]==x)^(Tree[z].ch[0]==y)?rotate(x):rotate(y); rotate(x); &#125; pushup(x);&#125;void Access(int x)&#123; for(int y=0;x;y=x,x=Tree[x].fa) &#123; Splay(x); Tree[x].ch[1]=y; pushup(x); &#125;&#125;void makeroot(int x)&#123; Access(x); Splay(x); reverse(x);&#125;int findroot(int x)&#123; Access(x); Splay(x); while(Tree[x].ch[0]) x=Tree[x].ch[0]; return x;&#125;void split(int x,int y)&#123; makeroot(x); Access(y); Splay(y);&#125;void Link(int x,int y)&#123; makeroot(x); Tree[x].fa=y;&#125;void Cut(int x,int y)&#123; split(x,y); Tree[y].ch[0]=0; Tree[x].fa=0;&#125;int n,m;char buf[20];int main()&#123; fac[0]=1.0; for(int i=1;i&lt;L;++i) fac[i]=fac[i-1]*(double)(i); n=read(),m=read(); scanf("%s",buf); for(int i=1;i&lt;=n;++i) &#123; Tree[i].f=read(); scanf("%lf%lf",&amp;Tree[i].a,&amp;Tree[i].b); pushup(i); &#125; for(int i=1;i&lt;=m;++i) &#123; scanf("%s",buf); if(buf[0]=='a') &#123; int u=read()+1,v=read()+1; Link(u,v); &#125; else if(buf[0]=='d') &#123; int u=read()+1,v=read()+1; Cut(u,v); &#125; else if(buf[0]=='m') &#123; int c=read()+1; makeroot(c); Tree[c].f=read(); scanf("%lf%lf",&amp;Tree[c].a,&amp;Tree[c].b); pushup(c); &#125; else if(buf[0]=='t') &#123; int u=read()+1,v=read()+1; double x; scanf("%lf",&amp;x); if(findroot(u)!=findroot(v)) puts("unreachable"); else &#123; split(u,v); double ans=0; for(int i=L-1;i&gt;=0;--i) ans=ans*x+Tree[v].poly[i]; printf("%.8e\n",ans); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>LCT</tag>
        <tag>泰勒展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4198 荷马史诗]]></title>
    <url>%2F2019%2F10%2F08%2Fbzoj-4198-%E8%8D%B7%E9%A9%AC%E5%8F%B2%E8%AF%97%2F</url>
    <content type="text"><![CDATA[贪心. $k$ 叉 $Huffman$ 树编码问题,可以等价为每次最多合并 $k$ 个果子的合并果子问题. 这是因为两者的合并树是相同的. 于是就像合并果子那样贪心,维护一个小根堆,每次取出前 $k$ 小的元素合并,需要先补 $0$ ,使得每次都恰好合并 $k$ 个. 这道题还需要让最大的长度最小,所以在权值相同时,按照深度从小到大排序,优先合并深度小的. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;ll,int&gt; pli;#define mp make_pairint n,k,mx=0;ll ans=0;priority_queue&lt;pli&gt; q;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) q.push(mp(-read(),-1)); while((n-1)%(k-1)) &#123; q.push(mp(-0,-1)); ++n; &#125; while(q.size()&gt;1) &#123; ll val=0; int mxd=0; for(int i=1;i&lt;=k;++i) &#123; val-=(q.top()).first; mxd=max(mxd,-(q.top()).second); q.pop(); &#125; q.push(mp(-val,-mxd-1)); ans+=val; mx=max(mx,mxd); &#125; cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;mx&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3211 花神游历各国]]></title>
    <url>%2F2019%2F10%2F08%2Fbzoj-3211-%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD%2F</url>
    <content type="text"><![CDATA[线段树. 对于修改操作,若区间内全为 $1$ ,就跳过,否则就暴力开根. 利用线段树维护区间和. 因为每个数是不会增大的,所以每个数最多被开 $\log \log a_i$ 次根号就被开成 $1$ 了. 时间复杂度 $O(m\log n+n\log \log a)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//%std#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;inline int Sq(int x)&#123; return (int)(sqrt(x));&#125;const ll inf=9e18;const int MAXN=1e5+10;int n,m,a[MAXN];struct node&#123; int mx; ll sum;&#125; Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void pushup(int o)&#123; root.mx=max(lson.mx,rson.mx); root.sum=lson.sum+rson.sum;&#125;void BuildTree(int o,int l,int r)&#123; if(l==r) &#123; root.sum=root.mx=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;int query_mx(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mx; int res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query_mx(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) res=max(res,query_mx(o&lt;&lt;1|1,mid+1,r,L,R)); return res;&#125;ll query_sum(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query_sum(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query_sum(o&lt;&lt;1|1,mid+1,r,L,R); return res;&#125;void Rebuild(int o,int l,int r,int L,int R)&#123; if(root.mx&lt;=1) return; if(l==r) &#123; root.mx=root.sum=Sq(root.mx); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) Rebuild(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) Rebuild(o&lt;&lt;1|1,mid+1,r,L,R); pushup(o);&#125;void Sqrt(int L,int R)&#123; int mx=query_mx(1,1,n,L,R); if(mx&lt;=1) return; Rebuild(1,1,n,L,R);&#125;int main()&#123; n=read(); for(rg int i=1; i&lt;=n; ++i) a[i]=read(); BuildTree(1,1,n); m=read(); for(rg int i=1; i&lt;=m; ++i) &#123; int op=read(),L=read(),R=read(); if(op==1) printf("%lld\n",query_sum(1,1,n,L,R)); else Sqrt(L,R); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1229]]></title>
    <url>%2F2019%2F10%2F08%2FCF1229%2F</url>
    <content type="text"><![CDATA[$Div.1$ A Marcin and Training Camp 有 $n$ 个人,每个人有一个集合,用二进制数 $a_i$ 表示,以及一个能力值 $b_i$ . 现在需要选出一些人形成一个大小 $\ge 2$ 的集合 $S$ ,满足 $\forall i\in S,\exists j\not=i,a_i \&amp; a_j=a_i$ . 需要求出最大的 $\sum_{i\in S}b_i$ ,无解输出 $0$ . 容易发现,选出的人中至少有两个人的 $a_i$ 是相同的,即形成自环.否则就会存在拓扑序,至少存在一个不合法的元素. 可以先将有相同的元素都选上. 对于其他元素,只需要判一下能否被那些有相同的元素限制,即找到 $a_i \&amp; a_j=a_i$ 的 $j$ ,内部不需要判断. 这是因为 $a_i \&amp; a_j=a_i$ 这个关系是可以传递的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=7777;int n,m;struct node&#123; ll first; int second; bool operator &lt; (const node &amp;rhs) const &#123; return first&lt;rhs.first; &#125; bool operator == (const node &amp;rhs) const &#123; return first==rhs.first; &#125; &#125;a[MAXN],p[MAXN],q[MAXN];unordered_map&lt;ll,bool&gt; vis;int main()&#123; n=read(); int t=0; if(n==1) return puts("0")&amp;0; for(int i=1;i&lt;=n;++i) a[i].first=read(); for(int i=1;i&lt;=n;++i) a[i].second=read(); sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) &#123; if(vis[a[i].first]) q[++t]=a[i]; else p[++m]=a[i]; vis[a[i].first]=true; &#125; for(int i=1;i&lt;=t;++i) p[m+i]=q[i]; ll ans=0; for(int i=1;i&lt;=m;++i) &#123; bool f=false; for(int j=m+1;j&lt;=n &amp;&amp; !f;++j) if((p[i].first&amp;p[j].first)==p[i].first) f=true; if(f) ans+=p[i].second; &#125; if(!ans) return puts("0")&amp;0; for(int i=m+1;i&lt;=n;++i) ans+=p[i].second; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B Kamil and Making a Stream 给一棵以 $1$ 为根的有根树,每个点有一个权值 $x_i$ . 设 $f(x,y)$ 表示从 $x$ 到 $y$ 的路径上所有权值的 $\gcd$ . 需要求出$\sum_{\text {u is an ancestor of v}} f(v,u)$ ,答案对 $10^9+7$ 取模. 一个点到根的路径上,不同的 $\gcd$ 最多只有 $\log x$ 种,因为 $\gcd$ 每次改变时至少会 $/2$ . 于是倍增处理每个点向上跳 $2^i$ 步这段的 $\gcd$ 进行处理. 或者 $dfs$ 时直接把 $\gcd$ 的 $vector$ 数组传下来,相同的数合并,只记录次数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10,L=17;int n,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct node&#123; ll v; int t; bool operator &lt; (const node &amp;rhs) const &#123; return v&lt;rhs.v; &#125; node(ll v=0,int t=0):v(v),t(t) &#123;&#125;&#125;;int ans=0;ll val[MAXN];vector&lt;node&gt; G[MAXN],tmp;void dfs(int u,int f)&#123; G[u].push_back(node(val[u],1)); for(auto x:G[f]) G[u].push_back(node(gcd(x.v,val[u]),x.t)); sort(G[u].begin(),G[u].end()); ll cv=-1; int ct=0; for(auto x:G[u]) &#123; if(cv!=x.v) &#123; if(cv!=-1) tmp.push_back(node(cv,ct)),ans=add(ans,mul(cv%P,ct)); cv=x.v; ct=x.t; &#125; else ct+=x.t; &#125; tmp.push_back(node(cv,ct)); ans=add(ans,mul(cv%P,ct)); G[u]=tmp; tmp.clear(); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dfs(v,u); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) val[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Konrad and Company Evaluation 有 $n$ 个人,每个人有一个工资,初始时等于他的编号. 给出一张图,对于一条边 $(u,v)$ ,若 $u$ 的工资比 $v$ 高,则从 $u$ 连向 $v$ ,否则从 $v$ 连向 $u$ . 有 $q$ 次询问,第 $i$ 次询问给出一个 $x$ ,表示将第 $x$ 个人的工资改为 $n+i$ ,再求出图中长度为 $3$ 的链的数目. 将 $a$ 向 $b$ 炫耀看成一条有向边 $a\to b$ . 记录每个点的入度 $indeg_i$ 和出度 $outdeg_i$ ,答案为 $\sum_i indeg_i\cdot outdeg_i$ . 每次将 $v$ 的工资调到最大,就是将所有 $u\to v$ 的边全部反向. 只要将这些边一条条的暴力反向的同时维护答案就可以了. 通过一些势能分析,可以得出每次修改时均摊反向 $O(\sqrt m)$ 条边. 时间复杂度 $O(n+m+q\cdot \sqrt m)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10,L=17;int n,ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct node&#123; ll v; int t; bool operator &lt; (const node &amp;rhs) const &#123; return v&lt;rhs.v; &#125; node(ll v=0,int t=0):v(v),t(t) &#123;&#125;&#125;;int ans=0;ll val[MAXN];vector&lt;node&gt; G[MAXN],tmp;void dfs(int u,int f)&#123; G[u].push_back(node(val[u],1)); for(auto x:G[f]) G[u].push_back(node(gcd(x.v,val[u]),x.t)); sort(G[u].begin(),G[u].end()); ll cv=-1; int ct=0; for(auto x:G[u]) &#123; if(cv!=x.v) &#123; if(cv!=-1) tmp.push_back(node(cv,ct)),ans=add(ans,mul(cv%P,ct)); cv=x.v; ct=x.t; &#125; else ct+=x.t; &#125; tmp.push_back(node(cv,ct)); ans=add(ans,mul(cv%P,ct)); G[u]=tmp; tmp.clear(); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dfs(v,u); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) val[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Wojtek and Card Tricks 给出 $n$ 个长度为 $k$ 的置换, $n\le 2\times 10^5,k\le 5$ . 定义 $f(l,r)$ 表示只用第 $l$ 个到第 $r$ 个置换对排列 $1,2,3,\dots,k$ 进行若干次操作,最多能得到的排列的数目. 需要求出 $\sum_{l=1}^n \sum_{r=l}^n f(l,r)$ . 对于每个左端点 $l$ ,先预处理出从 $l$ 向后走,哪些置换是第一次出现的,这可以从后往前扫一遍完成. 枚举左端点 $l$ ,只用考虑从 $l$ 开始第一次出现的置换,最多只有 $k!$ 个,其它地方答案不变,可以直接计算. 加入一个新的置换时,如果它能被已经加入的置换组合出,就没有用,直接跳过. 否则,直接大力 $bfs$ 出所有已经加入的有用的置换能操作出的排列,若答案改变,说明这个排列有用. 状态数最多为 $k!$ ,而有用的置换不会超过 $O(\log k!)$ 个,所以每加入一个有用的置换复杂度为 $O(k!\log k!)$ . 时间复杂度 $O((k!)^2+nk!k)$ . 常数没卡过去,不想卡了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,MAXS=120;typedef vector&lt;int&gt; perm;map&lt;perm,int&gt; id;int n,k,idx=0;int calc(perm p)&#123; if(id.find(p)==id.end()) id[p]=idx++; return id[p];&#125;perm p[MAXN];perm lst,pos[MAXN];perm rep;int S,vis[MAXS],tid;queue&lt;int&gt; Q;int ts=0,pt;int G[MAXS][MAXS];perm p1,p2,p3;void init()&#123; p1.resize(k),p2.resize(k),p3.resize(k); for(int i=0;i&lt;k;++i) p1[i]=p2[i]=i; for(int i=0;i&lt;S;++i) &#123; for(int j=0;j&lt;S;++j) &#123; for(int t=0;t&lt;k;++t) p3[t]=p2[p1[t]]; G[calc(p1)][calc(p2)]=calc(p3); next_permutation(p2.begin(),p2.end()); &#125; next_permutation(p1.begin(),p1.end()); &#125;&#125;int bfs()&#123; ++tid; int res=ts; int st,newst; if(vis[0]&lt;=pt) res++; vis[0]=tid; Q.push(0); int tot=rep.size(); while(!Q.empty()) &#123; st=Q.front(); Q.pop(); if(vis[st]==tid) &#123; for(auto trans:rep) &#123; newst=G[st][trans]; if(vis[newst]&lt;=pt) &#123; ++res; vis[newst]=tid; Q.push(newst); &#125; &#125; &#125; else &#123; int trans=rep[tot-1]; newst=G[st][trans]; if(vis[newst]&lt;=pt) &#123; ++res; vis[newst]=tid; Q.push(newst); &#125; &#125; &#125; return ts=res;&#125;int main()&#123; n=read(),k=read(); for(int i=0; i&lt;n; ++i) &#123; S=1; for(int j=0; j&lt;k; ++j) p[i].push_back(read()-1),S*=(j+1); &#125; init(); lst.resize(S); for(int i=0; i&lt;S; ++i) lst[i]=n; for(int i=n-1; i&gt;=0; --i) &#123; int x=calc(p[i]); lst[x]=i; pos[i]=lst; sort(pos[i].begin(),pos[i].end()); &#125; ll ans=0; for(int l=0; l&lt;n; ++l) &#123; rep.clear(); ts=0; pt=tid; int tmp=1,head=-1; for(auto x:pos[l]) &#123; if(x==n) break; if(head!=-1) ans+=1LL*tmp*(x-head); head=x; if(vis[calc(p[x])]&gt;pt) continue; rep.push_back(calc(p[x])); int newtmp=bfs(); if(newtmp==tmp) rep.pop_back(); else tmp=newtmp; &#125; ans+=1LL*tmp*(n-head); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>codeforces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191007-eve]]></title>
    <url>%2F2019%2F10%2F08%2Ftest20191007-eve%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/Oo4bGpDFXPme+yaEWmWnIUVSdEFSzcqNX4YZieXud+6F/Z38fxgPOJNC1W5EZ9gkhKQd/v7VOj7MRNgLDWbO+RvfEW/ftmJZaOZPQBpYyve2uT+dM90rCiEHPDvtxDHV5TLgxOnizWM26k/fl0o4fYJGgzrg7ZMVQ5fTo+19ZArqcPplGf9hAXyverE0l/nUP8hKkrTjLjW6k6J/s3eaxGz19mXOkce1cWxupfXlltkkoxEZkQ57NufE3cSw4ci+oiY773n/1V2TSflPPLOLZyg6BNA+i9qT1rmfpl38pD5rodGT+rylGJgG3GvJKVrBr5Ykl29pc3azbAPEIhwI3kMp40h5R9+iVRwHyPDpV6S9v9dGVdKAR37hE1Vof+d5YA3J5TKJqVBwsFvUaiOvTLKxBlZTyWaU96D1EXvU0rW5ux/Lny0zEO/vmLISA//NiPlkSlDz4+1LalKe/dgLpFxKbuLxPG/wKb3RJCjw3YyipLAC7d1QOw6DDquEcyhMsg5iGJnEs68NB5bkAfcoM037oiNj9nEnKWZcDKzRTFz4q7NcnWmazkgHNlFPJW0fAtEjM+Zfbyj1OqYxexD8xD0Fcwi2y4tg9LIzMN2jXcSi2HFtMqwBU5ylIxe4ORVVllYHL0tcLGSdrWTxGt2qTFMw9JPMdNM23YIZb9tlNNEx/nulR4FgPIOtgO+oJPbS4Ll7ENqQIgJLsGsT2o3mBhoLD5vOQXkK/A94oyX6Yn0/NrlTx4qK8Z9qJiLCH70mBdlKko1kKPfilN3Mut8ngHq4/n939UA/1xy3+mSoDLaiCydLmm/S+QTyimkMQ8eLr8/WLl5tlVmdR8ZHhWfDFLMxGI8R4384hvpRcazW8hBhbiyNmFi0Af7L30RepO960nvs/sjmOJXBhZfydssYJlkm8JoANZQh+MM8G4dWm2EyBBvvSIbmhEgGLKwSSBitDMbzMoujlp8e6ebojPGpkc/W1uXnE2iF0I0FgYw5RtV0tN79krqr23IIRs6G7oUWUQqIRYMGYbxwr9jn+OF9TS6kut05gbJeoROWQbJxnFfK03SYRe+GSTuHyFyV2ThW6BKUjuYvaS0T19G+fsc/F9KH1BiCr8e7hLGjSTxSvwL7DYAnNjX6VOFcggN8i+qNyPfBjamDJ/8Dj/oeYmhbQmnIFWzOR4oGCOfusJM49LbFTJuEIYjHhneyYzMrYIXkYENbMx/RNvWzCzabyYGoy3pSZpbXkvQnHpSzibT2+N0BwlqwOVRFXIuCW3ZJEGc3ia6LY1sN9yMkC1w/kZ5941x/mJ2RbRu/V/Q+watrVNfEIWynyYqNQ2Wjl2sIz9jXWvfZIGEtjhkGx9itFGqjs0tFJkZu9zt7UKPB0wD/WYf1Z+04YNyK9LrHiK5A2d+BMX8awWJt5U7K3pa4U0Ag8pjCjAphLwxL5rVRy1/O3uHs/h/hBB+Z//5wWsdPbif7t5pMJqRRs/Zus0cb/FPYATIZGS5zkPOFXXX6Ru0h+iOBO+TgDfmpBlGN7L4prVqp8UOmLhw80DSNCzAsh+HZk05WHtgeUTWEFwa6ldShop/Dbp7LZULpsDO+gU2Doy+i6W5r2pDmYI9qaw49aWVNraw+InUEWq/kAWDXo6WhiQZiXB8Rp8dCANWe40P4dSLICOwwPICqg/XBpcfRNeb1VLtkppWJbCcnnm39FElIoDabz/9uoeo66DYo0I/PhJ91vndzji9xJ+w== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191007-am]]></title>
    <url>%2F2019%2F10%2F07%2Ftest20191007-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5416 冒泡排序]]></title>
    <url>%2F2019%2F10%2F06%2Fbzoj-5416-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[观察结论 + $dp$ 计数. 通过提示,可以发现一个排列合法,当且仅当它的最长下降子序列长度 $&lt;3$ . 否则,若存在 $\ge 3$ 的下降子序列,中间的元素需要先与左边的交换,再与右边的交换,就存在了冗余的步数,不合法. 而根据 $Dirworth$ 定理,该条件又等价于这个排列能被 $2$ 个上升子序列覆盖. 从前往后依次填入所有数,设 $f(i,j)$ 表示还有 $i$ 个数没填,且这 $i$ 个数中有 $j$ 个数大于已经填入的最大值的方案数. 转移时,枚举填的数是这 $j$ 个数中的第 $k$ 小,若 $k=0$ ,则表示填入的数不在这 $j$ 个数中.$$f(i,j)=\sum_{k=0}^j f(i-1,j-k)$$容易发现它是个前缀和,$$f(i,j)=f(i,j-1)+f(i-1,j)$$而 $f(i,i)=0$ ,即不合法,那么可以看出 $f(i,j)$ 的组合意义. 它表示从 $(0,0)$ 出发,每次可以向右方或上方走一步,在中途不触碰直线 $y=x$ ,到达 $(i,j)$ 的方案数. 于是预处理阶乘及其逆元后,可以 $O(1)$ 求 $f(i,j)$ . 还有一个限制是字典序必须大于给出的排列 $p$ ,就像数位 $dp$ 那样做就可以了,时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b); &#125; int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=6e5+10;int fac[MAXN&lt;&lt;1],invfac[MAXN&lt;&lt;1];void init(int N)&#123; fac[0]=1; for(int i=1;i&lt;=N;++i) fac[i]=mul(fac[i-1],i); invfac[N]=fpow(fac[N],P-2); for(int i=N-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int f(int i,int j)&#123; return add(C(i+j-1,j),P-C(i+j-1,j-2));&#125;int n,a[MAXN],val[MAXN],pre[MAXN],suf[MAXN];struct FenwickTree&#123; int bit[MAXN];#define lowbit(x) x&amp;(-x) void init() &#123; memset(bit,0,sizeof bit); &#125; void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int query(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;T;void solve()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.init(); for(int i=n;i&gt;=1;--i) &#123; suf[i]=n-i-T.query(a[i]); T.add(a[i],1); pre[i]=i-1-(n-a[i]-suf[i]); &#125; int cnt=n,ans=0; for(int i=1;i&lt;=n;++i) &#123; if(!suf[i]) break; bool flag=(suf[i]&lt;cnt); cnt=min(cnt,suf[i]); ans=add(ans,f(n-i+1,cnt-1)); if(!flag &amp;&amp; pre[i]!=a[i]-1) break; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; init(MAXN-10&lt;&lt;1); int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191004]]></title>
    <url>%2F2019%2F10%2F06%2Ftest20191004%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+vGDNMud3vDPftZgEmGtd81DFwxqjXGs+G//VfggH0E57Ozuq84ZDKl9UaXYimMM98N1RTKYQJOuLhRBlhdng/QDCgP47wgonomPeRgFknZIkQnk9iQnzi47gP2Qc9OQNEDRhknk0bbRlKG+WjZUDfIaXxaQ4LRdmteLIqX5DjNeIQkFpffCCyH17JOCG9VjUk6Z37VV/YGm0XytqcBNx3fHZinmhAMPLlvcUrOYS7JPwqv1Uw/vIkzeKc1vouo413sH1vyGGty/33D0xbElExH7kOWapgMJtQThITh8CzO9aCPfsKAhLdqqBeZbcjIo02ul6P2DtQRLfpg9LFCIaUh4T4G5WQchxTKTrUUAqZbntS+zh1lSztxbvDGXzxZD2j6zLQkjU93GCtCEty/hRAmA4x4ZPF9FAtpZ/D7BtwGaKPLSRm8bsbxHsXcPNYUw9pEFKcEqc/As0Gbxw1AUAk75DUojkHmDYDhoI1/gEh+5bi6gMUH2Tu235AOSlazu7FJl3STGIT6DV8cstVB0c7zQ0kU3HycSNTBvifAoQff8HXHOpPBOkbjPOQMZrGyGZisT+oZXqRBpnJjbRkMTPoCXDmUjrX5BcDhPeagBflsM5ULZqICZkEUY4EHxrLgReMjiNcc4j8YkrraqamCz/pxQ15sl8fuJX3ypO32WFxM1TESIVYyvVavdMt+P5JIQ1kSGThNXVEMnfjyJUZUr3D6OZmADPYXtn1gsGwQIPG5cYJTY17AvC1gS8UhDpCSm83QzRGpoCKCgiy0QmXqeQVAsn0C0FYgI1apneBknriPYKSYd0mSpM35edKXW23HZM0MEK0JKl94rUN4v+W6Stl3O2f/FyuWVxMWkYub//RrTgj9piIYHNyAnhqkLK/c1AQ3R6lgwA0xF7wxh/vL3mmHu22CD1w00OI2hXUk0bNWEwbO7WDWNcBiwizIE539Fn4xJBCrKSMGFTF/x4WoJ9ceqN4ZfS9Mw8iIF+x51y7rWirAzWL84/mJlAOuwXZR8wv2r0dScmRvRZQGLs774ZwOfxHthVmsfSu5LJn4kkO7s9F1r/GZAJbHjlfnDf/WQks8vi3Jmsv6NES0XqsdRR1duS2UgOkR0GX+HAwMvwiu5fqfyPthap0GpN2rrUGr9Y/isb/cZYAqxAMsVwUY3CHD8k93lx8vI1RDZFHAQLefaoXpfstsDcN var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>test</tag>
        <tag>meet in the middle</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20191001]]></title>
    <url>%2F2019%2F10%2F06%2Ftest20191001%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>test</tag>
        <tag>矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1228]]></title>
    <url>%2F2019%2F09%2F30%2FCF1228%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Distinct Digits$l,r$ 比较小,不需要数位 $dp$ ,直接按照题意模拟即可. B Filling the Grid每个 $r,c$ 都可以确定一些格子的颜色.如果出现矛盾,答案为 $0$ . 否则没有被确定颜色的 $k$ 个格子可以任意选颜色,答案为 $2^k$ . 写完直接测第三个样例,就交上去了,把 $C$ 写了才发现 $B$ 没过,没判无解的情况… C Primes and Multiplication$x$ 的各个质因子之间贡献独立,分开计算. 一个质因子 $p$ 的贡献显然是 $\prod p^{n/p^k}$ ,注意判断是否令 $k$ 增加 $1$ 继续循环时,需要用除法判断,否则会爆 $\rm long\ long$ . D Complete Tripartite先随便选一个点 $x$ ,尝试将所有点划分成两个集合. 将 $x$ 加入第一个集合,若 $y$ 与 $x$ 有边,则加入第二个集合,否则加入第一个集合. 然后再在第二个集合中选一个点 $x$ ,将第二个集合划分成两个集合. 若划分后出现了空集,则无解.最后需要判断一下集合内的点是否没有边,以及跨越集合的点对都有边. 可以枚举每一个点 $u$ 和它的邻居 $v$ ,判断所有的 $v$ 是否恰好覆盖了 $u$ 所在集合外的所有点. E Another Filling the Grid直接容斥,枚举有 $x$ 行 $y$ 列一定没有 $1$ . $x=n$ 或者 $y=n$ 的贡献只能算一次,因为它们都是覆盖了整个矩形,而其他情况显然都是互异的. F One Node is Gone注意到删掉一个点后,根节点一定是直径最中间的两个点之一. Case 1若删掉的点是根节点的儿子,直径会 $-1$ ,就可能产生两个答案,且根节点为直径最中间的那两个点之一. 还需要判断它们的子树是否都是满二叉树. Case 2删掉的点不是根节点的儿子,此时直径不变,为偶数,只可能有一个答案,且根节点为直径最中间的那一个点. 可以将剩下的树遍历一次,对于度数异常的点进行判断. 若度数为 $1$ 或 $3$ ,那么这个节点是正常的. 若度数为 $2$ ,那么被删的是它的儿子.只需判断它剩下的那个儿子是不是叶子. 若度数为 $4$ ,那么被删的是它的儿子.需要判断它的三个儿子的子树是否都是满二叉树,且高度为 $h,h,h+1​$ . 若度数 $&gt;4$ ,显然不合法. 若有多个度数异常的点,显然也不合法. 判断某个子树是否为满二叉树,可以对树 $dfs$ 处理. 这颗子树为满二叉树,当且仅当它是叶子,或左右儿子的子树都是满二叉树,且高度相同.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>codefoces</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190929]]></title>
    <url>%2F2019%2F09%2F29%2Ftest20190929%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Comet OJ 模拟赛Day2]]></title>
    <url>%2F2019%2F09%2F28%2FComet-OJ-%E6%A8%A1%E6%8B%9F%E8%B5%9BDay2%2F</url>
    <content type="text"><![CDATA[昨天忘打了,就只打了今天这一场. $reorder$像归并排序那样直接贪心就可以了. $prefix$把 $n$ 个串搞到 $Trie$ 树上,利用 $dfs$ 求出每个串的排名. 然后就是个类似于康拓展开的东西,用树状数组搞一搞. $monotony$ 一上来就口胡了个做法,写到最后一步的时候发现不会做了. 暂时先咕了.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190928]]></title>
    <url>%2F2019%2F09%2F28%2Ftest20190928%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树分治</tag>
        <tag>暴力</tag>
        <tag>高斯消元</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190927]]></title>
    <url>%2F2019%2F09%2F27%2Ftest20190927%2F</url>
    <content type="text"><![CDATA[修数据场. $decoration$对单调不降,单调不增分别用树状数组维护 $dp$ 值. 转移时注意相邻两个元素相等时对两种序列都可以产生贡献. $path$从高位到低位贪心即可,用并查集判断只用当前这位为 $0$ 的边能否让 $1$ 与 $n$ 连通. $multiplication$判掉无解的情况,然后 $tarjan$ 缩点后在 $DAG$ 上 $dp$ 计数.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>tarjan</tag>
        <tag>并查集</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190926]]></title>
    <url>%2F2019%2F09%2F26%2Ftest20190926%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190925]]></title>
    <url>%2F2019%2F09%2F25%2Ftest20190925%2F</url>
    <content type="text"><![CDATA[$CF\ vp$ 场. $per$用所有的方案 $n!$ 减去 $a$ 单调不减的方案,再减去 $b$ 单调不减的方案,再把 $a,b$ 都不减的方案加回来. $medium$记 $pr=\frac a b$ ,单场概率确定的情况下,答案只与点的个数有关. 设 $f(x)$ 表示有 $x$ 个点时,游戏总场次的期望.边界有 $f(0)=f(1)=0$ . 强连通分量在缩成一个点后,最终会形成一个 $\text{DAG}$ ,所以缩点前,一定存在一个出度为 $0$ 的强连通分量. 枚举这个出度为 $0$ 的强连通分量的大小进行转移.$$f(n)=\sum_{i=1}^n p(i)\cdot g(n,i)\cdot (f(i)+f(n-i)+i\cdot(n-i)+{i\choose 2})$$其中 $p(i)$ 表示 $i$ 个点形成强连通分量的概率, $g(n,i)$ 表示从 $n$ 个点中选出 $i$ 个点,被其他 $n-i$ 个点打败的概率. 注意到枚举时有 $f(n)$ 转移到自己的情况,所以要移项解方程来计算. 考虑如何计算 $g(n,i)$ ,枚举 $n$ 是被打败的 $i$ 个点中的一个,还是 $n-i$ 个点中的一个.$$g(n,i)=pr^{n-i}\cdot g(n-1,i)+(1-pr)^i \cdot g(n-1,i-1)$$考虑如何计算 $p(i)$ ,仍然像计算 $f(i)$ 那样,枚举出度为 $0$ 的强连通分量大小.$$p(n)=1-\sum_{i=1}^{n-1}p(i)\cdot g(n,i)$$时间复杂度 $O(n^2)$ . $easy$把每个套娃看成一个点, $a​$ 能套住 $b​$ 看做一条边 $a\to b​$ ,权值是产生的空隙大小,即 $a_{in}-b_{out}​$ . 直接连边的复杂度是 $O(n^2)$ ,把套娃按 $out$ 排序,每个套娃能连向的点是一段区间,可以线段树优化连边. 从 $S$ 向每个入度为 $0$ 的点连边权为 $0$ 的边,从每个出度为 $0$ 的点向 $T$ 连边权为 $x_{in}$ 的边. 那么要求的方案数就是从 $S$ 到 $T$ 的最短路数目,图是 $\text{DAG}$ ,可以直接记忆化搜索求出.]]></content>
      <tags>
        <tag>概率/期望</tag>
        <tag>线段树连边</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190924]]></title>
    <url>%2F2019%2F09%2F24%2Ftest20190924%2F</url>
    <content type="text"><![CDATA[乱搞场. $func$考虑推式子.当 $n&gt;m$ 时,有$$a_n=n-1+\frac 2 n \cdot S_{n-1} \\S_n=n-1+\frac {n+2}{n} S_{n-1} \\\frac{S_n}{(n+1)(n+2)}=\frac {n-1}{(n+1)(n+2)}+\frac {S_{n-1}}{n(n+1)}$$记 $f(n)=\frac {S_n}{(n+1)(n+2)}$ ,得到$$f(n)=f(n-1)+\frac{n-1}{(n+1)(n+2)}$$分块打表处理 $\frac{n-1}{(n+1)(n+2)}$ 的前缀和即可. $ill$考虑写出一个集合 $S$ 的答案.$$\sum_{i\in S}\frac{p_i}{1-p_i} \cdot \prod_{i\in S}(1-p_i)$$记 $x=\sum_{i\in S}\frac{p_i}{1-p_i},y=\prod_{i\in S}(1-p_i)$ . 考虑加入一个 $p_x$ ,答案会增加 $p_x\cdot y\cdot (1-x)$ . 可以贪心地将所有 $p_x$ 从大到小加入,当 $x\ge 1$ 时退出,得到最优解. $mask$经典题目. 带修莫队,二维数点,分块 + 树状数组都比较可做.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>test</tag>
        <tag>莫队</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4151 The Cave]]></title>
    <url>%2F2019%2F09%2F23%2Fbzoj-4151-The-Cave%2F</url>
    <content type="text"><![CDATA[结论题. 以 $1$ 为根,预处理出每个点的深度 $dep$ . 对于一条限制 $(a,b,d)$ ,满足限制的点中,深度最小的点一定在 $a,b$ 的 $lca$ 到根的路径上. 设这个点为 $x​$ ,则 $x​$ 需要满足 $dep_a+dep_b-2dep_x\le d​$ ,可得 $dep_x\ge \lceil \frac{dep_a+dep_b-d}{2} \rceil​$ . 考虑所有的 $m​$ 条限制,可得 $dep_x\ge \max \lceil \frac{dep_a+dep_b-d}{2} \rceil​$ . 记点 $p$ 为所有 $m$ 条限制中, $\lceil \frac{dep_a+dep_b-d}{2} \rceil$ 最大的那条限制对应的点 $x$ . 有结论,若 $p$ 点不能满足所有限制,则一定无解.于是判断 $p$ 是否合法即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,dep[MAXN],fa[MAXN];void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u]) continue; fa[v]=u; dep[v]=dep[u]+1; dfs(v); &#125;&#125;int a[MAXN],b[MAXN],d[MAXN];void solve()&#123; ecnt=0; memset(head,0,sizeof head); n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dep[1]=fa[1]=0; dfs(1); int mx=0,p; for(int i=1;i&lt;=m;++i) &#123; a[i]=read(),b[i]=read(),d[i]=read(); int tmp=dep[a[i]]+dep[b[i]]-d[i]; if(tmp&gt;mx) mx=tmp,p=i; &#125; if(!mx) return (void)(puts("TAK 1")); mx=(mx+1)/2; int x=a[p]; for(int t=dep[x]-mx;t&gt;0;--t,x=fa[x]); dep[x]=fa[x]=0; dfs(x); bool flag=true; for(int i=1;i&lt;=m &amp;&amp; flag;++i) if(dep[a[i]]+dep[b[i]]&gt;d[i]) flag=false; if(flag) printf("TAK %d\n",x); else puts("NIE");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4195 程序自动分析]]></title>
    <url>%2F2019%2F09%2F23%2Fbzoj-4195-%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[并查集. 把所有 $x_i=x_j$ 的 $(i,j)$ 用并查集合并在一起,再对于所有 $x_i\not= x_j$ 的 $(i,j)$ ,查询是否在同一个并查集中即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;struct edge&#123; int u,v,tp;&#125;E[MAXN];int n,val[MAXN&lt;&lt;1],tot=0;int fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:fa[x]=Find(fa[x]);&#125;bool solve()&#123; tot=0; n=read(); for(int i=1;i&lt;=n;++i) &#123; val[++tot]=E[i].u=read(); val[++tot]=E[i].v=read(); E[i].tp=read(); &#125; sort(val+1,val+1+tot); tot=unique(val+1,val+1+tot)-val-1; for(int i=1;i&lt;=tot;++i) fa[i]=i; for(int i=1;i&lt;=n;++i) &#123; E[i].u=lower_bound(val+1,val+1+tot,E[i].u)-val; E[i].v=lower_bound(val+1,val+1+tot,E[i].v)-val; if(E[i].tp &amp;&amp; Find(E[i].u)!=Find(E[i].v)) fa[Find(E[i].u)]=Find(E[i].v); &#125; for(int i=1;i&lt;=n;++i) if(!E[i].tp &amp;&amp; Find(E[i].u)==Find(E[i].v)) return false; return true;&#125;int main()&#123; int T=read(); while(T--) &#123; if(solve()) puts("YES"); else puts("NO"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4543 Hotel加强版]]></title>
    <url>%2F2019%2F09%2F23%2Fbzoj-4543-Hotel%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[长链剖分经典题目. 设 $f(i,j)$ 表示子树 $i$ 中距离 $i$ 为 $j$ 的点的数目. 设 $g(i,j)$ 表示子树 $i$ 中点对 $(x,y)$ 的数目,其中点对满足 $x,y$ 的 $lca$ 与它们的距离都为 $d$ ,而与 $i$ 的距离为 $d-j$ . 借用一下 $\text{Bill Yang}$ 的图片. 直接暴力合并 $u$ 与它的儿子节点 $v$ 的信息,时间复杂度是 $O(n^2)$ 的,只能通过原题. 注意到维护的下标是以深度为下标,利用长链剖分即可做到 $O(n)$ . 合并 $u$ 当前信息与它的儿子 $v​$ 的信息时,转移有,$$ans+=f(u,j-1)\cdot g(v,j)+g(u,j+1)\cdot f(v,j) \\g(u,j+1)+=f(u,j+1)\cdot f(v,j)\\g(u,j)+=g(v,j+1) \\f(u,j)+=f(v,j-1)$$利用指针移动实现空间的高效分配,以及继承重儿子信息. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,ecnt=0,nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],head[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int mxdep[MAXN],mxson[MAXN];void dfs_init(int u,int fa)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs_init(v,u); mxdep[u]=max(mxdep[u],mxdep[v]); if(!mxson[u] || mxdep[v]&gt;mxdep[mxson[u]]) mxson[u]=v; &#125; mxdep[u]=mxdep[mxson[u]]+1;&#125;ll *f[MAXN],*g[MAXN],tmp[MAXN&lt;&lt;2],*id=tmp,ans=0;void dfs(int u,int fa)&#123; if(mxson[u]) &#123; f[mxson[u]]=f[u]+1; g[mxson[u]]=g[u]-1; dfs(mxson[u],u); &#125; f[u][0]=1; ans+=g[u][0]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || v==mxson[u]) continue; f[v]=id,id+=mxdep[v]&lt;&lt;1,g[v]=id,id+=mxdep[v]&lt;&lt;1; dfs(v,u); for(int j=0;j&lt;mxdep[v];++j) &#123; if(j) ans+=f[u][j-1]*g[v][j]; ans+=g[u][j+1]*f[v][j]; &#125; for(int j=0;j&lt;mxdep[v];++j) &#123; g[u][j+1]+=f[u][j+1]*f[v][j]; if(j) g[u][j-1]+=g[v][j]; f[u][j+1]+=f[v][j]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs_init(1,0); f[1]=id,id+=mxdep[1]&lt;&lt;1,g[1]=id,id+=mxdep[1]&lt;&lt;1; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190922]]></title>
    <url>%2F2019%2F09%2F22%2Ftest20190922%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190921]]></title>
    <url>%2F2019%2F09%2F21%2Ftest20190921%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+SjNjEbdXdJPncNY1bWr+mmMb9FSCGmr0BgsfR5KVgtSrHG25DWXNwiHJPXrP62rs+TC/++Npa7MyDxlhENszhbd1W01jVhVJacaBSgRxmX5h1HSBp8h7zS5vEb7VMGm01ZEdfc4Tw4Fc5BVUUhDJXTs1iKcTG0Zb2omt9+Hb9wYS/bfH4oQsaHzP3KMxVvNY6IbnK8xtg1QZHwSjLnzBsi2Tb4wnNYIhZ9qY9N74AiqXCZg2RDX8RH3PH/7tlZgIZZ3KuEn8lY8Kr9jBpR2npny4nyBfnK6XAFyVuA6B5Co+6OJ2BdeIgoEqFK0IMzI6Nxp91EMjdoS3z+zelolqf/rqRzfKdRHypMBf9kKWQSyI2Hx7V7nO+ZVZ3MGF143rnLgVRboOjw2KaGEoavWB3dyNJMVflKmJD9AIEKPma1rdi3bMbIi7as/0oGXWukGsKa2042RIF1NzsFjOSN36c7nL43w+8iCKSj/wDZAgMo8bXPb33L3FwvIgaNFa4UND6XMAewKRzI499xkIk1+ygyp2bP8DEzgugjDtQVOpBIZ6RihM1k25x+aZVn0BlOYeQm50HffkWN2StXs9VQEXDD3fqFBvuOpLuW/ubM6n5szPFg06JdLFgEjrGY9SgUBss4uXN5IBh10sKBaRFer69so1E1V0XLKp2bxKTAIrDe1d8kdrMxIFnHG7aF2C15wwvIFm/FGQbk4Sx0s2eKXQRCdd6KgCFeGp3j1rPUf8gFKkRtr73TrcS1vRo3vNh0pT31jpSf4uW2bfME6osSl43Qf5e5urpOxcBrtqtD7Bm3p1idi8MCFnMypLBxWL46R361pY4j6I/pLZoUWIfs46vtFzg+6wlatK/qboCMrefsoUFJor49cyHRIA8nyRu7/cAm2MCJqVlX1X2Ih1zur3qvgaYfYmaejJOYMhPSg+oQgWB9h4ReNsGLuzGRkAdj3Rbn/HvF1QGkAauOcS3qtComy6d33V1L031/lYsghs8hFEj7GNL7y1shKtpaFTLego4VcoVFAdwQhx35uwT9VJizSqf+Adhpk/zcvmC9wGpmjOJQ4bQPmRtQ1ZI53FHyIxTk7wcOONyAVPtHv/FatlCnOF0Arlae6cgW47OAqU79YuTTrl5e0sbe0zUq7sinsJNCVmWFB6WuDQkMWCBUrO03lHpmc5ftV2SADmfhJCCKwdpzdBJz/CLorNL7rvZLC4YDxbFmIjL+hV/+Zh+g4l0VenOr691/QzaePqhZ2FIAcJfIWZ+yoxtIZHX9MsCZFSAc5ZjyQ8XmyuCxUZISdI+si+J/wFT/R6G9ha6tSaCrEaXKBT54FJ40SbKRF94qt3F9Pj/k8wYz/GtdtxW1YnQWnJXMZ25qi9b3XRJFxFqTo9lPIPkeSkXZ9DlsZ/v1O/txeTCISrrBg== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>树形dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190920-pm]]></title>
    <url>%2F2019%2F09%2F20%2Ftest20190920-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>树状数组</tag>
        <tag>容斥原理</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190920-am]]></title>
    <url>%2F2019%2F09%2F20%2Ftest20190920-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+1pfaWkzOIgsfAOZuV0SI0UcqWW4k1DLeiJEkzpn4BaBFw+az7KsshTHue4fN9CS1tDbENWBWqSHcbnVfOBgC/Uf2h+yvw08h7qwQ9MInGmr+Fd8UEkOCJUHKPUhreXCj/eQgTD+GBl6AnzRNUr9c0g4/bMkMN8MNSqsOATKu/YvTEUI9X5pDqLQKEzHFkcZCeKoAr7POEHmGiKZWCA10QpvWQaB19bm6g7OTmIwEFmYmxcfASUib+hgRgyyDu3TLunYeRP1fwKg7plSYiOVQQq0yH3ng9RkQ4wbzrnZesr9nbGHoSCrN2zBEbRlwtxb1jcaPrKq3CwcQRkNlDmt4SXLzXlO/E+v7Hf+qbdN/Uc2/KN5RACnUr50aLe7u1OJKELt9V5dG/4hvChGyCIFQPlHdFht+s7F5yV79RB7Dzh1CzwbnJdGP6Z+D+bx+54BoYwsrU9m+pNmuXOvBH7Qn6n6Ar02H5WlXeoOuUqyednH4+Ka74G+mypZSb3njabVayg3LpfcPbCjUC6/5B8feEJ8Ck80cDL18hYujWLrC7k3hClps5VvWFXTnHiq+WI46IPKzlI1oF3Dk+smIeW+w4gyg4tHmBj7eDfIg0dgGooUzFKgGp0IWM var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190919-pm]]></title>
    <url>%2F2019%2F09%2F19%2Ftest20190919-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>test</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190919-am]]></title>
    <url>%2F2019%2F09%2F19%2Ftest20190919-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+wVnF5kNZwTucrFJTjRhf90+FKTbz2n1ZVZGD/iUTMQbGVrmd41XkgmVRF1Y4/5XeOCeZCdUCPEsTt1xtthby/IjuSvVxSECxZJoZq4B12QWFSqMogh/2MRsufcqSqemNNCGsEuLR4nKFf8AiblS6yg9C9XXzIdjkJ4MibR8p3umYPlHd16c3KGBinHIvbXLBUUSQtFnKWGXIyp2s440MI/eMB8frq9/DPqo74BNx+3fLXFbh2k4kLvZexWnVvQgYCoPGISMOw4yDphbXvMBUe4Eo/x/FBBuYl4JqW/GoQEiqSDxB4YNX4EZvQz9G4Ts+9K9DyeCZ/39v08WJpwCtyjiEtUowum/bT8qLG4mkAD1UcaaTDR1FoYmDX6bMuyo+PwB7VZoY6c3SFjFns+FYuivWgAICluO65wHnb8NAvcg3yrJJKLKz56IMBh61GDuuwGQpDfbvfAJqJdrck0RR1JKNUGgGAGozyE50LhETcur/NkGYzxWVo2ERax2yTc5x7Jq5Chj64Fv6QKMDqRDk27o+iZeSZs7jharIGLaH1u//qx9cM/l84/IV9o2UItZKtuSa0kXlA5tgV7G7229AU0q2fXSRt5izCRSHmXnrFrRyqGM/auSTD/LptRnvvUhjlNECg4Obi5LfOnbi9GttWIqKprBjkKv4rxleVvD7t1OvV5Wr8sn93kZMPLjVy533NmkEvNY1nDNvVrKW21WJgWEZihzKVJYHsXoSQt6VL6lZahXTizLnVIUs3Uu4zZGkkdvPpBwqV0w9CwS+pQPFAeBfZCMkVD1fCLYZfHBc0Bq/oRxeoVtZIAsivFHYT/oW1nm8PH9NR6qHDc+FVJ+6KuoIyLwT+l66S3zgnquUs1rUpOTS/TZj24Jtgc4VNjyVpG89QMrCcMQpbhYXiuze+BUfaCKK2JZFzT9L2RPdZdS7wWGMz/5ZgDmVa0s0W/jeJ6zKqVC6tNKp66EH0ybMKLzGJjY/ClbU5D21T+SxffcWO/IZicT6lDSP+Rent6E1FuYstWPKrMtKOTqg6T8kMI1PeM3cf7QLxHJHhVjjcgLSgGqCYptZ4zJTPkUYWt7ysSdj4l2CgY9672ayOFN6q+N5D/STz261lHjN/kITfrCD9aF/M6Ef8iW9cOhnaIMSotgrkcP8I54FQZgiFRHLnCiKrw9UoMxCd79DbEj6Mi9wtTqlfwF2/gp+YEA0j4ULrK9Rjvs5SluKXxe3HBoP7Ih7jEYyWleuTxP/V4/mY0dBX+PeLUj6xaVDC8LVYB/3fKfX2TuBQ6QMJ3PhnFgF0TBAPoiH/PnY0YY1IXZQwJDYX0ui0I1dV6hSige2wb/2KmdwfUSQjhjcvm5rCVhcK0B8TnB68iBQZz6l8OPFobRNYnhjr9qXWjxaZ3/36guQAqqI1gffX0Q0/7u64b8nUIC3apdvExW/mu2j3PzGrjFJpUpeGr8SV8E51u+S2tumOtRLPMoI+AQKUZ+pGy7mMaWyyCkSKIBrSjDwaisf1u31YJG1fMHPbcFfvIumb04/iTT21qYVUZUBQn3Sug81YxQEje6vutOAgcOFUEAsNKd8w3Qo8S3m6qjgFuXzU1OoqACdaKyFzmdzET3xl2IWU4k7NgF34kmiRQbI2uQye/sjXh+bnEg7YEio+fPkXwzkaSe18J49lUObsMDpP5wMeUsXFCrIPn0fMOJhxcezs6yS2ua3+ARu7D+rqzExRuCo39Pu4zfF8bQvM3Mh7ePxIg7/8aMuwkOrLxVV+OuYIurfVWScHSYfHXH+axTNqSgPfS9zptbeo3YkpvbFw+pWsP6H9fvs2qcTnTD4KtPvQJpgbYJhG1bdhhRM90s5hsktGxljI+2jtyuQLJhvLA3JdPlgzCwbycHQ= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>博弈论</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4897 成绩单]]></title>
    <url>%2F2019%2F09%2F18%2Fbzoj-4897-%E6%88%90%E7%BB%A9%E5%8D%95%2F</url>
    <content type="text"><![CDATA[巧妙的区间 $dp$ . 设 $f(i,j,l,r)$ 表示最后一次操作将 $j$ 删掉,且最后一次操作的最小值为 $l$ ,最大值为 $r$ ,删掉区间 $[l,r]$ 的最小代价. 设 $g(i,j)$ 表示以任意顺序删掉区间 $[i,j]$ 的最小代价. $g$ 的转移是枚举最后一次操作.$$f(i,k,l,r)+g(j+1,k)+A+B\cdot(r-l)^2 \to g(i,k)$$$f​$ 的转移是枚举用来更新最值的数.$$f(i,j,l,r)+g(j+1,k-1)\to f(i,k,\min(l,w_k),\max(r,w_k))$$需要注意两个 $dp$ 数组的初始化以及权值的离散化. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//%std#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;int sqr(int x)&#123; return x*x;&#125;const int MAXN=51;int tot,val[MAXN];int n,w[MAXN],A,B,inf;int f[MAXN][MAXN][MAXN][MAXN],g[MAXN][MAXN];int main()&#123; n=read(); A=read(),B=read(); for(int i=1;i&lt;=n;++i) val[i]=w[i]=read(); sort(val+1,val+1+n); tot=unique(val+1,val+1+n)-val-1; for(int i=1;i&lt;=n;++i) w[i]=lower_bound(val+1,val+1+tot,w[i])-val; memset(f,0x7f,sizeof f); memset(g,0x7f,sizeof g); inf=f[0][0][0][0]; for(int i=1;i&lt;=n;++i) &#123; f[i][i][w[i]][w[i]]=0; g[i+1][i]=0; &#125; g[1][0]=0; for(int i=n;i&gt;=1;--i)for(int j=i;j&lt;=n;++j) for(int l=1;l&lt;=tot;++l)for(int r=l;r&lt;=tot;++r) if(f[i][j][l][r]&lt;inf) &#123; for(int k=j+1;k&lt;=n;++k) upd(f[i][k][min(l,w[k])][max(r,w[k])],f[i][j][l][r]+g[j+1][k-1]); for(int k=j;k&lt;=n;++k) upd(g[i][k],f[i][j][l][r]+g[j+1][k]+A+B*sqr(val[r]-val[l])); &#125; cout&lt;&lt;g[1][n]&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[test20190918-pm]]></title>
    <url>%2F2019%2F09%2F18%2Ftest20190918-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+lKWfet1k+CDN5wQKNVJgHk0I2qOeiuq6EtrLWbeGuSRv2lJ3GS8nvQQHxcEMYi2DejZm8HtVA2WTcbEfbtSEV0OVUPnmCrnsl/2HGUun2v6s6Rs/CT9PHafceP7uSb65gh966NTSVCZrIe5OsundkpMQg7yW6GNkHSp0/AttHuLzzgBdCVUMpwbWYDRzc0jCytxG3OklmvvC5/ErorWb+/25NZeJx7K72hfjSEn1uElYQ4or+n2yWVFrR/l0LpnNUK/PVMVWW1k+32j2dtDxGgNwzrZWjOO3ciOydbXUW5/Ougv2yxwUtvhfrYCcL3/7Ivxh5Kl5yClN/peG0y63w4T2OtYWBm15qSuE+jm0a4/uMrjbt6Jq2Oko968UOCEwQfBExXT+8o48XcMZBet24j8T6uRRajADEx46zjiKXNxyWGc7exQFbVI5ZYztqIlf7PQg7CBIoS3XvYzjUOjSEChCvYfLScPOA9Asok80y5OeSW2CBaRXWAUIOPuOrmgN3WVy7HjHSbZqtXrw1uR9bS69VWmXaJyX1UpE/FAiO67b3u3CUflW48xxs3axzkx4bLW2wYUSeYiZKNUjAMwxSXi3xIdzmIh2a1kOjT4fUTtJafM7z34nRj7Gu365aVibsZmb7mg39ILflxORit++rbYebBuZ8sutXBhKGWfHZI1qDQNAvTxZDl9TNQB+1DB6Cy6aMZHCJ2p/VdXLykN/037H6LoG3TQ6JPlZCO71/LfuONeET8YU8BlR7ZN5ktpGSdWJvhRcAUOj0EewHeD0t+BxrydB3iazMvDUTr6C4SErKZ+1V6Li0qdtgkZnkH9KG4CI4+5IAbwivhXwVw8LZSIaAFJtNu/vDRDXbzsHGzTsgx0c1vwPBXfDarS+AeSv6X9i49PCaKMEsj1ktol5Kq0suTJTtwuGqUi6liPSrn+OYi8613Pc5Ky/Fe0WY4D3RcLONXDJDiKy/wrQ/Z49vSUa25hsP2x07NmH3mWKw49iWsIXkDw6eHLMxPrvgsbKoO80jObPvTs27ElXYFjk95VhVh/K77yr7dWk4toxxLeEfPTca0akuKqF+05tiaNEwdzizrzA9HrynlzsjtTzaJChsVlDv30j5QUtn7Kkx4QWuhv9jcYVDCQ/TcU2YEMEw3aH4EjCj+yvLI1EkLOIMLdRrno+hC5AJMzeJG2ViQmxbHJkWWLpGmG34cI1wuYrzSyHs0S+bfpQMOs3395k8tlBbYKgu0xdl6Mn5tIOou06os8uajmHQGAe6worGCamX1s8LeSjHenBsYbMR8hvWF/zro7DigJlCsbDQvKZUsVGM6hl9onxNeAQO7SCBRCuJXeG2PDW2bATIrNkGY21S4/CoYiNXNZ79vGs5VNWPJBbfSBNjEsvLDHAmPJXbZySaN4Ce0Abf5f0zbh0n3hwOhyxpgwTNqY98ljMJ4RLAHCGhvj+uFo4+KdSjZehsE63xZ2Mw9UqN5tXLGBC0fs7wib35S/9NoB+R6wZsLAEnfHrh/DoDtIwNWtrUtk2vtC8F9a3sN9jls/5SVDr9baxUFce9m25Zf/POfVL5wEfnGq5S6MJXJmGzqgG5H2L+qmBmavDJVeJJgfCNdWt20iVK9wqsasX5mKSKzoxUnfH00iqBnsJvMA1grHbGOR4J6ok87gHGBI4AhZxNRGc0F5g2RlnSaGuklTs9nXh200ZaP/huYvTYZ96jm3LNbc1BlBXqfrTpOsud+iqiCPEVqSVOPqUSRTpXTraAMFuwEkuhC1IkCxQnGLF96uzGZwVt4BQh+6l8UYED+aV79N33YsItT1xAMQeDb1pX98uwcHJMjUzUEW/CUVf7wbagwM84fM59xF3y7M+/MFTYksCcQVDw3+ETgc7S9DEi5/JdL9kjtni+4NtUbhwgfyzoJOMPNIX7QgV4IFmU3Q== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>位运算</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190918-am]]></title>
    <url>%2F2019%2F09%2F18%2Ftest20190918-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1/F6wxY07Xb1f5hYs7i+PxeNmrIL7q4UTjFhslkC5Pzvu6VPQmx3XfIYBWi26Wl0BDzH9MJA9529SL7GQ7d5LfRe43bx4e8ww1wDuOikHoiPVi/CIFfw9uaqN3ELvx8rXCqJ9+dYuXAVbLRpDLgsASPsBp/tJp1BQvmxMQDtBjXzP/lqZmwO/XvvdDgA4CFCXQY92XW+aTU1Am6ixMGRIc6bLUTXNSIfDRRPOxDVPVQincDPGZl4vXFDB5m5rUFqkvCfyZRAil8cXXGIeAz+5Ul3B5Lb3A3GFoXFEi+YMj6j9hCtEFr213KmvvZDdrrjn1HK4uJ1o1zZoEfcuExTHMHQAJkvpj9iVf7hOs6LJESeAYuz0j4nV+xvCVtXenEYGEYNLE1sYXjVn5h3seGInBQ+4Ej1vM9Xee6R9NqLDUmpDokpwzwuJgM3gvCe1t8KAq92dHrU5gtYAJ+YYOqTR2+A54Uh7GgAs+Lhibb2Q4j0xnf3cK//Xyn9vE0JS/nglKR+fY5/i6O2wApZMaTb0zq65fLbTemdFvFbmZOxgK66nW/T8jrb4XLOK7sscrXeSiXyzTekL3Ec6K5OGYsB+slVTdq1ZIcHIzfxTJ9c+KS+jPPllt+yiFMGzZa/LY6hcHlsA3PAYQh9vCU28y8bAs+ZMtND45fabIlNiIAKaWgPytDuQt8OX+mYS5HayVJ/w+8JUDA2IVDCzd4ZpL6dR6gpFbJm10m4FHKfKWQfcRKCHFe8ybpCu7nQz4ZKrUsnmyCe/wXxC0XBintV99v+F7jxKl2yY/ZwmcCzO24owMTN2gH+FRKqj+d5sR7f/Ls80OnrISdHCfRiQsiS3BvICf/X60QifiegLKzuma3XlKagSs4hYWYxSx4jCuKOUNsAUmlveFCa9HMQ7BLQ1TKY1+yhUN6bL3wzEwT/FeaYhPDEbsk9CobAU3LOqSz7olpbcQJXVeGy2ezUyXA3Liu1bGF7/ehJFyAipLswa8W2gciwJxP/aOeMbbajZ0/sVbQre3tJN10JFvKhXEfalu2bJCEu2bM231laR2mFQYTgy8Tk1z2s/rccdaHGyPgV7uQr2SYUmIDQ4PRDyS3tOcZfFLd06Cuuj3KklWkY8aMwCJ2ookOCEo7JVfj2JoOcH97FIO02a9CrdoiVy9vIkvH570Lp+NhneAJRekrlT1UJDaUtp62nLehiQKsAz4K5KY/Ug58lOEw8V40PKkSpnrVERIG3BQsUS9iwFK65+hG3UogKU/jvhpKqcI2CeZZ2C8KEHf4/IR2GLOugBg0HxZkQrmtcEnJLC0AdOsk0CmYQugJWPveUcuXwzOLCSRXCF24jpyhUkA+hDZSYbQmbumYqC92QMkmFH47H8GjnO1MmFlRnBZweFKqGe4J6wxA1Zfz4Iu5XaoGG5Oq6HcuEkHVXaxvUbXCM4AvrI988X6kwBP0lRVe1lXT2p9lruYD3vR/Wa2jby3qYQl5ZXcY+WgAHZ8aQ6nqs/zA6XIrLAmvMSR5ssMS1ZE0e4t54P1toWj8W+ctaA/zOO9rAkHYtXiBBcQD/oaIuzyXOZHzAlkB4Q1NHQMBVnRgBFWXIvzoBQXT1yyUR45i35en0yV8QUOf5qTJBca4HlcMc2Srs3WZm8b7ke6VHJV5KbS45hjcPEb4vVt+QCnYgYGKXirvy/mpcUz3xySVVCmr65frqD80ZIeDwfD+XvFQ3C5O4uhsWpVEyytmgnZrqLu/k47kP5pXwtGCGBwGx3pzoxegY1lwWkGqrB0JuarRa2hFi8yue+QLvbqMJ1/DdD4L21A2ivhVxqKeHtq2LNyBL7fO9Go+bVNEzqoFRFSxfsZsm9/rmc4azEIBi/FUh+/YvLrJwYo3X8MO2D4YsCvWTklx/UPxZzWVX+dC5k2DymCdypMWWOUQNqMKNZApBTacr6Bjj6/0YvC8RtsP+8wibk+693S3b2MWC54rAdBFgjcPK7auoQeUGTHlsasc2Pu29ljnoc5E4Pn1LrckjrIDXJbL7musmKmtvvWyFt7RBCqoXuU/9aC+QQHOb0BQypbAPtnEcU6aoEAUPL79NVe+/peY3NaYIK7SnJmOiM5KC+qwmBnTzz9vEsh0+ONweDCc3GamZ1z4SDTfNnhq2tzc8yQ7zqsrM23pqJFECW6izkFwnVRCdgIiyAliciionW+ePUcWB4kNWPDW1ogFnXHYZxfIyAu22rPuDU43PjcGLWde/lQSCgTPIA+3zj/X/tgykqwJUMjr7TNoTqJnBb+I2+76Oyz0F4WB6KlZEWUCuyfslrzWBLb5bALb0vyfLKxIbZ2cOWt5qKdQeJbCwQKztMwMEjfj8F6MqA2uZtgC8ey8XQw7f//yf1GPmusoTmzqgNkWvW73SP0PwUjFU0gMq40RhV0MALbpf/lUM/W/jC3Bcw+W2JUFBjOFh6kLGD3rODhchBoJWvRucWU4JKl40VC1xAQ24pmE4d80kWQf30WTU6k1OIGR+4YcdME0gYOCbsCYQcZsl6DJtX4MSq1FiIc= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190917-pm]]></title>
    <url>%2F2019%2F09%2F17%2Ftest20190917-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190917-am]]></title>
    <url>%2F2019%2F09%2F17%2Ftest20190917-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+nu6zywfpAR0wT0Bb30zKBwJXMe1UjU9CV1t+s/v5qFr7QYq2w6Gn5r7xb752j7M+x5JGm8D/1wEy3HHH0lbDicN/yVvIPTvGPYa8z7NabzzBMYndZideOq1J8qawHqzGPSXR+fW3Qt6b6Kc0ZXs3O/JJJ+R9ozVOaOBoZ0lRvyMY/N+FVa+K03hQmeK8wQvByKwdFfrYIt2L6CT0niH3iV7HqUKK5LRs5CTN/qrL3VOWK+Kxvk5krzhHWfTVvm7CwSGCk6JFJ18KChGWjOv8OGzw97R/NGbNm/T3WKXfXebau/v32HnxPaJZhrF6NYKRnQAV29nV0PkrY4ozsSo95AtLae46ONR2a1ONTDO6a6W6lnQdQfFW7KEruzXBcsYIo/n97O88SUQJIjB7fgPVOMTCSjHOSso95df5/NO/igItDwyApd+QBzP4aF/4LhhZ82aDfHBDWzGKhUWSYDJrakhPOkQRrCNASZ6BmyG+vrQNucwHqoDC/J2spbddHEgvfHbvS3xq5T2UJXqby5klMS4mO8vtmTXI04l5YlZrpSRk2ciGiNHgEM6C5jAQqUuZwGqyZzF3IlnXlnSUYAW4frbc0gyB3mVvjRfzJpNy27MOdvnH9SMxDnpOW7agY0/70KK9lwVm0IvwvogUHC/31dG9d8fGtjz3lfT0SkJZfpXMZJBU8cyA7FVigRxvLpU9DLXINXoKDRrrKWMiHyXzrfykBQFAQ0Yd7EKc0pmPn9XZLE0rnAz7ve3+/gy2vT3nqHjd7okkSiKV1gvRiwu9xxZbeORDcdNgsNKkyIoYeJ3m3N6eyagcF7k6eoWWVV6ndHHOQh9aD2CMaORLdUvRo7KySUqI/CYFLWzRysZEGpGTLoJJZ+CRUg7amq5ARMtB4dBhnHy47ng9RB9NBlKNr3yBKvbYSyv+kei2iKzY81xO6MM83gPjvceEPFrz4ewTKSuQVQh1UovRbmaHdVkBPDWTKHG6UUGoI3OnEM3/fx0UmXwR+T/Ma3MBoGpcIjC+jqXcPH3c9bswRG9si+qqFn4nrnOVc0S+kh5cy4/Vbk4mmxyMCNYeX2o0kz0fKt7IAVU0OcR3Uz6EZN0WxjBwvTv6RANfPhrn0M9tAtT98zr9zDwCsg2UHpKEyuGamdbd7otsQ1eGNMSz2mXYtHsO5aykGkBeF5Qh+MBcrEc+5AxTQ814fqRwVcUALACL7uHyFJ6rHhkyuJvWw9QJ45mPdFT4VeXbmNaJ/zQMSUB7QDZqT0L3dXawvM/K2Od6zZF2Dman5AFNHLnh0qMoSLo5wG72LNINyQxQLFKDhvGlmhVcxAFm7iYqTGJgNjHxoS353MSX0Eubm3n9oXhn+brRZxS5zUQYIatCWuGnh3cvhIm4OpPCPiafNjgGgL+lEmChwA7RI1wbvsIFeWgEEUSF7zE0q4YnshY1H8AGcz8MlzIaCk2crS28VysG923ZOAR7nBdp7eYBStshXD+1ipVJckFR31w3ORh726YEfhNMwndeAvbUXMOAPg3P0KcNoKQGdMss/IO48s5E7WOfddHdtqTybxRulNdOq2TaA4fMFpIoqXM/OlRKz9JdAfKESgQlE+RL18dEoxHdFbGq7knjpRPVfzMS5b/uFyrS6NsrfjNF+eJDltTi7GRP9fzLWgCm2ZkxcdO7QSb/lREIu9uXhzjQG5LG48A7mWeovouLdgmG3WpgVvIauDs7OydTCFstFQPq1FiPr1kZ14RO3BMaGvgIUNoKw0aMk1I3m3sZb4S0VRO28KPJjBtuzBL7+6z8Fccem5IQLEC7Ima8Vm+21fNk9w+JpCRpbknxeIs4lZnCkrp9WwKAfbjiSrsjT5aXRM9G7bkYTm2KZErDhEVGsEwGhWdKeH/YQdcvjL0No/J2aGuCjLzjDKXQMo3raBgJkAkG14d1Lhg7NWDQD2OpEhrYg9YPFvHcXKaD4bDu5Z5WrreFAkEY3 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190916-pm]]></title>
    <url>%2F2019%2F09%2F16%2Ftest20190916-pm%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX186bnapwM+77mBfNpl8lKEn81Ee57REUefcdk9wqI63R6C3FCM+t8Q2qbJ8RMrapoNgioB7DSpGIzXdlZubJkLicVWsaXHsb/+loWTWXdI0Q5JlLKZ2AU9t1ULiEOAHHK9KfTIE3ay+FytQqpdLlxFZHh6GKrTcrw34ycBX7cc+/D2PyeZWyeoQFUhJi7xM7qDkMl2U99n/re0oZQ+F2VmoHZqynKbca84KVD8Ik2iP1WMsd2Vdk2ydGpeXop8bZWD1zGgCq1LjHbq9NE2eJ0/ENrfnPxCL0+mpK/TTC5P2WlsT3t2pIEpuy33yMNKi3aj1vtjg78SqTyNLtpcqTDnszJcLSP5IPCOwqm9hcNi9FaWkIwLIRtvubiz4pw19JYFtICRP6WRDbGOZJG4qMY6sEMvgzqa1aABOUN+z47nrbsmbS2QX7Tms26DinK0NLSr0qz9VOX8oyPnHod0UVuJIYlj9K735obed3rgn8heIj3nOr6R7iosKNHQA7zH8+O49wJbdrRs0uEZtqKn3Ij5TXi06CVIZ7Plbk4m5vGyJvqxu18gaOQqDk+Bsxi2Db/UEcngBvCQpy4OIGg5kp9UvpofbrzqygcwmrxIhFojoAekdkdY/d6xmVcT2deLFg+k9Atq80nwDh0uV7de9tACfkMMRL9tKZ4eMhry6UrdebA5ws4L4ivLFPpQgi2CFEdIe3oM6OvpINx4tsgcnUVV1T695gsqBkE8BcYR+UWPOZqMpzceZcOSMs4YivgHpnGgHJ3V1hGGqziOTWsEJAOP8pPDAefHKO5U7+9RBd13IP4jB1xX9BMrUeiwZlLPqph9LOaHsWdiHYZEaUOkzfkK1bG4ufKHh9POyACWW83xmx62pob2uLTDF1Vz5XruuOGlKnlYVuZ+s1qoY9iNhDl9hib728EM4Q5PYaFoJDb5VYBJF0XuQQpukZa5SI4QUnUZjDFtUHUHSlDN650wMhuVRNhE88DvdpiJGqBuHT1rOdEcEYsSPYaCTk+KrDg4LTlWYP2jyTfvwHw== var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
        <tag>test</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190916-am]]></title>
    <url>%2F2019%2F09%2F16%2Ftest20190916-am%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19Wqnx2nfd+2J4DWrojZTaaHDBlXO+Sh6Xu3YYJ4e/egLsnpxpo2Upi68fhePLsE7rgmkGT97nB8A1sXCJ03W3IjJ8GoRAn53klTkaeb+KoksXBElzAop3axIuwf/2Dt7CaCOjUrf3xyHuBJxl/aMPc23oLnYwACvcPnsSrODxh0MISTjMoIsQIxPHoC8wKzHidRkIrszEyT0nnk4Jhv7UYTbjnrtRT7v2KBdHAIgKSJ2CL/8ckGEuyBgm6n6OlU4YcZyQlvwuIiT0Gpa2oGEtIsbbNZZVKMC0Qrb1pEcssTlX20Uf0omFKtuqcZEzKoEABlMlErZrgr/UZHQFs1fxRW+nSL1kvRBo+H6F6wFjeZPPOPs+QV+d9B/YKxJzSZy6M1M6yiiAaTyV0htme8KEn3rO/G9+xaTVHsR7a3KZlOFnkmy6eMw5xTb0BAJXFFQU8MUeKZZeB3xpYnc0gde9tM+znu5/LPiqx/mlEcMWcSFJF8GZ5bZdw4FdPBXXomEhbpEDWLOTU9DxxTKT+VPgkjBVQXZ85xF4WSP8iMZuOgA1gjGDzQ0h2mi+OGgpmMzVyIPu5U3M1xDznEU57uDqhInc8k26lYqRDDeW/04J5bpQSqD11z7cxOlXnEOp5+piE0bxfjL9H/PBizdBV2BUt/p9Hu7SswdJ74Fe2Yg0C+1OMrX613MDcVQup0HbLx0bu5tzzCw+mROp1ZBayeAyDs6mfmet54ly6EZJUrEqeEQv2m8nN5wFseyJ0lXX8rbAgeu5AjKE8rYZ6+hZmbo/jkP2xa3HrweLP/7AQLMs6fHhw3u3lvOaCR90zhRshO1UXgYfLusaUfGnkxbzEV9X4GZpght//i8642hcBOw0lQ2zggR2oygu/gMmQo1LlYnaxAFKJzUmZlfrBC0nFZ8C2MrO75nBgtWXhqbBKbznQSlAZMgXzer0PSn3ynD4tElDgBTHA0hGwLbzbA9jbsBU31SV/ESj/Uuc= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>多项式</tag>
        <tag>test</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1215]]></title>
    <url>%2F2019%2F09%2F15%2FCF1215%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Yellow Cards贪心,分类讨论一下牌是否够用. B The Number of Products维护一下两种符号出现次数的前缀和即可. C Swap Letters若同一个位置, $s,t$ 串相同,就不用考虑. 若分别是 $a,b$ ,就把这个位置权值当做 $1$ ,若分别是 $b,a$ ,就把这个位置权值当成 $0$ . 若有两个 $1$ ,就可以操作一次将它们都消去,两个 $0$ 同理. 也可以通过一次操作将一个 $1$ 变成 $0$ ,或者将一个 $0$ 变成 $1$ ,于是讨论一下即可. D Ticket Game判一个巴什博弈的模型. E Marbles其实就是给这 $20$ 个数自定义一个大小关系,求可能的最小逆序对数目. 考虑两个数 $i,j$ ,若规定 $i$ 比 $j$ 小,可以算出它们对逆序对的贡献 $t_1$ . 若规定 $j$ 比 $i$ 小,可以算出另一个贡献 $t_2$ . 若 $t_1\not= t_2$ ,则 $i$ 与 $j$ 的大小关系是确定的,可以用一条有向边表示. 做一次拓扑排序把自定义的大小顺序求出,再求一遍逆序对就是答案了.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190915]]></title>
    <url>%2F2019%2F09%2F15%2Ftest20190915%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX1+374201N5U9YUd2Z6KbrbwZ6vI7qy0UZknO6pINaYn2mjUSksKjpC1W4oLhjvUdKbH+rIn05drX8tJ3G5JRTFRHeizkKZDDI7cL2m/P+ZTMfdGxsCr4nDRKj9lW4kHIfjUp+iyhJcoUkBdIZUYaD2f9iKcfo9sKnw3KKKbysHhEqmzby/ktD2duaz0zk/jf6pAs+tYj5moGHohuD9aAjMb9v6gUnNcIc5HkbWU9w0aw7JoYBxJAMpq4LwXrS6TKTaUqMd4FXdEumdw4aUTNeXTrxZPPnBcn4W37sFsGjB0AwVTVqYMjoYNNgPoaQztuXkn6Fa9t8VvOobMFuvL2NVUr0w+JZqr/0dPylZ26t6qAYSRd8wKsUl0CCysRdsefiZ5AFxoXTeaTKcq7uK9scsYT6D36zpOLPaOqTc6DI6kt0XH8ttIaGCI4qb+FHd6Yg8YQZH4bZBMkhGLtavc7EyJdVrbAfvYEYVAqCGeb2iRYJgtYPHLhRhFK89pT8C/+uoJwLC4nSEhatzyJRHSLLeviboGlRFdVnyCxdl+9StAkrNpWSKm+kdSRDbYYfhDqBWoZ3XCgnCAfmTVhHIwQtxQKsXHRccJlqLGDrN6AF4Q1bhr5Qif/rzYfXUtab8SitmpFU3kJFmjJ/9DJw2z4CsgkxufW7b+NBY7/oAXCOAXSoA0pqHeM/2J+a2hb6scvQWHdUn0mYcFFlrid2uIo9kHkE4CKxfs5ioblF2uf1W2Yzox3teBlgPFL8vdllN7Te72isFZXOk/CbyckyP+MOtPMCarF49VE0ZYecZ+lQnUdo6nNg4NDcAdivAsgE/JxEnmb6Vu3LtSiIx1HaxoEPF8g+lQDH0FDh8/lh3abmMx7/b27EV485VoJsVj3n30HLw9t70fTAiBO9ooOp+rXvdHqEYbgWTePyQVK8Joz1u9Q2gHXVKtg1vYQnvJm8JeGC8G60l8KF1HMr6Tp/N11pU64EOyADevvxvjFbb4DoN7ZqNvb55IhKTb5HxjnRQBqJT3Mwjkr9NBHDa16xe3QS9Vc4duDsmVOtci53kGWQ+GOHQVzJFl40JrZOFTQzeO9UW+fEzXqx49hoMYeTMriJdItaPHBKgklTEFh8GQODCwSOtmYiOelghsuw+tnbRYoj6Vfepz/7/8L12nhJ89fnb+AD1sLy26jDftZk0CG+OVAmjdqcY6d3KMxQRk7yZdppXXFKESTALtyQYiW70mNsW1YX/0tmim1OEbUOyz5svaOjwJTDR7r6Y1QVOZNP8H23xU2exRrVZw4iYfE5iarWWrf9RQytKEY3DzlkEpVp891aqOyEsMyCVk5mlrGvJXzolaV+K+A4zNtk0hfm4W9Bxp/K7gSTA0+5sVJ8pmfK4XW3fyaQKAeNrAfBwhNgL38bbvZuuq+zPg4PVEk9RC9x1/1RmaK5Ily+sNqhXz81dNBeMGAEON6aFXS6rOjAUA3W2eDT6HgCft6+qamYMQXi3v1IADopXyFac= var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>Trie</tag>
        <tag>test</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1209]]></title>
    <url>%2F2019%2F09%2F15%2FCF1209%2F</url>
    <content type="text"><![CDATA[$Div.1+Div.2$ A Paint the Numbers将所有元素排序,从小到大贪心处理,如果之前有它的因数,就不用新建一块. B Koala and Lights每盏灯的周期是 $2t$ ,所以整个系统的周期不会超过 $\mbox{LCM}(2,4,6,8,10)+5=125$ ,在这个范围内枚举时间即可. C Paint the Dights考虑从 $0$ 到 $9$ 枚举两个序列的分界值 $x$ . 若 $a_i&gt;x$ ,或 $a_i=x$ ,但之前没有比 $x$ 大的元素出现,就染成 $2$ ,否则染成 $1$ . D Cow and Snacks贪心,每次拿了一个 $(x,y)$ 后,就让含有 $x$ 或 $y$ 的人先来拿,这样最多挤掉一个人,所以是对的. E Rotate Columns把每一列按照该列的最大值从大到小排序,只把前 $n$ 列拿出来做状压 $dp$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190914]]></title>
    <url>%2F2019%2F09%2F14%2Ftest20190914%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树上差分</tag>
        <tag>test</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190912]]></title>
    <url>%2F2019%2F09%2F12%2Ftest20190912%2F</url>
    <content type="text"><![CDATA[分块被卡成暴力. $road$预处理出 $S$ 到每个点的距离, $T$ 到每个点的距离. 加入一条边 $(u,v)$ 后,可能产生的路径是 $S\to u\to v\to T$ 和 $S\to v\to u\to T$ ,判断一下长度是否减小即可. $multiset$考虑对于所有 $x$ 相同的情况,相当于每次修改一段区间,若为 $0$ ,则 $+1$ ,否则 $\times 2$ . 用两棵线段树,一棵维护答案,另一颗维护每个位置是否为 $0$ . 修改时对状态相同的连续段一起操作,每次操作最多增加 $2$ 个连续段,操作次数仍为 $O(n)$ . 如果有很多种 $x$ ,就给每个 $x$ 开两棵线段树,利用动态开点进行处理. $tree$考虑链的部分,可以设 $f(i,j)$ 表示根节点的标号被继承到 $i$ , $i$ 的子树还有 $j$ 条边时,最后留下根节点标号的概率. 转移时分类讨论一下删掉哪条边以及被留下的标号. 从链上拓展到树上,只需要考虑如何合并两个子树的 $dp$ 值. 其实只要再乘上两个组合数表示删边的顺序就可以了.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>概率/期望</tag>
        <tag>最短路</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190911-night]]></title>
    <url>%2F2019%2F09%2F11%2Ftest20190911-night%2F</url>
    <content type="text"><![CDATA[$T_3$ 打了 $\mbox{5kb}$ ,前前后后打了 $7$ 个错误版本,还都过了大样例. $string$显然,答案与操作顺序无关,直接把所有 $a$ 移到最前面,这样 $b$ 的个数会翻倍,记录一下 $b$ 的数目即可. $number$直接数位 $dp$ ,注意特判 $k=0,1$ 的情况. $city$先跑一次 $dfs$ ,把环上所有点依次存下来. 考虑用环上的点把所有点分成若干块,每个点属于离它最近的环上的点. 答案分为两种情况,一种情况是两个端点在同一块,这部分贡献就是若干棵子树的直径最大值,仍然用 $dfs$ 求出. 另一种情况是两个端点在不同块,显然要经过环上点. 对环上的第 $i$ 个点,记录 $d(i)$ 表示这个点到它的那一块中的点距离最大值. 枚举断掉环上的哪一条边,环变成一条链,可以钦定一个起点,记 $H(i)$ 表示此时起点到环上第 $i$ 个点的路径长度. 如果此时选择了环上的第 $x,y$ 个点来更新答案,贡献就是 $d(y)+H(y)+d(x)-H(x)$ ,且必须 $x\not= y$ . 用线段树维护一下 $d+H,d-H$ 的最大值,最大值取到的位置 ,次大值,就可以计算出断掉某一条边的贡献. 当断边切换时,所有 $H$ 都会同时减少一个值,原端点的 $H$ 又加上所有环上边的长度,利用线段树可以维护. 时间复杂度 $O(n\log n)$ .]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190911-am]]></title>
    <url>%2F2019%2F09%2F11%2Ftest20190911-am%2F</url>
    <content type="text"><![CDATA[$\mbox{difficulty gap}$ 稍微有点大. $tree$树形 $dp$ 入门. 设 $f(u)$ 表示仅操作子树 $u$ 内的点,能获得的最大收益,转移时讨论删不删 $u$ 即可,时间复杂度 $O(n)$ . $xor$$x\mbox{ xor }2x=3x$ ,将 $\mbox{xor}$ 理解为二进制下不进位的加法. 注意到 $x+2x=3x$ ,可以得出, $x$ 与 $2x$ 在二进制下没有某一位都为 $1$ . 而 $2x$ 在二进制下可以视作 $x$ 所有数位左移了一位,于是限制等价于 $x$ 没有两位连续的 $1$ . 做一做数位 $dp$ 求出答案,注意减掉 $x=0$ 的情况. $equ$标准型线性规划,约束数目很少,但变量个数很多. 转成它的对偶线性规划,就变成了 $2$ 个变量和很多约束的线性规划. 写一个半平面交来处理.]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>数位dp</tag>
        <tag>test</tag>
        <tag>线性规划</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4896 补退选]]></title>
    <url>%2F2019%2F09%2F10%2Fbzoj-4896-%E8%A1%A5%E9%80%80%E9%80%89%2F</url>
    <content type="text"><![CDATA[$Trie$ 树 + $vector$ 暴力维护答案. 把串全部扔进 $Trie$ 树里面,对于 $Trie$ 树上的每个节点,开一个 $vector$ 维护出现过的值的答案. 即,若某个前缀出现次数最大为 $mx$ ,就只维护 $1\sim mx$ 的答案. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+1,L=60,S=10;char buf[L+10];int tid=0,len;struct Trie&#123; int idx; Trie()&#123;idx=0;&#125; struct node &#123; int mx,cur,ch[S]; vector&lt;int&gt; v; node()&#123;mx=cur=0;v.push_back(0);&#125; &#125;Tree[MAXN*L];#define root Tree[o] void ins(int val) &#123; int o=0; for(int i=0;i&lt;len;++i) &#123; int c=buf[i]-'a'; if(!root.ch[c]) root.ch[c]=++idx; o=root.ch[c]; root.cur+=val; if(root.cur&gt;root.mx) &#123; root.mx=root.cur; (root.v).push_back(tid); &#125; &#125; &#125; int query(int x) &#123; int o=0; for(int i=0;i&lt;len;++i) &#123; int c=buf[i]-'a'; if(!root.ch[c]) return -1; o=root.ch[c]; &#125; if(x&gt;root.mx) return -1; return root.v[x]; &#125;&#125;T;int lastans=0;int main()&#123; int m=read(); while(m--) &#123; ++tid; int op=read(); scanf("%s",buf); len=strlen(buf); if(op==1) T.ins(1); else if(op==2) T.ins(-1); else &#123; int a=read(),b=read(),c=read(); int x=(1LL*a*abs(lastans)%c+b)%c+1; lastans=T.query(x); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190910]]></title>
    <url>%2F2019%2F09%2F10%2Ftest20190910%2F</url>
    <content type="text"><![CDATA[给题面点赞. $move$直接二分 + $hash$ . $cook$把反图建出来,跑一个最大字典序的拓扑序,再把这个序列反过来就是答案. $block$ 摘自原题的解题报告. 暴力来做的话,接口有 $12$ 个位置,状态数为$2^{12} = 4096$ . 这个状态维数显然不能矩阵乘法. 然后消掉所有等价的状态,即旋转,镜像,上下翻转. 比如 $100000000000$ 和 $000000000001$ 这两个的状态的 $dp$ 值,在每一轮都相等,不需要都存下来. 同样的,旋转,镜像,上下翻转都可以消除掉一些. 然后我们发现一些状态值一定是 $0$,比如接口有奇数个块的. 比如将所有块黑白染色,接口处黑色个数不等于白色个数的. 经过这些删除后,只剩下 $95$个状态. 然后直接矩阵乘法就可以了.]]></content>
      <tags>
        <tag>拓扑排序</tag>
        <tag>矩阵优化</tag>
        <tag>状压dp</tag>
        <tag>hash</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5368 真实排名]]></title>
    <url>%2F2019%2F09%2F10%2Fbzoj-5368-%E7%9C%9F%E5%AE%9E%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[分类讨论 + 简单组合计数. 题目描述可以等价为变化之后,分数严格小于 $A_i$ 的人数不变. 分两种情况讨论. 情况一, $A_i$ 没有翻倍. 若其它的某个翻倍的分数原来是 $x$ ,为了使排名不变,必须满足 $2x&lt;A_i$ 或 $x\ge A_i$ . 排序后二分,找出这样的 $x$ 有 $p$ 个,那么这种情况的方案数就是 $p \choose k$ . 情况二, $A_i$ 翻倍. 为了使排名不变,其余 $A_i\le x&lt;2A_i​$ 的数也必须翻倍,另外的数可以随意选择. 排序后二分,找出这样的 $x$ 一共有 $q$ 个,若 $q&lt;k-1$ ,则方案数为 $0$ ,否则为 $n-q-1\choose k-q-1$ . 根据加法原理,把两种情况的方案数加在一起就是答案. 时间复杂度 $O(n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int n,k,fac[MAXN],invfac[MAXN];void init_fac()&#123; fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=fpow(fac[n],P-2); for(int i=n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[M-N],invfac[N]));&#125;int A[MAXN],a[MAXN],ans[MAXN];int Binary_Search(int val)&#123; int L=1,R=n,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(A[mid]&lt;=val) res=mid,L=mid+1; else R=mid-1; &#125; return res;&#125;int calc(int L,int R)//L&lt;=x&lt;=R&#123; if(L&gt;R) return 0; return Binary_Search(R)-Binary_Search(L-1);&#125;void solve()&#123; for(int i=1;i&lt;=n;++i) &#123; int val=A[i]; int p=calc(A[1],(val+1)/2-1)+calc(val,A[n])-1; int q; if(val&lt;=2*val-1) q=calc(val,2*val-1)-1; else q=0; ans[i]=add(C(p,k),C(n-q-1,k-q-1)); &#125;&#125;int main()&#123; n=read(),k=read(); init_fac(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); solve(); for(int i=1;i&lt;=n;++i) &#123; int pos=lower_bound(A+1,A+1+n,a[i])-A; printf("%d\n",ans[pos]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4029 定价]]></title>
    <url>%2F2019%2F09%2F08%2Fbzoj-4029-%E5%AE%9A%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[贪心. 乍一看像是数位 $dp$ ,仔细想一下其实只需要枚举每个数就可以了. 暴力枚举定价为 $x$ ,每次用 $x$ 更新答案后,把 $x$ 最低的不为 $0$ 的那一位 $+1$ ,继续枚举,中间的显然都没有 $x$ 优. 每一位最多被加 $10$ 次,时间复杂度 $O(T\cdot 10\log^2 R)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;int calc(int x)&#123; while(x%10==0) x/=10; int p=(x%10==5); int a=0; while(x) x/=10,++a; return 2*a-p;&#125;int nxt(int x)&#123; int cnt=0; while(x%10==0) x/=10,++cnt; ++x; while(cnt--) x*=10; return x;&#125;int main()&#123; int T=read(); while(T--) &#123; int L=read(),R=read(); int mi=inf,ans,x=L; while(x&lt;=R) &#123; int val=calc(x); if(val&lt;mi) mi=val,ans=x; x=nxt(x); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4035 数组游戏]]></title>
    <url>%2F2019%2F09%2F08%2Fbzoj-4035-%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$SG$ 函数 + 整除分块. 假定可以选择黑点进行操作,可以发现,若选择黑点,不能直接胜利,而对方下一步可以选同样的位置翻转回来. 所以最优策略下仍不会选择黑点进行操作. 把每个白点看成一个子游戏,最后将它们的 $SG$ 函数值全部异或起来就是整个游戏的 $SG$ 异或值. 根据 $SG$ 函数的定义,转移有,$$SG(i)=\mbox{mex}_{j=2}^{\lfloor \frac n i \rfloor}\ SG(i\cdot j)$$简单归纳一下不难得出,若 $\lfloor \frac n x\rfloor=\lfloor \frac n y\rfloor$ ,则 $SG(x)=SG(y)$ . 于是只有 $O(\sqrt n)$ 个有用的值,整除分块进行计算. 时间复杂度 $O(n)$ ,但实际上是跑不满的,可以通过. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,SG[2][MAXN],stk[MAXN],tp;bool vis[MAXN];int nxt(int x,int y)&#123; return x==y?y+1:y/(y/(x+1));&#125;void init()&#123; for(int i=1;i&lt;=n;i=nxt(i,n)) &#123; tp=0; int tmp=0; for(int j=2;j&lt;=i;j=nxt(j,i)) &#123; int x=i/j; int val=(x&gt;m)?SG[1][n/x]:SG[0][x]; stk[++tp]=tmp^val; vis[stk[tp]]=1; if((i/x-i/(x+1))&amp;1) tmp^=val; &#125; tmp=1; while(vis[tmp]) ++tmp; if(i&gt;m) SG[1][n/i]=tmp; else SG[0][i]=tmp; for(int j=1;j&lt;=tp;++j) vis[stk[j]]=0; &#125;&#125;int main()&#123; n=read(); m=sqrt(n); init(); int T=read(); while(T--) &#123; int tot=read(),ans=0; while(tot--) &#123; int x=n/read(); ans^=(x&gt;m)?SG[1][n/x]:SG[0][x]; &#125; if(ans) puts("Yes"); else puts("No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4028 公约数数列]]></title>
    <url>%2F2019%2F09%2F08%2Fbzoj-4028-%E5%85%AC%E7%BA%A6%E6%95%B0%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[分块. $\mbox{xor}$ 显然就只是一个系数,用不上什么特殊性质. 考虑对序列分块,每个元素维护 $f(i)$ 表示从该块的 $l$ 到 $i$ 的前缀 $\gcd$ , $g(i)$ 表示从该块的 $l$ 到 $i$ 的前缀 $\mbox{xor}$ . 查询时依次处理每个块,记前面所有块的前缀 $\gcd$ 为 $pregcd$ ,前缀 $\mbox{xor}$ 为 $prexor$ . 前缀 $\gcd$ 是单调不升的,若加上这一块后, $pregcd$ 不变,则说明这一块的所有前缀 $gcd$ 都是 $pregcd$ . 此时只需要找一下这块内的第一个 $g(i) = \frac x {pregcd}\mbox{ xor } prexor$ ,这可以用 $map$ 预处理出来. 如果加上这一块后, $pregcd$ 会改变,就暴力枚举这个块内的每个位置,判断是否有解. 每次 $pregcd$ 减小时,都会至少减小到原来的一半,所以暴力枚举的位置最多 $O(\log a)$ 个. 修改时直接暴力重构所在的那一块即可. 时间复杂度 $O(m\cdot \sqrt n\cdot \log a)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;const int MAXN=1e5+10,S=320;int n,m,blocksiz,tot=0,L[S],R[S],bel[MAXN];int a[MAXN],f[MAXN],g[MAXN];map&lt;ll,int&gt; mp[S];void init_block()&#123; blocksiz=sqrt(n); for(int i=1;i&lt;=n;++i) bel[i]=(i-1)/blocksiz+1; tot=bel[n]; for(int i=n;i&gt;=1;--i) L[bel[i]]=i; for(int i=1;i&lt;=n;++i) R[bel[i]]=i;&#125;void calc_block(int x)&#123; mp[x].clear(); f[L[x]]=g[L[x]]=a[L[x]]; for(int i=L[x]+1;i&lt;=R[x];++i) &#123; f[i]=gcd(f[i-1],a[i]); g[i]=g[i-1]^a[i]; &#125; for(int i=R[x];i&gt;=L[x];--i) mp[x][1LL*g[i]]=i;&#125;int query(ll x)&#123; int pregcd=0,prexor=0; for(rg int i=1;i&lt;=tot;++i) &#123; if(gcd(pregcd,f[R[i]])==pregcd) &#123; if(x%pregcd==0) &#123; ll val=(x/pregcd)^prexor; if(mp[i].find(val)!=mp[i].end()) return mp[i][val]-1; &#125; &#125; else &#123; for(rg int j=L[i];j&lt;=R[i];++j) if(1LL*(prexor^g[j])*gcd(pregcd,f[j])==x) return j-1; &#125; pregcd=gcd(pregcd,f[R[i]]); prexor=prexor^g[R[i]]; &#125; return -1;&#125;char op[10];int main()&#123; n=read(); init_block(); for(rg int i=1;i&lt;=n;++i) a[i]=read(); for(rg int i=1;i&lt;=tot;++i) calc_block(i); m=read(); for(rg int i=1;i&lt;=m;++i) &#123; scanf("%s",op); if(op[0]=='M')//Modify &#123; int id=read()+1,x=read(); a[id]=x; calc_block(bel[id]); &#125; else//Query &#123; ll x; scanf("%lld",&amp;x); int ans=query(x); if(ans!=-1) printf("%d\n",ans); else puts("no"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190908]]></title>
    <url>%2F2019%2F09%2F08%2Ftest20190908%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 140]]></title>
    <url>%2F2019%2F09%2F07%2FAtcoder-Beginner-Contest-140%2F</url>
    <content type="text"><![CDATA[心态炸裂. A Password直接输出 $n^3$ . B Buffet按照题意模拟. C Maximal Value贪心一下. D Face Produces Unhappiness对一个区间 $[a,b]$ 进行操作,只用考虑 $a$ 与 $b+1$ 处贡献是否改变. 只有 $”LR”$ 与 $”RL”$ 这两种串匹配时贡献才会增多,暴力匹配一下. E Second Sum二分 + 线段树找出每个元素左边第一个,第二个比它大的,右边第一个,第二个比它大的. 算一下哪些区间的次大值是这个元素,加入贡献即可. F Many Slimes贪心模拟,每次尝试用当前拥有的最大的去生成次大的,依次判断. 比赛时由于一些代码中的弱智问题没有过掉这道题.]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190907]]></title>
    <url>%2F2019%2F09%2F07%2Ftest20190907%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>构造</tag>
        <tag>树状数组</tag>
        <tag>差分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190906]]></title>
    <url>%2F2019%2F09%2F07%2Ftest20190906%2F</url>
    <content type="text"><![CDATA[卡空间是真的毒瘤. $kanade$设那两个数为 $x,y$ .将所有数都异或起来,记得到的结果是 $z=x\mbox{ xor } y$ . $z\not= 0$ ,所以可以找出 $z$ 二进制上为 $1$ 的某一位. 将所有数分成两组,这一位上为 $0$ 的分在一组,这一位上为 $1$ 的分在另一组,那么 $x,y$ 就被分到了不同的组. 将某一组内的数全部异或起来,就得到了 $x,y$ 其中的一个,继而可以求出另一个. $sakura$设 $f(i)$ 表示将节点 $i$ 放上樱花所需要的樱花数目. 在 $dfs$ 时,显然将子节点按照 $f(i)-a(i)$ 从大到小排序,依次放就可以了. $chtolly$设 $f_i$ 表示当前在位置 $i$ ,走到终点的期望时间,则答案为 $f_0$ . 有 $f_0=f_1+1,f_1=f_1$ ,而方程都是线性的,所以可以将所有 $f_i$ 都表示成 $f_i=kf_1+b$ 的形式. 前两项的表达形式已知,一直往后递推,可以得到 $f_{n+1}=1$ 的表示形式,解出 $f_1$ ,也就得到了 $f_0$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>位运算</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4027 兔子与樱花]]></title>
    <url>%2F2019%2F09%2F06%2Fbzoj-4027-%E5%85%94%E5%AD%90%E4%B8%8E%E6%A8%B1%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[贪心. 在合法的前提下,一定是在每棵子树中也删掉尽可能多的点,这样这个子树的根对它的父亲的贡献最小. 于是对树 $dfs$ ,处理完 $u$ 的所有子节点 $v$ 后,需要考虑删掉哪些 $v$ . 将每个 $v$ 被删掉后对 $u$ 的贡献从小到大排序,能删就删即可. 时间复杂度 $O(n\log n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e6+10;int ecnt=0,nx[MAXN],to[MAXN],head[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,c[MAXN],ans=0,tmp[MAXN],tot;int sonsiz[MAXN];bool cmp(int x,int y)&#123; return c[x]+sonsiz[x]&lt;c[y]+sonsiz[y];&#125;void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v); &#125; tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; tmp[++tot]=v; &#125; sort(tmp+1,tmp+1+tot,cmp); for(int i=1;i&lt;=tot;++i) &#123; int v=tmp[i]; if(c[u]+sonsiz[u]+c[v]+sonsiz[v]-1&lt;=m) &#123; c[u]+=c[v]; sonsiz[u]+=sonsiz[v]-1; ++ans; &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;=n;++i) &#123; sonsiz[i]=read(); for(int k=1;k&lt;=sonsiz[i];++k) &#123; int j=read()+1; addedge(i,j); &#125; &#125; dfs(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4026 dC Loves Number Theory]]></title>
    <url>%2F2019%2F09%2F05%2Fbzoj-4026-dC-Loves-Number-Theory%2F</url>
    <content type="text"><![CDATA[主席树. 区间 $[L,R]$ 的答案可以表示成 $\prod_{i=L}^R A_i\cdot \prod \frac {p_i-1}{p_i}$ . 前者容易维护,后者就是所有在 $[L,R]$ 区间内出现过的质数的贡献,做法比较经典. 从前往后依次加入元素,加入 $A_i$ 时,枚举 $A_i$ 的所有质因子 $p$ ,在第 $i$ 棵线段树中给位置 $i$ 乘上 $\frac {i-1} i$ . 若 $p$ 在之前出现过,且最后一个出现的位置是 $lst$ ,则还要在第 $i$ 棵线段树中给位置 $lst$ 乘上 $\frac i {i-1}$ ,即消除贡献. 询问时,后面那个 $\prod \frac {p_i-1}{p_i}$ 就是在第 $R$ 棵线段树中询问区间 $[L,R]$ 的连乘积. 用主席树来维护,时间复杂度 $O(P+n\log n\log P)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e6+777;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv[P+10],pcnt=0,prime[P+10],ism[P+10],minp[P+10];void init_pr()&#123; inv[1]=1; for(int i=2;i&lt;P;++i) inv[i]=mul(P-P/i,inv[P%i]); ism[1]=1; for(int i=2;i&lt;P;++i) &#123; if(!ism[i]) &#123; prime[++pcnt]=i; minp[i]=i; &#125; for(int j=1;j&lt;=pcnt &amp;&amp; i*prime[j]&lt;P;++j) &#123; int num=i*prime[j]; ism[num]=1; minp[num]=prime[j]; if(i%prime[j]==0) break; &#125; &#125;&#125;const int MAXN=5e4+10;int lastans=0;int n,m,preprod[MAXN],a[MAXN],rt[MAXN];struct PreSegtree&#123; int idx; PreSegtree()&#123;idx=0;&#125; struct node &#123; int ls,rs; int prod; node()&#123;ls=rs=0;prod=1;&#125; &#125;Tree[MAXN*100];#define root Tree[o] void upd(int &amp;o,int lst,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[lst]; root.prod=mul(root.prod,c); if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[lst].ls,l,mid,pos,c); else upd(root.rs,Tree[lst].rs,mid+1,r,pos,c); &#125; void query(int o,int l,int r,int L,int R,int &amp;res) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return (void)(res=mul(res,root.prod)); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) query(root.ls,l,mid,L,R,res); if(R&gt;mid) query(root.rs,mid+1,r,L,R,res); &#125;&#125;T;int lst[P+10];void init_seg()&#123; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; int lsp=rt[i-1],cur; while(x!=1) &#123; int p=minp[x],cnt=0; if(lst[p]) &#123; T.upd(cur,lsp,1,n,lst[p],mul(p,inv[p-1])); lsp=cur; &#125; T.upd(cur,lsp,1,n,i,mul(p-1,inv[p])); lsp=cur; lst[p]=i; while(x%p==0) x/=p; &#125; rt[i]=cur; &#125;&#125;int solve(int L,int R)&#123; lastans=mul(preprod[R],inv[preprod[L-1]]); T.query(rt[R],1,n,L,R,lastans);&#125;int main()&#123; init_pr(); n=read(),m=read(); preprod[0]=1; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); preprod[i]=mul(preprod[i-1],a[i]); &#125; init_seg(); for(int i=1;i&lt;=m;++i) &#123; int L=read()^lastans,R=read()^lastans; solve(L,R); printf("%d\n",lastans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190905]]></title>
    <url>%2F2019%2F09%2F05%2Ftest20190905%2F</url>
    <content type="text"><![CDATA[由 $ChitongZ$ 亲自出题. $game$考试时候的乱搞:求解最大权重独立子集, $bitset$ 暴力维护线性基. 最坏情况下复杂度为 $O(n^2\log n+\frac {n^3} {64})$ ,但在随机数据下,稍微优化下常数就过了. 正解:记前缀异或和为 $sum$ ,则每次询问区间 $(i,j)$ 相当于是获得了 $sum_{i-1}$ 与 $sum_j$ 的关系. 从 $sum_0$ 到 $sum_n$ 一共有 $n+1$ 个点,而 $sum_0$ 是已知的,所以做出一棵最小生成树就是答案. $matrix$模拟退火,先随机出一个状态,每次退火尝试交换两个数,并以一定概率接受较劣的解. $tree$考虑暴力 $dp$ ,设 $f(u,i)$ 表示在子树 $u$ 内选出若干点,乘积在模 $m$ 意义下为 $i$ 的方案数. 转移时,枚举 $u​$ 的子节点 $v​$ ,有 $f’(u,i)=\sum_{j\times k=i} f(u,j)\cdot f(v,k)​$ ,然后把 $f’​$ 复制到 $f​$ 里面. 这样做的时间复杂度是 $O(n\cdot m^2)$ . 转移形式很像卷积,求出 $m$ 的原根 $g​$ . 转移就变成了 $f’(u,i)=\sum_{j+ k=i} f(u,j)\cdot f(v,k)$ . 此时 $f(u,i)$ 表示在子树 $u$ 内选出若干点,乘积在模 $m$ 意义下为 $g^i​$ 的方案数. 这样就是卷积的形式了,利用 $NTT$ 进行优化,时间复杂度 $O(n\cdot m\log m)​$ .]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>最小生成树</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4018 小Q的幻想之乡]]></title>
    <url>%2F2019%2F09%2F04%2Fbzoj-4018-%E5%B0%8FQ%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%8B%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演 + 线性筛. 由于每次只能走一种路径,并且边是双向的,所以从 $i$ 到 $j$ 的边数就是 $\frac {|i-j|} {\gcd(i,j)}$ . 于是每次询问要求 $ans=\sum_{i=1}^n \sum_{j=1}^m \frac {|i-j|} {\gcd(i,j)}$ . 与 $\gcd$ 有关的式子,考虑用莫比乌斯反演那一套操作,假定 $n\le m$ ,开始推式子, 记 $A=\min(\lfloor \frac n d\rfloor,\lfloor \frac m d\rfloor),B=\max(\lfloor \frac n d\rfloor,\lfloor \frac m d\rfloor)$ . 则后面那个 $\sum_{i=1}^A \sum_{j=1}^B |i-j|=\frac {(A-1)A(A+1)} 3+\frac {AB(B-A)} 2$ ,大佬的推导过程 . 前面那一块,需要预处理 $f(d)=\sum_{k|d} k\cdot \mu(k)$ 的前缀和,这是个积性函数,直接线性筛处理. 然后整除分块计算答案,时间复杂度 $O(n+T\cdot \sqrt m)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P1=1e9+7,P2=1e9+9;struct Z&#123; int v1,v2; Z(int v1=0,int v2=0):v1(v1),v2(v2) &#123;&#125; Z operator + (const Z &amp;rhs) const &#123; return Z(v1+rhs.v1&gt;=P1?v1+rhs.v1-P1:v1+rhs.v1,v2+rhs.v2&gt;=P2?v2+rhs.v2-P2:v2+rhs.v2); &#125; Z operator - (const Z &amp;rhs) const &#123; return Z(v1-rhs.v1&lt;0?v1-rhs.v1+P1:v1-rhs.v1,v2-rhs.v2&lt;0?v2-rhs.v2+P2:v2-rhs.v2); &#125; Z operator * (const Z &amp;rhs) const &#123; return Z(1LL*v1*rhs.v1%P1,1LL*v2*rhs.v2%P2); &#125; void pr() &#123; printf("%d %d\n",v1,v2); &#125;&#125;;Z fpow(Z a,int b)&#123; Z res=Z(1,1); while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;const int N=2e6;int prime[N+10],ism[N+10],pcnt=0;Z f[N+10],inv2,inv3;void init()&#123; inv2=fpow(Z(2,2),P1-2)*Z(1,2)*Z(1,2); inv3=fpow(Z(3,3),P1-2)*Z(1,3)*Z(1,3); f[1]=Z(1,1); ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++pcnt]=i; f[i]=Z(1,1)-Z(i,i); &#125; for(int j=1;j&lt;=pcnt &amp;&amp; 1LL*i*prime[j]&lt;=N;++j) &#123; int num=i*prime[j]; ism[num]=1; if(i%prime[j]==0) &#123; f[num]=f[i]; break; &#125; f[num]=f[i]*f[prime[j]]; &#125; &#125; for(int i=1;i&lt;=N;++i) f[i]=f[i-1]+f[i];&#125;Z calc(int a,int b)&#123; if(a&gt;b) swap(a,b); Z A=Z(a,a),B=Z(b,b); Z I=Z(1,1); return (A-I)*A*(A+I)*inv3+A*B*(B-A)*inv2;&#125;void solve()&#123; int n=read(),m=read(); if(n&gt;m) swap(n,m); Z ans=Z(0,0); for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); ans=ans+(f[r]-f[l-1])*calc(n/l,m/l); &#125; ans.pr();&#125;int main()&#123; init(); int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1214]]></title>
    <url>%2F2019%2F09%2F04%2FCF1214%2F</url>
    <content type="text"><![CDATA[$Div.1+Div.2$ A Optimal Currency Exchange第一种货币只有面值 $1$ 有用,第二种货币只有面值 $5$ 有用. 枚举换了多少个第二种货币,时间复杂度 $O(\frac n {5e})$ . B Badges读懂题后就是两个不等式,手动解一下. C Bad Sequence第一次遇到不合法的 $-1$ 时,将它忽略,最后再放回去,看能否合法. D Treasure Island显然答案 $\le 2$ ,因为我们可以去掉与出发点相邻的两个点. 于是只需要判断 $0$ 与 $1$ 是否合法. $0$ 就是判断起点能否到终点. $1$ 就是判断是否存在一个点 $x$ ,使得每条从起点到终点的路径都经过 $x$ . 设 $f(x),g(x)$ 分别表示起点到 $x$ 的路径数, $x$ 到终点的路径数,判断是否有 $f(x)\cdot g(x)$ 等于 起点到终点的路径数. E Petya and Construction Set可以假定 $d_i$ 是从大到小排好序的,否则可以先排序. 建出一条链,链上节点依次为 $1,3,5,\dots,2i-1$ . 然后再将偶数编号的节点 $2i$ 依次挂上去,找到链上的第 $i+d_i-1$ 个节点,将 $2i$ 挂在它的旁边即可. 因为 $d_i$ 是从大到小排好序的,且 $d_i\le n$ ,所以这样做总能构造出合法解. F Employment待更. G Feeling Good待更. H Tiles Placement待更.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4017 小Q的无敌异或]]></title>
    <url>%2F2019%2F09%2F04%2Fbzoj-4017-%E5%B0%8FQ%E7%9A%84%E6%97%A0%E6%95%8C%E5%BC%82%E6%88%96%2F</url>
    <content type="text"><![CDATA[树状数组. 对于第一问,将每个二进制位分开计算贡献,变为 $0/1$ 数列,询问有几个区间的异或和为 $1$ ,随便做做. 对于第二问,仍然将每个二进制位分开算,只需要考虑所有的区间和的第 $i$ 位有奇数个 $1$ 还是偶数个 $1$ . 记前缀和 $sum(x)=\sum_{i=1}^x a_i​$ ,那么每个区间和都是 $sum(r)-sum(l-1)​$ 的形式. 从前往后枚举 $r$ ,若 $sum(r)-sum(l-1)$ 第 $i$ 位上为 $1$ ,则只有两种可能. 一种是 $sum(r)$ 与 $sum(l-1)$ 第 $i$ 位不同,且 $sum(r)\bmod 2^i\ge sum(l-1)\bmod 2^i$ ,即没有向第 $i$ 位借位. 另一种是 $sum(r)$ 与 $sum(l-1)$ 第 $i$ 位相同,且 $sum(r)\bmod 2^i&lt; sum(l-1)\bmod 2^i$ ,即有向第 $i$ 位借位. 将所有前缀和离散化,开两个树状数组进行维护,时间复杂度 $O(37\cdot n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10;int n,a[MAXN];struct FenwickTree&#123; int bit[MAXN];#define lowbit(x) x&amp;(-x) void add(int x) &#123; for(;x&lt;=n+1;x+=lowbit(x)) bit[x]^=1; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s^=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)^sum(l-1); &#125; void reset() &#123; memset(bit,0,sizeof bit); &#125;&#125;T[2];int mx;void solve1()&#123; int tot[2]; int ans=0; for(int k=0;(1&lt;&lt;k)&lt;=mx;++k) &#123; tot[0]=1,tot[1]=0; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum^=(a[i]&gt;&gt;k)&amp;1; ans=add(ans,mul(1&lt;&lt;k,tot[sum^1])); ++tot[sum]; &#125; &#125; printf("%d ",ans);&#125;ll s[MAXN],S;int tot;void solve2()&#123; ll t,sum,ans=0; for(int k=0;(1LL&lt;&lt;k)&lt;=S;++k) &#123; T[0].reset(); T[1].reset(); sum=tot=0; s[++tot]=sum&amp;((1LL&lt;&lt;k)-1); for(int i=1;i&lt;=n;++i) &#123; sum+=a[i]; s[++tot]=sum&amp;((1LL&lt;&lt;k)-1); &#125; sort(s+1,s+1+tot); tot=unique(s+1,s+1+tot)-s-1; sum=t=0; T[(sum&gt;&gt;k)&amp;1].add(lower_bound(s+1,s+1+tot,sum&amp;((1LL&lt;&lt;k)-1))-s); for(int i=1;i&lt;=n;++i) &#123; sum+=a[i]; int id=(sum&gt;&gt;k)&amp;1,p=lower_bound(s+1,s+1+tot,sum&amp;((1LL&lt;&lt;k)-1))-s; t^=T[id].query(p+1,tot); t^=T[id^1].query(1,p); T[id].add(p); &#125; ans+=t&lt;&lt;k; &#125; printf("%lld\n",ans);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); mx=max(mx,a[i]); S+=a[i]; &#125; solve1(); solve2(); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4180 字符串计数]]></title>
    <url>%2F2019%2F09%2F04%2Fbzoj-4180-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[$SAM$ + 二分 + $\text{distance product}​$ . 先考虑如果给出了一个串 $S$ ,如何求构造出 $S$ 的最少操作次数. 做法是将串 $S$ 在 $SAM$ 上贪心地向后匹配,出现空转移时,转移到根节点对应的儿子继续匹配,且操作数 $+1$ . 这样能让后面接上的子串尽可能短,就有更多的机会继续向后匹配. 现在要求解原问题,我们令出现空匹配时转移到根节点对应儿子的这条边代价为 $1$ ,其余边代价为 $0$ . 那么就是求从根节点出发走 $n$ 步的最大代价. 注意到这个图中很多边的权值都是 $0$ ,可以发现真正有用的就只有根节点的 $A,B,C,D$ 四个儿子节点. 预处理一下 $A\to B$ 在原图上要走 $x$ 步,那么 $A\to B$ 的权值就是 $x$ ,其他的边同理. 由于从 $A\to B$ 操作数一定 $+1$ ,就等价于在这个 $K_4$ 上询问走边权和不超过 $n$ 的边,最多走过的边数. 可以二分答案 $mid$ ,尝试检验. 用 $\text{distance product}$ 来定义矩阵乘法,那么邻接矩阵的 $mid$ 次方就表示最多走 ​$mid$ 条边时两点的最短路径长度. 时间复杂度 $O(|T|+4^3\cdot\log^2 N)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,S=4;const ll inf=1e18;char buf[MAXN];ll n;struct Matrix&#123; ll v[S][S]; Matrix() &#123; memset(v,0x7f,sizeof v); &#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int i=0; i&lt;S; ++i) for(int k=0; k&lt;S; ++k) for(int j=0; j&lt;S; ++j) res.v[i][j]=min(res.v[i][j],v[i][k]+rhs.v[k][j]); return res; &#125;&#125; A;Matrix fpow(Matrix a,ll b)&#123; Matrix res=a; --b; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int vis[MAXN],dep[MAXN];queue&lt;int&gt; q;struct Suffix_Automaton&#123; int idx,lst; int ch[MAXN][S],fa[MAXN],len[MAXN]; Suffix_Automaton() &#123; idx=lst=1; &#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[nq]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void bfs(int k) &#123; int st=ch[1][k]; q.push(st); dep[st]=1; vis[st]=1; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0; i&lt;S; ++i) if(ch[u][i] &amp;&amp; !vis[ch[u][i]]) &#123; int v=ch[u][i]; q.push(v); dep[v]=dep[u]+1; vis[v]=1; &#125; else A.v[k][i]=min(A.v[k][i],(ll)(dep[u])); &#125; &#125; bool check(ll mid) &#123; --mid; Matrix tmp=fpow(A,mid); ll dist=inf; for(int i=0;i&lt;S;++i) for(int j=0;j&lt;S;++j) dist=min(dist,tmp.v[i][j]); ++dist; return dist&lt;=n; &#125; ll solve() &#123; for(int i=0; i&lt;S; ++i) &#123; memset(vis,0,sizeof vis); bfs(i); &#125; ll L=1,R=n,ans; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; return ans; &#125;&#125; SAM;int main()&#123; n=read(); scanf("%s",buf+1); int L=strlen(buf+1); for(int i=1; i&lt;=L; ++i) SAM.Extend(buf[i]-'A'); cout&lt;&lt;SAM.solve()&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>矩阵优化</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4154 Generating Synergy]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4154-Generating-Synergy%2F</url>
    <content type="text"><![CDATA[$kd$ 树. 将每个点的 $dfn,dep$ 视作 $x,y$ 坐标,那么每次修改就是给平面上一个矩形内的点染色. 用 $kd$ 树写一写,时间复杂度 $O(n\log n+q\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10;const int inf=1e9;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dfn[MAXN],idx=0,siz[MAXN],dep[MAXN];void dfs(int u)&#123; dfn[u]=++idx; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v); siz[u]+=siz[v]; &#125;&#125;int n,C,Q,Tp;struct node&#123; int v[2],mx[2],mi[2],fa,id; int col,tag,ls,rs; node()&#123;mx[0]=mx[1]=-inf,mi[0]=mi[1]=inf;&#125; bool operator &lt; (const node &amp;rhs) const &#123; return v[Tp]&lt;rhs.v[Tp]; &#125;&#125;Tree[MAXN];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]inline void pushup(int o)&#123; for(int i=0;i&lt;2;++i) &#123; root.mx[i]=max(lson.mx[i],rson.mx[i]); root.mx[i]=max(root.mx[i],root.v[i]); root.mi[i]=min(lson.mi[i],rson.mi[i]); root.mi[i]=min(root.mi[i],root.v[i]); &#125;&#125;int pos[MAXN];int BuildTree(int l,int r,int tp)&#123; Tp=tp; int mid=(l+r)&gt;&gt;1; int o=mid; nth_element(Tree+l,Tree+mid,Tree+r+1); pos[root.id]=o; if(l&lt;=mid-1) &#123; root.ls=BuildTree(l,mid-1,tp^1); lson.fa=o; &#125; if(mid+1&lt;=r) &#123; root.rs=BuildTree(mid+1,r,tp^1); rson.fa=o; &#125; pushup(o); return o;&#125;inline void pushdown(int o)&#123; if(root.tag) &#123; if(root.ls) lson.col=lson.tag=root.tag; if(root.rs) rson.col=rson.tag=root.tag; root.tag=0; &#125;&#125;int Mx[2],Mi[2];void upd(int o,int c)&#123; if(root.mi[0]&gt;Mx[0] || root.mx[0]&lt;Mi[0] || root.mi[1]&gt;Mx[1] || root.mx[1]&lt;Mi[1]) return; if(Mi[0]&lt;=root.mi[0] &amp;&amp; root.mx[0]&lt;=Mx[0] &amp;&amp; Mi[1]&lt;=root.mi[1] &amp;&amp; root.mx[1]&lt;=Mx[1]) return (void)(root.col=root.tag=c); if(Mi[0]&lt;=root.v[0] &amp;&amp; root.v[0]&lt;=Mx[0] &amp;&amp; Mi[1]&lt;=root.v[1] &amp;&amp; root.v[1]&lt;=Mx[1]) root.col=c; pushdown(o); if(root.ls) upd(root.ls,c); if(root.rs) upd(root.rs,c);&#125;int stk[MAXN],tp;inline int query(int x)&#123; tp=0; int y=x; while(Tree[y].fa) &#123; stk[++tp]=Tree[y].fa; y=Tree[y].fa; &#125; while(tp) pushdown(stk[tp--]); return Tree[x].col;&#125;void solve()&#123; n=read(),C=read(),Q=read(); ecnt=0; idx=0; for(int i=1;i&lt;=n;++i) head[i]=0; for(int i=2;i&lt;=n;++i) addedge(read(),i); dfs(1); for(int i=1;i&lt;=n;++i) &#123; Tree[i].v[0]=dfn[i]; Tree[i].v[1]=dep[i]; Tree[i].ls=Tree[i].rs=0; Tree[i].col=1; Tree[i].tag=0; Tree[i].fa=0; Tree[i].id=i; &#125; int rt=BuildTree(1,n,0); int ans=0; for(int i=1;i&lt;=Q;++i) &#123; int x=read(),y=read(),c=read(); if(!c) //query ans=add(ans,mul(i,query(pos[x]))); else //update &#123; Mi[0]=dfn[x]; Mx[0]=dfn[x]+siz[x]-1; Mi[1]=dep[x]; Mx[1]=dep[x]+y; upd(rt,c); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4162 shlw loves matrix II]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4162-shlw-loves-matrix-II%2F</url>
    <content type="text"><![CDATA[拉格朗日插值求特征多项式 + 多项式取模. $k\times k$ 的方阵 $M$ 的特征多项式 $f(x)=|xI-M|$ ,它是个 $k$ 次多项式,首项系数为 $1$ . 可以随便选 $k+1$ 个 $x$ ,代到多项式里,用高斯消元算出对应的 $f(x)​$ . 然后利用拉格朗日插值得到特征多项式 $f(x)$ 的系数. 根据 $Cayley-Hamilton$ 定理, $f(M)=0$ , 那么我们给 $M^n$ 加上任意多个 $f(M)$ 都不会影响答案,即 $M^n=M^n\bmod f(M)$ . 只需计算 $M^n\bmod f(M)$ ,两者都是关于 $M$ 的多项式,模数不是 $NTT$ 模数,多项式快速幂 + 暴力取模. 最终得到的 $M^n\bmod f(M)$ 次数显然小于 $k$ ,将 $M$ 代进去暴力算即可. 时间复杂度 $O(k^4+k^2\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=51,L=1e4+10;char buf[L];int n,m,len,tmp[MAXN&lt;&lt;1],p[MAXN];void Mul(int *a,int *b,int *f)&#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=n;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=m;i&gt;=n;--i) &#123; int inv=mul(tmp[i],fpow(p[n],P-2)); for(int j=0;j&lt;=n;++j) tmp[i-j]=add(tmp[i-j],P-mul(p[n-j],inv)); &#125; for(int i=0;i&lt;=n;++i) f[i]=tmp[i];&#125;int a[MAXN][MAXN],b[MAXN][MAXN];int Det()&#123; int res=1,sgn=1; for(int i=1;i&lt;=n;++i) &#123; for(int j=i;j&lt;=n;++j) if(b[j][i]) &#123; if(i!=j) swap(b[i],b[j]),sgn*=-1; break; &#125; int inv=fpow(b[i][i],P-2); for(int j=i+1;j&lt;=n;++j) &#123; if(!b[j][i]) continue; int t=mul(b[j][i],inv); for(int k=i;k&lt;=n;++k) b[j][k]=add(b[j][k],P-mul(b[i][k],t)); &#125; res=mul(res,b[i][i]); &#125; if(sgn==1) return res; else return add(P-res,0);&#125;int y[MAXN],c[MAXN],d[MAXN],mat[MAXN][MAXN],rmat[MAXN][MAXN];int main()&#123; scanf("%s%d",buf+1,&amp;n); len=strlen(buf+1); m=n&lt;&lt;1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) a[i][j]=read(); for(int i=0;i&lt;=n;++i) &#123; memset(b,0,sizeof b); for(int j=1;j&lt;=n;++j) for(int k=1;k&lt;=n;++k) b[j][k]=(j==k)?(add(i,P-a[j][k])):(add(0,P-a[j][k])); y[i]=Det(); &#125; for(int i=0;i&lt;=n;++i) &#123; memset(tmp,0,sizeof tmp); tmp[0]=y[i]; for(int j=0;j&lt;=n;++j) if(i!=j) &#123; for(int k=n;k;--k) tmp[k]=add(tmp[k-1],P-mul(tmp[k],j)); tmp[0]=add(0,P-mul(tmp[0],j)); int inv=fpow(add(i,P-j),P-2); for(int k=0;k&lt;=n;++k) tmp[k]=mul(tmp[k],inv); &#125; for(int j=0;j&lt;=n;++j) p[j]=add(p[j],tmp[j]); &#125; c[0]=d[1]=1; for(int i=len;i;--i) &#123; if(buf[i]=='1') Mul(c,d,c); Mul(d,d,d); &#125; memset(b,0,sizeof b); for(int i=1;i&lt;=n;++i) mat[i][i]=1; for(int l=0;l&lt;=n;++l) &#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) b[i][j]=add(b[i][j],mul(c[l],mat[i][j])); memset(rmat,0,sizeof rmat); for(int i=1;i&lt;=n;++i) for(int k=1;k&lt;=n;++k) for(int j=1;j&lt;=n;++j) rmat[i][j]=add(rmat[i][j],mul(mat[i][k],a[k][j])); memcpy(mat,rmat,sizeof mat); &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%d ",b[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线性代数</tag>
        <tag>高斯消元</tag>
        <tag>多项式</tag>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4128 Matrix]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4128-Matrix%2F</url>
    <content type="text"><![CDATA[$BSGS$ . 因为保证了矩阵 $A$ 在模 $p$ 意义下有逆,并且在 $p$ 以内有解,所以就直接像普通的 $BSGS$ 那样做就可以了. 可以手写一个 $hash$ 函数,来判断两个矩阵是否完全相等. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=70;typedef unsigned long long ull;const ull Base=137;int n,P;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct Matrix&#123; int v[MAXN][MAXN]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int i=0;i&lt;n;++i) for(int k=0;k&lt;n;++k)if(v[i][k]) for(int j=0;j&lt;n;++j) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125; ull Hash() &#123; ull res=0; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) res=res*Base+(ull)(v[i][j]); return res; &#125;&#125;A,B,I;Matrix fpow(Matrix a,int b)&#123; Matrix res=I; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;map&lt;ull,int&gt; mp;int BSGS()&#123; int m=sqrt(P); Matrix prod=B,tmp=A; for(int j=0;j&lt;m;++j) &#123; mp[prod.Hash()]=j; prod=prod*tmp; &#125; prod=tmp=fpow(A,m); for(int i=1;i&lt;=m;++i) &#123; ull t=prod.Hash(); if(mp.find(t)!=mp.end()) return i*m-mp[t]; prod=prod*tmp; &#125; return -1;&#125;int main()&#123; n=read(),P=read(); for(int i=0;i&lt;n;++i) I.v[i][i]=1; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) A.v[i][j]=read(); for(int i=0;i&lt;n;++i) for(int j=0;j&lt;n;++j) B.v[i][j]=read(); cout&lt;&lt;BSGS()&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>hash</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4247 挂饰]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-4247-%E6%8C%82%E9%A5%B0%2F</url>
    <content type="text"><![CDATA[贪心 + 记忆化搜索. 贪心,先考虑挂钩多的选不选,再考虑挂钩少的选不选,将物品按照挂钩数目从大到小排序. 设 $f(i,j)$ 表示可以选择 $i\sim n$ 的物品,有 $j$ 个挂钩,能获得的最大收益,枚举第 $i$ 个选还是不选来转移. 因为物品是按照挂钩数目从大到小考虑的,就没有后效性了. 挂钩数目可能很多,但有用的最多 $n$ 个,所以状态数是 $O(n^2)$ 的. 时间复杂度 $O(n\log n+n^2)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e3+10,inf=0x7fffffff;int n,f[MAXN][MAXN];pair&lt;int,int&gt; p[MAXN];int dfs(int i,int j)&#123; j=min(j,n); if(i&gt;n) return 0; if(f[i][j]!=-inf) return f[i][j]; f[i][j]=dfs(i+1,j); if(j&gt;0) f[i][j]=max(f[i][j],dfs(i+1,j-1+p[i].first)+p[i].second); return f[i][j];&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].first=read(); p[i].second=read(); &#125; sort(p+1,p+1+n); reverse(p+1,p+1+n); for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=n;++j) f[i][j]=-inf; cout&lt;&lt;dfs(1,1)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2124 等差子序列]]></title>
    <url>%2F2019%2F09%2F03%2Fbzoj-2124-%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[树状数组动态维护 $hash$ 值. 只需要判断是否存在长度为 $3$ 的等差子序列,即满足 $1\le i&lt;k&lt;j\le n,2a_k=a_i+a_j$ 的三元组 $(i,j,k)$ . 考虑从前往后枚举 $k$ ,记录一个 $vis$ 数组表示各个数当前是否出现过. 只需要检查 $a_k$ 两侧的字符串是否对称 (一侧超出的长度不计) ,若对称,说明不存在合法的 $(i,j,k)$ ,否则存在. 因为给出的序列是从 $1$ 到 $n$ 的一个排列,如果一个数 $x$ 当前没有出现,则一定会在之后出现,正确性就显然了. 用树状数组动态维护 $vis$ 正串与反串的 $hash$ 值,时间复杂度 $O(T\cdot n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;typedef unsigned long long ull;const ull Base=137;ull pw[MAXN];int n;struct FenwickTree&#123; ull bit[MAXN]; void reset() &#123; memset(bit,0,sizeof bit); &#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; int p=x; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=pw[x-p]*c; &#125; ull sum(int x) &#123; int p=x; ull s=0; for(;x;x-=lowbit(x)) s+=bit[x]*pw[p-x]; return s; &#125; ull query(int l,int r) &#123; return sum(r)-sum(l-1)*pw[r-l+1]; &#125;&#125;T1,T2;bool solve()&#123; n=read(); T1.reset(); T2.reset(); bool flag=false; for(int i=1;i&lt;=n;++i) &#123; int x=read(); if(flag) continue; int len=min(x-1,n-x); if(len &amp;&amp; T1.query(x-len,x-1)!=T2.query(n-(x+len)+1,n-(x+1)+1)) flag=true; T1.add(x,1); T2.add(n-x+1,1); &#125; return flag;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=10000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; if(solve()) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3531 旅行]]></title>
    <url>%2F2019%2F09%2F02%2Fbzoj-3531-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[动态开点线段树. 先上个树链剖分,转化成序列上的问题. 只有 $10^5$ 种宗教,可以给每种宗教开一棵动态开点线段树维护信息. 修改宗教只有单点修改,比较容易处理,随便写一写就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;ll ans;int cnt=0;struct Segtree&#123; struct node &#123; int ls,rs; int mx; ll sum; node()&#123;mx=sum=0;&#125; &#125;Tree[MAXN*20];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); root.sum=lson.sum+rson.sum; &#125; void upd(int &amp;o,int l,int r,int pos,int c) &#123; if(!o) o=++cnt; if(l==r) return (void)(root.sum=root.mx=c); int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,l,mid,pos,c); else upd(root.rs,mid+1,r,pos,c); pushup(o); &#125; void query(int o,int l,int r,int L,int R,int op) &#123; if(!o) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!op) ans=max(ans,1LL*root.mx); else ans+=root.sum; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) query(root.ls,l,mid,L,R,op); if(R&gt;mid) query(root.rs,mid+1,r,L,R,op); &#125;&#125;T;int rt[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,k;int idx=0,siz[MAXN],mxson[MAXN],dep[MAXN],top[MAXN],fa[MAXN],dfn[MAXN];int w[MAXN],c[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++idx; T.upd(rt[c[u]],1,n,dfn[u],w[u]); if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;void solve(int x,int y,int op)&#123; int C=c[x]; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); T.query(rt[C],1,n,dfn[top[x]],dfn[x],op); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); T.query(rt[C],1,n,dfn[y],dfn[x],op);&#125;char op[10];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) w[i]=read(),c[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=m;++i) &#123; scanf("%s",op); if(op[0]=='C') &#123; if(op[1]=='C') &#123; int x=read(),y=read(); T.upd(rt[c[x]],1,n,dfn[x],0); T.upd(rt[y],1,n,dfn[x],w[x]); c[x]=y; &#125; else &#123; int x=read(),y=read(); T.upd(rt[c[x]],1,n,dfn[x],y); w[x]=y; &#125; &#125; else &#123; ans=0; int x=read(),y=read(); if(op[1]=='S') solve(x,y,1); else solve(x,y,0); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>动态开点线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6690 灵梦的计算器]]></title>
    <url>%2F2019%2F09%2F02%2FLoj-6690-%E7%81%B5%E6%A2%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[牛顿迭代求解方程. 令 $k=\lfloor n^a+n^b\rfloor,f(x)=x^a+x^b$ ,那么就是要求解 $f(n_0)=k$ 与 $f(n_1)=k+1$ 两个方程. 直接二分精度不够,利用牛顿迭代,这两个根都在 $n$ 附近,取 $x_0=n$ ,迭代一次精度即可达到要求. 发现常数比较大,跑不过去,其实并不需要把这两个根分别求出来,只需要求得两根之差,加入贡献即可.$$\begin{aligned}n_0&amp;=n-\frac{f(n)-k}{f’(n)} \\n_1&amp;=n-\frac{f(n)-k-1}{f’(n)} \\n_1-n_0&amp;=\frac {1} {f’(n)}=\frac {1} {an^{a-1}+bn^{b-1}}\end{aligned}$$发现这个贡献与 $k$ 无关,于是每次询问可以少调用 $4$ 次 $pow$ 函数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;namespace Mker&#123;// Powered By Kawashiro_Nitori// Made In Gensokyo, Nihon #define uint unsigned int uint sd;int op; inline void init() &#123;scanf("%u %d", &amp;sd, &amp;op);&#125; inline uint uint_rand() &#123; sd ^= sd &lt;&lt; 13; sd ^= sd &gt;&gt; 7; sd ^= sd &lt;&lt; 11; return sd; &#125; inline double get_n() &#123; double x = (double) (uint_rand() % 100000) / 100000; return x + 4; &#125; inline double get_k() &#123; double x = (double) (uint_rand() % 100000) / 100000; return (x + 1) * 5; &#125; inline void read(double &amp;n,double &amp;a, double &amp;b) &#123; n = get_n(); a = get_k(); if (op) b = a; else b = get_k(); &#125;&#125;int main()&#123; int T=read(); Mker::init(); double n,a,b,k,ans=0; while(T--) &#123; Mker::read(n,a,b); ans+=1/(a*pow(n,a-1)+b*pow(n,b-1)); &#125; printf("%.3lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>牛顿迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3881 Divljak]]></title>
    <url>%2F2019%2F09%2F02%2Fbzoj-3881-Divljak%2F</url>
    <content type="text"><![CDATA[$AC$ 自动机 + 树上小技巧. 对所有的 $s$ 串建出 $AC$ 自动机以及 $fail$ 树. $fail$ 树中的每个点都能表示一个串,并且在子树 $i$ 内的点,每个点表示的串都有节点 $i$ 对应的串作为后缀. 每次插入一个串 $p$ 时,就在 $AC$ 自动机上匹配它,匹配过程中经过的所有点都是 $p$ 的前缀,而子串可以看做是前缀的后缀,所以将经过的这些前缀都加上一种新颜色,询问时答案就是 $s_i$ 对应节点子树中所含颜色种类. 可以用 $dfs$ 序 + 树状数组进行维护,为了避免一种颜色贡献被算多次,每次染色时将所有需要染色的点按 $dfs$ 序排序,相邻的两个点权值 $+1$ ,它们的 $LCA$ 权值 $-1$ ,询问时直接询问子树内权值总和. 这样做是和构造虚树时的做法差不多的,正确性比较显然. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e6+10,S=26;int id[MAXN],ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dfn[MAXN],dfnidx=0,top[MAXN],siz[MAXN],mxson[MAXN],dep[MAXN],fa[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++dfnidx; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;=dep[y]?x:y;&#125;struct FenwickTree&#123; int bit[MAXN];#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=dfnidx;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;T;char s[MAXN];int len,tmp[MAXN],tot=0;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;struct AhoCorasick_Automaton&#123; int ch[MAXN][S],fail[MAXN],vis[MAXN],idx; AhoCorasick_Automaton()&#123;idx=1;&#125; void ins(int x) &#123; int u=1; for(int i=1;i&lt;=len;++i) &#123; int c=s[i]-'a'; if(!ch[u][c]) ch[u][c]=++idx; u=ch[u][c]; &#125; id[x]=u; &#125; void getfail() &#123; queue&lt;int&gt; q; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=0;i&lt;S;++i) if(ch[u][i]) &#123; int v=ch[u][i]; q.push(v); int f=fail[u]; while(f &amp;&amp; ch[f][i]==0) f=fail[f]; if(f) fail[v]=ch[f][i]; else fail[v]=1; addedge(fail[v],v); &#125; &#125; &#125; void match() &#123; int u=1; tot=0; for(int i=1;i&lt;=len;++i) &#123; int c=s[i]-'a'; if(ch[u][c]) u=ch[u][c]; else &#123; while(u &amp;&amp; ch[u][c]==0) u=fail[u]; if(ch[u][c]) u=ch[u][c]; else u=1; &#125; tmp[++tot]=u; T.add(dfn[u],1); &#125; sort(tmp+1,tmp+1+tot,cmp); for(int i=1;i&lt;tot;++i) T.add(dfn[LCA(tmp[i],tmp[i+1])],-1); &#125; int query(int x) &#123; return T.sum(dfn[x]+siz[x]-1)-T.sum(dfn[x]-1); &#125;&#125;AC;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",s+1); len=strlen(s+1); AC.ins(i); &#125; AC.getfail(); dfs1(1,0); dfs2(1,1); int m=read(); for(int i=1;i&lt;=m;++i) &#123; int op=read(); if(op==1) &#123; scanf("%s",s+1); len=strlen(s+1); AC.match(); &#125; else &#123; int x=read(); printf("%d\n",AC.query(id[x])); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1204]]></title>
    <url>%2F2019%2F09%2F02%2FCF1204%2F</url>
    <content type="text"><![CDATA[$Div.2$ A BowWow and the Timetable判断一下读入的数是不是 $0$ 或者 $4$ 的幂次. B Mislove Has Lost an Array若首先放入 $1,2,4,\dots 2^{l-1}$ ,剩下的位置都放入 $1$ ,得到的和最小. 若首先放入 $1,2,4,\dots,2^{r-1}$ ,剩下的位置都放入 $2^{r-1}$ ,得到的和最大. C Anna, Svyatoslav and Maps如果上个点到下个点的所有最短路都不经过当前点,那么当前点必须选. $floyd$ 预处理两点间最短路长度后进行判断. D Kirk and a Binary String将原串中的 $10$ 子串全部删去,再把剩余的 $1$ 改成 $0$ ,将删掉的 $10$ 放回原位即得答案. 因为这样的子串对 $LIS$ 的贡献只可能是 $1$ ,所以删掉不会造成影响. E Natasha, Sasha and the Prefix Sums记 $sum$ 表示 $a$ 的前缀和. 考虑枚举 $x=f(a)$ ,并且枚举第一次得到这个前缀和时,用了 $y$ 个 $1$ . 即,若 $k$ 是第一个使得 $sum(k)=x$ 的位置,从 $1$ 到 $k$ 一共有 $y$ 个 $1$ ,那么从 $1$ 到 $k$ 一共有 $y-x$ 个 $-1$ . 求出这种数列的方案数 $t$ ,那么这些数列对答案的贡献就是 $t\cdot x$ . 由于位置 $k$ 一定是 $1$ ,所以只需要分别求出 $1\sim k-1$ 与 $k+1\sim n+m$ 这两段的方案数,相乘即为 $t$ . $1\sim k-1$ 的 $1,-1$ 的个数都是确定的,只要求每个位置从 $1$ 开始的前缀和都 $&lt;x$ . $k+1\sim n+m$ 的 $1,-1$ 个数也是确定的,只要求每个位置从 $k+1$ 开始前缀和都 $\le 0$ . 这两个问题都可以归纳为在二维平面上,从 $(0,0)$ 走到 $(X,Y)$ ,每次只能往右或上走一格,并且不能触碰到直线 $y=x+b$ 的方案数,注意不能跨越也可以转化为不能触碰,将直线向上平移一个位置即可. 设原点关于该直线的对称点为 $P$ ,答案就是从原点走到终点的方案数减去从 $P$ 走到终点的方案数,都不考虑限制. 因为从 $P$ 走到终点的每种方案都恰好对应了一种从原点走到终点,但触碰到了直线的方案. 时间复杂度 $O(n^2)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e3+10;const int P=998244853;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int fac[MAXN],invfac[MAXN];void Init(int N)&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;=N;++i) fac[i]=mul(fac[i-1],i); invfac[N]=inv(fac[N]); for(int i=N-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)&#123; if(N&gt;M || N&lt;0 || M&lt;0) return 0; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int ans=0,n,m;int calc(int x,int y,int b)//(0,0)-&gt;(x,y),without touching y=x+b&#123; return add(C(x+y,y),P-C(x+y,y-b));&#125;int main()&#123; Init(4000); n=read(),m=read(); for(int x=1;x&lt;=n;++x) for(int y=x;y&lt;=n &amp;&amp; y-x&lt;=m;++y) &#123; int t=calc(y-x,y-1,x); t=mul(tmp,calc(m+x-y,n-y,1)); ans=add(ans,mul(tmp,x)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>codeforces</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3670 动物园]]></title>
    <url>%2F2019%2F09%2F02%2Fbzoj-3670-%E5%8A%A8%E7%89%A9%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[$kmp$ . 对于每个位置 $i$ ,需要找出 $2|Border|\le i$ 的非空 $Border$ 数目. 用 $kmp$ 求一次 $next$ 数组,根据 $next$ 数组,可以建出 $kmp$ 自动机的树. 这棵树以 $0$ 为根, $next(i)$ 向 $i$ 连边, $i$ 号点表示了长度为 $i$ 的前缀,从根到 $i$ 路径上的点都为前缀 $i$ 的 $Border$ . 那么只需要知道根节点到 $i$ 的路径上有多少个编号 $\le \lfloor \frac i 2\rfloor$ 的节点. 编号从上到下是单调递增的,所以可以维护一个栈,存储根节点到当前节点路径上的点,在栈中二分求出答案. 时间复杂度 $O(T\cdot n\log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e6+10;char s[MAXN];int n,nxt[MAXN];int ecnt=0,head[MAXN],nx[MAXN],to[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int stk[MAXN],tp,ans;void dfs(int u)&#123; if(u) stk[++tp]=u; int L=1,R=tp,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(stk[mid]*2&lt;=u) res=mid,L=mid+1; else R=mid-1; &#125; ans=mul(ans,res+1); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v); &#125; if(u) --tp;&#125;void solve()&#123; ecnt=0; memset(head,0,sizeof head); scanf("%s",s+1); n=strlen(s+1); nxt[1]=0; addedge(0,1); for(int i=2;i&lt;=n;++i) &#123; int j=nxt[i-1]; while(j &amp;&amp; s[i]!=s[j+1]) j=nxt[j]; if(s[i]==s[j+1]) ++j; nxt[i]=j; addedge(nxt[i],i); &#125; ans=1; tp=0; dfs(0); printf("%d\n",ans);&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 139]]></title>
    <url>%2F2019%2F09%2F01%2FAtcoder-Beginner-Contest-139%2F</url>
    <content type="text"><![CDATA[莫名奇妙被罚了 $6$ 次. A Tenki签到题,注意两个字符串虽然长度都为 $3$ ,但直接这样开会错掉. 1char a[3],b[3]; 要开大一些,可能是因为终止符/空格的问题? 一开始没注意,交上去被罚了一次. B Power Socket签到题,但题意有点难理解. 应该是一开始有 $1$ 个物品,每次可以把 $1$ 个换成 $A$ 个,问至少有 $B$ 个,需要操作多少次,然后就简单了. C Lower签到题,读入后反过来递推即可. D ModSum考试的时候根据样例猜了个结论,令 $P_i=i+1(1\le i&lt;n),P_n=1$ . 这样答案是 $\frac {n(n-1)} 2$ ,然后就过了. E League把每场比赛看做一个点,若 $A$ 必须在 $B$ 之前比赛,就连边 $A\to B$ . 若有环,则无解,否则答案为 $DAG$ 上的最长链. F Engines 其实应该算 POI 原题? 最终的向量一定是由那些在它的方向上投影为正的向量相加得到. 极角排序后扫一圈更新答案即可.]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>贪心</tag>
        <tag>DAG</tag>
        <tag>拓扑排序</tag>
        <tag>计算几何</tag>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3012 First!]]></title>
    <url>%2F2019%2F09%2F01%2Fbzoj-3012-First%2F</url>
    <content type="text"><![CDATA[$Trie$ 树 + 拓扑排序判环. 将所有串插入到一棵 $Trie$ 树中. 若一个字符串 $s_i$ 成为了字典序最小的串,因为这些串互不相同,所以必须要求其他串都不能是 $s_i$ 的前缀. 即在 $Trie$ 树上,根节点到这个串的终止节点路径上不能有其它的串的终止节点. 另一个条件是根到这个节点路径上每条边字符的字典序比它父亲向所有兄弟的边字符的字典序小. 这可以用若干条有向边表示字符间的大小关系,建出图后拓扑排序,若有环,则不合法,否则合法. 时间复杂度 $O(|S|^2\cdot n+|S|\cdot \sum |s|)$ ,其中 $S$ 代表字符集, $s$ 代表读入的串. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10,N=3e4+10,S=26;char buf[N],s[MAXN];int n,len;int G[S][S],deg[N],ans[N],ans_cnt=0;int d[N],cnt,vis[N];void del(int u)&#123; ++cnt; vis[u]=1; for(int v=0;v&lt;S;++v) if(G[u][v]) &#123; d[v]-=G[u][v]; if(!d[v]) del(v); &#125;&#125;bool topsort()&#123; memset(vis,0,sizeof vis); memcpy(d,deg,sizeof d); cnt=0; for(int i=0;i&lt;S;++i) if(!d[i] &amp;&amp; !vis[i]) del(i); return cnt==S;&#125;struct Trie&#123; int ch[MAXN][S],idx; int val[MAXN]; Trie()&#123;idx=0;&#125; void ins(int id) &#123; int u=0; for(int i=1;i&lt;=len;++i) &#123; int c=buf[i]-'a'; if(!ch[u][c]) ch[u][c]=++idx; u=ch[u][c]; &#125; val[u]=id; &#125; void dfs(int u) &#123; if(val[u]) &#123; if(topsort()) &#123; ans[val[u]]=1; ++ans_cnt; &#125; return; &#125; int q[S],t=0; for(int c=0;c&lt;S;++c) &#123; int v=ch[u][c]; if(!v) continue; q[++t]=c; &#125; for(int c=0;c&lt;S;++c) &#123; int v=ch[u][c]; if(!v) continue; for(int i=1;i&lt;=t;++i) if(q[i]!=c) &#123; ++G[c][q[i]]; ++deg[q[i]]; &#125; dfs(v); for(int i=1;i&lt;=t;++i) if(q[i]!=c) &#123; --G[c][q[i]]; --deg[q[i]]; &#125; &#125; &#125;&#125;T;int lp[N],rp[N];int main()&#123; n=read(); int tot=0; for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); len=strlen(buf+1); lp[i]=tot+1; for(int j=1;j&lt;=len;++j) s[++tot]=buf[j]; rp[i]=tot; T.ins(i); &#125; T.dfs(0); printf("%d\n",ans_cnt); for(int i=1;i&lt;=n;++i) if(ans[i]) &#123; for(int j=lp[i];j&lt;=rp[i];++j) putchar(s[j]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>拓扑排序</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190901]]></title>
    <url>%2F2019%2F09%2F01%2Ftest20190901%2F</url>
    <content type="text"><![CDATA[自闭场. $masodik$维护 $r$ 和 $c$ 的下凸壳,当前哪个斜率大走哪个. $count$$60​$ 分的做法可以直接枚举 $a,b​$ ,此时可以唯一确定 $c,d​$ ,用 $hash​$ 检验,时间复杂度 $O(n^2)​$ ,但跑不满. 另外一个 $O(n^2)$ 的做法是枚举 $len=b-a+1$ . 当 $len$ 固定时,将串右移 $len+F$ 位,合法的 $(a,b,c,d)$ 中, $(a,b)$ 段和 $(c,d)$ 段就会匹配上. 于是扫一遍,计算匹配数,就可以得出 $len$ 确定时的解,时间复杂度 $O(n^2)$ . 考虑进行优化,仍然枚举 $len$ ,将原串按 $len$ 分段,发现下面这样的红色匹配是没有意义的: 因为红色匹配的长度不会超过 $len$ ,而有效的匹配一定是像绿色匹配那样跨越边界的. 段边界的匹配可以转化为段两端的 $LCP$ 和 $LCS$ ,二分 + $hash$ 来求. 用这一段的 $LCP$ 和前一段的 $LCS$ 组合,若 $LCS\ge len$ ,则这段的解全都合法. 否则这段的解有 $LCP+LCS-len+1$ 个. 时间复杂度 $O(n\log^2 n)$ . 这里的 $LCS$ 指最长公共后缀. $theory$先考虑 $m=0$ 的情况,此时相当于求解 $n^{2n}\equiv x$ . 保证有解,所以 $x$ 一定是二次剩余,等价于求解 $n^n\equiv \sqrt x \pmod p$ . 令 $n\equiv \sqrt x \pmod p,n\equiv 1 \pmod { p-1}$ . 因为 $\gcd(p,p-1)=1​$ ,所以可以 $crt​$ 合并得出一个合法解. 对于 $m&gt;0​$ 的情况,尝试枚举 $n\equiv t\pmod p​$ ,只要 $x-t^m​$ 在模 $p​$ 意义下是二次剩余,就可以沿用上面的做法. 由于一个数是二次剩余的概率为 $\frac 1 2​$ ,所以期望步数很小,可以视作常数. 时间复杂度 $O(\sqrt p)​$ .]]></content>
      <tags>
        <tag>test</tag>
        <tag>crt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2342 双倍回文]]></title>
    <url>%2F2019%2F09%2F01%2Fbzoj-2342-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[$Manacher$ . 考虑用 $Manacher$ 预处理出每个位置的回文半径. 枚举双倍回文子串的中心 $i$ ,为了得到以 $i$ 为中心的最长双倍回文子串,需要找到左边第一个 $j+R(j)-1\ge i$ ,且 $R(i)\ge 2i-2j $ 的位置 $j$ ,这里的 $i,j​$ 在新串上的字符都必须为 ‘#’​ . 通过第二个条件可知 $j\ge \frac {2i-R(i)} {2}​$ ,即 $j\ge i-\lfloor \frac {R(i)} 2\rfloor​$ . 将所有 $j$ 按照 $j+R(j)-1$ 排序,从大到小枚举 $i$ ,将所有 $j+R(j)-1\ge i$ 的 $j$ 放入一个 $set$ 中. 此时在 $set$ 中查询 $i-\lfloor \frac {R(i)} 2\rfloor$ 的后继,就是要求的 $j$ ,注意特判不存在的情况以及检验 $j&lt;i$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;char buf[MAXN],s[MAXN];int n,R[MAXN];int ans=0;void Manacher()&#123; s[0]='$'; for(int i=1;i&lt;=n;++i) &#123; s[2*i-1]='#'; s[2*i]=buf[i]; &#125; s[2*n+1]='#'; s[2*n+2]='@'; n=2*n+2; int p=0,mx=0; for(int i=1;i&lt;n;++i) &#123; if(i&gt;mx) R[i]=1; else R[i]=min(mx-i+1,R[2*p-i]); while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; &#125;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairset&lt;int&gt; S;set&lt;int&gt;::iterator it;pii tmp[MAXN];int tot=0;int main()&#123; n=read(); scanf("%s",buf+1); Manacher(); for(int j=1;j&lt;n;++j) if(j&amp;1) tmp[++tot]=mp(j+R[j]-1,j); sort(tmp+1,tmp+tot+1); int nx=tot; for(int i=n-1;i&gt;=1;--i) &#123; if(!(i&amp;1)) continue; while(nx&gt;0 &amp;&amp; tmp[nx].first&gt;=i) S.insert(tmp[nx--].second); it=S.lower_bound(i-R[i]/2); if(it!=S.end() &amp;&amp; *it&lt;i) ans=max(ans,2*(i-*it)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190831]]></title>
    <url>%2F2019%2F08%2F31%2Ftest20190831%2F</url>
    <content type="text"><![CDATA[神仙题目. $crypto$讲道理,这应该是个愚人节题目. 枚举密钥的长度,假设密钥的长度为 $l$ .我们考虑恢复出密钥的每一位. 例如要恢复第一位,就将密文的第$1,l+1,2l+1,\dots$个字符取出来. 然后这些字符的字母频率应该符合英文字母的分布,可以根据样例输出统计. 可以枚举加密时候的位移是多少,根据英文字母的分布选出最小二乘解. 对于每种密钥长度解密后,选出 $THE$ 最多的长度作为正确答案. $string$貌似只有这道题比较可做. 可以把所有加入的串建一个广义后缀自动机. 或者将相邻的两个串中间加入一个标识符,当成一个串,插入后缀自动机中. 然后每次询问在上面暴力匹配就好了. $eigen$做法是用 幂法 迭代出绝对值最大的解,再不断构造变换,得出其他的解. 我不会做.]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2565 最长双回文串]]></title>
    <url>%2F2019%2F08%2F30%2Fbzoj-2565-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$Manacher$ . 考虑枚举 $X,Y$ 两个回文串的分界位置,不能以首尾的 ‘#’ 作为分界位置,否则 $X,Y$ 长度可以为 $0$ . 利用 $Manacher$ ,位置 $i$ 作为分界位置的贡献就是左边能覆盖到 $i$ 的最大长度加上右边能覆盖到 $i$ 的最大长度. 以找左侧最优位置为例,从左往右扫描,同时维护一个当前处理到的右边界 $k$ . 扫描到第 $i$ 位时,就把 $k+1\sim i+R(i)-1$ 这一段的最优位置全部更新为 $i$ ,然后将右边界更新为 $i+R(i)-1$ . 右边界只会向右移动,所以时间复杂度为 $O(n)$ . 右侧最优位置的处理方法同理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;char buf[MAXN],s[MAXN];int n,R[MAXN],sum[MAXN];void Manacher()&#123; s[0]='$'; for(int i=1;i&lt;=n;++i) &#123; s[2*i-1]='#'; s[2*i]=buf[i]; &#125; s[2*n+1]='#'; s[2*n+2]='@'; n=2*n+2; int p=0,mx=0; for(int i=1;i&lt;n;++i) &#123; if(mx&lt;i) R[i]=1; else R[i]=min(mx-i+1,R[2*p-i]); while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; &#125; for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+('a'&lt;=s[i] &amp;&amp; s[i]&lt;='z');&#125;int lp[MAXN],rp[MAXN];int main()&#123; scanf("%s",buf+1); n=strlen(buf+1); Manacher(); int k=0; for(int i=1;i&lt;n;++i) &#123; for(int j=k+1;j&lt;=i+R[i]-1;++j) lp[j]=i; k=max(k,i+R[i]-1); &#125; k=n; for(int i=n-1;i&gt;=1;--i) &#123; for(int j=k-1;j&gt;=i-R[i]+1;--j) rp[j]=i; k=min(k,i-R[i]+1); &#125; int ans=0; for(int i=3;i&lt;n-2;++i) if(i&amp;1) &#123; int t=2*(sum[i]-sum[lp[i]-1])-sum[lp[i]]+sum[lp[i]-1]; t+=2*(sum[rp[i]]-sum[i-1])-sum[rp[i]]+sum[rp[i]-1]; ans=max(ans,t); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190830]]></title>
    <url>%2F2019%2F08%2F30%2Ftest20190830%2F</url>
    <content type="text"><![CDATA[开始还以为是原题大战,后来发现题号是连着的,应该是考完后传上去的. $common$典故 考虑分块,将编号 $1\sim n$ 分成 $\sqrt n$ 个块. 做一遍 $dfs$ ,预处理出每个点的 $dfs$ 序,以及它对每一块的贡献次数. 询问时,整块的部分直接调用答案,边角部分利用 $dfs$ 序逐个查询. 时间复杂度 $O(n\sqrt n \log n)$ . $\text{long long}$ 会被卡,要用 $\text{unsigned long long}$ . $art$典故 考虑矩阵树定理,将那 $n$ 个点标号为 $1\sim n$ ,另外 $m$ 个点标号为 $n+1\sim n+m$ . 由于图是一张完全二分图,所以可以直接写出它的基尔霍夫矩阵去掉最后一行一列得到的余子式.$$\begin{vmatrix}m &amp; 0 &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\0 &amp; m &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots\\0 &amp; 0 &amp;\cdots &amp; m &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\-1 &amp; -1 &amp;\dots &amp; -1 &amp; n &amp; 0 &amp; \dots &amp; 0 \\-1 &amp; -1 &amp;\dots &amp; -1 &amp; 0 &amp; n &amp;\dots &amp; 0 \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \ddots&amp; \vdots\\-1 &amp; -1 &amp;\dots &amp; -1 &amp; 0 &amp; 0 &amp;\dots &amp; n\end{vmatrix}$$ 这个矩阵的行列式就是答案,比较明显的,可以将它分成 $4$ 个区域,左下角和右上角全都是 $-1$ . 左上角是一个 $n\times n$ 的对角矩阵,对角线上元素都是 $m$ . 右下角是一个 $(m-1)\times (m-1)$ 的对角矩阵,对角线上元素都是 $n$ . 由于这个矩阵十分特殊,我们直接尝试手算它的行列式. 由于前 $n$ 行已经完成了上三角化,只需要对后 $m-1$ 行上三角化. 将前 $n​$ 行每一行都乘一个 $\frac 1 m ​$ ,加到后 $m-1​$ 行的每一行中,行列式不变,矩阵被消成了这样:$$\begin{vmatrix}m &amp; 0 &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\0 &amp; m &amp;\cdots &amp; 0 &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots\\0 &amp; 0 &amp;\cdots &amp; m &amp; -1 &amp; -1 &amp;\cdots &amp; -1 \\0 &amp; 0 &amp;\dots &amp; 0 &amp; \frac{n(m-1)}m &amp; \frac{-n}m &amp; \dots &amp; \frac{-n}m \\0 &amp; 0 &amp;\dots &amp; 0 &amp; \frac{-n}m &amp; \frac{n(m-1)}m &amp;\dots &amp; \frac{-n}m \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots&amp; \vdots&amp; \vdots&amp; \ddots&amp; \vdots\\0 &amp; 0 &amp;\dots &amp; 0 &amp; \frac{-n}m &amp; \frac{-n}m &amp;\dots &amp; \frac{n(m-1)}m\end{vmatrix}$$此时,因为下面 $m-1$ 行的前 $n$ 列都是 $0$ ,无论怎样进行行变换都不会变,所以这个矩阵的行列式其实就等于左上角的 $n\times n$ 的矩阵的行列式与右下角 $(m-1)\times (m-1)$ 的矩阵行列式之积. 左上角的那个对角线矩阵行列式显然是 $m^n​$ . 对于右下角那个矩阵,我们将每个元素都乘上 $\frac m n​$ ,行列式会变为原来的 $(\frac m n)^{m-1}​$ 倍,最后答案要乘上系数 $(\frac n m)^{m-1}​$ . 右下角的元素乘上 $\frac m n$ 后,得到的新的 $(m-1) \times (m-1)$ 的矩阵是这样的:$$\begin{vmatrix}m-1 &amp; -1 &amp;\cdots &amp;-1 \\-1 &amp; m-1 &amp;\cdots &amp;-1\\\vdots &amp; \vdots &amp;\ddots &amp;\vdots\\-1 &amp; -1 &amp; -1 &amp; m-1\end{vmatrix}$$即主对角线上的元素都是 $m-1$ ,其余元素都是 $-1$ . 如果我们再给他在外面补上一行一列,补成一个 $m\times m$ 的矩阵,$$\begin{vmatrix}m-1 &amp; -1 &amp;-1 &amp;\cdots &amp;-1 &amp;-1 \\-1 &amp; m-1 &amp;-1 &amp;\cdots &amp;-1 &amp;-1\\-1 &amp; -1 &amp;m-1 &amp;\cdots &amp;-1 &amp;-1\\\vdots&amp;\vdots &amp; \vdots &amp;\vdots &amp;\ddots&amp;\vdots\\-1 &amp;-1 &amp; -1 &amp; \cdots &amp; -1&amp; m-1\end{vmatrix}$$这个 $m\times m$ 的矩阵其实就是一张完全图 $K_m$ 的基尔霍夫矩阵,每个点度数为 $m-1$ ,每两个点之间都有边. 根据矩阵树定理,那个 $(m-1)\times (m-1)$ 的矩阵的行列式就等于完全图 $K_m$ 的生成树个数. 根据 $Cayley$ 定理,或利用 $prufer$ 序列,这个数目应该是 $m^{m-2}$ . 将两个行列式与那个系数 $(\frac n m)^{m-1}​$ 乘在一起,就得到了答案.$$\begin{aligned}ans&amp;=m^n\cdot n^{m-1} \cdot m^{1-m} \cdot m^{m-2} \\&amp;=m^{n-1}\cdot n^{m-1}\end{aligned}$$ $hands$典故 把两种移动方式看做两个向量 $\vec a,\vec b$ .因为题目保证它们不共线,所以每个点都可以被写成 $x\cdot \vec a+y\cdot \vec b$ . 以解出来的 $(x,y)$ 代替原来的坐标,就变成了每次可以向右或向上走一步,可以直接舍去坐标转换后不是整点的点. 要求不能经过障碍点,求起点到终点的方案数. 如果没有障碍,答案显然是 $C_{x+y}^x$ .但现在有障碍.直接递推显然不行,因为新坐标的大小可以达到 $2\times 500^2$ . 将障碍点,目标点视为关键点,记原点为第 $0​$ 个关键点. 坐标转换后,按照 $x$ 为第一关键字, $y$ 为第二关键字排序,就做出了一个拓扑序,再进行 $dp$ . 设 $f(i)$ 表示从原点到达第 $i$ 个关键点而不经过其他关键点的方案数. $g(i,j)​$ 表示从第 $i​$ 个关键点到第 $j​$ 个关键点的所有方案数. 转移有 $f(i)=g(0,i)-\sum_{j=1}^{i-1} g(j,i)\cdot f(j)$ .而 $g$ 不需要考虑障碍,若能够到达,就是组合数,否则是 $0$ . 时间复杂度 $O(n^2)​$ .]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>线性代数</tag>
        <tag>test</tag>
        <tag>分块</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF17E Palisection]]></title>
    <url>%2F2019%2F08%2F29%2FCF17E-Palisection%2F</url>
    <content type="text"><![CDATA[$Manacher$ + 差分. 利用补集转化思想,求出回文子串的总对数 $-$ 不相交的回文子串对数就是答案. 先跑一遍 $Manacher$ ,得出每个位置的回文半径以及回文子串的总对数. 于是接下来只需要计算不相交的回文子串对数. 记 $f(i)$ 表示以位置 $i$ 开始的回文子串数目, $g(i)$ 表示以位置 $i$ 结尾的回文子串数目. 这可以在跑 $Manacher$ 时打差分标记计算出来. 每个实际位置 $i$ ,即是字母的位置 $i$ ,贡献为 $f(i)\cdot \sum_{j&lt;i} g(j)$ ,枚举的时候记录一下 $g$ 的实际位置上的前缀和. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=51123987;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=4e6+10;char buf[MAXN],s[MAXN];int n,R[MAXN],ans=0;int f[MAXN],g[MAXN];void Manacher()&#123; s[0]='$'; for(int i=1;i&lt;=n;++i) &#123; s[2*i-1]='#'; s[2*i]=buf[i]; &#125; s[2*n+1]='#'; s[2*n+2]='@'; n=2*n+2; int mx=0,p=0; for(int i=1;i&lt;n;++i) &#123; int fl=1,j=2*p-i; if(mx&lt;i) R[i]=1; else if(mx-i&gt;R[j]) R[i]=R[j],fl=0; else R[i]=mx-i+1; if(fl) while(s[i-R[i]]==s[i+R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; ++f[i-R[i]+1],--f[i+1]; ++g[i],--g[i+R[i]]; ans=add(ans,R[i]/2); &#125;&#125;int main()&#123; n=read(); scanf("%s",buf+1); Manacher(); ans=(1LL*ans*(ans-1)/2)%P; int tmp=0; for(int i=1;i&lt;=n;++i) &#123; f[i]+=f[i-1]; g[i]+=g[i-1]; if(!(i&amp;1)) &#123; ans=add(ans,P-mul(f[i],tmp)); tmp=add(tmp,g[i]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2160 拉拉队排练]]></title>
    <url>%2F2019%2F08%2F29%2Fbzoj-2160-%E6%8B%89%E6%8B%89%E9%98%9F%E6%8E%92%E7%BB%83%2F</url>
    <content type="text"><![CDATA[$Manacher$ + 差分维护数列. 首先将字符串添加特殊字符,利用 $Manacher$ 算法求出每个位置的回文半径 $R(i)$ . 维护一个 $cnt(i)$ 表示原串中长度为 $i$ 的回文串数目. 由于只考虑奇回文串,所以枚举时只处理字母作为回文中心的贡献. 若第 $i$ 个位置是字母,则它在原串中对应的奇回文串的长度分别是 $1,3,5,\dots,R(i)-1$ . 给 $1\sim R(i)-1$ 的所有 $cnt$ 都 $+1$ ,可以用差分来维护. 最后统计答案时,从大到小枚举长度,只将奇数长度计入贡献. 时间复杂度 $O(n\log n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=19930726;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=2e6+10;char s[MAXN],buf[MAXN];int n,R[MAXN],cnt[MAXN];void Manacher()&#123; buf[0]='$'; for(int i=1;i&lt;=n;++i) &#123; buf[2*i-1]='#'; buf[2*i]=s[i]; &#125; buf[2*n+1]='#'; buf[2*n+2]='@'; //1~2n+1 int mx=1,p=1; R[1]=1; for(int i=2;i&lt;=2*n+1;++i) &#123; int f=1; int j=2*p-i; if(mx&lt;i) R[i]=1; else if(mx-i&gt;R[j]) R[i]=R[j],f=0; else R[i]=mx-i+1; if(f) while(buf[i+R[i]]==buf[i-R[i]]) ++R[i]; if(i+R[i]-1&gt;mx) mx=i+R[i]-1,p=i; if('a'&lt;=buf[i] &amp;&amp; buf[i]&lt;='z') ++cnt[1],--cnt[R[i]]; &#125;&#125;ll k;int main()&#123; n=read(),k=read(); scanf("%s",s+1); Manacher(); int ans=1; for(int i=1;i&lt;=n;++i) cnt[i]+=cnt[i-1]; for(int i=n;i&gt;=1;--i) if(cnt[i] &amp;&amp; (i&amp;1)) &#123; if(k&gt;cnt[i]) &#123; ans=mul(ans,fpow(i,cnt[i])); k-=cnt[i]; &#125; else &#123; ans=mul(ans,fpow(i,k)); printf("%d\n",ans); return 0; &#125; &#125; puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher算法学习笔记]]></title>
    <url>%2F2019%2F08%2F29%2FManacher%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[感觉自己之前学的时候没学清楚,于是重新整理了一遍. 本文主要整理自 2014年集训队论文 《浅谈回文子串问题 徐毅》. 回文半径以字符串第 $i$ 个位置为中心的回文子串长度的一半,称为该字符串第 $i$ 位的回文半径,记作 $R(i)​$ . 预处理处理回文子串问题时,为了方便,经常将原字符串加入特殊字符,避免奇偶讨论与边界问题. 如: &quot;abbabcba&quot; -&gt; &quot;$#a#b#b#a#b#c#b#a#@&quot; 对新字符串求出每个位置的回文半径,就对应了原串中以字符为中心的奇回文串和以空隙为中心的偶回文串. $Manacher$ 算法又称马拉车算法. 可以以 $O(n)$ 的时间复杂度求解长度为 $n$ 的字符串每个位置的回文半径. 首先执行上文的预处理,再依次计算位置 $1\sim n$ 的回文半径. 记 $mx$ 表示已经计算出的回文半径覆盖到的最右边界,即 $\max k+R(k)-1$ . 记 $p$ 为对应中心的位置,即使得 $k+R(k)-1$ 取得最大值的 $k$ . 枚举 $i$ ,计算 $R(i)$ 时,考虑暴力匹配的过程,就是从 $i$ 不断向外拓展,也就是从 $1$ 开始枚举 $R(i)​$ ,直到不能拓展. $Manacher$ 算法就是通过记录的 $mx,p$ ,来给 $R(i)$ 确定一个下界,这样枚举 $R(i)$ 时只用从下界开始枚举. 记 $j=2p-i$ ,即 $i$ 关于 $p$ 的对称位置.分以下 $3$ 种情况进行讨论: 情况一: $mx&lt;i$ ,只能确定 $R(i)\ge 1$. 情况二: $mx-i&gt;R(j)$ ,即以第 $j$ 位为中心的回文子串包含于以第 $p$ 位为中心的回文子串. 由于 $i$ 和 $j$ 关于 $p$ 对称,以第 $i$ 位为中心的回文子串必然也包含于以第 $p$ 位为中心的回文子串,故有 $R(i)=R(j)$ . 情况三: $mx-i\le R(j)$ ,此时以第 $j$ 位为中心的回文子串不一定包含于以第 $p$ 位为中心的回文子串. 但因为 $i$ 与 $j$ 关于 $p$ 对称,所以以 $i$ 为中心向右至少能拓展到 $mx$ 的位置,即 $R(i)\ge mx-i+1$ . 在情况一与三中,确定下界后,再从下界开始枚举 $R(i)$ ,继续拓展,即暴力向外匹配. 不难验证,每次暴力向外匹配都会使得 $mx$ 增大,而 $mx$ 最多增大 $n$ 次,所以算法时间复杂度为 $O(n)$ . 从跳 $mx$ 的过程中也可以得到关于回文子串的两条比较重要的性质: 性质一: 一个长度为 $n$ 的字符串含有的本质不同的回文子串只有 $O(n)$ 个. 这是因为只有 $mx$ 增大时,才会产生本质不同的回文子串,否则一定存在对称的回文子串,而 $mx$ 增大不会超过 $n$ 次. 于是可以在算法执行过程中将所有本质不同的回文子串的位置给处理出来,在 $mx$ 增大时进行记录即可. 性质二: 一个长度为 $n$ 的字符串的回文性质可以用 $O(n)​$ 个相等与不等关系表示. 定义一个字符串的回文性质为所有回文子串出现位置的集合. 即,若串 $S$ 与串 $T$ 具有相同的回文性质,则 $S(i,\dots j)$ 为回文串,当且仅当 $T(i,\dots,j)$ 为回文串. 而一个串 $S​$ 的回文性质可以用一些相等和不等关系表示.对于以第 $i​$ 位为中心的回文子串,显然有 $0\le k&lt;R(i),S[i-k]=S[i+k]​$ ,以及 $S[i-R(i)]\not=S[i+R(i)]​$ ,这就是一些相等与不等关系. 只有当 $mx$ 增大时,才会产生新的相等关系,否则一定存在对称的相等关系,相等关系数量是 $O(n)$ 的. 而每个位置作为回文中心只会产生一个不等关系,不等关系数量也是 $O(n)$ 的. 所以可以只用 $O(n)$ 个相等和不等关系表示回文性质.]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190829]]></title>
    <url>%2F2019%2F08%2F29%2Ftest20190829%2F</url>
    <content type="text"><![CDATA[我上当了. $path$典故 枚举出发点 $S$ ,建出以 $S$ 为起点的最短路图,即只保留 $dis(u)+val(i)=dis(v)$ 的边 $i$ . 在最短路图上 $dp$ ,拓扑排序后求出 $f(i)$ 表示 $S\to i$ 的路径条数, $g(i)$ 表示以 $i$ 为起点的路径条数. 那么对于在最短路图上的一条边 $u\to v$ ,以 $S$ 为起点时的所有贡献为 $f(u)\cdot g(v)$ . 时间复杂度 $O(nm\log n)$ . $seq$典故 ,来自电子神大的 $OJ$. 由于题面没说清楚,就强行规定 $j&gt;i$ ,把数据修了. 就是要找到右边第一个严格大于 $a_x$ 的位置 $y$ ,那么 $[x+1,y-1]$ 这一段都可以作为答案,可以在线段树上二分. 然后加上从 $y$ 开始,最长单调不下降子序列的长度,这可以分块. 分成 $\sqrt n$ 个块后,维护每一块内部的不下降子序列和块边界处的不下降子序列. 询问时对整块二分,边角暴力. 然而直接 $O(n^2)$ 暴力可以过 $80\sim 100$ 分? 我上当了,写了个线段树 + 定期重构,比暴力的分还少一些,而且我发现去掉重构之后还是差不多慢. $area$求圆环的面积并, $n\le 1000$ . 留坑. 我上当了,写了个撒点,精度太垃圾了,甚至要开 $0$ 位小数才能过前两个点.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>计算几何</tag>
        <tag>最短路</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190828]]></title>
    <url>%2F2019%2F08%2F28%2Ftest20190828%2F</url>
    <content type="text"><![CDATA[原题大战. $dna$典故 学了回文自动机再来更. $color$其实应该算是原题的弱化版. 典故 记 $dist(x)$ 表示根节点到 $x$ 的距离, $dis(x,y)$ 表示 $x,y​$ 之间的距离.$$\begin{aligned}ans&amp;=\sum_{y=1}^{k} dis(x,y) \\&amp;=\sum_{y=1}^k dist(x)+dist(y)-2\cdot dist(LCA_{x,y}) \\&amp;=dist(x)\cdot k+\sum_{y=1}^{k} dist(y)-2\cdot\sum_{y=1}^k dist(LCA_{x,y})\end{aligned}$$前面两项都容易维护,考虑如何计算最后一项的贡献. $dist(LCA_{x,y})$ 其实就是 $x$ 到根的路径与 $y$ 到根的路径交集部分的长度. 每新染黑一个 $y$ ,就将 $y$ 到根节点上的每条边标记 $+1$ . 询问时,最后那一项就是 $x$ 到根节点路径上每条边的 标记次数 $\times​$ 边长. 可以用树链剖分 + 线段树来维护,时间复杂度 $O(n\log^2 n)$ . $land$典故 题目中已经告诉我们怎么判断一个格子是否在多边形内部,这个判断条件只跟穿过次数奇偶性有关. 可以利用它进行状压 $dp$. 给每个格子选一条射线,在转移的过程中更新有宝藏和陷阱的格子那条射线穿过边的奇偶性状态. $f(i,j,S)$ 表示当前在格子 $(i,j)$ ,宝藏和陷阱的射线奇偶性状态为 $S$ 时,多边形最小周长. 转移时直接 $bfs$ ,最后枚举哪些宝藏被圈了起来,统计答案.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>状压dp</tag>
        <tag>test</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190827]]></title>
    <url>%2F2019%2F08%2F27%2Ftest20190827%2F</url>
    <content type="text"><![CDATA[roll 制出题人. 大样例没有,小样例极水,权值范围也没有,题意还没说清楚. $guard$每个武器只能打死一个人.我以为能将小于等于它的的全部打死,就保龄了. 将所有武器按 $a$ 从小到大排序. 第一次枚举确定哪些武器用精灵,如果用精灵能打死的怪的 $b&gt; a_i​$ ,就用精灵打. 然后剩下的武器都不用精灵,直接贪心匹配. 时间复杂度 $O(T\cdot n\log n)$ $phase$直接用树剖 + 线段树维护区间内所有点权值的异或和,时间复杂度是 $O(n\log^2 n)$ . 但用一下异或的性质,就能做到 $O(n\log n)$ . 记 $dist(i)​$ 表示从 $i​$ 到根节点的路径上经过的所有点权值异或和. 每次询问 $(x,y)$ ,先求出它们的 $lca$ ,答案就是 $dist(x)\text{ xor }dist(y)\text{ xor }dist(lca)\text{ xor }dist(fa(lca))$ . 树剖后用线段树来维护每个点的 $dist$ ,每次修改时,子树 $x$ 内深度奇偶性与 $x$ 不同的点 $dist$ 会被异或上 $y$ . 线段树中维护两个标记,分别表示深度为奇/偶的点需要异或上的值,时间复杂度 $O(n\log n)$ . $refuse$$50$ 分的做法是状压 $dp$ ,设 $f(r,c)$ 表示行覆盖情况为 $r$ ,列覆盖情况为 $c$ 时的期望,时间复杂度 $O(2^{n+m}\cdot nm)$ . 但不知道怎么回事写挂了,就保龄了. 下面是正解. 设 $f(i)$ 为恰好经过 $i$ 次操作后成功的概率,根据期望定义,答案 $ans=\sum_{i=0}^{+\infty} f(i)\cdot i$ . 再设 $P(i)$ 表示经过了 $i$ 次操作后还没有成功的概率.那么就等价于在之后成功的概率之和, $P(i)=\sum_{j=i+1}^{+\infty} f(i)$ . 可以发现 $ans=\sum_{i=0}^{+\infty} P(i)$ ,因为这样计算,每个 $f(i)$ 都恰好被计算了 $i$ 次. 于是需要考虑如何求出 $P(i)$ . 枚举哪些行和列在前 $i$ 次操作都没有被标记,记它们形成的集合为 $s$ . 设 $p(s)$ 表示选中集合 $s$ 中的行列中的格子 $1$ 的概率,那么 $i$ 次都没选中就是 $(1-p(s))^i$ ,利用容斥原理计算,$$P(i)=\sum_s (-1)^{|s|+1} \cdot (1-p(s))^i$$代入答案 $ans$ ,$$\begin{aligned}ans&amp;=\sum_{i=0}^{+\infty} P(i) \\&amp;=\sum_{i=0}^{+\infty} \sum_s (-1)^{|s|+1} \cdot (1-p(s))^i \\&amp;=\sum_s (-1)^{|s|+1}\cdot \frac 1 {p(s)}\end{aligned}$$设 $tot$ 为格子 $1$ 的总数目, $sum(s)$ 表示集合 $s$ 的行列含有的 $1$ 的数目,那么答案为$$ans=\sum_{s}(-1)^{|s|+1}\cdot \frac {tot} {sum(s)}$$于是只需要计算 $sum(s)$ .因为 $sum(s)$ 相同的状态有很多,可以设 $num(x)=\sum_s [sum(s)=x]\cdot (-1)^{|s|+1}$ . 则答案为$$ans=\sum_{x=1}^{tot} num(x)\cdot \frac {tot} {x}$$考虑如何计算 $num(x)$ ,由于 $n\cdot m\le 200$ ,所以 $\min(n,m)\le 14$ . 假设 $n\le m$ ,否则只需交换行与列. 暴力 $2^n$ 枚举选了哪些行,对列做 $dp$ ,设 $dp(i,j,k)$ 表示考虑了前 $i$ 列, $|s|$ 的奇偶性为 $j$ , $sum(s)=k$ 的方案数. 最后根据奇偶性计算出每个 $num(x)​$ ,统计答案即可. 时间复杂度为 $O(2^n\cdot m^2\cdot n )​$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>树链剖分</tag>
        <tag>概率/期望</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190826]]></title>
    <url>%2F2019%2F08%2F26%2Ftest20190826%2F</url>
    <content type="text"><![CDATA[两个简单题 + 一个比较难的原题. $Gene$有一个十分简单的 $O(n\log n)$ 的做法,字符串 $hash$ + 二分,用自然溢出常数比较小,是可以过的. $O(n)$ 的一个做法是 $SAM$ ,对反串建后缀自动机,答案就是每个点的 $siz$ 之和,但空间很容易炸. 另一个做法是利用 $kmp$ 的 $fail$ 数组,每个位置不断往前跳,每跳一次就说明有一个合法的匹配. 暴力跳会超时,记忆化一下,用 $f(i)$ 表示从 $i$ 开始能往前跳几次,则 $f(i)=f(fail_i)+1$ . $Shield$因为给出的两个向量线性无关,可以它们为一组基底,解出每个点在这组基底下的坐标. 于是一个点可以转移到 $x,y$ 都不小于它的点. 将点按 $x$ 为第一关键字, $y$ 为第二关键字排序,将 $y$ 离散化后用树状数组做一个类似于 $LIS$ 的 $dp$ 即可. 时间复杂度 $O(n\log n)$ . 坐标太大,精度爆掉了一个点.其实可以在比较元素时再转换坐标,避免小数运算. $Chronosphere$典故 首先可以建出源汇点 $S,T​$ ,源点向所有点连边,所有点向汇点连边. 问题转化为最小化删去一个点后 $S\to T$ 的最长路长度. 拓扑排序 + $dp$ 处理出 $f(i),g(i)$ 分别表示 $S\to i$ 的最长链与 $i\to T$ 的最长链经过的点数. 那么对于一条边 $u\to v$ ,它的的贡献就是 $f(u)+g(v)-1$ . 若有一个 $S\to T$ 的割,那么所有 $S\to T$ 路径一定会经过至少一条割集中的边,只需要考虑割集中的边贡献. 一开始让 $s$ 集只有 $S$ , $T$ 集包含剩余的所有点,这是一个合法的割. 按照拓扑序枚举删掉 $x$ 后的答案,依次进行如下操作,以将点 $x$ 从 $T$ 集合中取出,放入 $S$ 集中. $1.$ 将 $x$ 的所有入边从割集中删掉. $2.$ 所有割集的边的最大贡献就是删掉点 $x$ 的答案. $3.$ 将 $x$ 的所有出边加入割集. 正确性可以利用数学归纳法证明. 执行第 $1$ 步之前,割是整张图的一个割,假设它不含从 $x$ 出发能到的任何边. 所以删掉 $x$ 的入边后,割就是去掉 $x$ 的图的一个合法割,此时可以更新答案. 若将 $x$ 放回图中, $S\to T$ 的路径就一定经过 $x$ ,所以割掉 $x$ 的所有出边,又成了一个合法割. 因为是按照拓扑序依次处理的,所以加入的 $x$ 的入边在之后一定不能被到达,满足了先前的假设. 而初始状态也是满足假设的,所以可以归纳证得以上算法的正确性. 割集只需要记录边的贡献,不记录边的编号,所以可以用一棵权值线段树进行维护,时间复杂度 $O(m\log m)$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>kmp</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190825]]></title>
    <url>%2F2019%2F08%2F25%2Ftest20190825%2F</url>
    <content type="text"><![CDATA[我的线段树自带 $10$ 倍常数. $Count$对于每一种 $\prod a_i\not=n^m​$ 的选法,都恰好存在另一种对应的选法 $\prod \frac n {a_i}​$ . 随便选的方案数为 $(\sigma(n))^{2m}$ ,再加上 $\prod a_i=n^m$ 的方案数,除以 $2$ 就是答案. 于是只需要算 $\prod a_i=n^m$ 的方案数. 将 $n$ 分解质因数,显然每个质因子可以分开算方案,答案是每个质因子的贡献乘积. 每个质因子的贡献就是一个整数划分问题, $dp$ 一下,因为方案数只与质因子质数有关,所以可以最后一起加入贡献. $Delete$每次删掉最长的一个单调序列,直到删完. 假设当前的序列长度为 $n$ ,最长上升子序列长度为 $a$ ,最长下降子序列长度为 $b$ . 根据 $Dilworth$ 定理,用最长上升子序列覆盖这个序列至少需要的子序列数目也是 $b$ . 所以就有 $a\cdot b\ge n$ ,得到 $\max(a,b)\ge \sqrt n$ . 于是每次操作至少会使得一个长度为 $n$ 的序列长度减少 $\sqrt n$ ,当 $n=64000$ 时,一定可以在 $500$ 次内删完. $Floor\ it$考虑斐波那契数列的两个特征根 $\phi_1=\frac {1+\sqrt 5} 2,\phi_2=\frac {1-\sqrt 5} 2$ ,其中 $\phi_1$ 就是题目中给出的 $x$ . 构造数列 $a_i=\phi_1^i+\phi_2^i$ ,则 $a$ 有递推式 $a_i=a_{i-1}+a_{i-2},a_1=1,a_2=3$ ,可知 $\forall i\in \mathbb N+,a_i\in \mathbb N+ $. 当 $n$ 为偶数时, $0&lt;\phi_2^n&lt;1,\lfloor x^n\rfloor=a_n-1$ . 当 $n$ 为奇数时, $-1&lt;\phi_2^n&lt;0,\lfloor x^n \rfloor=a_n$ . 用矩阵快速幂 $O(\log n)​$ 求 $a_n​$ 即可.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Japanese Student Championship 2019 Qualification]]></title>
    <url>%2F2019%2F08%2F25%2FJapanese-Student-Championship-2019-Qualification%2F</url>
    <content type="text"><![CDATA[$\text{+9 rating}$ 可还行. A Takahashi Calendar签到题,按题意暴力枚举一下. B Kleene Inversion贡献可以分成两部分,两个数在同一块中的贡献与两个数在不同块中的贡献,分开算一下. C Cell Inversion操作顺序对答案没有影响,将操作视作一个二元组 $(l,r)$ ,我们可以规定按 $l$ 从小到大的顺序操作,最后答案乘上 $n!$ . 将黑色看为 $1$ ,白色看为 $0$ ,显然只需要将偶数位置上的状态取反,然后答案就是前面的 $1$ 与后面的 $0$ 配对的方案数. 开始没判 $1$ 和 $0$ 个数不等的情况,卡了挺久的. D Classified题意读错了.意思是走回来时,走过的长度为偶数,不是每条边经过的次数都为偶数. 于是就要求同一种边权的边形成的图是二分图. 如果用到最大的边权为 $k$ ,那么最多只能构造出 $n=2^k$ 的情况. 首先证最大边权为 $k​$ 时, $n=2^k+1​$ 不可行. 考虑使用数学归纳法,当 $k=1,n=2^1+1=3$ 时,显然不可行.否则,假定 $k=x-1,n=2^{x-1}+1$ 时不可行. 那么当 $k=x,n=2^x+1$ 时,二分图中黑色的节点至少有 $2^{x-1}+1$ 个,否则白色的节点至少有 $2^{x-1}+1$ 个. 假设黑色节点至少有 $2^{x-1}+1$ 个,对于黑色节点内部,因为用前 $x-1$ 种边权无合法解,所以一定会有权值为 $x$ 的边. 这与二分图的定义相矛盾了,所以结论成立,即最大边权为 $k$ 时, $n=2^k+1$ 不可行. 再来证 $n\le2^k$ 时一定存在最大边权不超过 $k$ 的合法解,尝试直接构造方案. 对于节点 $i,j$ ,若它们的二进制位从低到高第 $x$ 位不同,就将它们之间的边权设为 $x$ . 这样对于任意一个 $0\le x&lt;k$ ,边权为 $k$ 的边一定只存在于第 $x$ 位为 $0$ 与第 $x$ 位为 $1$ 的点之间,形成了二分图. E Card Collector考虑像网络流那样,每一行每一列都建出一个点,读入的每个点向所在行列连边,权值都是 $A_i$ . 于是需要选出一些边使得它们的权值最大,并且任意两条边不能有公共点. 分析性质后,发现就是在求解加权拟阵的最大权值独立子集,贪心求解即可. 即将所有边按权值从大到小排序后,依次遍历,若当前的边能加入,就加入. F Candy Retribution留坑.]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>二分图</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4245 OR-XOR]]></title>
    <url>%2F2019%2F08%2F24%2Fbzoj-4245-OR-XOR%2F</url>
    <content type="text"><![CDATA[贪心. 因为答案的形式是每一段的权值 $\text {or}$ 起来,从高位到低位考虑,贪心地让高位尽可能为 $0$ . 尝试让答案的第 $i$ 位为 $0$ ,就要求选出的 $m$ 个权值的第 $i$ 位都为 $0$ . 因为这 $m$ 段是连续的,所以就等价于选出 $m$ 个右端点,且最后一个必须选 $n$ . 求出原数列的前缀异或和,容易发现这 $m$ 个右端点处的前缀异或和第 $i$ 位都必须为 $0$ . 于是从高位往低位做,若当前位有至少 $m$ 个可选的位置(必须包含 $n$ ),则这一位对答案的贡献为 $0$, 否则为 $1$ . 每次贡献为 $0$ 时,将前缀异或和这一位为 $1$ 的位置标记出来,表示以后都不能再选了,否则会使得这一位为 $1$ . 注意要用 $\text{1LL}$ 参与位运算. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m;ll sum[MAXN];bool vis[MAXN];bool check(int k)&#123; if((sum[n]&gt;&gt;k)&amp;1LL) return false; int cnt=0; for(int i=1;i&lt;=n;++i) if(!((sum[i]&gt;&gt;k)&amp;1LL) &amp;&amp; !vis[i]) ++cnt; return cnt&gt;=m;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]^read(); ll ans=0; for(int k=62;k&gt;=0;--k) &#123; if(check(k)) &#123; for(int i=1;i&lt;=n;++i) if((sum[i]&gt;&gt;k)&amp;1LL) vis[i]=true; &#125; else ans|=(1LL&lt;&lt;k); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4299 FRBSUM]]></title>
    <url>%2F2019%2F08%2F24%2Fbzoj-4299-FRBSUM%2F</url>
    <content type="text"><![CDATA[主席树. 考虑如何计算一个集合的 $\text{Forbidden Sum}​$ . 将集合内的数从小到大排序,依次加入.若当前可以表示出 $[0,s]$ 内的所有数,再加入一个数 $x$ . 若 $x\le s+1$ ,则可以表示出 $[0,s+x]$ 内的所有数.若 $x&gt; s+1$ ,则 $s+1$ 无法被表示出,答案为 $s+1$ . 实际做的时候可以换一种思路,将枚举 $x$ 变为不断更新 $s$ . 初始令 $s=1​$ ,每次在区间 $[l,r]​$ 内询问所有 $\le s​$ 的数之和,即上面分析的前缀和.若询问到的 $x&lt;s​$ ,则答案为 $s​$ . 否则令 $s=x+1$ ,继续询问. 询问一段区间内 $\le s​$ 的所有数之和可以用主席树实现. 考虑时间复杂度,若每次都 $x\ge s$ ,每次询问 $s$ 至少翻一倍,所以在主席树上查询了 $O(\log \sum a_i)$ 次. 总时间复杂度为 $O(m\cdot \log \max a_i\cdot \log \sum a_i)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct PreSegtree&#123; int idx; struct node &#123; int ls,rs; int sum; node()&#123;ls=rs=sum=0;&#125; &#125;Tree[MAXN*30]; PreSegtree()&#123;idx=0;&#125;#define root Tree[o] void ins(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[pre]; root.sum+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,Tree[pre].ls,l,mid,pos,c); else ins(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; int query(int o,int l,int r,int val)// \le val &#123; if(l&gt;val) return 0; if(r&lt;=val) return root.sum; int mid=(l+r)&gt;&gt;1; return query(root.ls,l,mid,val)+query(root.rs,mid+1,r,val); &#125;&#125;T;int n,m,a[MAXN],mx=0,rt[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) mx=max(mx,a[i]=read()); for(int i=1;i&lt;=n;++i) T.ins(rt[i],rt[i-1],1,mx,a[i],a[i]); m=read(); for(int i=1;i&lt;=m;++i) &#123; int L=read(),R=read(); for(int s=1,x;;s=x+1) &#123; x=T.query(rt[R],1,mx,s)-T.query(rt[L-1],1,mx,s); if(x&lt;s) &#123; printf("%d\n",s); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4289 Tax]]></title>
    <url>%2F2019%2F08%2F23%2Fbzoj-4289-Tax%2F</url>
    <content type="text"><![CDATA[构造建图 + 最短路. 先将无向边拆成两条有向边,于是可以将原图中的每条有向边看成一个点,建一个新图. 枚举中继点 $x$ ,则对 $a\to x,x\to b$ 这两条边在新图中连上对应有向边,权值为两者最大值. 在新图中建立源汇点 $S,T$ ,从 $S$ 向所有在原图中以 $1$ 为起点的边连边,从所有在原图中以 $n$ 为终点的边向 $T$ 连边,权值均为原来的权值,那么答案就是新图中 $S\to T$ 的最短路. 但这样边数可以被菊花图这样的东西卡到 $O(m^2)$ 去,需要利用差分的思想优化连边. 对于每个点 $u$ ,将所有以它为起点的边按照权值从小到大排序,对于相邻的两条边 $x,y$ ,假设 $val_x&lt;val_y$ ,就在新图中从 $x$ 向 $y$ 连权值为 $val_y-val_x$ 的边,从 $y$ 向 $x$ 连权值为 $0$ 的边, $S,T$ 相关的边连法不变. 这样连边边数就是 $O(m)$ 了,在新图上跑 $Dijkstra$ 求出最短路. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=1e5+10,M=4e5+10;const int MAXM=2e6+10;int n,m;typedef pair&lt;ll,int&gt; pli;priority_queue&lt;pli&gt; q;const ll inf=1e18;struct Graph&#123; int ecnt,head[MAXM],to[MAXM],nx[MAXM],vis[MAXM]; ll val[MAXM],dis[MAXM]; void addedge(int u,int v,ll w) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt; &#125; Graph()&#123;ecnt=0;memset(head,0,sizeof head);&#125; ll Dijkstra(int S,int T,int tot) &#123; for(int i=1;i&lt;=tot;++i) vis[i]=0,dis[i]=inf; dis[S]=0; q.push(make_pair(-dis[S],S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-val[i]&gt;dis[u]) &#123; dis[v]=dis[u]+val[i]; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125; return dis[T]; &#125;&#125;G;int ecnt,head[N],to[M],nx[M];ll val[M];void addedge(int u,int v,ll w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;bool cmp(int x,int y)&#123; return val[x]&lt;val[y];&#125;int S,T,tmp[MAXM],cnt;void BuildGraph()&#123; S=ecnt+1,T=ecnt+2; for(int i=1;i&lt;=ecnt;i+=2) &#123; G.addedge(i,i+1,val[i]); G.addedge(i+1,i,val[i]); &#125; for(int u=1;u&lt;=n;++u) &#123; cnt=0; for(int i=head[u];i;i=nx[i]) tmp[++cnt]=i; sort(tmp+1,tmp+1+cnt,cmp); for(int i=1;i&lt;cnt;++i) &#123; int x=tmp[i],y=tmp[i+1]; G.addedge(x,y,val[v]-val[u]); G.addedge(y,x,0); &#125; &#125; for(int i=head[1];i;i=nx[i]) G.addedge(S,i,val[i]); for(int i=head[n];i;i=nx[i]) G.addedge((i&amp;1)?i+1:i-1,T,val[i]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); ll w=read(); addedge(u,v,w); addedge(v,u,w); &#125; BuildGraph(); printf("%lld\n",G.Dijkstra(S,T,T)); return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3516 国王奇遇记加强版]]></title>
    <url>%2F2019%2F08%2F23%2Fbzoj-3516-%E5%9B%BD%E7%8E%8B%E5%A5%87%E9%81%87%E8%AE%B0%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[推式子题目. 设 $s_x=\displaystyle \sum_{i=1}^n i^x\cdot m^i$ ,则答案 $ans=s_m$ . 考虑构造出 $s_x$ 的递推式. $$\begin{aligned}s_x+(n+1)^x\cdot m^{n+1}&amp;=m\cdot\sum_{i=1}^n (i+1)^x \cdot m^i+m \\&amp;=m\cdot \sum_{i=1}^n \sum_{j=0}^x {x\choose j} i^j \cdot m^i+m\\&amp;=m\cdot \sum_{i=0}^x s_i\cdot {x\choose i} + m\\(1-m)s_x&amp;=m\cdot \sum_{i=0}^{x-1}s_i\cdot {x\choose i}+m-(n+1)^x\cdot m^{n+1}\end{aligned}$$ 特判 $m=1$ 的情况,其余情况利用等比数列求和公式算出 $s_0$ ,再 $O(m^2)$ 递推求得 $s_m$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; a=(a%P+P)%P; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int n,m,C[MAXN][MAXN];int s[MAXN];int main()&#123; n=read(),m=read(); if(m==1) return printf("%d\n",mul(mul(n,n+1),inv(2)))&amp;0; for(int i=0;i&lt;=m;++i) C[i][0]=1; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j-1],C[i-1][j]); s[0]=fpow(m,n)-1; s[0]=mul(s[0],inv(m-1)); s[0]=mul(s[0],m); for(int x=1;x&lt;=m;++x) &#123; int &amp;tmp=s[x]; for(int i=0;i&lt;x;++i) upd(tmp,mul(s[i],C[x][i])); tmp=mul(tmp,m); upd(tmp,m); upd(tmp,P-mul(fpow(n+1,x),fpow(m,n+1))); tmp=mul(tmp,inv(1-m)); &#125; cout&lt;&lt;s[m]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5343 混合果汁]]></title>
    <url>%2F2019%2F08%2F20%2Fbzoj-5343-%E6%B7%B7%E5%90%88%E6%9E%9C%E6%B1%81%2F</url>
    <content type="text"><![CDATA[二分答案 + 主席树. 将美味度离散化,并将所有果汁按照美味度从小到大排序. 可以用主席树维护单价区间能购买到的最大体积之和与总金额之和,对美味度可持久化. 对于每个询问,二分答案 $ans$ ,只考虑美味度 $\ge ans$ 的果汁. 显然应该贪心地选,尽可能选便宜的凑够体积. 于是查询时在主席树上将美味度 $\ge ans$ 的部分抠出来,进行二分. 若左儿子内的体积够,就返回左儿子的答案. 否则将需要的体积减去左儿子内的体积,返回右儿子的答案加上左儿子的所有价格. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;int n,m,td,tp;ll D[MAXN],P[MAXN];struct Juice&#123; int d,p,lim; bool operator &lt; (const Juice &amp;rhs) const &#123; return d&lt;rhs.d; &#125;&#125;a[MAXN];int rt[MAXN];struct PreSegtree&#123; int idx; struct node &#123; int ls,rs; ll sumv,sumc; node()&#123;ls=rs=sumv=sumc=0;&#125; &#125;Tree[MAXN*30]; PreSegtree()&#123;idx=0;&#125; void upd(int &amp;cur,int pre,int l,int r,int cost,ll v,ll c) &#123; cur=++idx; Tree[cur]=Tree[pre]; Tree[cur].sumv+=v; Tree[cur].sumc+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(cost&lt;=mid) upd(Tree[cur].ls,Tree[pre].ls,l,mid,cost,v,c); else upd(Tree[cur].rs,Tree[pre].rs,mid+1,r,cost,v,c); &#125;#define root1 Tree[Lrt]#define root2 Tree[Rrt] ll query(int Lrt,int Rrt,int l,int r,ll tmpv) &#123; if(root2.sumv-root1.sumv&lt;tmpv) return inf; if(root2.sumv-root1.sumv==tmpv) return root2.sumc-root1.sumc; if(l==r) return tmpv*P[l]; int mid=(l+r)&gt;&gt;1; ll totl=Tree[root2.ls].sumv-Tree[root1.ls].sumv; if(totl&gt;=tmpv) return query(root1.ls,root2.ls,l,mid,tmpv); return Tree[root2.ls].sumc-Tree[root1.ls].sumc+query(root1.rs,root2.rs,mid+1,r,tmpv-totl); &#125;&#125;T;int pos[MAXN];bool check(int k,ll budget,ll tmpv)&#123; int rt1=rt[pos[k]-1],rt2=rt[n]; ll cost=T.query(rt1,rt2,1,tp,tmpv); return cost&lt;=budget;&#125;void init()&#123; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) &#123; int x=a[i].d; if(!pos[x]) pos[x]=i; T.upd(rt[i],rt[i-1],1,tp,a[i].p,a[i].lim,1LL*a[i].lim*P[a[i].p]); &#125;&#125;void solve()&#123; for(int i=1;i&lt;=m;++i) &#123; ll budget=read(),tmpv=read(); int L=1,R=td,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid,budget,tmpv)) res=mid,L=mid+1; else R=mid-1; &#125; if(res==-1) puts("-1"); else printf("%lld\n",D[res]); &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; D[i]=a[i].d=read(); P[i]=a[i].p=read(); a[i].lim=read(); &#125; sort(D+1,D+1+n); td=unique(D+1,D+1+n)-D-1; for(int i=1;i&lt;=n;++i) a[i].d=lower_bound(D+1,D+1+td,a[i].d)-D; sort(P+1,P+1+n); tp=unique(P+1,P+1+n)-P-1; for(int i=1;i&lt;=n;++i) a[i].p=lower_bound(P+1,P+1+tp,a[i].p)-P; init(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我复习 noip 数据结构这件小事]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%85%B3%E4%BA%8E%E6%88%91%E5%A4%8D%E4%B9%A0-noip-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[平衡树与 $LCT$ 待更. $STL$关键是会用.比较常用的有 $set,mutiset,priority\ queue,map$ 这几个. 简单说一下 $bitset$ . 1bitset&lt;MAXN&gt; s; 这样就定义了一个 $bitset$ .默认所有位置都是 $0$ . 可以把它看成是一个长度为 $MAXN$ 的布尔数组,也可以看成是有 $MAXN$ 位的二进制数. 它支持直接调用/修改某一位上的值, 12s[0]=1;s[1]=1; 也可以用它直接进行位运算, 1s=s|(s&lt;&lt;10); 一次位运算耗时是长度/系统位数,一般是 $32$ 或者 $64$ . 这个东西就可以把一些只有 $0/1$ 运算的做法给优化 $32/64$ 倍. 原理也很好理解,就是把每 $32/64$ 位压成一个整数参与运算,所以也可以手写它,不过会比较麻烦. 贪心只能过样例 sol 并查集一定记得要初始化. 优化的方式主要有两种,路径压缩和按秩合并.按秩合并就是把小的合并进大的里面. 如果需要支持退回上一步操作,那么就只能选用按秩合并. 单独使用路径压缩或者按秩合并,查询一次的时间复杂度是 $O(\log n)$ ,同时使用是 $O(\alpha(n))$ . 但大多数情况我们都只写路径压缩,因为很难将它卡到 $\log$ 的级别去. 有些并查集会顺带维护这个块内的其他信息,合并的时候一起合并就可以了. 树状数组一维的树状数组比起线段树的优势就是代码容易编写与常数较小,而功能远不如线段树全面. 它的优点是可以比较简单的拓展到高维,而二维线段树就已经比较难写了. 如二维平面上的数点/求和,但坐标可能需要离散化. 上帝造题的七分钟 线段树经典数据结构,使用的方法也很多. 经典应用线段树的经典应用,维护区间内的信息,并支持单点/区间修改.如维护区间和,支持区间加,区间乘. 本质上只有这三个点是会根据不同的题而产生差别的. 如何将两个小区间内的信息合并起来得到大区间. 一个修改操作执行后,区间内的各个信息分别会怎样变化. 如何合并两个懒标记(如果有区间修改). 如果你发现这三点都能在很短的时间内做到,那么这个信息就可以用线段树来维护. 算术天才⑨与等差数列 sol 排序 sol 序列 sol 动态开点线段树就是新到一个点的时候,如果没有,你再新建一个节点作为这个节点. 回转寿司 sol 可持久化线段树 又称主席树,因为发明者的姓名拼音缩写为 hjt ,与中华人民共和国前国家主席的缩写一样… 可以存储 $m$ 个版本的线段树信息,要求每次修改都只是单点修改,每颗线段树的管辖范围都是 $[1,n]$ . 考虑线段树的一次单点修改操作,影响到的节点只有对应叶子节点到根节点路径上的所有节点. 这些节点数目是 $O(\log n)$ 的,所以在维护新版本的线段树时,只用新建出这些节点,其它节点沿用上个版本的. 并不用每次都把上个版本的所有节点拷贝出来,因为每个节点只需要知道儿子节点,直接将儿子节点指过去. 显然需要使用动态开点. 经典的使用方法是利用主席树对 $[1,1],[1,2],[1,3]\dots,[1,n]$ 这 $n$ 个前缀建出 $m$ 颗线段树. 这样在查询可减的信息时(如某数的个数),就可以直接用 $[1,R]$ 的线段树答案减去 $[1,L-1]$ 的线段树答案了. Kth number sol 混合果汁 sol 李超线段树解决的经典问题是每次可以在平面内添加一条 $y=kx+b​$ 的线段,或者询问当 $x=x_0​$ 时,各个线段中最大的 $y​$ . 如果是先添加完所有线段,再进行若干次询问,可以求出上凸壳, $O(n\log n)$ 解决. 李超线段树维护的是各段区间内 优势线段 的编号. 优势线段 是指,这段区间内能成为最优线段的长度最大的那条线段. 往区间 $(l,r)$ 插入一条线段 $c$ 时,就与当前区间 $(l,r)$ 内维护的优势线段 $s$ 比较. 若这两条线段在 $(l,r)$ 内满足一条完全覆盖了另一条,就直接更新优势线段并返回. 否则,就递归下去,用 $c$ 去更新两个子区间. 因为至少在 $[l,mid]$ 与 $[mid+1,r]$ 这两个区间中的一者, $c$ 完全覆盖了 $s$ ,或 $s$ 完全覆盖了 $c$ . 所以更新一个线段树上的区间的时间复杂度是 $O(\log n)$ ,插入一条线段的总时间复杂度是 $O(\log^2 n)$ . 查询时就在线段上向下走,经过一个区间时,就用这个区间的优势线段来更新答案,每次的时间复杂度是 $O(\log n)$ . 适者 sol 游戏 sol) 吉司机线段树区间取最值问题维护一个长度为 $n$ 的整数序列 $a$ ,支持以下 $m$ 次操作: 区间 $[L,R]$ 内的所有数 $a_i$ 与 $x$ 取 $\min$ . 区间 $[L,R]$ 内所有数加上 $x$ . 询问区间 $[L,R]$ 中 $a_i$ 的最大值. 询问区间 $[L,R]$ 中 $a_i​$ 的和. 对线段树每个区间维护最大值 $mx$ ,最大值的个数 $cnt$ ,次大值 $se$ ,区间和 $sum$ . 询问操作可以定位后直接做. 对于修改操作,若将一个线段树区间对 $x$ 取 $\min$ ,可以分情况讨论: $mx\le x$ ,无效果,直接返回. $se&lt;x&lt;mx$ .效果就是将所有 $mx$ 改为 $x$ ,其它不变.新的区间和 $sum’=sum-(mx-x)\cdot cnt​$ 可以直接算出,再打上修改标记,返回. $x\le se​$ .递归下去,分别修改左右儿子. 复杂度为 $O(n\log^2 n)$ ,但实现效果接近 $O(n\log n)$ .如果没有操作 $2$ ,复杂度就是 $O(n\log n)$ . 最假女选手 历史最值问题维护一个长度为 $n$ 的数列 $a$ ,支持以下 $m$ 次操作: 区间 $[L,R]$ 内所有数加上 $x$ . 区间 $[L,R]$ 内所有数变为 $x$ . 询问 $[L,R]$ 内数的最大值. 询问 $[L,R]$ 内数的历史最大值. 修改操作的 $x$ 可能 $&lt;0$ . 尝试将两种修改操作归纳为一种修改操作 $(a,b)$ ,表示先加上 $a$ ,再与 $b$ 取 $\max$ . 那么修改 $1$ 对应的操作就是 $(x,-\inf)$ ,修改 $2$ 对应的操作就是 $(-\inf,x)$ . 考虑两个标记如何合并,假设当前权值为 $v$ ,依次经过 $(a,b),(c,d)$ 两次修改的效果:$$\begin{aligned}v&amp;\to \max{\max{v+a,b}+c,d} \\&amp;=\max{v+a+c,b+c,d} \\&amp;=\max{v+a+c,\max{b+c,d}}\end{aligned}$$可以看出就等价于一次修改操作 $(a+c,\max{b+c,d})$ ,于是两个标记就合并为了一个. 为了能查询历史信息,维护一个意义一样的标记 $(a,b)$ ,表示区间内历史的最大增加量 $a$ ,历史最大与 $b$ 取 $\max$ . 将两个标记的 $+$ 定义为两个标记的合并,两个标记取 $\max$ 定义为两个元素分别取 $\max$ . 每次更新标记后,若当前标记为 $x$ ,历史标记为 $y$ ,则让 $y=\max(x,y)$ . 每个结点需要维护当前标记,历史标记,当前最大值,历史最大值 $4$ 个信息. CPU监控 线段树分治题目也是让你维护一些信息,每次可以询问,可以执行一种操作,也可以将之前的某个操作撤回. 操作容易维护,但撤回操作不容易维护. 需要将操作,询问都离线下来.将时间轴画出来,那么每个操作只在时间轴上的一个区间内生效. 用线段树给这个区间打上这个操作的标记,维护信息. 数学计算 sol 洞穴勘测 sol 线段树合并其实就是两颗权值线段树的合并,都使用动态开点. 如果合并到一个位置时,其中一者没有这个位置上的节点,就直接返回另一者. 否则将这个位置的信息合并后,还要递归合并它们的儿子. 树的难题 sol $kd-tree$处理二维/高维上点的信息.其实就是一棵二叉树. 注意它是二叉树,所以信息的存储与线段树不同. $kd-tree$ 每个结点存储的是整个子树的信息和自己的信息. 每个点有若干个维度,可以表示为 $(p_1,p_2,p_3,\dots,p_k)$ . 建树时,选择按照当前维度排序后的中点作为根,递归建左右子树,每次进入下一层是更换当前维度. 每个节点需要维护自己的坐标,以及每个维度的管辖范围. 查找平面上最近点是爆搜 + 剪枝,复杂度为玄学. 如果提出一个范围内所有点进行修改/询问,复杂度为 $O(n^{1-\frac 1 k})$ ,其中 $k$ 为维度. 这里的范围是指每一维的坐标都在某个特定的区间中,如二维平面中的矩形. 巧克力王国 弹跳 莫队经典莫队需要离线,且无修改操作. 问题是给出 $m$ 个询问,每次询问序列上一个区间 $[l,r]$ 内的信息. 特点是如果维护了 $[l,r]$ 内的所有信息与答案,则可以 $O(1)$ 得出 $[l,r+1],[l,r-1],[l-1,r],[l+1,r]$ 这些区间的信息与答案. 做法是将长度为 $n$ 的序列分块,每 $B$ 个数分为一块. 再将询问排序,排序时以 $l$ 所属块的编号为第一关键字,以 $r$ 为第二关键字. 然后维护当前区间 $[L,R]$ 中的信息,遍历每个询问,不断移动当前区间端点并更新信息,当前区间与询问区间重合时,就得到了答案. 考虑这样做的时间复杂度. 对于同一块内的询问, $L$ 移动 $O(B)$ 次, $R$ 只会往右侧移动,移动 $O(n)$ 次. 对于不同块内的询问, 在每次块改变时, $L$ 移动 $O(B)$ 次, $R$ 移动 $O(n)$ 次. 所以总移动次数为 $O(mB+\frac {n^2} B)$ 取 $B=\frac n {\sqrt m}$ 时最优. 再加上给询问排序,整个算法时间复杂度为 $O(n\sqrt m+m\log m)$ . mex sol permu sol 带修莫队就是支持修改的莫队. 做法是将每次询问的时间也考虑进去,形成一个三元组 $(l,r,t)$ 排序时加入 $t$ 作为第三关键字. 若移动端点的同时时间跨越了某个修改操作,那么就执行/撤回修改. 为了便于分析,视 $n,m$ 同阶,时间复杂度 $O(n^{\frac 5 3})$ . 树上莫队分块方式 定义这里的取反是指,若当前节点的信息在贡献中,则除去,否则加入. 若从$(pu,pv)$ 移动到 $(u,v)$ ,则只需对路径 $(pu,u),(pv,v)$ 的点是否包含情况取反, $LCA​$ 不处理. 保存答案前对 $(u,v)$ 的 $LCA$ 取反,答案保存后再将它取反回去. 若有修改操作,则还需记录每个询问的时间. 时间复杂度与序列上的莫队完全一致. 糖果公园 扫描线最经典的是求矩形面积并.将每个矩形按照 $x$ 坐标排序,从左往右扫过来,看成两个事件,加入和删除. 每次发生了加入事件就去更新答案. 需要注意边界的处理问题,加入和删除操作需要分出前后顺序,根据题目而定. 花火 sol $cdq$ 分治一段区间 $[l,r]$ 内的元素两两之间可能产生贡献,要计算出所有贡献. 取区间中点 $mid$ 将区间分为左右两段. 贡献可以分为左边对左边的贡献,右边对右边的贡献,左边对右边的贡献. 前两者可以递归下去处理,所以只需要考虑左边对右边的贡献. 注意每次处理左边对右边的贡献时,时间复杂度必须是与 $[L,R]$ 的长度相关,而不是与整个序列长度 $n$ 相关. 陌上花开 sol 稻草人 sol]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2956 模积和]]></title>
    <url>%2F2019%2F08%2F19%2Fbzoj-2956-%E6%A8%A1%E7%A7%AF%E5%92%8C%2F</url>
    <content type="text"><![CDATA[整除分块. 可以把 $i=j$ 的贡献算上,后面再减掉. 假设 $n\le m$ . $$\begin{aligned}ans&amp;=\sum_{i=1}^n \sum_{j=1}^m (n\bmod i)(m\bmod j)-\sum_{i=1}^n (n\bmod i)(m\bmod i) \\&amp;=\sum_{i=1}^n \sum_{j=1}^m (n-\lfloor\frac n i \rfloor\cdot i)(m-\lfloor\frac m j \rfloor\cdot j)-\sum_{i=1}^n (n-\lfloor\frac n i \rfloor\cdot i)(m-\lfloor\frac m i \rfloor\cdot i) \\&amp;=\sum_{i=1}^n (n-\lfloor\frac n i \rfloor\cdot i)\sum_{i=1}^m (m-\lfloor\frac m i \rfloor\cdot i) -\sum_{i=1}^n nm+i^2\cdot \lfloor\frac n i \rfloor\lfloor\frac m i \rfloor-n\cdot \lfloor\frac m i \rfloor\cdot i-m\cdot \lfloor\frac n i \rfloor \cdot i\end{aligned}$$整除分块计算即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=19940417;const int inv2=(P+1)&gt;&gt;1,inv6=3323403;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int S1(int l,int r)&#123; return mul(mul(l+r,r-l+1),inv2);&#125;int s2(int x)&#123; return mul(mul(x,mul(x+1,2*x+1)),inv6);&#125;int S2(int l,int r)&#123; return add(s2(r),P-s2(l-1));&#125;int calc(int n)&#123; int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); upd(ans,mul(n,r-l+1)); upd(ans,P-mul(S1(l,r),n/l)); &#125; return ans;&#125;int main()&#123; int n=read(),m=read(); if(n&gt;m) swap(n,m); int ans=0; upd(ans,mul(calc(n),calc(m))); for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); upd(ans,P-mul(mul(n,m),r-l+1)); upd(ans,P-mul(mul(n/l,m/l),S2(l,r))); upd(ans,mul(mul(n,m/l),S1(l,r))); upd(ans,mul(mul(m,n/l),S1(l,r))); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3105 新Nim游戏]]></title>
    <url>%2F2019%2F08%2F19%2Fbzoj-3105-%E6%96%B0Nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[贪心求解最大权值线性无关组. $A$ 先拿走一堆石子, $B$ 再拿走一堆石子,然后做 $Nim$ 游戏. 如果 $A$ 拿了之后给 $B$ 留下的石子中存在一个子集,它们的异或和为 $0$ , $B$ 就可以把其它的石子拿走, $A$ 就败了. 所以 $A$ 要拿走最少的石子,使剩下的石子在异或意义下线性无关. 那么就是要求解最大权值线性无关组,用拟阵的那一套理论,贪心处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=100+10;int n,a[MAXN],c[32];ll ans=0;void ins(int x,int val)&#123; for(int i=31;i&gt;=0;--i) if((x&gt;&gt;i)&amp;1) &#123; if(!c[i]) &#123; c[i]=x; break; &#125; else x^=c[i]; &#125; if(!x) ans+=val;&#125;int main()&#123; n=read(); if(!n) return puts("-1")&amp;0; for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); reverse(a+1,a+1+n); for(int i=1;i&lt;=n;++i) ins(a[i],a[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190818]]></title>
    <url>%2F2019%2F08%2F19%2Ftest20190818%2F</url>
    <content type="text"><![CDATA[沙茶出题人数据造出锅了,还要大家来帮他修. 甚至连个题解都没有. $A$考虑换根,若当前根节点从 $u$ 换到 $v$ ,显然只有 $u$ 和 $v$ 的贡献会改变. 预处理一大堆东西,从 $u$ 换到 $v$ 时更新贡献,回溯时撤回. 时间复杂度 $O(n)$ . $B$将每次变换看做一个矩阵,转化为矩阵的 $BSGS$ . 由于矩阵可能没有逆,所以最后再判一下解是否合法. 时间复杂度 $O(T\cdot \sqrt P\cdot \log \sqrt P )$ . $C$将每个数看做 $0/1$ 串,正着建一棵字典树,反着建一棵字典树. 那么每个前缀武器就能在前缀的字典树树上割下一颗子树,每个后缀武器能的后缀的字典树上割下一颗子树. 每个给出的点在两棵树上至少被割掉一次,可以将两颗树拼在一起,建立一个最小割模型.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Trie</tag>
        <tag>网络流</tag>
        <tag>test</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拟阵学习笔记]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%8B%9F%E9%98%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[可用于解决一些最大权重独立子集的问题. 拟阵的定义一个有限 拟阵 是满足以下条件的二元组 $M=(S,I)$ : $S$ 是有限集. $I$ 是由 $S$ 的一些子集组成的有限非空集合(非空族) ,这些子集称为 $S$ 的 独立子集 . $I​$ 有 遗传性 ,即,若 $B\in I,A\subset B​$ ,则 $A\in I​$ .又因为 $I​$ 非空,所以一定有 $\emptyset \in I​$ . $M$ 有 交换性 ,即,若 $A,B\in I,|B|&gt;|A|$ ,则 $\exists x\in B-A$ ,使得 $A\cup \lbrace x \rbrace \in I$ . 举个例子, $M=(S,I)​$ 是一个拟阵,其中 $S=\lbrace 1,2,3 \rbrace ,I=\lbrace A\subset S:|A|\le 2 \rbrace​$ . 容易验证 $M$ 满足以上的 $4$ 个条件. 拓展有拟阵 $M=(S,I)$ ,若 $A\in I,x\not \in A,A\cup { x } \in I$ ,则称 $x$ 是独立子集 $A$ 的一个 拓展 . 最大独立子集若一个独立子集 $A$ 不存在拓展,则称它为 最大独立子集 . 由这个定义与拟阵的交换性质可以得出一条重要性质:拟阵中所有 最大独立子集 都具有相同的大小. 线性无关与拟阵设 $S$ 是一个行向量组, $I$ 是由所有 $S$ 的线性无关子集组成的集合,有定理: 二元组 $M=(S,I)$ 是一个拟阵. 证明该定理只需要证明 $M=(S,I)$ 满足拟阵的 $4$ 个条件.前 $2$ 个条件显然满足,只需证遗传性和交换性. 遗传性的证明一个线性无关组的子集,显然也线性无关.即,若 $A\in I,B\subset I$ ,则 $B\in I$ ,满足遗传性. 交换性的证明令 $X,Y\in I,|X|&gt;|Y|$ . 考虑反证法,假设 $\forall x\in X-Y​$ ,都有 $Y\cup {x} \not \in I​$ 成立. 则说明将任意一个在 $X$ 集合中,而不在 $Y$ 集合中的向量 $x$ 添加到 $Y$ 集合中,都会使得 $Y$ 变为线性相关. 说明任意一个这样的 $x$ 都可以被 $Y$ 中向量线性组合表示. 而 $X$ 中其它向量也被 $Y$ 包含,也可以被 $Y$ 中向量线性组合表示. 于是 $X$ 中的所有向量都可以被 $Y$ 中向量线性组合表示.但 $X$ 线性无关,不可能被更小的集合完全表示,矛盾. 交换性得证. 加权拟阵若一个拟阵 $M=(S,I)$ 关联了一个权重函数 $w$ ,它为 $S$ 中的每一个元素 $x$ 赋予了一个 严格大于0 的权重 $w(x)$. 则称拟阵 $M$ 是加权的,即 加权拟阵 . $S$ 的子集 $A$ 的权值就是$$w(A)=\sum_{x\in A}w(x)$$ 最大权重独立子集定义在加权拟阵 $M=(S,I)$ 中,权值最大的 独立子集 . 即所有 $A\in I$ 中, $w(A)$ 最大的 $A$ . 贪心求解 将 $S$ 中所有元素按照 $w(x)$ 降序排列. 初始有一个集合 $A=\emptyset​$ ,按照第 $1​$ 步排好的顺序依次遍历 $S​$ 中的每个元素 $x​$ ,若 $A\cup {x}\in I​$ ,则令 $A=A\cup {x}​$ . 遍历结束后,此时的 $A$ 就是要求的最大权重独立子集的一个解. 贪心正确性证明若 $I= { \emptyset }$ ,正确性显然,考虑 $I\not= { \emptyset }$ 的情况. 只需要考虑加权拟阵 $M=(S,I)$ 的 $3$ 条优美性质. 贪心选择性若 $S$ 中的元素已按 $w(x)$ 降序排列,令 $x$ 为 $S$ 中第一个 ${x}\in I$ 的元素. 那么存在一个最大权重独立子集 $A$ ,使得 $x\in A$ . 元素只考虑一次如果一个元素 $x$ 被遍历到时, $A\cup {x}\not \in I$ ,那么之后 $A$ 增大时,也总是有 $A\cup {x}\not \in I$ . 反证,由拟阵的遗传性即可得出矛盾. 最优子结构性质若 $x$ 是求解过程中第一个被选出的元素,那么选出剩下的元素就归结为一个子问题. 即求解加权拟阵 $M’=(S’,I’)$ 的最大权重独立子集,其中,$$S’={y\in S:{x,y}\in I}\I’={B\subset S-{x}:B\cup {x}\in I}$$ 应用根据线性无关与拟阵的关系,一个常见的应用是求解向量组的 最大权值线性无关组 . 直接套用贪心求解的过程即可. 对于其它的问题,如果能构造出对应的拟阵,也可以套用上述贪心求解的过程.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4237 稻草人]]></title>
    <url>%2F2019%2F08%2F17%2Fbzoj-4237-%E7%A8%BB%E8%8D%89%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[$cdq$ 分治 + 单调栈. 将所有点先按照 $y$ 排序,然后 $cdq$ 分治,每次只考虑上面的一部分点作为右上角,下面的一部分点作为左下角的贡献. 将上下两部分的点分别按照 $x$ 排序,从左往右枚举上面的点. 发现上面的一个点在只会受到 $y$ 比自己小的点中, $x$ 最大的点的制约,维护一个 $y$ 递增的单调栈来找出这个点. 然后在下面的点中统计有哪些点是合法的,对下面的点维护一个 $y$ 不增的单调栈. 每次在上面加入点后,就将下面 $x$ 小于等于它的点加入下面的栈. 在下面的单调栈中使用二分,找出合法点的区间,时间复杂度 $O(n\log^2 n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct node&#123; int x,y;&#125;a[MAXN],up[MAXN],down[MAXN];bool cmpy(node a,node b)&#123; return a.y==b.y?a.x&lt;b.x:a.y&gt;b.y; &#125;bool cmpx(node a,node b)&#123; return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;int n,stk1[MAXN],stk2[MAXN],tp1,tp2;ll ans=0;void cdq(int l,int r)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; cdq(l,mid); tp1=tp2=0; int ls=mid-l+1,rs=r-mid; for(int i=l;i&lt;=mid;++i) up[i-l+1]=a[i]; for(int i=mid+1;i&lt;=r;++i) down[i-mid]=a[i]; sort(up+1,up+1+ls,cmpx); sort(down+1,down+1+rs,cmpx); int p=1; for(int i=1;i&lt;=ls;++i) &#123; while(tp1&gt;0 &amp;&amp; up[stk1[tp1]].y&gt;=up[i].y) --tp1; stk1[++tp1]=i; while(p&lt;=rs &amp;&amp; down[p].x&lt;=up[i].x) &#123; while(tp2&gt;0 &amp;&amp; down[stk2[tp2]].y&lt;down[p].y) --tp2; stk2[++tp2]=p; ++p; &#125; if(!tp2) continue; if(tp1==1) &#123; ans+=tp2; continue; &#125; int L=1,R=tp2,lim=up[stk1[tp1-1]].x,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(down[stk2[mid]].x&gt;=lim) res=mid,R=mid-1; else L=mid+1; &#125; if(res!=-1) ans+=tp2-res+1; &#125; cdq(mid+1,r);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].x=read(); a[i].y=read(); &#125; sort(a+1,a+1+n,cmpy); cdq(1,n); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>cdq分治</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190816]]></title>
    <url>%2F2019%2F08%2F16%2Ftest20190816%2F</url>
    <content type="text"><![CDATA[点分治爆栈祭. $phantasm$将每次选择的位置看成一个数列,第一个位置必定是 $1$ ,所以只需要求出它的差分序列方案数. 差分序列中共 $m-1$ 个元素,每个元素必须 $\le k$ ,总和为 $n-1$ . 调整一下后用隔板法处理,答案是组合数,在模 $2$ 意义下,根据 $Lucas$ 定理,只需判断二进制位即可. $skylines$直接大力点分治预处理所有点的答案. 枚举子树时正反顺序都做一次,再考虑上分治中心. 时间复杂度 $O(n\log n+T)$ . $kiseki$题面写得太垃圾了. 每次从已有的数中选一个,得到它的权值,并获得它的后继,存档可以重复获得. 考虑 $dp$ ,状态只与当前有的存档集合有关,与顺序无关. 而从小到大排序后,相邻两项的差分值只可能是 $0/1$ ,所以可以用一个二进制数 $S$ 来记录. 设 $f(i,S)$ 表示有 $i$ 个存档,差分值的状态是 $S$ 的方案数,转移时枚举增加的存档. 总方案数是 $m!$ ,预处理差分状态 $S$ 对应的序列权值是 $val(S)$ ,答案就为 $$\sum_{S} \frac {f(m,S)} {m!} \cdot val(S)$$ 时间复杂度 $O(m\cdot 2^m)$ .]]></content>
      <tags>
        <tag>数学</tag>
        <tag>概率/期望</tag>
        <tag>状压dp</tag>
        <tag>test</tag>
        <tag>Lucas定理</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4236 JOIOJI]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-4236-JOIOJI%2F</url>
    <content type="text"><![CDATA[$map$ . 用 $sum(i,0/1/2)$ 分别表示三种字母出现次数的前缀和. 一段区间 $[L+1,R]$ 合法的充要条件是 $sum(r,0)-sum(l,0)=sum(r,1)-sum(l,1),sum(r,1)-sum(l,1)=sum(r,2)-sum(l,2)$ . 将两种差看成两个权值,加入每个元素后询问两个权值都与它相等的元素出现的第一个位置,可以用 $map$ 维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;typedef pair&lt;int,int&gt; pii;map&lt;pii,int&gt; mp;int n,sum[MAXN][3];char buf[MAXN];int trans(char c)&#123; if(c=='J') return 2; return c&lt;'J';&#125;int main()&#123; n=read(); scanf("%s",buf+1); int ans=0; mp[make_pair(0,0)]=0; for(int i=1;i&lt;=n;++i) &#123; int x=trans(buf[i]); for(int j=0;j&lt;3;++j) sum[i][j]=sum[i-1][j]; ++sum[i][x]; int u=sum[i][0]-sum[i][1],v=sum[i][1]-sum[i][2]; pii tmp=make_pair(u,v); if(mp.find(tmp)!=mp.end()) ans=max(ans,i-mp[tmp]); else mp[tmp]=i; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1143 祭祀]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-1143-%E7%A5%AD%E7%A5%80%2F</url>
    <content type="text"><![CDATA[$floyd$ 传递闭包 + 二分图的相关理论. 先用 $floyd$ 做传递闭包,预处理每两点间的连通性. 每个点拆成入点和出点,再枚举点 $a,b$ ,若 $a$ 能到 $b$ ,就从 $a$ 的入点向 $b$ 的出点连边. 然后就是要求新建出来的二分图的最大独立集,就等于原来的点数减去它的最大匹配数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;int n,m;bool f[MAXN][MAXN];void floyd()&#123; for(int k=1;k&lt;=n;++k) for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) f[i][j]|=(f[i][k]&amp;f[k][j]);&#125;int par[MAXN],vis[MAXN];int dfs(int u)&#123; for(int v=1;v&lt;=n;++v) &#123; if(v!=u &amp;&amp; !vis[v] &amp;&amp; f[u][v]) &#123; vis[v]=1; if(!par[v] || dfs(par[v])) &#123; par[v]=u; return 1; &#125; &#125; &#125; return 0;&#125;int Hungarian()&#123; int ans=0; for(int i=1;i&lt;=n;++i) &#123; memset(vis,0,sizeof vis); ans+=dfs(i); &#125; return ans;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) f[i][i]=true; for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); f[u][v]=true; &#125; floyd(); int ans=Hungarian(); printf("%d\n",n-ans); return 0;&#125;]]></content>
      <tags>
        <tag>floyd</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4358 permu]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-4358-permu%2F</url>
    <content type="text"><![CDATA[莫队. 使用莫队,考虑加入一个数 $x$ 造成的影响,发现需要用到 $x-1,x+1$ 的信息. 需要对每个数维护当前它所在的最大连续区间长度,但修改时可能会修改很多数的答案. 简单粗暴的办法是用线段树维护最大子段和,但多一个 $\log$ ,而且常数比较大,跑不过去. 用 $pre_i,nxt_i$ 分别表示 $i$ 在值域上往左/右走最多有几个数, $pre_i+nxt_i-1$ 可以更新答案. 插入数 $i$ 的时候,用 $i-1$ 的 $pre$ 更新 $i$ 的 $pre$ ,用 $i+1$ 的 $nxt$ 更新 $i$ 的 $nxt$ . 然后再更新 $i$ 所在最长连续区间左端点的 $nxt$ 和右端点的 $pre$ . 中间不用管,因为不可能再在中间插入数,也就不可能再用到它们的 $pre,nxt$ 了. 发现删除操作不好维护,我们可以保证右端点不删除,只可能撤销左端点的插入操作,就可以维护了. 对于 $l$ 在同一块内的询问,若 $r​$ 也在这一块内,可以暴力做. 对于 $r$ 在这一块外的,将它们按照 $r$ 从小到大排序. 先将 $L$ 设置为当前块的末尾,右移 $R$ 到询问的 $r$ ,再将 $L$ 左移到询问的 $l$ ,更新答案,再将 $L$ 移回当前块的末尾. 因为插入一个数最多只会影响 $3$ 个数的信息,所以把它们记录下来,移回时撤销,时间复杂度 $O(n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,res,Ans[MAXN];int BlockSize,tot=0,bel[MAXN],a[MAXN];int lpos[MAXN],rpos[MAXN];struct Query&#123; int l,r,id,block; bool operator &lt; (const Query &amp;rhs) const &#123; return block==rhs.block?r&lt;rhs.r:block&lt;rhs.block; &#125;&#125;q[MAXN];int bf_pre[MAXN],bf_nxt[MAXN];int bf_stk[MAXN],bf_tp;int bf(int i)&#123; bf_tp=0; int ans=0; for(int j=q[i].l;j&lt;=q[i].r;++j) &#123; int x=a[j]; bf_stk[++bf_tp]=x; bf_pre[x]=bf_pre[x-1]+1; bf_nxt[x]=bf_nxt[x+1]+1; int len=bf_pre[x]+bf_nxt[x]-1; ans=max(ans,len); bf_nxt[x-bf_pre[x]+1]=len; bf_pre[x+bf_nxt[x]-1]=len; &#125; Ans[q[i].id]=ans; for(int j=1;j&lt;=bf_tp;++j) bf_pre[bf_stk[j]]=bf_nxt[bf_stk[j]]=0;&#125;int nxt[MAXN],pre[MAXN],tp;struct opt&#123; int x; int p1,n1; // pre[x]:p1-&gt;p2 nxt[x]:n1-&gt;n2 void undo() &#123; pre[x]=p1; nxt[x]=n1; &#125;&#125;;opt stk[MAXN];void solve()&#123; int lstblock=-1,L,R; for(int i=1;i&lt;=m;++i) &#123; if(q[i].block!=lstblock) &#123; L=rpos[q[i].block]; R=L-1; res=0; memset(pre,0,sizeof pre); memset(nxt,0,sizeof nxt); tp=0; lstblock=q[i].block; &#125; if(bel[q[i].l]==bel[q[i].r]) &#123; bf(i); continue; &#125; while(R&lt;q[i].r) &#123; int x=a[++R]; pre[x]=pre[x-1]+1; nxt[x]=nxt[x+1]+1; int len=pre[x]+nxt[x]-1; res=max(res,len); nxt[x-pre[x]+1]=len; pre[x+nxt[x]-1]=len; &#125; int tmp=res; while(L&gt;q[i].l) &#123; int x=a[--L]; pre[x]=pre[x-1]+1; nxt[x]=nxt[x+1]+1; stk[++tp]=(opt)&#123;x,0,0&#125;; int len=pre[x]+nxt[x]-1; stk[++tp]=(opt)&#123;x-pre[x]+1,pre[x-pre[x]+1],nxt[x-pre[x]+1]&#125;; stk[++tp]=(opt)&#123;x+nxt[x]-1,pre[x+nxt[x]-1],nxt[x+nxt[x]-1]&#125;; nxt[x-pre[x]+1]=len; pre[x+nxt[x]-1]=len; res=max(res,len); &#125; Ans[q[i].id]=res; while(tp) &#123; stk[tp].undo(); --tp; &#125; L=rpos[q[i].block]; res=tmp; &#125;&#125;void init_Block()&#123; BlockSize=sqrt(n); for(int i=1;i&lt;=n;++i) bel[i]=(i-1)/BlockSize+1; tot=bel[n]; for(int i=1;i&lt;=n;++i) rpos[bel[i]]=i; for(int i=n;i&gt;=1;--i) lpos[bel[i]]=i;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); init_Block(); for(int i=1;i&lt;=m;++i) &#123; q[i].l=read(); q[i].r=read(); q[i].block=bel[q[i].l]; q[i].id=i; &#125; sort(q+1,q+1+m); solve(); for(int i=1;i&lt;=m;++i) printf("%d\n",Ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>离线</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190815]]></title>
    <url>%2F2019%2F08%2F15%2Ftest20190815%2F</url>
    <content type="text"><![CDATA[发现自己的码力还是太弱,可能需要多做毒瘤题(?) $cubicp$$P=a^3-b^3=(a-b)(a^2+ab+b^2)$ ,因为 $P$ 是质数,所以 $a-b=1$ . 于是 $P=3b^2+3b+1$ ,先预处理所有合法的答案,然后快速回答即可. $dp$考虑朴素的 $dp$ ,设 $f(i,j)$ 表示将前 $i$ 个数分成 $j$ 段的最小花费. 先枚举 $j$ ,可以发现 $i$ 的转移决策是具有单调性的,于是可以优化. 不能用二分决策栈的方法,因为转移额外代价 $cost(k,i)$ 不方便快速在线算. 对求解区间和决策区间分治,这样可以像莫队那样暴力移动端点来算 $cost$ ,时间复杂度 $O(n\log n)$ . $number$可以先二分答案 $mid$ ,于是要考虑 $1\sim mid$ 的全部区间.将它们按照 $x$ 从大到小排序,依次加入. 如果同一种 $x$ 的区间的交集被之前加入的所有区间的并集完全覆盖,显然就不合法,否则一定可以构造出合法的方案. 可以直接用线段树来维护区间覆盖,但会多一个 $\log$ . 优秀的做法是用并查集维护当前每个节点在并集中向右能跳到的最远点,就可以判断合法性了.]]></content>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
        <tag>test</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4345 Korale]]></title>
    <url>%2F2019%2F08%2F15%2Fbzoj-4345-Korale%2F</url>
    <content type="text"><![CDATA[$dfs$ + 堆,求第 $k$ 优解. 首先去求第 $k$ 小的子集权值 $val$ ,先将元素权值从小到大排序. 每个子集可以用一个二元组 $(i,j)$ 表示权值为 $i$ ,最大的元素编号为 $j$ . 将它加入优先队列,一个二元组 $(i,j)$ 可以得到 $(i-a_j+a_{j+1},j+1)$ 与 $(i+a_{j+1},j+1)$ . 前者表示不选 $j$ 了,后者表示保留 $j$ .第 $k$ 次取出二元组时对应的权值就是第 $k$ 小的子集权值. 然后要求第 $k$ 小的具体方案,直接 $dfs$ 爆搜,但要保证权值不超过 $val$ . 每次找后面第一个数,使得加入后权值仍不超过 $val$ ,用线段树来找这个数,第 $k$ 次时集合中的数就是答案. 注意除掉空集的贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,k,a[MAXN],b[MAXN],cnt=0;ll ans[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairpriority_queue&lt;pli&gt; q;void Find_kth()&#123; sort(b+1,b+1+n); q.push(mp(-b[1],1)); for(int t=1;t&lt;=k;++t) &#123; pli tmp=q.top(); ll i=-tmp.first; int j=tmp.second; q.pop(); ans[t]=i; if(t&lt;k &amp;&amp; j&lt;n) &#123; q.push(mp(-i+b[j]-b[j+1],j+1)); q.push(mp(-i-b[j+1],j+1)); &#125; &#125; for(int i=k;i &amp;&amp; ans[i]==ans[k];--i) ++cnt; printf("%lld\n",ans[k]);&#125;struct SegTree&#123; int Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root=min(lson,rson); &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) return (void)(root=a[l]); int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int p,ll v)//位置p之后第一个小于等于v的 &#123; if(p&lt;=l) &#123; if(root&gt;v) return 0; if(l==r) return l; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) &#123; int res=query(o&lt;&lt;1,l,mid,p,v); if(res) return res; &#125; return query(o&lt;&lt;1|1,mid+1,r,p,v); &#125;&#125;T;int stk[MAXN],tp=0;void dfs(int p,ll tmp)&#123; if(!cnt) return; if(!tmp) &#123; --cnt; if(!cnt) for(int i=1;i&lt;=tp;++i) printf("%d" ,stk[i]); return; &#125; for(int i=p+1;i&lt;=n;++i) &#123; i=T.query(1,1,n,i,tmp); if(i) &#123; stk[++tp]=i; dfs(i,tmp-a[i]); --tp; &#125; else break; &#125;&#125;void Construct_kth()&#123; T.BuildTree(1,1,n); dfs(0,ans[k]);&#125;int main()&#123; n=read(),k=read()-1; if(!k) return puts("0")&amp;0; for(int i=1;i&lt;=n;++i) a[i]=b[i]=read(); Find_kth(); Construct_kth(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 515 贪心只能过样例]]></title>
    <url>%2F2019%2F08%2F14%2FLoj-515-%E8%B4%AA%E5%BF%83%E5%8F%AA%E8%83%BD%E8%BF%87%E6%A0%B7%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[$bitset$ 优化 $dp$ . 考虑最朴素的 $dp$ , $f(i,j)$ 表示考虑前 $i$ 个数,能否使得 $S=j$ . 转移时枚举当前这一位选哪一个数,这样直接做的时间复杂度是 $O(n^5)$ . 因为只有 $0/1$ 运算,第二维的最大值为 $10^6$ ,用 $bitset$ 优化,复杂度变成 $O(\frac {n^5} {64})$ ,就可以过了. 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=101;int n;bitset&lt;MAXN*MAXN*MAXN&gt; f,lst;int main()&#123; n=read(); lst[0]=1; for(int i=1;i&lt;=n;++i) &#123; int L=read(),R=read(); f.reset(); for(int x=L;x&lt;=R;++x) f|=lst&lt;&lt;(x*x); lst=f; &#125; cout&lt;&lt;f.count()&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 514 模拟只会猜题意]]></title>
    <url>%2F2019%2F08%2F14%2FLoj-514-%E6%A8%A1%E6%8B%9F%E5%8F%AA%E4%BC%9A%E7%8C%9C%E9%A2%98%E6%84%8F%2F</url>
    <content type="text"><![CDATA[原以为此题必有高论,结果直接 $O(n^2)$ 暴力预处理答案就可以了. 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e4+10;int n,m,ans[MAXN],a[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read()+a[i-1]; ans[i]=-inf; &#125; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) ans[j-i+1]=max(ans[j-i+1],a[j]-a[i-1]); for(int i=n-1;i&gt;=1;--i) ans[i]=max(ans[i+1],ans[i]); for(int i=1;i&lt;=m;++i) printf("%d\n",ans[read()]); return 0;&#125;]]></content>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190814]]></title>
    <url>%2F2019%2F08%2F14%2Ftest20190814%2F</url>
    <content type="text"><![CDATA[$T2$ 被常数卡到暴力分了. $tree$原题.直接树形 $dp$ . $dance$从前往后枚举右端点,依次加入每个点,用单调栈维护后缀最大/最小值,线段树维护答案. $seq$打表或者分析,把递推式子搞出来, $f_i=f_{i-1}+(i-1)\cdot (i-2)$ . 然后用特征方程那一套理论把通项找出来, $f_n=2^{n+1}-n^2-n-2$ ,就可以直接算了.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>树形dp</tag>
        <tag>test</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2049 洞穴勘测]]></title>
    <url>%2F2019%2F08%2F14%2Fbzoj-2049-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[线段树分治 + 并查集. 这本来是个 $LCT$ 的模板题,但离线下来也可以用线段树分治 + 并查集来做. 每条边可以看做在一个时间区间内生效,每个线段树节点维护一个 $vector$ ,存储在该区间内都有效的边. 一条边只会被加入 $O(\log m)$ 个线段树节点,空间复杂度为 $O(m\log m)$ . 最后 $dfs$ 整个线段树,进入一个节点时,就让它的 $vector$ 中的边都生效,退出时撤销这些边. 因为有撤销,所以不能路径压缩,可以用按秩合并的并查集来维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXM=2e5+10;map&lt;pii,int&gt; Eid;struct Edge&#123; int u,v; int l,r; Edge()&#123;r=-1;&#125;&#125; E[MAXM];struct query&#123; int u,v,id;&#125;;int n,m,ans[MAXM],qcnt=0,ecnt=0;vector&lt;query&gt; qry[MAXM];vector&lt;pii&gt; opt[MAXM&lt;&lt;2];int fa[MAXM],siz[MAXM];void init()&#123; for(int i=1; i&lt;=n; ++i) fa[i]=i,siz[i]=1;&#125;int Find(int x)&#123; if(x==fa[x]) return x; return Find(fa[x]);&#125;void Union(int &amp;x,int &amp;y)&#123; if(siz[x]&lt;siz[y]) swap(x,y); siz[x]+=siz[y]; fa[y]=x;&#125;struct SegTree&#123; vector&lt;int&gt; s[MAXM&lt;&lt;2];#define root s[o] void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.push_back(c); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); &#125; void add(int o) &#123; int tot=root.size(); for(int i=0;i&lt;tot;++i) &#123; int x=root[i]; int u=Find(E[x].u),v=Find(E[x].v); if(u==v) continue; Union(u,v); opt[o].push_back(mp(u,v)); &#125; &#125; void del(int o) &#123; int tot=opt[o].size(); for(int i=0;i&lt;tot;++i) &#123; pii t=opt[o][i]; int u=t.first,v=t.second; fa[v]=v; siz[u]-=siz[v]; &#125; &#125; void solve(int o,int p) &#123; int tot=qry[p].size(); for(int i=0;i&lt;tot;++i) &#123; query q=qry[p][i]; int u=Find(q.u),v=Find(q.v); if(u==v) ans[q.id]=1; else ans[q.id]=0; &#125; &#125; void dfs(int o,int l,int r) &#123; add(o); if(l==r) &#123; solve(o,l); del(o); return; &#125; int mid=(l+r)&gt;&gt;1; dfs(o&lt;&lt;1,l,mid); dfs(o&lt;&lt;1|1,mid+1,r); del(o); &#125;&#125; T;int main()&#123; n=read(),m=read(); init(); for(int i=1; i&lt;=m; ++i) &#123; char op[10]; scanf("%s",op); int u=read(),v=read(); if(op[0]=='C') &#123; Eid[mp(u,v)]=Eid[mp(v,u)]=++ecnt; E[ecnt].u=u,E[ecnt].v=v; E[ecnt].l=i; &#125; else if(op[0]=='D') E[Eid[mp(u,v)]].r=i; else qry[i].push_back((query)&#123;u,v,++qcnt&#125;); &#125; for(int i=1; i&lt;=ecnt; ++i) &#123; if(E[i].r==-1) E[i].r=m; T.upd(1,1,m,E[i].l,E[i].r,i); &#125; T.dfs(1,1,m); for(int i=1; i&lt;=qcnt; ++i) puts(ans[i]?"Yes":"No"); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190813]]></title>
    <url>%2F2019%2F08%2F13%2Ftest20190813%2F</url>
    <content type="text"><![CDATA[考了一套简单题. $prime$贪心. 有一个比较明显的贪心策略,即先做若干次除法,再只做加法或只做减法. 做完除法后算答案直接暴力枚举加/减了几步就可以了. 因为 $10^9$ 内的两个相邻质数相差不会超过 $220$ ,所以答案也不会超过 $220$ . 据说质数密度是 $O(\log n)$ 级别的. $path$树状数组. 可以发现这个图就是由若干个不相交的链或者环组成的. 因为只有合并操作,所以可以用并查集来维护每条链和每个环,以及它们的大小. 查询 $(l,r)$ 时,可以用长度不超过 $r$ 的答案减去长度不超过 $l-1$ 的答案,只需要考虑如何计算长度不超过 $k$ 的路径数. 考虑一条大小为 $s$ 的链的贡献.若 $s\le k$ ,贡献为 $\frac {s(s+1)} 2$ ,否则,贡献为 $k\cdot s-\frac {k(k-1)} 2$ . 考虑一个大小为 $s$ 的环的贡献.若 $s\le k$ ,贡献为 $s^2$ ,否则, 贡献为 $s\cdot k$ . 用 $5$ 个树状数组分别维护贡献 (还有一个是链的条数) ,每个链/环的贡献加入它的大小的对应位置. 有个地方没开 $\mbox{long long}$ ,爆成 $95$ 了. 时间复杂度 $O(n\log n)$ . $book$期望 $dp$ . 设 $f(i,j)$ 表示第 $i$ 个人拿到的从新到旧的第 $j$ 本书的期望排名. 转移时枚举每个人拿了哪本书,时间复杂度 $O(n^3)$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3569 DZY Loves Chinese II]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-3569-DZY-Loves-Chinese-II%2F</url>
    <content type="text"><![CDATA[神仙题. 先做出原图的一棵 $dfs$ 树.对于每条非树边,随机分配一个权值 $x$ ,将它在树上覆盖到的树边的权值全部异或上 $x$ . 每次询问给定了一个边的集合 $S$ ,若存在 $S$ 的一个非空子集,该子集内所有的边权异或和为 $0$ ,则不连通,否则连通. 边权覆盖可以用树上差分,查询可以利用线性基,看给出的边权在 $\mbox{xor}$ 意义下是否线性无关. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=1e5+10,MAXM=1e6+10;int ecnt=0,head[MAXN],nx[MAXM],to[MAXM],id[MAXM];int st[MAXM],ed[MAXM],ontree[MAXM];void addedge(int u,int v,int k)&#123; ++ecnt; id[ecnt]=k; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,tot=0;int dfn[MAXN],idx=0;ull dif[MAXN],val[MAXM];void dfs(int u)&#123; dfn[u]=++idx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dfn[v]) continue; ontree[id[i]]=1; dfs(v); &#125;&#125;void calc(int u,int t)&#123; dfn[u]+=n; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dfn[v]&gt;n) continue; calc(v,i); dif[u]^=dif[v]; &#125; val[id[t]]=dif[u];&#125;void init()&#123; for(int i=1;i&lt;=m;++i) if(!ontree[i]) &#123; ull x=rand()*rand()*rand()*rand(); val[i]=x; int u=st[i],v=ed[i]; dif[u]^=x,dif[v]^=x; &#125; calc(1,0);&#125;struct Base&#123; ull a[64]; int siz; void init() &#123; siz=0; memset(a,0,sizeof a); &#125; void ins(ull x) &#123; for(int i=63;i&gt;=0;--i) if(x&amp;(1ULL&lt;&lt;i)) &#123; if(a[i]) x^=a[i]; else &#123; a[i]=x; ++siz; break; &#125; &#125; &#125;&#125;LB;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); addedge(u,v,i); addedge(v,u,i); st[i]=u,ed[i]=v; &#125; dfs(1); int Q=read(); if(idx!=n) &#123; while(Q--) puts("Disconnected"); return 0; &#125; srand(time(NULL)); init(); while(Q--) &#123; int k=read(); LB.init(); for(int i=1;i&lt;=k;++i) &#123; int c=read()^tot; LB.ins(val[c]); &#125; if(k==LB.siz) ++tot,puts("Connected"); else puts("Disconnected"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>树上差分</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4326 运输计划]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-4326-%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[二分答案 + 树上差分. 首先可以考虑二分答案,变为判定是否存在合法方案使得改造后给出的路径长度都不超过 $mid$ . 预处理每条路径的长度 $len$ ,若 $len\le mid$ ,则不用考虑.否则,被改造的边长度至少为 $mid-len$ . 将每条路径按上述过程处理,可以得出被改造的边长度至少为 $\max (mid-len_i)$ ,并且在所有需要考虑的路径上. 用树上差分给路径上的边打上标记,然后枚举每条边进行验证. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int n,m,x[MAXN],y[MAXN],z[MAXN],len[MAXN];int tofa[MAXN],dis[MAXN],mx=0;int dep[MAXN],Log[MAXN],fa[MAXN][20];int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=Log[dep[x]-dep[y]];i&gt;=0;--i) if(dep[x]-dep[y]&gt;=(1&lt;&lt;i)) x=fa[x][i]; if(x==y) return x; for(int i=Log[dep[x]];i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfs_pre(int u,int F)&#123; fa[u][0]=F; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; dep[v]=dep[u]+1; dis[v]=dis[u]+val[i]; tofa[v]=val[i]; dfs_pre(v,u); &#125;&#125;int dif[MAXN],tot,lim;bool dfs_calc(int u,int F)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; if(dfs_calc(v,u)) return true; dif[u]+=dif[v]; &#125; if(u!=1 &amp;&amp; dif[u]==tot &amp;&amp; tofa[u]&gt;=lim) return true; return false;&#125;bool check(int mid)&#123; tot=0,lim=0; for(int i=1;i&lt;=n;++i) dif[i]=0; for(int i=1;i&lt;=m;++i) &#123; if(len[i]&lt;=mid) continue; lim=max(lim,len[i]-mid); ++tot; ++dif[x[i]],++dif[y[i]]; dif[z[i]]-=2; &#125; if(!tot) return true; return dfs_calc(1,0);&#125;int main()&#123; n=read(),m=read(); Log[0]=-1,Log[1]=0; for(int i=2;i&lt;=n;++i) Log[i]=Log[i&gt;&gt;1]+1; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; for(int i=1;i&lt;=m;++i) &#123; x[i]=read(); y[i]=read(); &#125; dfs_pre(1,0); for(int i=1;i&lt;=m;++i) &#123; z[i]=LCA(x[i],y[i]); len[i]=dis[x[i]]+dis[y[i]]-2*dis[z[i]]; mx=max(mx,len[i]); &#125; int L=0,R=mx,ans; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 535 花火]]></title>
    <url>%2F2019%2F08%2F13%2FLoj-535-%E8%8A%B1%E7%81%AB%2F</url>
    <content type="text"><![CDATA[扫描线 + 线段树. 特判序列已经有序的情况,此时不需要进行任何交换. 首先,我们可以首先进行特殊的交换,再进行一般的交换,这样显然不会使答案变劣. 特殊交换之后,还需要的次数就是当前逆序对的数目.所以特殊交换要减少尽可能多的逆序对. 考虑交换两个数 $h_x,h_y,x&lt;y$ ,显然当 $h_x&gt;h_y$ 时,逆序对会减少,否则会增加,于是只考虑 $h_x&gt;h_y$ 的情况. 容易发现交换后减少的逆序对数目就是 $1+2|S|,S=\lbrace k|x&lt;k&lt;y,h_y&lt;h_k&lt;h_x \rbrace$ . 考虑左端点 $x$ 的选择,若 $h_{x_1}&gt;h_{x_2},x_1&lt;x_2$ , $x_2$ 就没用了.于是可以维护出有用的 $x$ . 考虑右端点 $pos_y$ 的选择,若 $h_{y_1}&lt;h_{y_2},y_1&gt;y_2$ , $y_2$ 就没用了.于是可以维护出有用的 $y$ . 考虑一个位置 $k$ 会存在哪些点对 $(x,y)$ 满足 $x&lt;k&lt;y,h_y&lt;h_k&lt;h_x$ .在第一个单调栈中二分找出最小的 $l$ ,使得 $h_l&gt;h_k$ ,在第二个单调栈中二分找出最小的 $r$ ,使得 $h_r&lt;h_x$ . 那么点对 $(x,y)$ 满足 $x&lt;k&lt;y,h_y&lt;h_k&lt;h_x$ ,即 $k$ 对 $(x,y)$ 有贡献的条件是 $x\in [l,k-1],y\in[k+1,r]$ . 这相当于是一个矩形覆盖,问题转化为给了若干个矩形,求一个点最多被覆盖了几次. 扫描线 + 线段树解决,时间复杂度 $O(n\log n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;int n,h[MAXN],H[MAXN];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;FT;ll ans=0;int vis[MAXN],sx[MAXN],tx=0,sy[MAXN],ty=0;int bsx(int x)&#123; int L=1,R=tx,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(h[sx[mid]]&gt;x) res=mid,R=mid-1; else L=mid+1; &#125; return sx[res];&#125;int bsy(int y)&#123; int L=1,R=ty,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(h[sy[mid]]&lt;y) res=mid,R=mid-1; else L=mid+1; &#125; return sy[res];&#125;struct node&#123; int x,ly,ry,tp;//1 + -1 - bool operator &lt; (const node &amp;rhs) const &#123; return x==rhs.x?tp&gt;rhs.tp:x&lt;rhs.x; &#125;&#125;p[MAXN&lt;&lt;2];struct SegTree&#123; struct node &#123; int mx,tag; &#125;Tree[MAXN&lt;&lt;4];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void BuildTree(int o,int l,int r) &#123; root.mx=0; root.tag=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void modify(int o,int c) &#123; root.mx+=c; root.tag+=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modify(o&lt;&lt;1,root.tag); modify(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modify(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query() &#123; return Tree[1].mx; &#125;&#125;ST;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) h[i]=H[i]=read(); sort(H+1,H+1+n); for(int i=1;i&lt;=n;++i) &#123; h[i]=lower_bound(H+1,H+1+n,h[i])-H; ans+=FT.sum(n)-FT.sum(h[i]); FT.add(h[i],1); &#125; if(!ans) return puts("0")&amp;0; ++ans; for(int i=1;i&lt;=n;++i) &#123; if(tx&gt;0 &amp;&amp; h[i]&lt;h[sx[tx]]) continue; sx[++tx]=i; vis[i]=1; &#125; for(int i=n;i&gt;=1;--i) &#123; if(ty&gt;0 &amp;&amp; h[i]&gt;h[sy[ty]]) continue; sy[++ty]=i; vis[i]=1; &#125; int cnt=0; for(int i=1;i&lt;=n;++i) &#123; if(vis[i]) continue; int l=bsx(h[i]),r=bsy(h[i]); if(l&lt;i &amp;&amp; i&lt;r) &#123; p[++cnt]=(node)&#123;l,i+1,r,1&#125;; p[++cnt]=(node)&#123;i-1,i+1,r,-1&#125;; &#125; &#125; sort(p+1,p+1+cnt); int s=0; for(int i=1;i&lt;=cnt;++i) &#123; ST.upd(1,1,n,p[i].ly,p[i].ry,p[i].tp); if(p[i].tp&gt;0) s=max(s,ST.query()); &#125; ans-=(1+2LL*s); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五边形数定理学习笔记]]></title>
    <url>%2F2019%2F08%2F13%2F%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[去 大佬的博客 学习了一下相关知识. 整数划分问题将一个正整数 $n$ 拆分成若干正整数之和,求方案数. 令 $f(i,j)$ 表示将 $j$ 拆成 $i$ 个数的方案数,转移有 $f(i,j)=f(i,j-i)+f(i-1,j-1)$ ,边界为 $f(0,0)=1$ . 意义是所有数都 $+1$ 或者新加入一个 $1$ ,时间复杂度 $O(n^2)$ . 几个拓展 要求拆成的正整数两两不同.这样,新加入一个 $1$ 之前的操作必须是每个数都 $+1$ . $f(i,j)=f(i,j-i)+f(i-1,j-i)$ .显然不超过 $\sqrt n$ 个数,时间复杂度 $O(n\sqrt n)$ . 要求拆成的数全部为奇数.方案数等同于拆成两两不同的方案数.可以构造出一一对应的映射( $Ferrers$ 图转置). 要求拆成若干个大小 $\le k$ 的正整数.方案数等同于拆成 $\le k$ 个任意大小的正整数. 五边形数定理五边形数 $f_1=1,f_n=f_{n-1}+3n-2$ .对差分求前缀和,得到 $f_n=\frac{n(3n-1)} 2$ . $1,5,12,22,35,51,70,92,117,145,176,210,247,287\dots$ 广义五边形数在公式 $f_n=\frac{n(3n-1)} 2$ 中, $n$ 取 $0,1,-1,2,-2\dots$ $0,1,2,5,7,12,15,22,26,35,40,51,57,70,77,92,100,117,126\dots$ 欧拉函数$$\phi(x)=\prod_{i=1}^{+\infty} (1-x^i)$$ 值得一提的是,上面这个函数就是我们在数论中经常使用的 $\varphi(x)$ 的展开形式. 它仅在 $|x|&lt; 1$ 时收敛,但这里作为形式幂级数,我们不考虑它的敛散性. 五边形数定理$$\begin{aligned}\phi(x)&amp;=1-x-x^2+x^5+x^7-x^{12}-x^{15}\dots \\&amp;=1+\sum_{i=1}^{+\infty}(-1)^i(x^{i(3i-1)/2}+x^{-i(-3i-1)/2})\end{aligned}$$ $x^{i(3i-1)/2}+x^{-i(-3i-1)/2}$ 这个东西的次数分别是相邻的两个广义五边形数. 五边形数定理与整数划分写出整数划分问题的生成函数 $G(x)$ ,显然,$$\begin{aligned}G(x)&amp;=\prod_{i=1}^{+\infty}(1+x^i+x^{2i}+x^{3i}+\dots) \\&amp;=\prod_{i=1}^{+\infty}\frac 1 {1-x^i}\end{aligned}$$发现 $G\times \phi=1$ .把多项式乘法暴力展开,观察系数,可以得到递推式$$G(1)=1,G(n)=G(n-1)+G(n-2)-G(n-5)-G(n-7)+\dots$$因为广义五边形数的级别是 $n^2$ 的,所以直接递推的时间复杂度为 $O(n\sqrt n)$ . 也可以直接在模 $x^{n+1}$ 意义下对 $\phi$ 求逆得到 $G$ ,时间复杂度 $O(n\log n)$.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6261 一个人的高三楼]]></title>
    <url>%2F2019%2F08%2F13%2FLoj-6261-%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E9%AB%98%E4%B8%89%E6%A5%BC%2F</url>
    <content type="text"><![CDATA[生成函数 + $NTT$ . 设这个数列做了 $i$ 次前缀和后的生成函数为 $F_i(x)$ . $F_0(x)$ 是已知的,将下标置为从 $0$ 开始. 考虑如何递推,令 $G(x)=\sum_{i=0}^{n-1}x^i$ ,则$$F_{i+1}(x)\equiv F_i(x)\cdot G(x)\ (\mbox{mod}\ x^n)$$那么就有$$F_k(x)\equiv F_0(x)\cdot G^k(x)\ (\mbox{mod}\ x^n)$$直接用多项式快速幂,时间复杂度 $O(n\log n)$ .但这种做法常数比较大,而且写起来麻烦. 考虑 $G(x)^k$ 的组合意义.有 $k$ 个盒子,每个盒子可以拿出 $0\sim n-1$ 个球, $[x^i]G^k(x)$ 表示拿出了 $i$ 个球的方案数. 盒子是不同的,而球是相同的,相当于把这 $i$ 个球分到 $k$ 个盒子里去.隔板法可知 $[x^i]G^k(x)={i+k-1\choose k-1}$ . 用 $NTT$ 将 $F_0(x)$ 和 $G^k(x)$ 乘起来就是答案了.时间复杂度 $O(n\log n)$ ,是与 $k$ 无关的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll read()&#123; ll out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int omega[MAXN&lt;&lt;2],inv[MAXN&lt;&lt;2],rev[MAXN&lt;&lt;2],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0; i&lt;n; ++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((n&gt;&gt;1)*(i&amp;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;int NTT_A[MAXN&lt;&lt;2],NTT_B[MAXN&lt;&lt;2];void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0; i&lt;lenA; ++i) NTT_A[i]=A[i]; for(int i=lenA; i&lt;n; ++i) NTT_A[i]=0; for(int i=0; i&lt;lenB; ++i) NTT_B[i]=B[i]; for(int i=lenB; i&lt;n; ++i) NTT_B[i]=0; DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true);&#125;int n;ll k;int A[MAXN],B[MAXN],C[MAXN&lt;&lt;2];int main()&#123; n=read(),k=read(); int t=(k-1)%P; for(int i=0; i&lt;n; ++i) A[i]=read(); B[0]=1; for(int i=1; i&lt;n; ++i) &#123; B[i]=mul(B[i-1],add(i,t)); B[i]=mul(B[i],fpow(i,P-2)); &#125; NTT(A,B,C,n,n); for(int i=0; i&lt;n; ++i) printf("%d\n",C[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式的几个板子]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[多项式的几个板子,代码也放在一起了. Luogu P4238 多项式求逆给定一个 $n$ 项的多项式 $A$ ,求多项式 $B$ ,使得 $A\cdot B\equiv 1 (\mbox{mod}\ x^n)$ . 首先还是用 $0$ 将 $n$ 补成 $2$ 的幂次,然后递归求解. 若 $n=1$ ,那么只需要让 $B=A_0^{-1}$ . 若 $n&gt;1$ ,则先求解 $B’$ ,使得 $A\cdot B’\equiv 1(\mbox{mod}\ x^{\frac n 2})$ . 因为 $A\cdot B\equiv 1(\mbox{mod}\ x^n)$ ,所以有 $B-B’\equiv 0(\mbox{mod}\ x^{\frac n 2})$ . 即 $B-B’=C\cdot x^{\frac n 2}$ ,所以 $B^2-2\cdot B\cdot B’+B’^2\equiv 0(\mbox{mod}\ x^n)$ . 两边同乘 $A$ ,得到 $B-2B’+A\cdot B’^2\equiv 0(\mbox{mod}\ x^n)$ . 于是可以得到 $B\equiv 2B’-A\cdot B’^2(\mbox{mod}\ x^n)$ . 由上过程可以看出,多项式 $A$ 有逆元的充要条件是常数项 $A_0$ 有逆元. 时间复杂度为 $\Theta(n\log n)$ . 实现时可以把递归改成迭代,常数会优秀许多. Luogu P4512 多项式除法/多项式取模给定一个 $n$ 次多项式 $A$ ,一个 $m$ 次多项式 $B$ ,满足 $m\le n$ ,求多项式 $D,R$ ,使得,$$A(x)=D(x)B(x)+R(x)$$并且 $\deg (D)\le n-m,\deg (R)&lt;m$ . 尝试先消去余式 $R(x)$ 的影响,考虑多项式的 系数反转 ,即对于一个 $n$ 次多项式 $A$ ,$$A^R(x)=x^n\cdot A(\frac 1 x)$$如 $A(x)=x^3+2x^2+3x+4$ ,则 $A^R(x)=x^3\cdot A(\frac 1 x)=4x^3+3x^2+2x+1$ . 我们要求满足 $A(x)=D(x)B(x)+R(x)$ 的 $D,R$ ,如果将 $x$ 全部用 $\frac 1 x$ 替换,等式仍然成立. 替换后再同时乘上 $x^n$ ,由于 $\deg(D)\le n-m,\deg(R)&lt;m$ ,将 $D,R$ 次数分别看做 $n-m,m-1$ ,不足用 $0$ 补. 于是可以得到,$$A^R(x)=D^R(x)B^R(x)+x^{n-m+1}\cdot R^R(x)$$我们将上面的等式两边都对 $x^{n-m+1}$ 取模, $x^{n-m+1}\cdot R^R(x)$ 就被消去了,于是得到,$$A^R(x)\equiv D^R(x)B^R(x) (\mbox{mod}\ x^{n-m+1})$$对 $B^R(x)$ 用一次多项式求逆,再用一次多项式乘法求得模 $x^{n-m+1}$ 意义下的 $D^R(x)$ . 由于 $\deg (D)\le n-m$ ,反转后 $\deg (D^R)\le n-m$ .所以模意义下求得的 $D^R(x)$ 就是真实的 $D^R(x)$ . 再系数反转求得 $D(x)$ ,回代 $A(x)=D(x)B(x)+R(x)$ 得到 $R(x)$ . 从上述过程可以看出,多项式除法/多项式取模的时间复杂度与多项式求逆相同,为 $\Theta(n\log n)$ . Luogu P4728 多项式 $\ln$首先需要了解多项式的求导和不定积分.对于一个 $n-1$ 次多项式 $A$ , $$A(x)=\sum_{i=0}^{n-1} a_i\cdot x_i\\A’(x)=\sum_{i=0}^{n-2} a_{i+1}\cdot(i+1)\cdot x^i \\\int A(x) \mbox d x=\sum_{i=1}^{n}\frac {a_{i-1}} i \cdot x^i+C$$ 现在给出 $n-1$ 次多项式 $A(x)$ ,要在模 $x^n$ 意义下求 $B(x)$ ,使得 $B(x)\equiv \ln (A(x))\ (\mbox{mod}\ x^n)$ . 两边同时求导,得到 $B’(x)\equiv \frac {A’(x)} {A(x)}\ (\mbox{mod}\ x^n)$ . 多项式求逆得到 $\frac 1 {A(x)}$ ,再算出 $B’(x)$ ,再对 $B’(x)$ 不定积分得到 $B(x)$ . 这里 $B(x)$ 的常数项是 $0$ ,因为 $a_0=1$ ,若将 $\ln$ 函数大力展开,就可以发现 $B$ 的常数项就是 $\ln a_0$ . 时间复杂度 $\Theta(n\log n)$ . 多项式牛顿迭代已知一个函数 $G(x)$ ,在模 $x^n$ 意义下求一个多项式 $F(x)\ \mbox{mod}\ x^n$ ,使得 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ . 仍然将项数用 $0$ 补到 $2$ 的幂次.当 $n=1$ 时,需要单独求解 $G(F(x))\equiv 0(\mbox{mod}\ x)$ . 否则,先求解 $F_0(x)$ ,使得 $G(F_0(x))\equiv 0 (\mbox{mod}\ x^{\frac n 2})$ . 考虑如何拓展到模 $x^n$ 下,把 $G(F(x))$ 在 $F_0(x)$ 处进行泰勒展开, $$G(F(x))=G(F_0(x))+\frac{G’(F_0(x))}{1!}\cdot (F(x)-F_0(x))+\frac{G’’(F_0(x))}{2!}\cdot (F(x)-F_0(x))^2 + \dots$$ 因为 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ ,所以 $G(F(x))\equiv 0(\mbox{mod}\ x^{\frac n 2})$ 也成立. 而 $G(F_0(x))\equiv 0 (\mbox{mod}\ x^{\frac n 2})$ 所以 $F(x)$ 与 $F_0(x)$ 次数低于 $x^{\frac n 2}$ 的部分是相同的. 所以展开式中从第三项 $\frac{G’’(F_0(x))}{2!}\cdot (F(x)-F_0(x))^2$ 起,在模 $x^n$ 意义下都为 $0$ .于是只保留前两项,得到 $$G(F(x))\equiv G(F_0(x))+{G’(F_0(x))}\cdot (F(x)-F_0(x))\ (\mbox{mod}\ x^n)$$ 而 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ ,所以就有 $$F(x)\equiv F_0(x)-\frac {G(F_0(x))} {G’(F_0(x))}\ (\mbox{mod}\ x^n)$$ 需要注意,这里的 $G’(F_0(x))$ 是以 $F_0(x)$ 作为自变量求导,而不是以 $x$ 作为自变量求导. 如,若 $G(x)=\ln x,F_0(x)=x$ ,则 $G’(F_0(x))=\frac 1 {F_0(x)}=\frac 1 x$ ,而不是 $\ln(1)=0$ . 时间复杂度为 $O(n\log n)$ ,由于可以实现类似解方程的操作,所以用途比较广泛. 如实现多项式开根,就可以直接设 $G(x)=x^2-A$ . Luogu P4726 多项式 $\exp$给定项数为 $n$ 的多项式 $A(x)$ ,在 $\mbox{mod} \ x^n$ 意义下求多项式 $B(x)$ ,使得 $B(x)\equiv \exp(A(x))\ (\mbox{mod} \ x^n)$ . 取对数,得到 $\ln B\equiv A \ (\mbox{mod} \ x^n)$ ,令 $G(x)=\ln x-A$ ,则问题等价于求解 $F(x)$ ,使得 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ . 直接套用牛顿迭代的那一套理论,得到$$F\equiv (1-{\ln (F_0)+A})\cdot F_0\ (\mbox{mod}\ x^n)$$递归求解,当 $n=1$ 时,令 $F_0(x)=\exp a_0$ 即可.一般会保证多项式 $A$ 的常数项 $a_0=0$ . Luogu P5245 多项式快速幂给定项数为 $n$ 的多项式 $A(x)$ ,正整数 $k$ . 在 $\mbox{mod}\ x^n$ 下求多项式 $B(x)$ ,使得 $B(x)\equiv A^k(x)\ (\mbox{mod} \ x^n)$ . 两边同时取对数,得到 $\ln B(x)\equiv k\ln A(x) \pmod {x^n}$ ,可以看出 $k$ 可以直接对 $P$ 取模. 再对两边同时做一次 $\exp$ ,得到 $B(x)\equiv \exp(k\ln A(x)) \pmod {x^n}$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=4e5+10;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int rev[MAXN],omega[MAXN],inv[MAXN];int curn;void init(int n)&#123; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; if(curn!=n) init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;int a[MAXN],b[MAXN];void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) a[i]=A[i]; for(int i=lenA;i&lt;n;++i) a[i]=0; for(int i=0;i&lt;lenB;++i) b[i]=B[i]; for(int i=lenB;i&lt;n;++i) b[i]=0; DFT(a,n,false); DFT(b,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;int tmp[MAXN];void poly_inverse(int *A,int *B,int n)&#123; for(int i=0;i&lt;2*n;++i) B[i]=0; B[0]=fpow(A[0],P-2); int k=0; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; ++k; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;int InvB[MAXN];int ModA[MAXN],ModB[MAXN];void poly_rev(int *A,int n)//n-&gt;最高项次数 &#123; for(int i=0;i&lt;n-i;++i) swap(A[i],A[n-i]);&#125;void poly_division(int *A,int *B,int *D,int *R,int n,int m)&#123; poly_rev(A,n); poly_rev(B,m); for(int i=0;i&lt;n-m+1;++i) ModA[i]=A[i],ModB[i]=B[i]; int N=1; while(N&lt;n-m+1) N&lt;&lt;=1; poly_inverse(ModB,InvB,N); for(int i=n-m+1;i&lt;N;++i) InvB[i]=0; NTT(ModA,InvB,D,n-m+1,n-m+1); poly_rev(D,n-m); poly_rev(A,n); poly_rev(B,m); NTT(B,D,R,m,n-m+1); for(int i=0;i&lt;n;++i) R[i]=add(A[i],P-R[i]);&#125;void poly_diff(int *A,int n)&#123; for(int i=0;i&lt;n-1;++i) A[i]=mul(A[i+1],i+1);&#125;void poly_int(int *A,int n)&#123; for(int i=n;i&gt;=1;--i) A[i]=mul(A[i-1],fpow(i,P-2));&#125;int InvA[MAXN],tmpA[MAXN];void poly_ln(int *A,int *B,int n)&#123; for(int i=0;i&lt;n;++i) tmpA[i]=A[i]; poly_inverse(tmpA,InvA,n); poly_diff(tmpA,n); NTT(tmpA,InvA,B,n,n); poly_int(B,n); B[0]=0; for(int i=0;i&lt;n;++i) tmpA[i]=0;&#125;int lnB[MAXN];void poly_exp(int *A,int *B,int n)&#123; if(n==1) &#123; B[0]=1; return; &#125; poly_exp(A,B,n&gt;&gt;1); for(int i=0;i&lt;n;++i) lnB[i]=0; poly_ln(B,lnB,n); for(int i=0;i&lt;n;++i) lnB[i]=add(A[i],P-lnB[i]); lnB[0]=add(lnB[0],1); NTT(B,lnB,B,n&gt;&gt;1,n); for(int i=n;i&lt;(n+(n&gt;&gt;1));++i) B[i]=0; &#125;int A[MAXN],B[MAXN];int main()&#123; int n=read(); for(int i=0;i&lt;n;++i) A[i]=read(); int N=1; while(N&lt;n) N&lt;&lt;=1; poly_exp(A,B,N); for(int i=0;i&lt;n;++i) printf("%d ",B[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4373 算术天才⑨与等差数列]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-4373-%E7%AE%97%E6%9C%AF%E5%A4%A9%E6%89%8D%E2%91%A8%E4%B8%8E%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[线段树 + $hash$ 乱搞. 可以考虑用线段树维护区间的最小值,最大值. 若是等差数列,根据最小/大值,公差可以算出长度,区间元素和,区间元素平方和,区间元素立方和,后两个自然溢出. 在线段树中把这些信息也维护进去,然后查询区间的这些要素,看一下是否符合预期结果即可. 立方和不判似乎也可以过.这东西应该挺难卡的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;const int P=1e9+7;ull cube(ull x)&#123; return x*x*x;&#125;ull S1(ull x)&#123; return x*(x+1)/2;&#125;ull S2(ull x)&#123; return x*(x+1)*(2*x+1)/6;&#125;ull S3(ull x)&#123; return S1(x)*S1(x);&#125;const ull U=1;int n,m,tot=0,a[MAXN];struct SegTree&#123; struct node &#123; int minv,maxv; ll sum1; ull sum2,sum3; friend node operator + (node lson,node rson) &#123; node root; root.minv=min(lson.minv,rson.minv); root.maxv=max(lson.maxv,rson.maxv); root.sum1=lson.sum1+rson.sum1; root.sum2=lson.sum2+rson.sum2; root.sum3=lson.sum3+rson.sum3; return root; &#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root=lson+rson; &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) &#123; root=(node)&#123;a[l],a[l],a[l],U*a[l]*a[l],cube(a[l])&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int pos,int c) &#123; if(l==r) &#123; root=(node)&#123;c,c,c,U*c*c,cube(c)&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,l,mid,pos,c); else upd(o&lt;&lt;1|1,mid+1,r,pos,c); pushup(o); &#125; node query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query(o&lt;&lt;1|1,mid+1,r,L,R); return query(o&lt;&lt;1,l,mid,L,R)+query(o&lt;&lt;1|1,mid+1,r,L,R); &#125; bool check(int L,int R,int k) &#123; node tmp=query(1,1,n,L,R); ull len=R-L+1; if((tmp.maxv-tmp.minv)!=(len-1)*k) return false; ll expsum1=len*(tmp.minv+tmp.maxv)/2; if(expsum1!=tmp.sum1) return false; ull b=tmp.minv-k; ull expsum2=len*b*b; expsum2+=k*b*(len+1)*len; expsum2+=k*k*S2(len); if(expsum2!=tmp.sum2) return false; ull expsum3=cube(k)*S3(len); expsum3+=U*3*k*k*b*S2(len); expsum3+=U*3*k*b*b*S1(len); expsum3+=len*cube(b); if(expsum3!=tmp.sum3) return false; return true; &#125;&#125;T;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.BuildTree(1,1,n); while(m--) &#123; int op=read(); if(op==1) &#123; int x=read()^tot,y=read()^tot; T.upd(1,1,n,x,y); &#125; else &#123; int L=read()^tot,R=read()^tot,k=read()^tot; if(T.check(L,R,k)) &#123; puts("Yes"); ++tot; &#125; else puts("No"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 134]]></title>
    <url>%2F2019%2F07%2F20%2FAtcoder-Beginner-Contest-134%2F</url>
    <content type="text"><![CDATA[$F$ 题不错. A Dodecagon签到题. 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int x=read(); cout&lt;&lt;3*x*x&lt;&lt;endl; return 0;&#125; B Golden Apple签到题. 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),D=read(); cout&lt;&lt;(n+2*D)/(2*D+1)&lt;&lt;endl; return 0;&#125; C Exception Handling$ST$ 表或者线段树写一写就好了.或许有不用数据结构的高论? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int a[MAXN];struct Segtree&#123; struct node &#123; int mx; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void bd(int o,int l,int r) &#123; if(l==r) &#123; root.mx=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(o&lt;&lt;1,l,mid); bd(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;R || L&gt;r || l&gt;R) return -1; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mx; int res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) res=max(res,query(o&lt;&lt;1|1,mid+1,r,L,R)); return res; &#125;&#125;T;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.bd(1,1,n); for(int i=1;i&lt;=n;++i) printf("%d\n",max(T.query(1,1,n,1,i-1),T.query(1,1,n,i+1,n))); return 0;&#125; D Preparing Boxes倒着确定每个数,显然每个数是唯一确定的. 暴力统计就好了,由调和级数知,时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN];int t[MAXN],m=0;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=n;i&gt;=1;--i) &#123; int x=a[i]; for(int j=i*2;j&lt;=n;j+=i) x^=t[j]; t[i]=x; if(x) ++m; &#125; cout&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=n;++i) if(t[i]) printf("%d ",i); return 0;&#125; E Sequence Decomposing给一个序列,求最少分成几个单调上升子序列. 大概就是导弹拦截那道题.答案就是最长单调不降子序列的长度. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,A[MAXN],a[MAXN];#define lowbit(x) x&amp;(-x)int bit[MAXN];void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=max(bit[x],c);&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s=max(s,bit[x]); return s;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); int m=unique(A+1,A+1+n)-A-1; for(int i=1;i&lt;=n;++i) &#123; int x=lower_bound(A+1,A+1+m,a[i])-A; x=m+1-x; int y=sum(x)+1; add(x,y); &#125; cout&lt;&lt;sum(n)&lt;&lt;endl; return 0;&#125; F Permutation Oddness$dp$ 计数,设 $f(i,j,k,l)$ 表示考虑前 $i$ 个位置, $1,2,\dots i $ 中有 $j$ 个数还没有填,位置 $1,2,\dots,i$ 中有 $k$ 个位置还没有放,已经确定的权值为 $l$ 时的方案数. 后两维可以写在一起,状态数 $O(n^4)$ ,转移 $O(1)$ ,时间复杂度 $O(n^4)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=51;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int N,K;int f[MAXN][MAXN][MAXN*MAXN];int main()&#123; N=read(),K=read(); f[0][0][0]=1; for(int i=1;i&lt;=N;++i) for(int j=0;j&lt;=i;++j) for(int k=2*j;k&lt;=K;++k) &#123; upd(f[i][j][k],mul(2*j+1,f[i-1][j][k-2*j])); upd(f[i][j][k],mul(j*j+2*j+1,f[i-1][j+1][k-2*j])); if(j) upd(f[i][j][k],f[i-1][j-1][k-2*j]); &#125; cout&lt;&lt;f[N][0][K]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>Atcoder</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190720]]></title>
    <url>%2F2019%2F07%2F20%2Ftest20190720%2F</url>
    <content type="text"><![CDATA[好题. $A\ Safe\ Bet$$25$ 分做法:枚举镜子摆放的位置,模拟光线,每次用 $set$ 找到下一面镜子,修改方向,最后检验是否从 $(R,C)$ 出来. 满分做法:不额外增加镜子,直接模拟光线,若最后从 $(R,C)$ 出来,答案为 $0$ . 否则,模拟反向光线,从 $(R,C+1)$ 反向射入,可以发现放镜子的可行位置为两条光线的所有交点. 用扫描线 + 线段树求交点数目以及字典序最小的交点即可. 考试情况:只写了 $25$ 分的做法. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=0;i&lt;n;++i)#define pb push_back#define mk make_pair#define X first#define Y second#define tree int t,int l,int r#define left t*2,l,mid#define right t*2+1,mid+1,r#define M int mid=l+r&gt;&gt;1const int N=1000005;typedef pair&lt;int,int&gt; pr;typedef vector&lt;pair&lt;int,pr&gt; &gt; seq;set&lt;pr&gt; a[N],b[N];seq f1,g1,f2,g2;int Case,n,m,R,C,x,y,ll,rr,c[N];long long ans;int get(int x)&#123; int res=0; for (; x; x-=x&amp;-x) res+=c[x]; return res;&#125;void add(int x,int v)&#123; for (; x&lt;=C; x+=x&amp;-x) c[x]+=v;&#125;void ins(int side)&#123; scanf("%d%d",&amp;x,&amp;y),a[x].insert(mk(y,side)),b[y].insert(mk(x,side));&#125;bool track(int x,int y,int d,seq &amp;f,seq &amp;g)&#123; f.clear(),g.clear(); set&lt;pr&gt; :: iterator it; for (;;) &#123; if (d&amp;1) &#123; if (d==1) &#123; it=b[y].upper_bound(mk(x,1)); f.pb(mk(x+1,mk(y,1))); if (it==b[y].end()) return f.pb(mk(R+1,mk(y,-1))),0; f.pb(mk(it-&gt;X,mk(y,-1))),x=it-&gt;X,d=it-&gt;Y?2:0; &#125; else &#123; it=b[y].lower_bound(mk(x,0)); f.pb(mk(x,mk(y,-1))); if (it==b[y].begin()) return f.pb(mk(1,mk(y,1))),0; --it; f.pb(mk(it-&gt;X+1,mk(y,1))),x=it-&gt;X,d=it-&gt;Y?0:2; &#125; &#125; else &#123; if (d==0) &#123; it=a[x].upper_bound(mk(y,1)); if (it==a[x].end()) return g.pb(mk(x,mk(y+1,C))),x==R; g.pb(mk(x,mk(y+1,it-&gt;X-1))),y=it-&gt;X,d=it-&gt;Y?3:1; &#125; else &#123; it=a[x].lower_bound(mk(y,0)); if (it==a[x].begin()) return g.pb(mk(x,mk(1,y-1))),0; --it; g.pb(mk(x,mk(it-&gt;X+1,y-1))),y=it-&gt;X,d=it-&gt;Y?1:3; &#125; &#125; &#125;&#125;void work(seq &amp;f,seq &amp;g)&#123; sort(f.begin(),f.end()),sort(g.begin(),g.end()); int m=f.size(),n=g.size(),j=0; rep(i,n) &#123; while (j&lt;m &amp;&amp; f[j].X&lt;=g[i].X) add(f[j].Y.X,f[j].Y.Y),++j; ll=g[i].Y.X,rr=g[i].Y.Y; int res=get(rr)-get(ll-1); ans+=res; if (g[i].X&lt;x &amp;&amp; res) &#123; x=g[i].X,y=ll; for (int j=20; j&gt;=0; --j) if (y+(1&lt;&lt;j)&lt;=rr &amp;&amp; !(get(y-1+(1&lt;&lt;j))-get(y-1))) y+=1&lt;&lt;j; &#125; &#125; while (j&lt;m) add(f[j].Y.X,f[j].Y.Y),++j;&#125;int main()&#123; freopen("safe.in","r",stdin); freopen("safe.out","w",stdout); while (scanf("%d%d%d%d",&amp;R,&amp;C,&amp;n,&amp;m)!=EOF) &#123; rep(i,R+1) a[i].clear(); rep(j,C+1) b[j].clear(); rep(i,n+m) ins(i&lt;n); printf("Case %d: ",++Case); if (track(1,0,0,f1,g1)) &#123; puts("0"); continue; &#125; track(R,C+1,2,f2,g2); ans=0,x=R+1,work(f1,g2),work(f2,g1); if (ans) printf("%I64d %d %d\n",ans,x,y); else puts("impossible"); &#125; return 0;&#125; $Room\ Service$$25$ 分做法:一堆特判.矩形的情况答案就是对角线长度 $\times 2$ . 我的 $60$ 分做法:其实就是乱搞,出题人是没有设计这一部分的,也没有卡我. 把每条边 $K$ 等分,拆成 $K+1$ 个点,设 $f(i,j,S)$ 表示从出发点到达第 $i$ 条边上的第 $j$ 个点,已经到达过的边集合为 $S$ 时走过的最短长度.大力转移,时间复杂度为 $O(n^2\cdot2^n\cdot K^2)$ .实际上有很多无用状态.参数 $K$ 取 $200$ 就可以了. 满分做法:若需要到的线段为直线,显然只需要将点 $P$ 关于 $n$ 条边都镜面反射一次,得到 $P’$ , $dis(P,P’)$ 即为答案. 但现在是线段,有可能交点在线段外,此时一定是某一个端点处最优.于是只有端点或交点处的状态有用, $flyod$ 预处理两点间最短路后,枚举第一个到的关键点和最后一个到的关键点,更新答案.时间复杂度 $O(n^3)$ . 考试情况:乱搞获得 $60$ 分. $std$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=1;i&lt;=n;++i)const double eps=1e-8;int Case,n;double ans,d[205][205];struct node&#123; double x,y; node() &#123;&#125; node(double _x,double _y):x(_x),y(_y) &#123;&#125; node operator +(const node &amp;A) &#123; return node(x+A.x,y+A.y); &#125; node operator -(const node &amp;A) &#123; return node(x-A.x,y-A.y); &#125; node operator *(const double &amp;A) &#123; return node(x*A,y*A); &#125; double operator *(const node &amp;A) &#123; return x*A.x+y*A.y; &#125; double operator %(const node &amp;A) &#123; return x*A.y-y*A.x; &#125; double norm() &#123; return x*x+y*y; &#125; double len() &#123; return sqrt(norm()); &#125; void read() &#123; scanf("%lf%lf",&amp;x,&amp;y); &#125;&#125; a[205];bool cross(node &amp;A,node &amp;B,node &amp;C,node &amp;D)&#123; return ((C-A)%(B-A))*((D-A)%(B-A))&lt;=0 &amp;&amp; ((C-A)%(B-A))*((D-A)%(B-A))&lt;=0;&#125;void rev(node A,node B,node &amp;C)&#123; node V=B-A; C=(A+V*(((C-A)*V)/V.norm()))*2-C;&#125;double work(node A,int l,node B,int r)&#123; for (int i=l; i&lt;r; ++i) rev(a[i],a[i+1],A); for (int i=r; i&gt;l; --i) &#123; if (!cross(A,B,a[i-1],a[i])) return 1e9; rev(a[i-1],a[i],A),rev(a[i-1],a[i],B); &#125; return (A-B).len();&#125;inline int chg(int x)&#123; return x&gt;n?x-n:x;&#125;inline void Min(double &amp;x,double y)&#123; if (y&lt;x) x=y;&#125;int main()&#123; freopen("room.in","r",stdin); freopen("room.out","w",stdout); while (scanf("%d",&amp;n)!=EOF) &#123; ans=1e9,a[0].read(); rep(i,n) a[i].read(),a[n+i]=a[i]; rep(i,n) rep(j,n-1) d[i][chg(i+j)]=work(a[i],i+1,a[i+j],i+j-1); rep(k,n) rep(i,n) rep(j,n) Min(d[i][j],d[i][k]+d[k][j]); rep(i,n) &#123; ans=min(ans,work(*a,i,*a,i+n)); for (int j=0; j&lt;n; ++j) d[0][chg(i+j)]=work(*a,i,a[i+j],i+j-1), d[chg(i+j)][0]=work(a[i+j],i+j+1,*a,i+n); rep(j,n) rep(k,n) Min(ans,d[0][j]+d[j][k]+d[k][0]); &#125; printf("%.2lf\n",ans); &#125; return 0;&#125; $Rain$满分做法:一个点的水面高度取决于它到边界必须经过的点中的最高海拔. 预处理出边界,从边界上的点出发跑 $Dijkstra$ ,求出每个点的水面高度,然后 $bfs$ 求联通块. 求边界可以先极角排序,从 $x$ 坐标最小的点出发,绕一圈就是边界. 时间复杂度 $O(m\cdot \log m)$ . 考试情况: puts(“0”); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=0,_=n;i&lt;_;++i)#define pb push_back#define mk make_pairconst int N=52*52;int Case,n,m,u,v,X,Y,now,o,x[N],y[N],h[N],d[N],id[N],ans[N];bool b[N];priority_queue&lt;pair&lt;int,int&gt; &gt; H;vector&lt;int&gt; e[N];char st[5];int C(char x)&#123; return x&lt;'a'?x-65:x-71;&#125;int get()&#123; scanf("%s",st); int v=C(st[0])*52+C(st[1]); if (id[v]&lt;0) id[v]=now++; return id[v];&#125;bool cmp(const int i,const int j)&#123; return atan2(y[i]-Y,x[i]-X)&lt;atan2(y[j]-Y,x[j]-X);&#125;void dfs(int i)&#123; if (!b[i] || d[i]&lt;=h[i]) return; b[i]=0; rep(k,e[i].size()) dfs(e[i][k]);&#125;int main()&#123; freopen("rain.in","r",stdin); freopen("rain.out","w",stdout); while (scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; rep(i,N) b[i]=1,id[i]=-1,e[i].clear(),d[i]=1&lt;&lt;20; now=0,o=0; rep(i,n) &#123; u=get(),scanf("%d%d%d",x+u,y+u,h+u); if (x[u]&lt;x[o]) o=u; &#125; rep(i,m) u=get(),v=get(),e[u].pb(v),e[v].pb(u); rep(i,n) X=x[i],Y=y[i],sort(e[i].begin(),e[i].end(),cmp); d[o]=h[o],H.push(mk(-d[o],o)); for (int j=o,i=e[o][0];; j=i,i=e[i][u]) &#123; rep(k,e[i].size()) if (e[i][k]==j) &#123; u=k; break; &#125; if (++u==e[i].size()) u=0; d[i]=h[i],H.push(mk(-d[i],i)); if (i==o &amp;&amp; !u) break; &#125; while (!H.empty()) &#123; pair&lt;int,int&gt; t=H.top(); H.pop(); int i=t.second; if (-t.first==d[i]) rep(k,e[i].size()) &#123; int j=e[i][k]; if (max(d[i],h[j])&lt;d[j]) d[j]=max(d[i],h[j]),H.push(mk(-d[j],j)); &#125; &#125; int L=0; rep(i,n) if (b[i] &amp;&amp; d[i]&gt;h[i]) ans[L++]=d[i],dfs(i); if (!L) puts("0"); sort(ans,ans+L); rep(i,L) printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>计算几何</tag>
        <tag>最短路</tag>
        <tag>扫描线</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4446 小凸玩密室]]></title>
    <url>%2F2019%2F07%2F20%2Fbzoj-4446-%E5%B0%8F%E5%87%B8%E7%8E%A9%E5%AF%86%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[树形 $dp$ . 设 $f(i,j)$ 表示将子树 $i$ 全部点亮,下一次点亮点 $j$ 的最小花费.这样的话,状态数是 $O(n^2)$ 的. 注意到点亮子树 $i$ 后,下一次要么点亮 $i$ 的某个祖先,要么点亮 $i$ 的某个祖先的另外一侧的儿子.树是完全二叉树,所以可以直接用深度表示,树深是 $O(\log n)$ 的,再通过位运算得到节点标号. 设 $f(i,j)$ 表示点亮子树 $i$ 后,下一次点亮 $i$ 的第 $j$ 级祖先的最小花费, $g(i,j)$ 表示点亮子树 $i$ 后,下一次点亮 $i$ 的第 $j$ 级祖先的另一个儿子的最小花费.这样状态数是 $O(n\log n)$ 的. 默认以 $1$ 为根, $dp$ 求出 $f,g$ 的值.然后枚举第一个点亮的点 $x$ ,先点亮子树 $x$ ,跳到 $fa_x$ ,再点亮 $fa_x$ 的另一侧子树,再跳到 $fa_{fa_x}$ ,点亮 $fa_{fa_x}$ 的另一颗子树…需要跳 $O(\log n)$ 次. 时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int fa(int x)&#123; return x&gt;&gt;1;&#125;int lson(int x)&#123; return x&lt;&lt;1;&#125;int rson(int x)&#123; return x&lt;&lt;1|1;&#125;int Ancestor(int x,int i)&#123; return x&gt;&gt;i;&#125;int Brother(int x,int i)&#123; return (x&gt;&gt;(i-1))^1;&#125;const int MAXN=2e5+10;const int Log=20;const ll inf=1e18;int n,dep[MAXN];ll a[MAXN],dis[MAXN][Log],f[MAXN][Log],g[MAXN][Log];int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) a[i]=read(); dep[1]=1; for(int i=2; i&lt;=n; ++i) &#123; dep[i]=dep[fa(i)]+1; dis[i][1]=read(); for(int j=2; j&lt;=dep[i]; ++j) dis[i][j]=dis[fa(i)][j-1]+dis[i][1]; &#125; for(int i=n; i&gt;=1; --i) &#123; int l=lson(i),r=rson(i); for(int j=1; j&lt;=dep[i]; ++j) &#123; if(r&lt;=n) //lson and rson &#123; f[i][j]=min(a[l]*dis[l][1]+g[l][1]+f[r][j+1],a[r]*dis[r][1]+g[r][1]+f[l][j+1]); g[i][j]=min(a[l]*dis[l][1]+g[l][1]+g[r][j+1],a[r]*dis[r][1]+g[r][1]+g[l][j+1]); &#125; else if(l&lt;=n)// only lson &#123; f[i][j]=a[l]*dis[l][1]+f[l][j+1]; g[i][j]=a[l]*dis[l][1]+g[l][j+1]; &#125; else //leaf &#123; f[i][j]=dis[i][j]*a[Ancestor(i,j)]; g[i][j]=(dis[i][j]+dis[Brother(i,j)][1])*a[Brother(i,j)]; &#125; &#125; &#125; ll ans=inf; for(int i=1; i&lt;=n; ++i) &#123; ll tmp=f[i][1]; for(int x=fa(i),y=i; x; y=x,x=fa(x)) &#123; int z=y^1; if(z&lt;=n) tmp+=dis[z][1]*a[z]+f[z][2]; else tmp+=dis[x][1]*a[fa(x)]; &#125; ans=min(ans,tmp); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4444 国旗计划]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4444-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[$two\ pointer$ + 倍增. 首先破环成链,接一段长度为 $m$ 的在后面.因为区间不覆盖,对于一个区间 $(l,r)$ ,它后面应该接的区间可以贪心确定,就是左端点在 $[l,r]$ 范围内,而右端点最大的区间.这个可以通过 $two\ pointer$ 预处理. 然后用倍增的做法,处理 $f(i,j)$ 表示区间 $i$ 之后的第 $2^j$ 个区间标号. 查询时从 $i$ 开始跳,找到第一个区间使得区间总长 $\ge m$ 即可.时间复杂度 $O(n\cdot \log m)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e5+10;struct node&#123; int l,r,id; node(int l=0,int r=0,int id=0):l(l),r(r),id(id) &#123;&#125; bool operator &lt; (const node &amp;rhs) const &#123; return r&lt;rhs.r; &#125;&#125;p[MAXN];int n,m,f[MAXN][20];int ans[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; int l=read(),r=read(); if(l&gt;r) p[2*i-1]=node(l,r+m,i),p[2*i]=node(l+m,r+2*m,i); else p[2*i-1]=node(l,r,i),p[2*i]=node(l+m,r+m,i); &#125; sort(p+1,p+1+2*n); for(int i=1,j=1;i&lt;=2*n;++i) &#123; while(j&lt;2*n &amp;&amp; p[j+1].l&lt;=p[i].r) ++j; f[i][0]=(i==j)?0:j; &#125; for(int j=1;(1&lt;&lt;j)&lt;=2*n;++j) for(int i=1;i&lt;=2*n;++i) f[i][j]=f[f[i][j-1]][j-1]; for(int i=1;i&lt;=2*n;++i) &#123; if(p[i].l&gt;m) continue; int x=i,tmp=0; for(int j=19;j&gt;=0;--j) if(f[x][j] &amp;&amp; p[f[x][j]].r&lt;p[i].l+m) x=f[x][j],tmp+=(1&lt;&lt;j); x=f[x][0]; ++tmp; ans[p[i].id]=tmp+(int)(p[i].id!=p[x].id); &#125; for(int i=1;i&lt;=n;++i) printf("%d ",ans[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>two pointer</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4443 小凸玩矩阵]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4443-%E5%B0%8F%E5%87%B8%E7%8E%A9%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[二分答案 + 二分图最大匹配. 二分答案 $mid$ ,权值 $\le mid$ 的边才有用,第 $k$ 大就是第 $n-k+1$ 小,判断一下最大匹配数是否达到 $n-k+1$ ,达到则合法,否则不合法. 时间复杂度 $O(n^3\cdot \log (\max v))$ . 匈牙利算法每次 $dfs$ 前都需要清空 $vis$ 数组. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=256;int a[MAXN][MAXN];vector&lt;int&gt; E[MAXN&lt;&lt;1];int pr[MAXN&lt;&lt;1],vis[MAXN&lt;&lt;1];int n,m,k;bool dfs(int u)&#123; int t=E[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=E[u][i]; if(!vis[v]) &#123; vis[v]=1; if(!pr[v] || dfs(pr[v])) &#123; pr[v]=u; pr[u]=v; return true; &#125; &#125; &#125; return false;&#125;bool check(int mid)&#123; for(int i=1;i&lt;=n+m;++i) E[i].clear(); memset(pr,0,sizeof pr); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(a[i][j]&lt;=mid) &#123; E[i].push_back(j+n); E[j+n].push_back(j); &#125; int ans=0; for(int i=1;i&lt;=n;++i) if(!pr[i]) &#123; memset(vis,0,sizeof vis); ans+=(int)(dfs(i)); &#125; return ans&gt;=(n+1-k);&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) a[i][j]=read(); int L=1,R=inf,ans=inf; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF19E Fairy]]></title>
    <url>%2F2019%2F07%2F19%2FCF19E-Fairy%2F</url>
    <content type="text"><![CDATA[树上差分. 二分图定义是能用黑白两种颜色给图染色,使得没有两个有边相连的节点颜色相同.其实也就是说图中不存在奇环. 那么一张二分图,删去任意一条边后一定仍是二分图.于是我们先做出原图的一棵生成树,再将剩下的边加入. 预处理 $LCA,dep$ ,然后加入非树边 $(u,v)$ .那么树上 $u\to v$ 路径上所有边都被这条非树边”覆盖”了. 若 $dis(u,v)$ 为奇,加入 $(u,v)$ 后会形成偶环,称这样的边为合法的边. 若 $dis(u,v)$ 为偶,则加入 $(u,v)$ 后会形成奇环,称这样的边为不合法的边. 记不合法的边总数为 $tot$ ,若 $tot=0$ ,可以删的边就是所有的边. 若 $tot=1$ ,可以删的边就是唯一的那条不合法边,以及树上被它覆盖,但未被合法边覆盖的边. 若 $tot&gt;1$ ,可以删的边就是树上被所有不合法边覆盖,但未被任意一条合法边覆盖的边. 删去树边时要求未被合法边覆盖,是因为 $(u,v)$ 若被合法边覆盖,删去后 $u$ 可以走奇数步走到 $v$ ,图中仍存在奇环. 判断使用树上差分,被不合法边覆盖 $+1$ ,被合法边覆盖 $-1$ . 图可能有重边,自环,判起来比较麻烦.还可能不连通,需要每个联通块分别做上述步骤. 没有判重边/自环的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,m,vis[MAXN];vector&lt;int&gt; G[MAXN];int color[MAXN];struct Edge&#123; int u,v,id,tp; bool operator &lt; (const Edge &amp;rhs) const &#123; return color[u]&lt;color[rhs.u]; &#125;&#125;E[MAXN];struct DSU&#123; int Fa[MAXN]; void init() &#123; for(int i=1;i&lt;=n;++i) Fa[i]=i; &#125; int Find(int x) &#123; if(x==Fa[x]) return x; return Fa[x]=Find(Fa[x]); &#125; bool Union(int x,int y) &#123; x=Find(x),y=Find(y); if(x==y) return false; Fa[x]=y; return true; &#125;&#125;dsu;void dfs_dye(int u,int col)&#123; color[u]=col; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(color[v]) continue; dfs_dye(v,col); &#125;&#125;typedef pair&lt;int,int&gt; pii;map&lt;pii,int&gt; mp;int fa[MAXN],dep[MAXN],siz[MAXN],mxson[MAXN],top[MAXN];void dfs1(int u,int F)&#123; fa[u]=F; siz[u]=1; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==F) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int rt[MAXN],L[MAXN],R[MAXN],delta[MAXN];vector&lt;int&gt; ans;void ins(int k)&#123; ans.push_back(E[k].id);&#125;void dfs_sum(int u)&#123; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==fa[u]) continue; dfs_sum(v); delta[u]+=delta[v]; &#125;&#125;int main()&#123; n=read(),m=read(); dsu.init(); int cnt=0; for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); ++cnt; E[cnt].u=u,E[cnt].v=v; E[cnt].id=i; G[u].push_back(v); G[v].push_back(u); &#125; m=cnt; int col=0; for(int i=1;i&lt;=n;++i) if(!color[i]) &#123; rt[++col]=i; dfs_dye(i,col); &#125; sort(E+1,E+1+m); for(int i=1;i&lt;=n;++i) G[i].clear(); int curcol=1; L[1]=1; for(int i=1;i&lt;=m;++i) &#123; int u=E[i].u,v=E[i].v; if(color[u]!=curcol) &#123; R[curcol]=i-1; ++curcol; L[curcol]=i; &#125; if(dsu.Union(u,v))//ontree &#123; E[i].tp=1; G[u].push_back(v); G[v].push_back(u); &#125; else E[i].tp=0; &#125; R[curcol]=m; for(int i=1;i&lt;=n;++i) if(!siz[i]) dfs1(i,0); for(int i=1;i&lt;=n;++i) if(!top[i]) dfs2(i,i); for(int c=1;c&lt;=curcol;++c) &#123; int tot=0,tmp; for(int i=L[c];i&lt;=R[c];++i) &#123; if(E[i].tp) continue; int u=E[i].u,v=E[i].v,lca=LCA(u,v); int dis=dep[u]+dep[v]-2*dep[lca],val; if(dis&amp;1) val=-1; else &#123; ++tot; val=1; tmp=i; &#125; delta[u]+=val,delta[v]+=val; delta[lca]-=2*val; &#125; if(!tot) &#123; for(int i=L[c];i&lt;=R[c];++i) ins(i); &#125; else &#123; dfs_sum(rt[c]); if(tot==1) ins(tmp); for(int i=L[c];i&lt;=R[c];++i) &#123; if(!E[i].tp) continue; int u=E[i].u,v=E[i].v; if(fa[u]==v) swap(u,v); if(delta[v]==tot) ins(i); &#125; &#125; &#125; sort(ans.begin(),ans.end()); int t=ans.size(); printf("%d\n",t); for(int i=0;i&lt;t;++i) printf("%d ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4417 超级跳马]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4417-%E8%B6%85%E7%BA%A7%E8%B7%B3%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[矩阵快速幂. 最朴素的 $dp$ 是设 $f(i,j)$ 表示从出发点走到 $(i,j)$ 的方案数.有一个比较精妙的状态设计, 直接令 $f(2,1)=f(2,2)=1,f(i,j)=f(i-2,j)+f(i-1,j-1)+f(i-1,j)+f(i-1,j+1)$ . 后面三项表示从前一列转移过来的贡献,而 $f(i-2,j)$ 表示从第 $i-3,i-5\dots$ 列转移过来的贡献前缀和. 构造一个 $2n\times 2n$ 的矩阵加速转移,时间复杂度 $O(n^3\cdot \log m)$ . 需要特判 $n=1$ 以及 $m=1$ 的情况. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=30011;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=101;int n,m,N;struct Matrix&#123; int v[MAXN][MAXN]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=0;k&lt;N;++k) for(int i=0;i&lt;N;++i) for(int j=0;j&lt;N;++j) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;Matrix fpow(Matrix a,int b)&#123; Matrix res; for(int i=0;i&lt;2*n;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; n=read(),m=read(); if(m==1) &#123; if(n==1) puts("1"); else puts("0"); return 0; &#125; Matrix trans,st; if(n==1) &#123; st.v[0][0]=1; st.v[1][0]=1; trans.v[0][1]=1; trans.v[1][1]=trans.v[1][2]=1; trans.v[2][1]=1; N=3; st=fpow(trans,m-1)*st; cout&lt;&lt;st.v[0][0]&lt;&lt;endl; return 0; &#125; st.v[0][0]=st.v[1][0]=1; for(int i=0;i&lt;n;++i) &#123; trans.v[i][i]=1; if(i&gt;0) trans.v[i][i-1]=1; if(i&lt;n-1) trans.v[i][i+1]=1; trans.v[i][i+n]=1; &#125; for(int i=n;i&lt;2*n;++i) trans.v[i][i-n]=1; N=2*n; st=fpow(trans,m-2)*st; cout&lt;&lt;st.v[n-1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4416 阶乘字符串]]></title>
    <url>%2F2019%2F07%2F18%2Fbzoj-4416-%E9%98%B6%E4%B9%98%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 设 $f(S)$ 表示从 $1$ 开始,使得集合 $S$ 中元素所有排列均出现的最小长度. 预处理从位置 $i$ 开始,字母 $j$ 首次出现的位置 $nxt(i,j)$ ,可以状压 $dp$ .转移时枚举排列的最后一个元素的位置, $O(2^n\cdot n+len\cdot n)$ . $n\le 26$ ,似乎过不去?然而字符串长度 $\le 450$ ,最小的合法串是 $O(n^2)$ 级别, $n\ge 22$ 时一定无解. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=451,MAXS=(1&lt;&lt;21)+10;int n,nxt[MAXN][26],f[MAXS];char buf[MAXN];void solve()&#123; n=read(); scanf("%s",buf+1); if(n&gt;=22) &#123; puts("NO"); return; &#125; int m=strlen(buf+1); buf[0]=buf[m+1]='#'; for(int j=0;j&lt;n;++j) nxt[m+1][j]=m+1; for(int i=m;i&gt;=0;--i) for(int j=0;j&lt;n;++j) nxt[i][j]=(buf[i+1]-'a'==j)?i+1:nxt[i+1][j]; memset(f,0,sizeof f); int mx=(1&lt;&lt;n)-1; for(int i=1;i&lt;=mx;++i) &#123; for(int j=0;j&lt;n;++j) if((1&lt;&lt;j)&amp;i) f[i]=max(f[i],nxt[f[i^(1&lt;&lt;j)]][j]); &#125; if(f[mx]&lt;=m) puts("YES"); else puts("NO");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190717]]></title>
    <url>%2F2019%2F07%2F17%2Ftest20190717%2F</url>
    <content type="text"><![CDATA[$noip$ 套题. 看了下题,感觉可能 $T1$ 比较麻烦,后面两个大概都是 $noip$ 难度. 于是打算把后面两个写了再做 $T1$ .( $flag$ ) $b$这个题上次 $nicodafagood$ 讲过,当时就直接口胡出来了,做法比较套路. 对第 $4$ 个条件 $\gcd_{i=1}^k a_i=1$ 容斥一下,设 $f(i)$ 表示所有数均为 $i$ 的倍数,不考虑第 $4$ 个条件的答案. 那么原问题答案就是 $f(1)-f(2)-f(3)-f(5)+f(6)\dots$ 有奇数个质因子就减去,偶数个质因子就加上,若它的某个质因子次数 $\ge 2$ ,那么它的贡献一定在算那个质因子的 $f$ 的时候被算入,就不用算了. 所以这个系数就是 $\mu$ ,记不考虑第 $4$ 个条件, $a_i$ 取值范围为 $[1,x]$ 时答案为 $F(x)$ ,即 $f(\lfloor \frac n x \rfloor)$. 原问题答案为 $\sum_{i=1}^n F(\lfloor \frac n i\rfloor)\cdot \mu(i)$ . 显然可以整除分块, $\mu$ 的前缀和用杜教筛计算. 计算 $F(x)$ 也是经典问题,位置 $i$ 的元素加上 $i-1$ ,就变成了求单调递增序列个数,而取值范围变成 $[1,x+k-1]$ . 随便取 $k$ 个数,从小到大排序后恰好对应了一种方案.于是 $F(x)={x+k-1\choose k}$ . $x$ 可能很大,但 $k\le 10^3$ ,所以每次求组合数的时候暴力 $O(k)$ 求,大概就能过了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int N=870963;int prime[N+10],cnt=0,ism[N+10],mu[N+10],summu[N+10];void init()&#123; ism[1]=1; mu[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; mu[i]=P-1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; 1LL*prime[j]*i&lt;=N;++j) &#123; int num=prime[j]*i; ism[num]=1; if(i%prime[j]==0) break; mu[num]=add(P,-mu[i]); &#125; &#125; for(int i=1;i&lt;=N;++i) summu[i]=add(summu[i-1],mu[i]);&#125;map&lt;int,int&gt; mp;int sum(int x)&#123; if(x&lt;=N) return summu[x]; if(mp.find(x)!=mp.end()) return mp[x]; int res=1; for(int l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); res=add(res,mul(P-sum(x/l),r-l+1)); &#125; return mp[x]=res;&#125;int n,k,invfack;int F(int x)&#123; int res=invfack; for(int i=x;i&lt;=x+k-1;++i) res=mul(res,i); return res;&#125;void solve()&#123; n=read(),k=read(); invfack=1; for(int i=2;i&lt;=k;++i) invfack=mul(invfack,i); invfack=inv(invfack); int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); int tmp=add(sum(r),P-sum(l-1)); tmp=mul(tmp,F(n/l)); ans=add(ans,tmp); &#125; printf("%d\n",ans);&#125;int main()&#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); init(); int T=read(); while(T--) solve(); return 0;&#125; $c$显然是点分治. 但点的贡献写起来比边的贡献麻烦,因为根节点的贡献只能贡献一次.所以记录时带上根节点的贡献,查询时不带. 分两种情况讨论一下,一种是最大值在当前点到根节点路径上,另一种是在根节点到另外一个点的路径上. 式子列一列,发现就相当于二维平面内有若干点,要统计 $x=x_0$ ,$y\le y_0$ 或 $y&gt;y_0$ 的点的数目. 按 $x$ 为第一关键字, $y$ 为第二关键字排序. 这个东西还要离散化,我的做法写起来特别麻烦,细节特别多. 一直写,一直改,终于改对的时候就没时间了. 于是 $T1$ 爆零. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;int P,n;inline int add(int a,int b)&#123; return (a + b) % P;&#125;const int MAXN=1e5+10;struct SegTree&#123; int idx,Rt; struct node &#123; int ls,rs; int sum; node()&#123;ls=rs=sum=0;&#125; &#125;Tree[MAXN*30];#define root Tree[o] SegTree()&#123;idx=Rt=0;&#125; int query(int o,ll l,ll r,ll L,ll R) &#123; if(!o || L&gt;R || R&lt;=0) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125; void ins(int &amp;o,ll l,ll r,ll pos,int c) &#123; if(pos&gt;r || pos&lt;l) return; if(!o) o=++idx; root.sum+=c; if(l==r) return; ll mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,l,mid,pos,c); else ins(root.rs,mid+1,r,pos,c); &#125;&#125;T1,T2,T3,T4;typedef pair&lt;int,int&gt; pii;#define mp make_pairint head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],ecnt=0;int val[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;ll ans=0;int rt,mi,totsiz,siz[MAXN],vis[MAXN];void Findrt(int u,int fa)&#123; siz[u]=1; int mxsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; Findrt(v,u); siz[u]+=siz[v]; mxsiz=max(mxsiz,siz[v]); &#125; mxsiz=max(mxsiz,totsiz-siz[u]); if(mxsiz&lt;mi) mi=mxsiz,rt=u;&#125;pii stk1[MAXN],stk2[MAXN];int tp1=0,tp2=0;pii q1[MAXN],q2[MAXN];pii q3[MAXN],q4[MAXN];int t=0,t1,t2;inline int id1l(int sum,int mx)&#123; return lower_bound(q1+1,q1+t1+1,mp(sum,mx))-q1;&#125;inline int id1r(int sum,int mx)&#123; return upper_bound(q1+1,q1+t1+1,mp(sum,mx))-q1-1;&#125;inline int id2l(int sum,int mx)&#123; return lower_bound(q2+1,q2+t2+1,mp(sum,mx))-q2;&#125;inline int id2r(int sum,int mx)&#123; return upper_bound(q2+1,q2+t2+1,mp(sum,mx))-q2-1;&#125;int calc1(int sum,int mx)&#123; ll L=id1l(add(P,mx-sum),0); ll R=id1r(add(P,mx-sum),mx); int k=T1.query(1,1,n,L,R); return k; &#125;int calc2(int sum,int mx)&#123; ll L=id2l(sum,mx-1); ll R=id2r(sum,1000000000); int k=T2.query(1,1,n,L,R); return k;&#125;void dfs_pre(int u,int fa,int sum,int mx)&#123; sum=add(sum,val[u]); mx=max(mx,val[u]); q1[++t]=mp(sum,mx); q2[t]=mp(add(P,mx-sum),mx); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; dfs_pre(v,u,sum,mx); &#125;&#125;void dfs(int u,int fa,int SS,int MM,int sum,int mx)&#123; sum=add(sum,val[u]); mx=max(mx,val[u]); SS=add(SS,val[u]); MM=max(MM,val[u]); ans+=calc1(sum,mx); ans+=calc2(sum,mx); stk2[++tp2]=mp(SS,MM); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; dfs(v,u,SS,MM,sum,mx); &#125;&#125;void solve(int u)&#123; t=0; q1[++t]=mp(val[u]%P,val[u]); q2[t]=mp(0,val[u]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; dfs_pre(v,0,val[u]%P,val[u]); &#125; sort(q1+1,q1+1+t); sort(q2+1,q2+1+t); t1=unique(q1+1,q1+1+t)-q1-1; t2=unique(q2+1,q2+1+t)-q2-1; stk1[tp1=1]=mp(val[u]%P,val[u]); T1.ins(T1.Rt,1,n,id1l(val[u]%P,val[u]),1); T2.ins(T2.Rt,1,n,id2l(0,val[u]),1); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; tp2=0; dfs(v,0,val[u],val[u],0,0); for(int i=1;i&lt;=tp2;++i) &#123; T1.ins(T1.Rt,1,n,id1l(stk2[i].first,stk2[i].second),1); T2.ins(T2.Rt,1,n,id2l(add(P,stk2[i].second-stk2[i].first),stk2[i].second),1); stk1[++tp1]=stk2[i]; &#125; &#125; for(int i=1;i&lt;=tp1;++i) &#123; T1.ins(T1.Rt,1,n,id1l(stk1[i].first,stk1[i].second),-1); T2.ins(T2.Rt,1,n,id2l(add(P,stk1[i].second-stk1[i].first),stk1[i].second),-1); &#125;&#125;void Divide(int u)&#123; vis[u]=1; solve(u); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf; totsiz=siz[v]; Findrt(v,0); Divide(rt); &#125;&#125;int main()&#123; freopen("c.in","r",stdin); freopen("c.out","w",stdout); n=read(),P=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; for(int i=1;i&lt;=n;++i) val[i]=read(); mi=inf; totsiz=n; Findrt(1,0); Divide(rt); cout&lt;&lt;ans+n&lt;&lt;endl; return 0;&#125; $a$暴力 + 最优化剪枝 可过.]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>test</tag>
        <tag>点分治</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4414 数量积]]></title>
    <url>%2F2019%2F07%2F17%2Fbzoj-4414-%E6%95%B0%E9%87%8F%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[结论题. 结论:对于类似斐波那契数列的,满足 $a_i=a_{i-1}+a_{i-2}(i\ge 2),a_1=a_2$ 的数列 $a$ ,有以下等式成立: $$a_1\cdot a_{n+m+1}=a_n\cdot a_m + a_{n+1} \cdot a_{m+1}$$ 等式右边那坨就是我们要求的数量积.即 $v_i\cdot v_j=C\cdot a_{2i+2j+1}$ . 把可以作为数量积的 $O(n)$ 个数全部求出来即可. 证明过程 $sto\ xmk$ . 考虑矩阵乘法. 比较一下最左端的向量和最右端的运算结果即得结论中的等式. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=6e5+10;int n;int res[MAXN],tot=0;int main()&#123; int f1=read(); P=read(),n=read(); int a=0,b=f1%P; for(int i=2;i&lt;=4*n-1;++i) &#123; int c=add(a,b); if((i&amp;1) &amp;&amp; (i&gt;=7)) res[++tot]=mul(c,f1); a=b; b=c; &#125; sort(res+1,res+1+tot); tot=unique(res+1,res+1+tot)-res-1; cout&lt;&lt;tot%P&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4783 矩阵求逆]]></title>
    <url>%2F2019%2F07%2F17%2FLuogu-4783-%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[矩阵求逆板子. 对一个矩阵,定义它的三种初等行变换: 交换某两行. 将某一行的元素全部 $\times k (k\not= 0)$ . 将某一行的元素的 $k$ 倍加到另一行对应位置上去. 每个初等行变换都对应了一个初等矩阵,即,对矩阵 $A$ 做一次初等行变换,等价于用对应的初等矩阵 $P_0$ 左乘 $A$ ,即 $A=P_0A$ . 若矩阵 $A$ 有逆,一定可以通过高斯消元,做有限次初等行变换得到单位矩阵 $I$ .即, $P_kP_{k-1}\dots P_0 A=I$ .根据矩阵乘法的结合律,把前面所有 $P_i$ 看做一个矩阵 $P$ ,即 $PA=I$ ,根据定义, $P$ 就是我们要求的 $A^{-1}$ . 而 $PI=P$ ,所以我们再维护一个矩阵 $B$ ,初始为 $I$ ,高斯消元时同步与 $A$ 做相同的初等行变换,当 $A$ 变为 $I$ 时, 得到的 $B$ 就是我们要求的 $P$ ,即 $A^{-1}$ . 若在高斯消元时发现 $A$ 无法消成 $I$ ,则说明 $A$ 不可逆. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=400+10;int n,A[MAXN][MAXN],B[MAXN][MAXN];void addrow(int a[],int b[],int t)&#123; for(int i=1;i&lt;=n;++i) a[i]=add(a[i],mul(b[i],t));&#125;bool inverse()&#123; for(int i=1;i&lt;=n;++i) B[i][i]=1; for(int i=1;i&lt;=n;++i) &#123; if(!A[i][i]) &#123; for(int j=i+1;j&lt;=n;++j) if(A[j][i]) &#123; swap(A[i],A[j]); swap(B[i],B[j]); break; &#125; &#125; if(!A[i][i]) return false; int inv=fpow(A[i][i],P-2); for(int j=i+1;j&lt;=n;++j) &#123; int x=A[j][i]; addrow(A[j],A[i],P-mul(x,inv)); addrow(B[j],B[i],P-mul(x,inv)); &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; int inv=fpow(A[i][i],P-2); for(int j=1;j&lt;i;++j) &#123; int x=A[j][i]; addrow(A[j],A[i],P-mul(x,inv)); addrow(B[j],B[i],P-mul(x,inv)); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(!A[i][i]) return false; int inv=fpow(A[i][i],P-2); for(int j=1;j&lt;=n;++j) B[i][j]=mul(B[i][j],inv); &#125; return true;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) A[i][j]=read(); if(inverse()) &#123; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%d ",B[i][j]); puts(""); &#125; &#125; else puts("No Solution"); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2019同步赛游记]]></title>
    <url>%2F2019%2F07%2F16%2FNOI2019%E5%90%8C%E6%AD%A5%E8%B5%9B%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[轻松与沉重 $Day -\infty$今年的 CTS 和 APIO 因为一些个人因素没有去. 这期间一边学 OI ,一边上文化课,月考凭借爆算苟了一个级 rk1 . 说起来这还是从初中开始的第一个 rk1 呢,算是完成了一个小心愿?虽然 rk2 拿了好几次… $Day\ 1$做题顺序 $1\to 2\to 3$ . $T1$ 感觉 $70$ 分很可做,大力 $O(\max q\cdot n)$ 来 $dp$ . 不是 $DAG​$ 也没有关系,时间那一维是没有后效性的,先枚举时间就好了. 然后又感觉后面的 $15$ 分也可以做,每个点按照所有的上/下车时间,将 $n$ 个点拆成 $O(m)$ 个点,这部分 $A=0$ ,贡献是线性的,所以对于原来一个点拆出来的所有点,连边时不需要两两连,按时间排序,相邻的才连边,然后跑 $Dijkstra​$ . 感觉这个玩意细节处理起来比较麻烦,只有 $15$ 分,就先放着,去看后面两个题. $T2$ 无想法,写了 $20$ 分暴力就放着了. $T3$ 无想法,写了个 $28$ 分的 $O(n^4)$ 大力 $dp$ 就放着了. 回过去看 $T1$ ,发现 $\max q$ 只有 $1000$ . 算了一下,发现答案不会爆 $int$ ,这样开一个 $\max q\cdot n$ 的二维数组需要 $400\ MB$ 左右?空间限制是 $512\ MB$ ? 那直接 $O(\max q\cdot n)$ 行不行啊,感觉还有很多无效状态的样子.写了一发,开上 $O2$ ,发现大样例要跑 $2s$ .感觉可以寻址优化,于是把二维数组的两个维度交换一下,就只用跑 $0.5s$ 了.这东西能过?虽然不太清楚但也只能先这样了… $T2$ 还是没有什么想法,但发现 $T3$ 费用流应该可以做 $n\le 150$ 的点,说不定 $n\le 2000$ 也可以过. 迅速建了个模,码码码…发现不对.肉眼调试了一会,发现没加反边.(蠢得离谱) 改过来,发现还是不对.调了一会,发现我求的是最小值.把费用改成负的,还是不对? 小数据调了一下,发现建模有问题,流量可以偷偷流走.调整了几波模型,发现流量还是偷偷流走. 可能就没什么时间了.费用流就破产了,把三道题的三个暴力检查了一下,卡了下常数,今天就结束了. 然后出去吃饭,黄学长还吃过敏了… 下午 $4$ 点左右有数据了.测了一下, $100+20+28=148$ ,没挂, 成功 获得暴力分. $Day\ 2$做题顺序 $1\to 2\to 3$ . $T1$ 感觉用 $kdt$ 建图就好了?然后发现空间 128 MB .跑了一波边数,发现开不下. 意识到出题人安排这个空间就是卡 $kdt$ 的?但是貌似想不出其他比较优秀的做法了… 只好头铁写了一波 $kdt$ . 看 $T2$ ,怎么又是 $landlords$ …先写了个 $10$ 分暴力,写 $dp$ 的部分分时候思路很乱,胡乱写了一发,过不了样例.调了一会,未果,只好放着了… $T3$ 是个交互?自己似乎是第一次做这种带端口的交互(之前只在 $CF/ATC$ 上遇到输出命令来交互的题). 有点被吓到,冷静下来分析一波,发现前面 $5$ 个点就是暴力分,每个点改一次,再询问所有点,变了的就是与它有边的. 度数 $=1$ 的部分也比较可做,图是 $N/2$ 个点对,询问次数是 $N\log N$ ,提示得比较明显,每个二进制位都做一次,将当前二进制位为 $1$ 的点 $modify$ 一次,再询问所有点,若它的状态改变,说明它连的点这一位上与它相同,否则不同. 于是就有 $36$ 分的暴力了. 回过去再卡了一下 $T1$ 的空间,就结束了… 下午测了一波, $76+10+36=122$ . 后记果然自己还是菜的真实,打 $\color{brown} {Cu}$ 了.希望明年能作为正式选手取得令自己满意的成绩吧. 结果官方测出来有 $286$ ?虽然还是打 $\color{brown} {Cu}$ 了.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190715]]></title>
    <url>%2F2019%2F07%2F15%2Ftest20190715%2F</url>
    <content type="text"><![CDATA[神仙题,又被虐了. $graph$ $60$ 分做法:将所有方程列出来,因为保证有唯一解,所以不用管方程个数,直接高斯消元.时间复杂度 $O(m^3)$ . 满分做法:比较神仙,注意到条件 $2$ 的形式是电学中基尔霍夫方程组,将 $A$ 看做 $\epsilon$ , $B$ 看做 $R$ , $C$ 看做 $I$ . 为每个节点定义一个电压 $\phi(u)$ ,规定 $\phi (1)=0$ , $\phi(u)=\sum_{i=0}^{k-1} I(v_i,v_{i+1})\cdot R(v_i,v_{i+1})-\epsilon (v_i,v_{i+1})$ ,其中 $&lt;v_0=1,v_1,\dots,v_{k-1},v_k=u&gt;$ 是原图中一条路径,这样定义也满足了条件 $3$ . 容易验证无论选择怎样的路径,每个点的电压值都是不变的.利用条件 $1$ 列出 $n-1$ 个方程,高斯消元解出 $2\sim n$ 的电压,再根据 $I(u,v)=\frac {\phi(u)-\phi(v)+\epsilon(u,v)} {R(u,v)}$ 求出电流.时间复杂度 $O(n^3)$ . 考试情况:只写了 $60$ 分的做法. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)#define repk(i,a,b) rep(i,a,(b)-1)#define rrep(i,a,b) for(int i=(b);i&gt;=(a);i--)#define rrepk(i,a,b) rrep(i,a,(b)-1)#define fe(e,x) for(edge *e = (x)-&gt;first;e;e = e-&gt;next)#define foreach(tank_type,iterator_name,set_name) \ for(tank_type::iterator iterator_name = (set_name).begin();iterator_name != (set_name).end();iterator_name++)#define comp_def(cmp_name,type) bool cmp_name(type l,type r)#define ifn(x) if(!(x))#define vind(p_point) (p_point-points)#define eind(p_edge) (p_edge-edges)#define eopp(p_edge) (edges+(eind(p_edge)^1))#define mp(x,y) make_pair((x),(y))typedef long long ll;const int inf = 0x3fffffff,upinf = 0x7fffffff,geps = 10;const double eps = 1e-12,dinf = 1e20;ll modnum;struct modll&#123; ll x; modll():x(0)&#123;&#125; modll(ll _x)&#123; _x &lt; 0 ? x = _x % modnum + modnum : (_x &gt;= modnum ? x = _x % modnum : x = _x); &#125; inline static ll pmod(ll _x)&#123; return _x &gt;= modnum ? _x - modnum : _x; &#125; inline static ll plus(ll x,ll y)&#123; return pmod(x + y); &#125; inline static ll minus(ll x,ll y)&#123; return pmod(x + modnum - y); &#125; inline static ll multi(ll x,ll y)&#123; ll s = 0; for(;y;y&gt;&gt;=1)&#123; if(y&amp;1) s = plus(s,x); x = plus(x,x); &#125;return s; &#125; inline static ll inv(ll a)&#123; ll b = modnum,c = a%b,q = a/b,k1 = 1,k2 = 0,k3 = pmod(minus(k1,multi(q,k2))); while(c^1) a = b,b = c,c = a%b,q = a/b,k1 = k2,k2 = k3,k3 = pmod(minus(k1,multi(q,k2))); return k3; &#125; inline static ll llpow(ll b,ll p)&#123; ll s = 1; for(;p;p&gt;&gt;=1)&#123; if(p&amp;1) s = multi(s,b); b = multi(b,b); &#125;return s; &#125;&#125;;bool operator==(modll l,modll r)&#123;return l.x == r.x;&#125;bool operator!=(modll l,modll r)&#123;return l.x != r.x;&#125;modll operator+(modll l,modll r)&#123;return modll(modll::plus(l.x,r.x));&#125;modll operator-(modll l,modll r)&#123;return modll(modll::minus(l.x,r.x));&#125;modll operator*(modll l,modll r)&#123;return modll(modll::multi(l.x,r.x));&#125;modll operator/(modll l,modll r)&#123;return modll(modll::multi(l.x,modll::inv(r.x)));&#125;modll operator^(modll l,ll r)&#123; return r &lt; 0 ? modll(modll::llpow(modll::inv(l.x),-r)) : modll(modll::llpow(l.x,r));&#125;modll operator-(modll l)&#123;return modll(-l.x);&#125;modll operator+=(modll&amp; l,modll r)&#123;return modll(l.x = modll::plus(l.x,r.x));&#125;modll operator-=(modll&amp; l,modll r)&#123;return modll(l.x = modll::minus(l.x,r.x));&#125;modll operator*=(modll&amp; l,modll r)&#123;return modll(l.x = modll::multi(l.x,r.x));&#125;modll operator/=(modll&amp; l,modll r)&#123;return modll(l.x = modll::multi(l.x,modll::inv(r.x)));&#125;modll operator^=(modll&amp; l,ll r)&#123; return modll( l.x = r &lt; 0 ? modll::llpow(modll::inv(l.x),-r) : modll::llpow(l.x,r) );&#125;const int maxn = 100,maxm = 2000;struct equation&#123; modll dat[maxn][maxn + geps]; int n; void clear(int _n)&#123; n = _n; repk(i,0,n) repk(j,0,n+1) dat[i][j].x = 0; &#125; modll&amp; operator()(int i,int j)&#123;return dat[i][j];&#125; void rowswap(int r1,int r2)&#123; repk(j,0,n+1) swap(dat[r1][j],dat[r2][j]); &#125; void elimination(int r1,int r2)&#123;//eliminate r2 from r1 modll g = dat[r2][r1]/dat[r1][r1]; repk(j,0,n+1) dat[r2][j] -= dat[r1][j] * g; &#125; vector&lt;modll&gt; getans()&#123; vector&lt;modll&gt; ans; repk(i,0,n)&#123; if(dat[i][i] == 0)&#123; repk(j,i+1,n) if(dat[i][j] != 0) &#123;rowswap(i,j);break;&#125; if(dat[i][i] == 0) return ans; &#125;repk(j,0,n) if(i != j) elimination(i,j); &#125;repk(i,0,n) ans.push_back(dat[i][n] / dat[i][i]); return ans; &#125;&#125;;struct Graph&#123; equation Eq;pair&lt;int,int&gt; edge[maxm]; modll As[maxm],Bs[maxm]; int V,E; void create(int _V)&#123;Eq.clear(V = _V);E = 0;&#125; void addedge(int u,int v,modll A,modll B)&#123; Eq(v,v) += 1/B; Eq(v,u) -= 1/B; Eq(v,V) -= A/B; Eq(u,v) -= 1/B; Eq(u,u) += 1/B; Eq(u,V) += A/B; As[E] = A,Bs[E] = B; edge[E++] = make_pair(u,v); &#125; vector&lt;ll&gt; solve_graph()&#123; repk(j,0,V+1) Eq(V-1,j) = 0; Eq(V-1,V-1) = 1; vector&lt;modll&gt; Por = Eq.getans(); vector&lt;ll&gt; ans; if(Por.size() == 0) return ans; repk(i,0,E)&#123; int u = edge[i].first,v = edge[i].second; ans.push_back(((Por[v] - Por[u] + As[i]) / Bs[i]).x); &#125;return ans; &#125;&#125;G;int n,m;void Init()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;modnum);G.create(n); int x,y;ll A,B; repk(i,0,m)&#123; scanf("%d%d%lld%lld",&amp;x,&amp;y,&amp;A,&amp;B); G.addedge(x-1,y-1,A,B); &#125;&#125;void solve()&#123; vector&lt;ll&gt; ans = G.solve_graph(); if(ans.size() == 0) printf("-1\n"); else foreach(vector&lt;ll&gt;,it,ans) printf("%lld\n",*it);&#125;int main()&#123; freopen("graph.in","r",stdin); freopen("graph.out","w",stdout); Init(); solve(); return 0;&#125; $grid$ $40$ 分做法:设 $f(s,i,j,d)$ 表示两人各自都走了 $s$ 步,以 $(1,1)$ 作为左下角,第一个人向右走了 $i$ 步,第二个人向右走了 $j$ 步,一共已经经过了 $d$ 个特殊点时的方案数.两人交换算一种方案,限制 $j\le i$ , $O(n^4)$ 大力 $dp$ . 满分做法:先考虑一条路径的方案数,将特殊点按照 $x+y$ 排序,那么一条路径上出现的特殊点的编号递增. 设 $f(i,j)$ 表示走到了第 $i$ 个特殊点,此前经过了 $j$ 个特殊点的方案数, $g(i,j)$ 表示从第 $i$ 个特殊点走到第 $j$ 个特殊点而不经过其他特殊点的方案数.枚举上一个走过的特殊点是 $k$ , $$f(i,j)=\sum_{k=1}^{i-1} f(k,j-1)\cdot g(k,i)$$ 把起点看做 $0$ 号点,终点看做 $C+1$ 号点,方案数为: $$ans=\sum_{i=0}^D f(C+1,i)$$ 考虑如何求 $g(i,j)$ .若不考虑特殊点,从 $(x_0,y_0)$ 走到 $(x_1,y_1)$ 的方案数显然是 $x_1-x_0+y_1-y_0\choose x_1-x_0$ . 记 $h(i,j)$ 表示从特殊点 $i$ 到特殊点 $j$ 的方案数(不考虑限制),枚举不合法路径上的第一个点 $k$ , $$g(i,j)=h(i,j)-\sum_{k=i+1}^{j-1} g(i,k)\cdot h(k,j)$$ 于是我们用 $O(C^3)$ 的时间复杂度解决了一条路径经过特殊点个数不超过 $D$ 的方案数. 到目前为止的部分和 这个题 做法是差不多的. 若要求两条不相交路径的方案数,将两条路径看做 $(1,2)\to (n-1,m)$ 与 $(2,1) \to (n,m-1)$ . 记它们为 $s_1\to t_1,s_2\to t_2$ .容斥一下,用总方案数减去路径相交的方案数. 若两条路径相交于点 $p$ ,可以将它们的后半段交换,得到 $s_1\to p\to t_2$ 与 $s_2\to p \to t_1$ 两条路径. 于是可以断言,所有的 $s_1\to t_2$ 与所有的 $s_2\to t_1$ 一定是一一对应的,且对应的两条路径一定相交. 那么最终答案为 $s_1\to t_1,s_2\to t_2$ 的方案数乘积减去 $s_1\to t_2$ 与 $s_2\to t_1$ 的方案数之和,不需要不相交,直接套用前部分算一条路径的方案数即可. 模数不为质数时,无法直接预处理阶乘逆元,需要分解质因子, $mod=\prod p_i^k$ ,处理每个质因子的时候,位置 $p_i^j$ 特判,其余位置直接求逆元,最后再用 $CRT$ 合并答案. 考试情况:只写了 $40$ 分的部分. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long long#define mkp make_pair#define fir first#define sec secondusing namespace std;const int MaxN = 200010, Log = 10;int fac[MaxN], facpow[MaxN][Log], facinv[MaxN];int factor[Log], ftot;int mod;void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x;&#125;int get_inv(int a) &#123; int x, y; exgcd(a, mod, x, y); return ((x % mod) + mod) % mod;&#125;int power(ll x, int l) &#123; ll ret = 1; for (; l; l &gt;&gt;= 1, x = x * x % mod) if (l &amp; 1) ret = ret * x % mod; return ret;&#125;void init(int n) &#123; ftot = 0; int x = mod; for (int i = 2; i * i &lt;= mod; ++i) if (x % i == 0) &#123; factor[ftot++] = i; while (x % i == 0) x /= i; &#125; if (x != 1) factor[ftot++] = x; fac[0] = facinv[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int x = i; memcpy(facpow[i], facpow[i - 1], sizeof facpow[i]); for (int j = 0; j &lt; ftot; ++j) while (x % factor[j] == 0) &#123; x /= factor[j]; ++facpow[i][j]; &#125; fac[i] = 1ll * fac[i - 1] * x % mod; facinv[i] = get_inv(fac[i]); &#125;&#125;int comb(int n, int m) &#123; int ret = 1ll * fac[n] * facinv[m] % mod * facinv[n - m] % mod; for (int j = 0; j &lt; ftot; ++j) ret = 1ll * ret * power(factor[j], facpow[n][j] - facpow[m][j] - facpow[n - m][j]) % mod; return ret;&#125;const int MaxC = 210;int n, m, c, d;int f[MaxC][MaxC], g[MaxC][MaxC], ways[MaxC][MaxC];bool mark[MaxC][MaxC];int a[2][2][MaxC], ans[MaxC];pair &lt;int, int&gt; car[MaxN];inline bool tless(pair &lt;int, int&gt; a, pair &lt;int, int&gt; b) &#123; return (a.fir &lt;= b.fir) &amp;&amp; (a.sec &lt;= b.sec);&#125;void init_car() &#123; memset(ways, 0, sizeof(ways)); memset(f, 0, sizeof(f)); memset(mark, 0, sizeof(mark)); for (int i = 1; i &lt;= c; ++i) for (int j = i; j &lt;= c; ++j) if (tless(car[i], car[j])) &#123; ways[i][j] = comb(car[j].fir - car[i].fir + car[j].sec - car[i].sec, car[j].fir - car[i].fir); mark[i][j] = 1; &#125; for (int i = 1; i &lt;= c; ++i) for (int j = 1; j &lt;= c; ++j) if (mark[i][j]) &#123; f[i][j] = ways[i][j]; for (int k = i + 1; k &lt; j; ++k) if (mark[i][k] &amp;&amp; mark[k][j] &amp;&amp; f[i][k]) &#123; f[i][j] = (f[i][j] - 1ll * f[i][k] * ways[k][j]) % mod; &#125; &#125;&#125;void calc(int a[], int sx, int sy, int tx, int ty) &#123; fill(a, a + c + 1, 0); car[0] = mkp(sx, sy); car[c + 1] = mkp(tx, ty); if (!tless(car[0], car[c + 1])) return; //init f[0][], f[][c + 1] for (int i = 0; i &lt;= c + 1; ++i) if (tless(car[0], car[i])) &#123; f[0][i] = ways[0][i] = comb(car[i].fir - sx + car[i].sec - sy, car[i].fir - sx); mark[0][i] = 1; for (int j = 1; j &lt; i; ++j) if (mark[0][j] &amp;&amp; mark[j][i] &amp;&amp; f[0][j]) f[0][i] = (f[0][i] - 1ll * f[0][j] * ways[j][i]) % mod; &#125; else &#123; f[0][i] = ways[0][i] = mark[0][i] = 0; &#125; for (int i = c + 1; i &gt;= 0; --i) if (tless(car[i], car[c + 1])) &#123; f[i][c + 1] = ways[i][c + 1] = comb(tx - car[i].fir + ty - car[i].sec, tx - car[i].fir); mark[i][c + 1] = 1; for (int j = i + 1; j &lt;= c; ++j) if (mark[i][j] &amp;&amp; mark[j][c + 1] &amp;&amp; f[i][j]) &#123; f[i][c + 1] = (f[i][c + 1] - 1ll * f[i][j] * ways[j][c + 1]) % mod; &#125; &#125; else &#123; f[i][c + 1] = ways[i][c + 1] = mark[i][c + 1] = 0; &#125; memset(g, 0, sizeof(g)); g[0][0] = 1; for (int i = 1; i &lt;= c + 1; ++i) for (int j = 1; j &lt;= d + 1; ++j) for (int k = 0; k &lt; i; ++k) &#123; g[i][j] = (g[i][j] + 1ll * g[k][j - 1] * f[k][i]) % mod; &#125; for (int i = 0; i &lt;= d + 1; ++i) a[i] = g[c + 1][i + 1];// for (int i = 0; i &lt;= d + 1; ++i) printf("%d ", a[i]); puts(";");&#125;void Main() &#123; scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;c, &amp;d, &amp;mod); init(n + m); for (int i = 1; i &lt;= c; ++i) scanf("%d%d", &amp;car[i].fir, &amp;car[i].sec); sort(car + 1, car + c + 1); init_car(); calc(a[0][0], 1, 2, n - 1, m); calc(a[0][1], 1, 2, n, m - 1); calc(a[1][0], 2, 1, n - 1, m); calc(a[1][1], 2, 1, n, m - 1); int ret = 0; memset(ans, 0, sizeof(ans)); for (int i = 0; i &lt;= d; ++i) &#123; for (int j = 0; j &lt;= i; ++j) ans[i] = (ans[i] + 1ll * a[0][0][j] * a[1][1][i - j] - 1ll * a[0][1][j] * a[1][0][i - j]) % mod; ret += (ans[i] &lt; 0 ? ans[i] += mod : ans[i]); ret &gt;= mod ? ret -= mod : ret; &#125; cout &lt;&lt; ret &lt;&lt; endl;&#125;int main()&#123; freopen("grid.in", "r", stdin); freopen("grid.out", "w", stdout); int T; scanf("%d", &amp;T); while (T--) Main(); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>高斯消元</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190714]]></title>
    <url>%2F2019%2F07%2F15%2Ftest20190714%2F</url>
    <content type="text"><![CDATA[又被虐了. $Fable$ 每做一次冒泡,对于一个数 $a_i$ ,若 $i$ 之前的位置有比它大的数,那么其中一个一定会跳到它的后面. 则它的位置向前移了一位,比它大的数少了一个. 初始时,若前面比它大的数的个数 $\ge k$ ,则说明每次都能往前移,最后的位置就是初始位置 $-k$ .对于剩下的数,它们最后一定会从小到大把剩余的位置补满. 离散化 + 树状数组处理. 考试情况:大部分时间都在想/写/调这个题.最后 $A$ 了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,k;typedef pair&lt;int,int&gt; pii;pii a[MAXN];int ans[MAXN],tot[MAXN],rk[MAXN];int bit[MAXN];#define lowbit(x) x&amp;(-x)void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c;&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s;&#125;int main()&#123; freopen("fable.in","r",stdin); freopen("fable.out","w",stdout); n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i].second=i,a[i].first=read(); sort(a+1,a+1+n); rk[a[1].second]=1; for(int i=2;i&lt;=n;++i) &#123; if(a[i].first==a[i-1].first) rk[a[i].second]=rk[a[i-1].second]; else rk[a[i].second]=i; &#125; for(int i=1;i&lt;=n;++i) &#123; add(rk[i],1); tot[i]=sum(n)-sum(rk[i]); if(tot[i]&gt;k) ans[i-k]=a[rk[i]].first; &#125; int pos=1; for(int i=1;i&lt;=n;++i) &#123; if(tot[a[i].second]&lt;=k) &#123; while(pos&lt;=n &amp;&amp; ans[pos]) ++pos; ans[pos]=a[i].first; &#125; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125; $Fiend$ 看到 排列,逆序对 ,考虑构造矩阵,观察其行列式. 构造一个矩阵 $A_{i,j}=[L_i\le j\le R_i]$ ,考虑它的行列式定义: $$|A|=\sum_{p\in S_n} sgn(p) \prod_{i=1}^k A_{i,p_i}$$ 对于一种排列 $p$ ,若存在 $L_i\leq p_i\le R_i$ 不成立,则 $A_{i,p_i}=0$ ,对于求和的贡献就是 $0$ . 否则,若逆序对数为偶数,贡献为 $1$ ,逆序对数为奇数,贡献为 $-1$ ,于是只需要判断 $|A|$ 的符号. 直接高斯消元是 $O(n^3)$ 的,可以获得 $70$ 分.由于构造的这个矩阵比较特殊,尝试手动消元. 每一行的 $1$ 都是一段区间,尝试在消元时保持每一行的 $1$ 仍然是一段区间.从小到大枚举 $x$ ,找出所有 $L_i=x$ 的行,找出其中 $R_k$ 最小的那一行 $k$ ,用第 $k$ 行去消其他的 $L_i=x$ 的行. 这些行被消过之后,其中的 $1$ 仍是一段区间,只是左端点变为了 $R_{k+1}$ .维护 $n$ 个集合, $i$ 号集合内存储左端点 $=i$ 的元素,每个元素记录它的行号,右端点. 从小到大枚举 $x$ ,将 $x$ 号集合的元素,除了 $R_k$ ,都放入 $R_{k+1}$ 号集合.用线段树合并实现. 考试情况:构造矩阵的时候不知道怎么就错了,于是感觉不可做,此题爆零. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairstruct node&#123; int val,pos,h; int ls,rs; node(int Val=0,int Pos=0) &#123; ls=rs=h=0; val=Val; pos=Pos; &#125;&#125;Tree[MAXN&lt;&lt;2];int merge(int a,int b)&#123; if(!a || !b) return a+b; if(Tree[a].val&gt;Tree[b].val) swap(a,b); Tree[a].rs=merge(Tree[a].rs,b); if(Tree[Tree[a].ls].h&lt;Tree[Tree[a].rs].h) swap(Tree[a].ls,Tree[a].rs); Tree[a].h=Tree[Tree[a].rs].h+1; return a;&#125;int n,rt[MAXN],id[MAXN],tmp[MAXN];int Calc_Det()&#123; int prod=1; for(int i=1;i&lt;=n;++i) &#123; if(!rt[i]) return 0; node cur=Tree[rt[i]]; rt[i]=merge(Tree[rt[i]].ls,Tree[rt[i]].rs); if(rt[i] &amp;&amp; Tree[rt[i]].val==cur.val) return 0; if(id[cur.pos]!=i) &#123; prod*=-1; int x=tmp[i]; swap(tmp[id[cur.pos]],tmp[i]); swap(id[cur.pos],id[x]); &#125; if(cur.val&lt;n) rt[cur.val+1]=merge(rt[cur.val+1],rt[i]); &#125; return prod;&#125;void solve()&#123; n=read(); for(int i=1;i&lt;=n;++i) rt[i]=0; for(int i=1;i&lt;=n;++i) &#123; int L=read(),R=read(); Tree[i]=node(R,i); id[i]=tmp[i]=i; rt[L]=merge(rt[L],i); &#125; int ans=Calc_Det(); if(ans&lt;0) puts("F"); else if(ans==0) puts("D"); else puts("Y");&#125;int main()&#123; freopen("fiend.in","r",stdin); freopen("fiend.out","w",stdout); int T=read(); while(T--) solve(); return 0;&#125; $Flair$ 分成两部分做,记恰好选 $i$ 道菜的概率为 $A_i$ ,浪费掉的钱为 $B_i$ ,答案为 $\sum_{i=0}^n A_i\cdot B_i$. 答案扩大 $100^n$ 倍,所以 $A_i=p^i\cdot (100-p)^{n-i}\cdot {n\choose i}$ .考虑如何计算 $B_i$ . 若将 $c_i$ 从小到大排序,在模 $c_1$ 意义下对金额跑最短路,显然长度不会超过 $c_1$ ,而每一步的权值不超过 $c_2$ ,所以浪费金额在 $c_1\cdot c_2$ 内, $B_i$ 就会以 $c_1$ 为周期循环. 记 $len=c_1\cdot c_2,per=c_1$ .需要计算出 $A_0,A_1,\dots,A_{len-1}$ 与 $D_j=\sum_{i\ge len,i\ mod\ per=j} A_i$ . 于是答案就为 $\sum_{i=0}^{len-1} A_i\cdot B_i+\sum_{j=0}^{per-1} \lceil \frac {n-len+1-j} {per} \rceil \cdot B_j\cdot D_j$ . $D$ 就是多项式 $(px+1-p)^n$ 长度为 $c_1$ 的循环卷积结果再减去 $&lt;len$ 的部分. 使用 $NTT$ 优化这个卷积.但 $P=10^9+7$ ,所以还要用 $MTT$ .(好毒啊) 考试情况:推出了 $B_i$ 的循环性质,但没有联想到循环卷积,于是只得了 $10$ 分暴力分.]]></content>
      <tags>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>树状数组</tag>
        <tag>多项式</tag>
        <tag>test</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4407 于神之怒加强版]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4407-%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 假定 $n\leq m$ ,推式子. 把后面那个 $\sum_{d|x} \mu(\frac x d) \cdot d^k$ 看做关于 $x$ 的函数 $f(x)$ ,它显然是个积性函数,因为可以看成 $\mu(x)$ 与 $x^k$ 的卷积. 线性筛预处理出 $f(x)$ 的前缀和,然后整除分块计算即可. 时间复杂度 $O(n+T\cdot \sqrt n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P?a+b-P:a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=5e6+10;int ism[MAXN],prime[MAXN],cnt=0,mu[MAXN],pw[MAXN];int k,sum[MAXN],f[MAXN];void init(int n)&#123; f[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; pw[i]=fpow(i,k); f[i]=add(pw[i],P-1); &#125; for(int j=1;j&lt;=cnt &amp;&amp; 1LL*i*prime[j]&lt;=n;++j) &#123; int x=i*prime[j]; ism[x]=1; pw[x]=mul(pw[i],pw[prime[j]]); if(i%prime[j]==0) &#123; f[x]=mul(f[i],pw[prime[j]]); break; &#125; f[x]=mul(f[i],f[prime[j]]); &#125; &#125; for(int i=1;i&lt;=n;++i) sum[i]=add(sum[i-1],f[i]);&#125;int n,m;int main()&#123; int T=read(); k=read(); init(5000000); while(T--) &#123; n=read(),m=read(); if(n&gt;m) swap(n,m); int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); int tmp=mul(n/l,m/l); tmp=mul(tmp,add(sum[r],P-sum[l-1])); ans=add(ans,tmp); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4403 序列统计]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[组合计数 + $Lucas$ 定理. 把位置 $i$ 上的数加上它的下标,就变成求单调上升序列的数目了. 即,对于长度为 $i$ 的序列,权值范围变为 $[l+1,r+i]$ .方案数显然为 $r-l+i \choose i$ ,即在权值范围内任选 $i$ 个不同的数,排序后就是一个单调上升序列. 答案为 $\sum_{i=1}^n {r-l+i\choose i}={r-l+1+n\choose n}-1$ . $-1$ 是减去长度为 $0$ 的情况. $P=10^6+3$ ,且是个质数,用 $Lucas$ 定理计算组合数即可.时间复杂度 $O(P+T\cdot \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e6+3;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int fac[P+10],invfac[P+10];void init()&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;P;++i) fac[i]=mul(fac[i-1],i); invfac[P-1]=fpow(fac[P-1],P-2); for(int i=P-2;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int n,int m)&#123; if(n&lt;0 || m&lt;0 || n&gt;m) return 0; if(n&lt;P &amp;&amp; m&lt;P) return mul(fac[m],mul(invfac[n],invfac[m-n])); return mul(C(n/P,m/P),C(n%P,m%P));&#125;int main()&#123; init(); int T=read(); while(T--) &#123; int n=read(),L=read(),R=read(); int m=R-L+1; printf("%d\n",add(C(n,m+n),P-1)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4402 Claris的剑]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4402-Claris%E7%9A%84%E5%89%91%2F</url>
    <content type="text"><![CDATA[组合计数. 求本质不同的序列数目,考虑以最小字典序表示序列,进行计数. 设序列中出现的最大值为 $m$ ,那么序列用最小字典序表示后只有下面两种情况: $1,(2,1,2,1\dots),2,(3,2,3,2\dots),3,\dots m$ . 或者 $1,(2,1,2,1\dots),2,(3,2,3,2\dots),3,\dots m,m-1$ . 若序列长度为 $n$ ,第一种情况可以看做 $\lfloor \frac {n-m} 2 \rfloor$ 个相同的球放入 $m-1$ 个盒子的方案数.盒子可以为空. 第二种情况可以看做$\lfloor \frac {n-m-1} 2 \rfloor$ 个相同的球放入 $m-1$ 个盒子的方案数.盒子可以为空. 枚举 $m$ ,由于长度是 $\le N$ 的,所以相当于那些球也可以不放.预处理阶乘及其逆元后 $O(M)$ 计算即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=2e6+10;int fac[MAXN],invfac[MAXN];int C(int n,int m)&#123; return mul(fac[m],mul(invfac[n],invfac[m-n]));&#125;int calc(int n,int m)&#123; return C(n,m+n-1);&#125;void Init_Fac(int n)&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=fpow(fac[n],P-2); for(int i=n-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int main()&#123; int N=read(),M=read(); Init_Fac((N+M)&gt;&gt;1); int ans=1;//m=1 for(int m=2;m&lt;=N &amp;&amp; m&lt;=M;++m) &#123; ans=add(ans,calc((N-m)&gt;&gt;1,m)); if(N&gt;=m+1) ans=add(ans,calc((N-m-1)&gt;&gt;1,m)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4419 发微博]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4419-%E5%8F%91%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[乱搞. 对每个人 $i$ 维护一个标记 $val_i$ ,表示这个人发过了多少条微博. 如果新连上一个点 $j$ , $ans_j-=val_i$ ,若断开一个点 $j$ , $ans_j+=val_i$ . 最后再将所有边断掉即可. 注意自己发的微博不计入自己的贡献. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,ans[MAXN],val[MAXN];set&lt;int&gt; s[MAXN];set&lt;int&gt;::iterator it;int main()&#123; n=read(),m=read(); while(m--) &#123; char buf[2]; scanf("%s",buf); if(buf[0]=='!') &#123; int x=read(); ++val[x]; &#125; else if(buf[0]=='+') &#123; int x=read(),y=read(); ans[x]-=val[y]; ans[y]-=val[x]; s[x].insert(y); s[y].insert(x); &#125; else &#123; int x=read(),y=read(); ans[x]+=val[y]; ans[y]+=val[x]; s[x].erase(y); s[y].erase(x); &#125; &#125; for(int i=1;i&lt;=n;++i) for(it=s[i].begin();it!=s[i].end();++it) &#123; int j=*it; s[i].erase(j); s[j].erase(i); ans[i]+=val[j]; ans[j]+=val[i]; &#125; printf("%d",ans[1]); for(int i=2;i&lt;=n;++i) printf(" %d",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1191]]></title>
    <url>%2F2019%2F07%2F13%2FCF1191%2F</url>
    <content type="text"><![CDATA[$Div.2$ 怎么出了两个博弈的题啊… A Tokitsukaze and Enhancement 模拟即可. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int x=read(); x%=4; if(x==0) puts("1 A"); else if(x==1) puts("0 A"); else if(x==2) puts("1 B"); else puts("2 A"); return 0;&#125; B Tokitsukaze and Mahjong 模拟即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;char buf[3][3];int k1(int i)&#123; return buf[i][0];&#125;int k2(int i)&#123; return buf[i][1];&#125;bool equal(int i,int j)&#123; return k1(i)==k1(j) &amp;&amp; k2(i)==k2(j);&#125;bool nx(int i,int j)&#123; return abs(k1(i)-k1(j))&lt;=2 &amp;&amp; k2(i)==k2(j);&#125;int main()&#123; for(int i=1;i&lt;=3;++i) scanf("%s",buf[i]); if(k1(1)==k1(2) &amp;&amp; k1(1)==k1(3) &amp;&amp; k2(1)==k2(2) &amp;&amp; k2(2)==k2(3)) &#123; puts("0"); return 0; &#125; if(k2(1)==k2(2) &amp;&amp; k2(1)==k2(3)) &#123; int a[3]; a[0]=k1(1),a[1]=k1(2),a[2]=k1(3); sort(a,a+3); if(a[1]-a[0]==1 &amp;&amp; a[2]-a[1]==1) &#123; puts("0"); return 0; &#125; &#125; if(equal(1,2) || equal(1,3) || equal(2,3)) puts("1"); else if(nx(1,2) || nx(1,3) || nx(2,3)) puts("1"); else puts("2"); return 0;&#125; C Tokitsukaze and Discard Items 模拟删数的过程,二分找出此次删掉的最后一个数. 每次至少删掉一个数,时间复杂度 $O(m\cdot \log m)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;ll p[MAXN];int x=1,m;int bs(ll lim,int tot)&#123; int L=x,R=m; int ans=x; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(p[mid]-tot&lt;=lim) ans=mid,L=mid+1; else R=mid-1; &#125; return ans;&#125;int main()&#123; ll n=read(); m=read(); ll k=read(); for(int i=1;i&lt;=m;++i) p[i]=read()-1; int tot=0,ans=0; while(tot!=m) &#123; ll pos=(p[x]-tot)/k; ll y=bs(pos*k+k-1,tot); ans++; tot+=y-x+1; x=y+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Tokitsukaze, CSL and Stone Game 感觉思路已经非常接近正解了,但有个情况没判到. 除了先手第一次拿后就必败,最后一定是石子数形成 $0,1,2,\dots n-1$ 的排列. 记初始时石子数为 $x$ 的有 $cnt_x$ 堆,特判一下先手第一次拿后就必败的情况: 若第一次取后未败,则只需判断使局面形成 $0,1,2,\dots n-1$ 的排列需要取的石头的奇偶性. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN],p[MAXN];unordered_map&lt;int,int&gt; cnt;bool check()&#123; if(cnt[0]==n) return true; if(cnt[0]&gt;=2) return true; int k=0; sort(p+1,p+1+n); int m=unique(p+1,p+1+n)-p-1; for(int i=1;i&lt;=m;++i) &#123; int x=p[i]; if(cnt[x]&gt;=3) return true; if(cnt[x]==2 &amp;&amp; cnt[x-1]&gt;=1) return true; if(cnt[x]==2) ++k; &#125; if(k&gt;=2) return true; return false;&#125;int main()&#123; n=read(); int s=0; for(int i=1;i&lt;=n;++i) &#123; p[i]=a[i]=read(); ++cnt[p[i]]; &#125; if(check()) return puts("cslnb")&amp;0; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) s^=(a[i]-i+1)&amp;1; if(s) puts("sjfnb"); else puts("cslnb"); return 0;&#125; E Tokitsukaze and Duel 给一段 $0/1$ 序列,双方轮流操作,每次操作将一段长度为 $k$ 的区间全部变成一个值,操作后使得整个序列全是 $0$ 或全是 $1$ 的人获胜.可能出现无限操作下去的情况,判为平局. 注意到一个人若第一次操作无法直接取胜,那么他永远也无法取胜,因为对方总是可以通过执行相反的操作. 于是先判断一下先手能否一次操作取胜,再判断一下是否先手第一次无论怎样操作,后手总能一次操作取胜. 若两者都不能取胜,则为平局. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k,a[MAXN],sum[MAXN];int pre[MAXN][2],nxt[MAXN][2];char s[MAXN];bool first_win(int p)&#123; int l=p,r=p+k-1; if(sum[l-1]+sum[n]-sum[r]+k==n) return true; if(sum[l-1]+sum[n]-sum[r]==0) return true; return false;&#125;int find_first(int L,int R,int x)&#123; int s=nxt[L][x]; if(s==0 || s&gt;R) return 0; return s;&#125;int find_last(int L,int R,int x)&#123; int s=pre[R][x]; if(s==0 || s&lt;L) return 0; return s; &#125;bool second_win(int p,int x)&#123; int l=p,r=p+k-1; int L,R; L=find_first(1,l-1,x); if(!L) L=find_first(r+1,n,x); R=find_last(r+1,n,x); if(!R) R=find_last(1,l-1,x); assert(L &amp;&amp; R); return R-L+1&lt;=k;&#125;bool Second_win(int p)&#123; return second_win(p,0) &amp;&amp; second_win(p,1);&#125;int main()&#123; n=read(),k=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i) &#123; a[i]=s[i]-'0'; sum[i]=sum[i-1]+a[i]; &#125; for(int i=1;i&lt;=n;++i) &#123; pre[i][0]=(a[i]==0)?i:pre[i-1][0]; pre[i][1]=(a[i]==1)?i:pre[i-1][1]; &#125; for(int i=n;i&gt;=1;--i) &#123; nxt[i][0]=(a[i]==0)?i:nxt[i+1][0]; nxt[i][1]=(a[i]==1)?i:nxt[i+1][1]; &#125; bool f=true; for(int i=1;i+k-1&lt;=n;++i) &#123; if(first_win(i)) &#123; puts("tokitsukaze"); return 0; &#125; if(f &amp;&amp; !Second_win(i)) f=false; &#125; if(f) puts("quailty"); else puts("once again"); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>codeforces</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4598 模式字符串]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4598-%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[点分治 + $hash$ . 考虑点分治.由于分治时路径起点不确定,无法直接匹配,所以需要 $hash$ 暂时存储状态. 若当前分治中心为 $rt$ ,维护 $pre(i),suf(i)$ 分别表示节点 $i$ 到 $rt$ 的路径, $rt$ 到 $i$ 的路径的 $hash$ 值. 到一个点,先算得它的 $pre$ ,在后面接上 $rt$ 的字符,判断这个串在循环意义下是否与模式串的某个前缀匹配. 可以反着推,假设它能与某个前缀循环匹配,那么根据这个串的长度,可以算出它应该是模式串重复了 $\lfloor len/m \rfloor$ 次,再接上一个长度为 $len\mod m$ 的前缀形成的.判一下 $pre$ 是否与理论上求得的 $hash$ 值相等即可. 若在循环意义下匹配上了长度为 $i$ 的前缀,它的贡献就是当前能与长度 $m-i$ 的后缀循环匹配的 $suf$ 数目. 再算这个点 $suf$ 的贡献,与上面的方法类似.维护一个反串的 $hash$ 会十分方便. 常数大的一批,写法是对的,但时限卡不进去. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e5+10;int n,m;char buf[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;typedef unsigned long long ull;const ull Base=37;ull pw[MAXN],Hash[MAXN],revHash[MAXN];ull val[MAXN],pre[MAXN],suf[MAXN];ull Pattern_Power[MAXN],revPattern_Power[MAXN];ull Add_Char(ull hash,int c)&#123; return hash*Base+c;&#125;void Init_Hash()&#123; Hash[0]=0; for(int i=1;i&lt;=m;++i) Hash[i]=Hash[i-1]*Base+(buf[i]-'A'); revHash[0]=0; for(int i=1;i&lt;=m;++i) revHash[i]=revHash[i-1]*Base+(buf[m-i+1]-'A'); Pattern_Power[0]=0; for(int i=1;i*m&lt;=n;++i) Pattern_Power[i]=Pattern_Power[i-1]*pw[m]+Hash[m]; revPattern_Power[0]=0; for(int i=1;i*m&lt;=n;++i) revPattern_Power[i]=revPattern_Power[i-1]*pw[m]+revHash[m];&#125;int rt,totsize,mi,siz[MAXN],vis[MAXN];ll ans;void Findrt(int u,int fa)&#123; siz[u]=1; int mxsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; Findrt(v,u); siz[u]+=siz[v]; if(siz[v]&gt;mxsiz) mxsiz=v; &#125; mxsiz=max(mxsiz,totsize-siz[u]); if(mxsiz&lt;mi) mi=mxsiz,rt=u;&#125;int sumpre[MAXN],sumsuf[MAXN];int stk1[MAXN],stk2[MAXN],tp=0;int lstpre[MAXN],lstsuf[MAXN],cnt=0;int Match_pre(ull hash,int len)&#123; int x=len/m,y=len%m; ull exphash=Pattern_Power[x]*pw[y]+Hash[y]; if(exphash==hash) return y; else return m;&#125;int Match_suf(ull hash,int len)&#123; int x=len/m,y=len%m; ull exphash=revPattern_Power[x]*pw[y]+revHash[y]; if(exphash==hash) return y; else return m;&#125;int prelen,suflen;ull preval,sufval;void dfs(int u,int fa,int len,int Rt)&#123; pre[u]=val[u]*pw[len-1]+pre[fa]; suf[u]=val[u]*pw[len-1]+suf[fa]; prelen=Match_pre(pre[u],len); suflen=Match_suf(suf[u],len); if(prelen!=m || suflen!=m) &#123; ++cnt; lstpre[cnt]=prelen; lstsuf[cnt]=suflen; &#125; preval=Add_Char(pre[u],val[Rt]); prelen=Match_pre(preval,len+1); sufval=Add_Char(suf[u],val[Rt]); suflen=Match_suf(sufval,len+1); if(prelen!=m) ans+=sumsuf[(m-prelen)%m]; if(suflen!=m) ans+=sumpre[(m-suflen)%m]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; dfs(v,u,len+1,Rt); &#125;&#125;void solve(int u)&#123; vis[u]=1; if(siz[u]&lt;m) return; for(int i=1;i&lt;=tp;++i) &#123; sumpre[stk1[i]]=0; sumsuf[stk2[i]]=0; &#125; pre[u]=suf[u]=0; ++sumpre[0],++sumsuf[0]; tp=1; stk1[tp]=0; stk2[tp]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; dfs(v,u,1,u); while(cnt) &#123; ++tp; stk1[tp]=lstpre[cnt]; stk2[tp]=lstsuf[cnt]; ++sumpre[lstpre[cnt]]; ++sumsuf[lstsuf[cnt]]; --cnt; &#125; &#125;&#125;void Divide(int u)&#123; solve(u); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf,totsize=siz[v]; Findrt(v,0); Divide(rt); &#125;&#125;void Reset()&#123; memset(head,0,sizeof head); ecnt=0; memset(vis,0,sizeof vis); ans=0;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=100000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; Reset(); n=read(),m=read(); scanf("%s",buf+1); for(int i=1;i&lt;=n;++i) val[i]=buf[i]-'A'; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; scanf("%s",buf+1); Init_Hash(); mi=inf,totsize=n; Findrt(1,0); Divide(rt); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>hash</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4893 聚变反应炉]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4893-%E8%81%9A%E5%8F%98%E5%8F%8D%E5%BA%94%E7%82%89%2F</url>
    <content type="text"><![CDATA[贪心 + 树形背包. 本以为此题必有高论,但发现只有 $n-1$ 条边,是个树.那很显然就是一个树形背包了. 前 $50$ 分 $n$ 比较大,但 $c_i\in \lbrace 0,1 \rbrace$ ,可以贪心.显然先将所有 $c=1$ 的点激发,再激发 $c=0$ 的点最优, 对于后面的 $50$ 分, $n\leq 2000$ ,树形背包解决. 设 $f(u,x)$ 表示将子树 $u$ 内的点全部激发,并且节点 $u$ 初始需要 $x$ 点能量激发. $dfs$ 到节点 $u$ 时,枚举它的所有儿子 $v$ ,递归下去计算出所有 $v$ 的 $f$ 值. 先选一些儿子出来(选 $0$ 个也可),将它们的子树激发,再激发 $u$ ,再激发剩余的子树.那么一个儿子 $v$ 被选,造成的贡献是 $f(v,d_v)$ ,没被选,造成的贡献是 $f(v,\max(d_v-c_u,0))$ , $u$ 的贡献是 $x$ 减去选了的 $c_v$ ,与 $0$ 取 $\max$ . 设 $g(i,j)$ 表示考虑了前 $i$ 个儿子,选了的儿子 $c_v$ 总和是 $j$ 时,前 $i$ 个儿子造成的最小贡献. 对于第 $i$ 个儿子 $v$ ,若选它,有转移 $g(i,j+c_v)\leftarrow g(i-1,j)+f(v,d_v)$ . 若不选它,有转移 $g(i,j)\leftarrow g(i-1,j)+f(v,\max(d_v-c_u,0))$ . 若 $u$ 有 $k$ 个儿子,那么 $f(u,x)=\min \lbrace g(k,j)+\max(x-j,0)\rbrace$ . 注意到 $f$ 的第二维 $x$ 对于确定的 $u$ ,其实只有 $2$ 种取值 $\lbrace d_u,\max(d_u-c_{fa},0)\rbrace$ ,分别用 $0,1$ 代替即可. 时间复杂度 $O(n\cdot \sum c_i)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;const int inf=1e9;const int MAXN=1e5+10,MAXS=1e4+10;int n,c[MAXN],d[MAXN],fa[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];int sumc[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[2019][2],g[2019][MAXS];int calc(int u,int x)&#123; if(!x) return d[u]; if(x==1) return max(0,d[u]-c[fa[u]]);&#125;void solve(int u,int id,int k)&#123; int x=calc(u,id); if(!k) &#123; f[u][id]=x; return; &#125; int i=0; for(int I=head[u];I;I=nx[I]) &#123; int v=to[I]; if(v==fa[u]) continue; ++i; for(int j=0;j&lt;=sumc[u];++j) &#123; if(j+c[v]&lt;=sumc[u]) upd(g[i][j+c[v]],g[i-1][j]+f[v][0]); upd(g[i][j],g[i-1][j]+f[v][1]); &#125; &#125; f[u][id]=inf; for(int j=0;j&lt;=sumc[u];++j) f[u][id]=min(f[u][id],g[k][j]+max(x-j,0)); for(int i=1;i&lt;=k;++i) for(int j=0;j&lt;=sumc[u];++j) g[i][j]=inf;&#125;void dfs(int u,int Fa)&#123; fa[u]=Fa; int k=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; sumc[u]+=c[v]; dfs(v,u); ++k; &#125; solve(u,0,k); solve(u,1,k);&#125;int solve_greedy()&#123; int greedy_ans=0; for(int u=1;u&lt;=n;++u) if(c[u]) &#123; greedy_ans+=max(d[u],0); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; d[v]-=c[u]; &#125; &#125; for(int u=1;u&lt;=n;++u) if(!c[u]) greedy_ans+=max(d[u],0); cout&lt;&lt;greedy_ans&lt;&lt;endl; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) d[i]=read(); for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; if(n&gt;2000) return solve_greedy(); for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=10000;++j) g[i][j]=inf; g[0][0]=0; dfs(1,0); cout&lt;&lt;f[1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>树形dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4592 脑洞治疗仪]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4592-%E8%84%91%E6%B4%9E%E6%B2%BB%E7%96%97%E4%BB%AA%2F</url>
    <content type="text"><![CDATA[线段树. 需要维护一段区间的区间和,最长包含左端点的全 $0$ 区间长度,最长的包含右端点的全 $0$ 区间长度,最长全 $0$ 区间长度,以及支持区间赋值. 用线段树维护.操作 $1,3$ 都比较简单,操作 $2$ ,先查询 $[L_0,R_0]$ 中 $1$ 的数目,再将这段覆盖成 $0$ . 接下来用线段树把 $[L_1,R_1]$ 拆成 $\log$ 个线段树上的区间,遍历一次,找到能填补的最后一个区间. 再在那个区间内二分能填到的最后一个位置.方法类似于找第 $k$ 大.这样就只有一只 $\log$ 了. 时间复杂度 $O(n \cdot \log n)$ . 另外一个做法是使用珂朵莉树,但使用前提是数据随机,或者,区间赋值操作的数目与随机时的数目相近. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m;struct SegTree&#123; struct node &#123; int sum,tag,Len; int lenl,lenr,len; &#125;Tree[MAXN&lt;&lt;2]; friend node operator + (node lson,node rson) &#123; node root; root.Len=lson.Len+rson.Len; root.sum=lson.sum+rson.sum; if(lson.lenl==lson.Len) root.lenl=lson.lenl+rson.lenl; else root.lenl=lson.lenl; if(rson.lenr==rson.Len) root.lenr=rson.lenr+lson.lenr; else root.lenr=rson.lenr; root.len=max(lson.len,rson.len); root.len=max(root.len,lson.lenr+rson.lenl); root.len=max(root.len,root.lenl); root.len=max(root.len,root.lenr); return root; &#125;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; int t=root.tag; root=lson+rson; root.tag=t; &#125; void BuildTree(int o,int l,int r) &#123; root.sum=root.Len=r-l+1; root.tag=-1; root.lenl=root.lenr=root.len=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void Modifiy(int o,int c) &#123; root.tag=c; root.sum=root.Len*c; root.lenl=root.lenr=root.len=c?0:root.Len; &#125; void pushdown(int o) &#123; if(root.tag!=-1) &#123; Modifiy(o&lt;&lt;1,root.tag); Modifiy(o&lt;&lt;1|1,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query_sum(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; pushdown(o); int res=0; if(L&lt;=mid) res+=query_sum(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query_sum(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125; int tmp[50],tot,LL[50],RR[50]; void Split(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; tmp[++tot]=o; LL[tot]=l; RR[tot]=r; return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) Split(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) Split(o&lt;&lt;1|1,mid+1,r,L,R); &#125; int Binary_Search(int o,int l,int r,int x) &#123; int mid=(l+r)&gt;&gt;1; if(l!=r) pushdown(o); if(root.Len-root.sum==x) return r; if(lson.Len-lson.sum&lt;x) return Binary_Search(o&lt;&lt;1|1,mid+1,r,x-lson.Len+lson.sum); else return Binary_Search(o&lt;&lt;1,l,mid,x); &#125; int Search(int L,int R,int brain) &#123; tot=0; Split(1,1,n,L,R); int zero=0,mxrt=-1,x; for(int i=1;i&lt;=tot &amp;&amp; mxrt==-1;++i) &#123; zero+=Tree[tmp[i]].Len-Tree[tmp[i]].sum; if(zero&gt;=brain) &#123; mxrt=i; x=brain-(zero-Tree[tmp[i]].Len+Tree[tmp[i]].sum); &#125; &#125; return Binary_Search(tmp[mxrt],LL[mxrt],RR[mxrt],x); &#125; node query_len(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; pushdown(o); if(R&lt;=mid) return query_len(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query_len(o&lt;&lt;1|1,mid+1,r,L,R); if(L&lt;=mid &amp;&amp; R&gt;mid) return query_len(o&lt;&lt;1,l,mid,L,R)+query_len(o&lt;&lt;1|1,mid+1,r,L,R); &#125; int solve(int L,int R) &#123; node tmp=query_len(1,1,n,L,R); return tmp.len; &#125;&#125;T;int main()&#123; n=read(),m=read(); T.BuildTree(1,1,n); while(m--) &#123; int tp=read(); if(tp==0) &#123; int L=read(),R=read(); T.upd(1,1,n,L,R,0); &#125; else if(tp==1) &#123; int L0=read(),R0=read(); int L1=read(),R1=read(); int tot1=T.query_sum(1,1,n,L0,R0); if(!tot1) continue; T.upd(1,1,n,L0,R0,0); int tot2=T.query_sum(1,1,n,L1,R1); if(tot1+tot2&gt;=R1-L1+1) T.upd(1,1,n,L1,R1,1); else &#123; int pos=T.Search(L1,R1,tot1); T.upd(1,1,n,L1,pos,1); &#125; &#125; else &#123; int L=read(),R=read(); printf("%d\n",T.solve(L,R)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4562 食物链]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4562-%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[记忆化搜索. 题面写得非常烂 .作为一道省选题,没有对 食物链 下任何规范的定义,就让求数目,甚至限制也只说 输入数据符合生物学特点. 讲道理,出题人是要出来谢罪的. 结合样例强行理解,可以给出抽象的题目描述. 给定一张 $DAG$ ,求满足以下条件的路径数目:路径的起点终点不同,且起点的入度为 $0$ ,终点的出度为 $0$ . 记忆化搜索一下,记 $f(i)$ 表示从 $i$ 出发到出度为 $0$ 的点的路径条数.答案为所有入度为 $0$ 的点的 $f$ 之和. 注意特判除掉入度出度均为 $0$ 的点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,indeg[MAXN],outdeg[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; ++outdeg[u]; ++indeg[v];&#125;int f[MAXN];int dp(int u)&#123; if(f[u]!=-1) return f[u]; if(outdeg[u]==0) return f[u]=1; int &amp;res=f[u]; res=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; res+=dp(v); &#125; return res;&#125;int main()&#123; memset(f,-1,sizeof f); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); addedge(u,v); &#125; int ans=0; for(int i=1;i&lt;=n;++i) if(!indeg[i] &amp;&amp; outdeg[i]) ans+=dp(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1189]]></title>
    <url>%2F2019%2F07%2F11%2FCF1189%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Keanu Reeves 显然只需要判断不分割是否可行,若不可行,就把第一个字符分出去,分成两段就好了. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;char s[MAXN];int main()&#123; int n=read(); scanf("%s",s+1); int t[2]=&#123;0,0&#125;; for(int i=1;i&lt;=n;++i) ++t[s[i]-'0']; if(t[0]!=t[1]) &#123; puts("1"); printf("%s\n",s+1); &#125; else &#123; puts("2"); putchar(s[1]); putchar(' '); for(int i=2;i&lt;=n;++i) putchar(s[i]); puts(""); &#125; return 0;&#125; B Number CirCle 假的一批,这个题被罚了 $3$ 次. 构造方法是先将元素排序,先将最大的放在任意一个位置 $x$ ,然后次大的放在 $x+1$ ,第三大放在 $x-1$ ,第四大放在 $x+1\dots$ 然后检验是否合法,若这样放置不合法,则其他所有放置也不可能合法. 为什么?因为题面中的图和样例就是这样做的.大概是因为一个比较大的数,它旁边的数尽量也安排成比较大的数,这样对于双方都最优. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN];int b[MAXN];bool check()&#123; if(b[1]&gt;=b[n]+b[2]) return false; if(b[n]&gt;=b[1]+b[n-1]) return false; for(int i=2;i&lt;n;++i) if(b[i]&gt;=b[i-1]+b[i+1]) return false; return true;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); int x=(n+1)/2; b[x]=a[n]; int tot=n-1; for(int i=1;tot;++i) &#123; b[x+i]=a[tot--]; if(tot) b[x-i]=a[tot--]; &#125; if(check()) &#123; puts("YES"); for(int i=1;i&lt;=n;++i) printf("%d ",b[i]); &#125; else puts("NO"); return 0;&#125; C Candies! 仔细思考一下,不难发现答案就是 $\lfloor \frac {sum(l,r)} {10}\rfloor$ . 因为这个答案就是进位的次数,与运算顺序无关,直接将它们加起来 $/10$ ,得到的就是进位次数. 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int a[MAXN];int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) a[i]=a[i-1]+read(); int q=read(); while(q--) &#123; int l=read(),r=read(); int ans=a[r]-a[l-1]; ans/=10; printf("%d\n",ans); &#125; return 0;&#125; D1 Add on a Tree 容易发现,当且仅当存在两条边,它们只能同时加减同一个数时,就无法得到它们的权值不同的情况. 若存在这样两条边,则一定存在两条这样相邻的边,要让它们满足条件,它们的公共点度数一定为 $2$ ,即不存在其他的边. 于是判一下是否存在度数为 $2$ 的点即可. 代码就是 $D2$ 的一小部分,就不贴了. D2 Add on a Tree: Revolution 好题. 判断合法性和 $D1$ 一样,判是否有度数为 $2$ 的点.若合法,要将每条边的权值都改为要求的权值.特判 $n=2$ . 考虑如何给一条路径 $(u,L_0)$ 上的所有边加上一个权值 $x$ ,其中 $L_0$ 为叶子节点.先选择一个非叶子节点作为根. $u$ 的度数至少为 $3$ ,故一定可以找到另外两个叶子节点 $L_1,L_2$ ,并且这 $3$ 个叶子节点在 $u$ 的 $3$ 个不同子树内. 因为边权都是偶数( $pairwise$ ),所以我们要加的 $x$ 也都选择偶数.于是执行 $(L_0,L_1,\frac x 2),(L_0,L_2,\frac x 2),(L_1,L_2,-\frac x 2)$ 这三个操作,路径 $(u,L_0)$ 上所有边权值就 $+x$ 了. 再来解决原问题,对每条边,维护当前边上的权值与要求的权值还差 $\Delta$ ,然后从根节点开始 $dfs$ ,遍历到 $u$ 时,对它的每个儿子节点 $v$ ,选出子树 $v$ 内任一个叶子节点 $L_0$ ,用上面的操作给路径 $(u,L_0)$ 上的边加上 $\Delta_{u,v}$ 即可. $n\le 1000$ ,可以暴力找/修改,不用写数据结构.时间复杂度 $O(n^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int head[MAXN],ecnt=0,to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];int n,m=0;struct opt&#123; int u,v; ll x; opt(int u=0,int v=0,ll x=0):u(u),v(v),x(x) &#123;&#125;&#125;;queue&lt;opt&gt; Q;void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int deg[MAXN],dfn[MAXN],siz[MAXN],idx=0;int fa[MAXN];ll Delta[MAXN];//Edge(i,fa_i)bool In_SubTree(int v,int x)&#123; return dfn[v]&lt;=dfn[x] &amp;&amp; dfn[x]&lt;=dfn[v]+siz[v]-1;&#125;void Init(int u,int Fa)&#123; dfn[u]=++idx; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; Delta[v]=val[i]; Init(v,u); siz[u]+=siz[v]; &#125;&#125;int rt;void Assign(int u,int v0,int L0,ll x)&#123; int L1=0,L2=0; if(u!=rt) &#123; for(int i=1;i&lt;=n;++i) &#123; if(deg[i]==1 &amp;&amp; !In_SubTree(v0,i)) &#123; if(!L1 &amp;&amp; In_SubTree(u,i)) L1=i; if(!L2 &amp;&amp; !In_SubTree(u,i)) L2=i; if(L1 &amp;&amp; L2) break; &#125; &#125; &#125; else &#123; int v1=0,v2; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==v0 || v==v1) continue; if(!v1) v1=v; else v2=v; &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==1 &amp;&amp; In_SubTree(v1,i)) L1=i; else if(deg[i]==1 &amp;&amp; In_SubTree(v2,i)) L2=i; &#125; m+=3; Q.push(opt(L0,L1,x/2)); Q.push(opt(L0,L2,x/2)); Q.push(opt(L1,L2,-x/2)); while(L0!=u) &#123; Delta[L0]-=x; L0=fa[L0]; &#125;&#125;void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u]) continue; int L0=0; for(int j=1;j&lt;=n &amp;&amp; !L0;++j) if(deg[j]==1 &amp;&amp; In_SubTree(v,j)) L0=j; Assign(u,v,L0,Delta[v]); dfs(v); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); ++deg[u],++deg[v]; &#125; if(n==2) &#123; puts("YES"); puts("1"); printf("1 2 %d\n",val[1]); return 0; &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==2) &#123; puts("NO"); return 0; &#125; puts("YES"); rt=0; for(int i=1;i&lt;=n &amp;&amp; !rt;++i) if(deg[i]&gt;1) rt=i; Init(rt,0); dfs(rt); cout&lt;&lt;m&lt;&lt;endl; opt tmp; while(!Q.empty()) &#123; tmp=Q.front(); Q.pop(); printf("%d %d %I64d\n",tmp.u,tmp.v,tmp.x); &#125; return 0;&#125; E Count Pairs 这个题比 $D2$ 简单许多.对于原方程,因为 $a_i\not= a_j$ ,两边乘上 $(a_i-a_j)$ ,可得$$a_i^4 - a_j^4 \equiv k(a_i-a_j)$$ 可以 $O(n) $枚举 $j$ ,计算有多少个 $i$ 满足方程.于是 $a_j$ 此时为常数,整理一下,得到$$a_i^4-k\cdot a_i \equiv a_j^4-k\cdot a_j$$ $k$ 是不变的,所以用一个 $map$ 对于每个 $x\in [0,P)$ 记录 $a_i^4-k\cdot a_i\equiv x$ 的 $i$ 有多少个就好了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int pw4(int x)&#123; x=mul(x,x); x=mul(x,x); return x;&#125;const int MAXN=3e5+10;unordered_map&lt;int,int&gt; cnt;int n,a[MAXN];int main()&#123; n=read(),P=read(); int k=read(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); int x=pw4(a[i]); x=add(x,mul(P-k,a[i])); if(cnt.find(x)!=cnt.end()) ans+=cnt[x]; ++cnt[x]; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; F Array Beauty 元素的顺序是不影响答案的,所以可以先将所有元素从小到大排序.记最大的元素为 $m$ . $Beauty$ 值最大为 $m$ ,记 $Beauty$ 值 $\ge x$ 的子序列有 $p_x$ 个,那么答案为 $\sum_{x=1}^m p_x$ ,因为若一个子序列的 $Beauty$ 值为 $s$ ,它就会在求和中贡献 $s$ 次. 枚举 $x$ 的值,用 $dp$ 求解 $p_x$ .设 $f(i,j)$ 表示以第 $i$ 个数结尾,长度为 $j$ 的,且美丽值 $\ge x$ 的子序列数目. 转移有 $f(i,j)=\sum f(d,j-1),d&lt;i,a_j-a_d\ge x$ .由于 $a$ 已经排过序,所以合法的 $d$ 一定是一段前缀,可以用 $two\ pointer$ 维护,并记录 $f$ 的前缀和.这样, $p_x=\sum f(i,k)$ ,求一个 $p_x$ 的时间复杂度为 $O(n\cdot k)$ . 注意到 $x$ 只需要枚举到 $\lfloor \frac m {k-1}\rfloor$ ,若 $x$ 大于这个值,子序列首尾元素差值就会 $&gt; m$ ,不可能出现. 所以整个问题的时间复杂度为 $O(m \cdot n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;const int MAXN=1e3+10;int n,k;int f[MAXN][MAXN],sum[MAXN][MAXN],a[MAXN];int solve(int x)&#123; for(int i=1;i&lt;=n;++i) f[i][1]=1,sum[i][1]=i; for(int j=2;j&lt;=k;++j) &#123; sum[0][j]=0; int r=1; for(int i=1;i&lt;=n;++i) &#123; while(a[r]&lt;=a[i]-x) ++r; f[i][j]=sum[r-1][j-1]; sum[i][j]=add(sum[i-1][j],f[i][j]); &#125; &#125; return sum[n][k];&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); int m=a[n]; int ans=0; for(int x=1;x&lt;=m/(k-1);++x) ans=add(ans,solve(x)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>codeforces</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4561 圆的异或并]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4561-%E5%9C%86%E7%9A%84%E5%BC%82%E6%88%96%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[扫描线 + $set$ . 把圆看做上下两段半圆弧,因为位置关系只有包含和相离,所以无论 $x$ 取什么值,各个圆弧上下相对顺序是不变的.所以可以将它们全都丢进 $set$ 里面,方便接下来查询. 做一个扫描线,左边插入,右边删除.对于每个圆弧,插入的时候询问它的 $upper_bound$ . 若找到的是上圆弧,说明它就是当前圆外面的第一个圆. 若找到的是下圆弧,说明当前圆外面的第一个圆就是那个下圆弧外面的第一个圆. 可能出现找不到的情况,需要特判. 发现自己好像是第一次写扫描线… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;inline double sq(double x)&#123; return x*x;&#125;const int MAXN=2e5+10;int n;double x[MAXN],y[MAXN],r[MAXN],pos;int Sgn[MAXN];struct LR_Arc&#123; int id,sgn; LR_Arc(int id=0,int sgn=0):id(id),sgn(sgn) &#123;&#125; bool operator &lt; (const LR_Arc &amp;rhs) const &#123; return x[id]+sgn*r[id]&lt;x[rhs.id]+rhs.sgn*r[rhs.id]; &#125;&#125;q[MAXN&lt;&lt;1];struct UD_Arc&#123; int id,sgn;//1-up -1-down UD_Arc(int id=0,int sgn=0):id(id),sgn(sgn) &#123;&#125; bool operator &lt; (const UD_Arc &amp;rhs) const &#123; int i=id,j=rhs.id; double y1=y[i]+sgn*(sqrt(sq(r[i])-sq(x[i]-pos))); double y2=y[j]+rhs.sgn*(sqrt(sq(r[j])-sq(x[j]-pos))); return y1==y2?sgn&lt;rhs.sgn:y1&lt;y2; &#125;&#125;;set&lt;UD_Arc&gt; S;set&lt;UD_Arc&gt;::iterator it;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; x[i]=(double)(read()); y[i]=(double)(read()); r[i]=(double)(read()); q[i*2-1]=LR_Arc(i,-1); q[i*2]=LR_Arc(i,1); &#125; sort(q+1,q+1+2*n); for(int i=1;i&lt;=2*n;++i) &#123; pos=x[q[i].id]+q[i].sgn*r[q[i].id]; if(q[i].sgn==-1) &#123; it=S.upper_bound(UD_Arc(q[i].id,1)); if(it!=S.end()) &#123; UD_Arc tmp=*it; if(tmp.sgn==-1) Sgn[q[i].id]=Sgn[tmp.id]; else Sgn[q[i].id]=-Sgn[tmp.id]; &#125; else Sgn[q[i].id]=1; S.insert(UD_Arc(q[i].id,1)); S.insert(UD_Arc(q[i].id,-1)); &#125; else &#123; S.erase(UD_Arc(q[i].id,1)); S.erase(UD_Arc(q[i].id,-1)); &#125; &#125; double ans=0; for(int i=1;i&lt;=n;++i) ans+=sq(r[i])*Sgn[i]; cout&lt;&lt;(ll)(ans)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4560 字符串覆盖]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4560-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[字符串 $hash$ + 贪心 + $dp$ . 首先可以字符串 $hash$ 预处理出 $N$ 个串各自可以放的位置 (用开头的位置表示) ,以及 $L_{i,j} ,R_{i,j}$ 分别表示从位置 $j$ 往左/右边找,能找到的第一个可以放第 $i$ 个串的位置(不包含 $j$ ). 求最大值,可以贪心.首先枚举这 $N$ 个串放置的 $N!$ 种顺序,依次选择位置.分两种情况,记上个串结束位置为 $p$ ,若与上个串相交,则放在 $L_{i,p}$ 最优,若与上个串不相交,则放在 $R_{i,p}$ 最优.这个决策也可以大力枚举.这一步的时间复杂度 $O(N!\cdot 2^N)$ 求最小值,不相交时贪心放在 $R_{i,p}$ 不一定最优,考虑 $dp$ . 仍然枚举 $N!$ 种放置顺序,设 $f(i,j)$ 表示考虑了前 $j$ 个位置,下一个放置的应该是第 $i$ 个串. 若不放第 $i$ 个串,则转移到 $f(i,j+1)$ . 若放第 $i$ 个串,若它与上一个串不相交,转移到 $f(i+1,j+Len(i))$ .否则放在匹配 $j$ 后能放的第一个位置. 这一步时间复杂度 $O(N!\cdot N\cdot Len(A))$ ,也是总的时间复杂度. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;const ull Base=37;int n,N,len[5];ull Hash[MAXN],pw[MAXN];char A[MAXN],B[5][MAXN];void Init_Hash()&#123; Hash[0]=0; for(int i=1;i&lt;=n;++i) Hash[i]=Hash[i-1]*Base+(ull)(A[i]-'a');&#125;ull Calc_Hash(int l,int r)&#123; return Hash[r]-Hash[l-1]*pw[r-l+1];&#125;int L[5][MAXN],R[5][MAXN],f[5][MAXN];int id[5];int DP(int i,int j)&#123; if(i&gt;N) return 0; j=R[id[i]][j]; if(j==0) return n+1; if(f[i][j]!=-1) return f[i][j]; int &amp;ans=f[i][j]; ans=DP(i,j+1); int k=j+len[id[i]],st=j; ++i; for(;i&lt;=N;++i) &#123; ans=min(ans,DP(i,k)+k-j); int p=R[id[i]][j]; if(p&lt;st || p&gt;=k) return ans; st=p; k=max(k,st+len[id[i]]); &#125; ans=min(ans,k-j); return ans;&#125;int dfs(int i,int j)&#123; if(i&gt;N) return 0; j=R[id[i]][j]; if(!j) return 0; int k=j+len[id[i]],st=j; int ans=0; ++i; for(;i&lt;=N;++i) &#123; ans=max(ans,dfs(i,k)+k-j); int p=L[id[i]][k]; if(p&lt;st || p&gt;=k) return ans; st=p; k=max(k,st+len[id[i]]); &#125; ans=max(ans,k-j); return ans;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=10000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; scanf("%s",A+1); n=strlen(A+1); N=read(); for(int i=1;i&lt;=N;++i) &#123; scanf("%s",B[i]+1); len[i]=strlen(B[i]+1); &#125; Init_Hash(); memset(L,0,sizeof L); memset(R,0,sizeof R); for(int i=1;i&lt;=N;++i) &#123; ull val=0; for(int j=1;j&lt;=len[i];++j) val=val*Base+(B[i][j]-'a'); for(int j=1;j+len[i]-1&lt;=n;++j) if(Calc_Hash(j,j+len[i]-1)==val) L[i][j]=j; else L[i][j]=L[i][j-1]; for(int j=n+1-len[i];j&gt;=1;--j) if(Calc_Hash(j,j+len[i]-1)==val) R[i][j]=j; else R[i][j]=R[i][j+1]; &#125; for(int i=1;i&lt;=N;++i) id[i]=i; int minans=n+1,maxans=0; do &#123; memset(f,-1,sizeof f); minans=min(minans,DP(1,1)); maxans=max(maxans,dfs(1,1)); &#125;while(next_permutation(id+1,id+1+N)); printf("%d %d\n",minans,maxans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4559 成绩比较]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-4559-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[组合计数 + 容斥原理 + 拉格朗日插值法. 首先我们确定哪些人被碾压,再确定没有被碾压的人各科分数分别是高于 $B$ 神还是小于等于 $B$ 神.然后就可以将每科分开算所有人各自具体分数的方案数,最后乘在一起. 选出被碾压的人有 $n-1\choose k$ 种方案. 对于课程 $i$ ,有 $r_i-1$ 个人的分比 $B$ 神高,这 $r_i-1$ 个人显然只能在未被碾压的 $n-k-1$ 个人中产生.如果任意分配,可能会出现新的人被碾压.所以用容斥原理计算这部分的贡献,没有人被碾压方案数 $=$ 总方案数 $-$ 保证 $1$ 个人被碾压方案数 $+$ 保证 $2$ 个人被碾压方案数 $\dots$ 记这个答案为 $s$ . 再来计算第 $i$ 科排名恰好为 $r_i$ 的方案数 $p_i$ .枚举这一科 $B$ 神考了 $x$ 分.(有 $r_i=1$ 的情况,所以定义 $0^0=1$ ). $$\begin{aligned}p_i=\sum_{x=1}^{u_i} x^{n-r_i}\cdot (u_i-x)^{r_i-1}\end{aligned}$$ 若暴力算 $p_i$ 可以拿到 $70$ 分.注意到 $p_i$ 是个关于 $u_i$ 的 $n$ 次多项式,而我们只需要求它在某一个位置的值. 拉格朗日插值即可,答案为 ${n-1\choose k}\cdot s \cdot \prod p_i$ . 时间复杂度 $O(n^3\cdot \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int n,m,k,C[MAXN][MAXN];int u[MAXN],r[MAXN];void init()&#123; C[0][0]=1; for(int i=1;i&lt;=n;++i) C[i][0]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]);&#125;int Assign_Rank()&#123; int res=1; for(int i=1;i&lt;=m;++i) res=mul(res,C[n-k-1][r[i]-1]); bool flag=true; for(int i=1;i&lt;=n-k-1 &amp;&amp; flag;++i) &#123; int tmp=C[n-k-1][i]; for(int j=1;j&lt;=m;++j) if(n-k-1-i&gt;=r[j]-1) tmp=mul(tmp,C[n-k-1-i][r[j]-1]); else &#123; tmp=0; flag=false; break; &#125; if(i&amp;1) res=add(res,P-tmp); else res=add(res,tmp); &#125; return res;&#125;int Calc_p(int i,int U)&#123; int res=0; for(int x=1;x&lt;=U;++x) res=add(res,mul(fpow(x,n-r[i]),fpow(U-x,r[i]-1))); return res;&#125;int x[MAXN],y[MAXN];int Lagrange(int N,int pos)&#123; int res=0; for(int i=1;i&lt;=N;++i) &#123; int tmp=y[i]; for(int j=1;j&lt;=N;++j) if(i!=j) &#123; tmp=mul(tmp,add(pos,P-x[j])); tmp=mul(tmp,inv(add(x[i],P-x[j]))); &#125; res=add(res,tmp); &#125; return res;&#125;int Assign_Score(int i)&#123; for(int U=2;U&lt;=n+2;++U) x[U-1]=U,y[U-1]=Calc_p(i,U); return Lagrange(n+1,u[i]);&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=m;++i) u[i]=read(); for(int i=1;i&lt;=m;++i) r[i]=read(); init(); int ans=C[n-1][k]; ans=mul(ans,Assign_Rank()); for(int i=1;i&lt;=m;++i) ans=mul(ans,Assign_Score(i)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>拉格朗日插值法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4558 方]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-4558-%E6%96%B9%2F</url>
    <content type="text"><![CDATA[容斥原理. 记 $s_i$ 表示顶点恰好有 $i$ 个点是不合法点的正方形数,答案显然是 $s_0-s_1+s_2-s_3+s_4$ . $s_0$ 可以直接算, $s_1$ 可以枚举每个不合法点来算. 算 $s_2,s_3,s_4$ 都只需要枚举每对不合法点,并判断其他两个顶点是否合法,将贡献加入对应的 $s$ . 注意考虑斜着放的正方形. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e8+7;const int inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairset&lt;pii&gt; S;int n,m,k,s[5];int Calc(int l,int r,int h)&#123; int z=min(l+r,h); if(!z) return 0; int res=mul(mul(z,z+3),inv2); if(z&gt;l) res=add(res,P-mul(inv2,mul(z-l,z-l+1))); if(z&gt;r) res=add(res,P-mul(inv2,mul(z-r,z-r+1))); return res;&#125;int calc1(int x,int y)&#123; int t=x,b=n-x,l=y,r=m-y; int res=0; res=add(res,Calc(t,b,l)); res=add(res,Calc(t,b,r)); res=add(res,Calc(l,r,t)); res=add(res,Calc(l,r,b)); res=add(res,P-min(l,t)); res=add(res,P-min(r,t)); res=add(res,P-min(l,b)); res=add(res,P-min(r,b)); return res;&#125;bool check(int x,int y)&#123; return x&gt;=0 &amp;&amp; x&lt;=n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=m;&#125;void count(int ax,int ay,int bx,int by)&#123; if(check(ax,ay) &amp;&amp; check(bx,by)) &#123; int t=S.count(mp(ax,ay))+S.count(mp(bx,by)); ++s[2]; if(t&gt;0) s[3]=add(s[3],1); if(t&gt;1) s[3]=add(s[3],1),s[4]=add(s[4],1); &#125;&#125;int x[MAXN],y[MAXN];void solve()&#123; for(int i=1;i&lt;=n &amp;&amp; i&lt;=m;++i) s[0]=add(s[0],mul(i,mul(n-i+1,m-i+1))); for(int i=1;i&lt;=k;++i) s[1]=add(s[1],calc1(x[i],y[i])); for(int i=1;i&lt;k;++i) for(int j=i+1;j&lt;=k;++j) &#123; int dx=x[i]-x[j]; int dy=y[i]-y[j]; count(x[i]+dy,y[i]-dx,x[j]+dy,y[j]-dx); count(x[i]-dy,y[i]+dx,x[j]-dy,y[j]+dx); if(abs(dx)+abs(dy) &amp; 1) continue; int X=(dx-dy)&gt;&gt;1,Y=(dx+dy)&gt;&gt;1; count(x[i]-X,y[i]-Y,x[j]+X,y[j]+Y); &#125; s[3]/=3; s[4]/=6;&#125;int main()&#123; n=read(),m=read(); k=read(); for(int i=1;i&lt;=k;++i) &#123; x[i]=read(); y[i]=read(); S.insert(mp(x[i],y[i])); &#125; solve(); int ans=0; for(int i=0;i&lt;=4;++i) if(i&amp;1) ans=add(ans,P-s[i]); else ans=add(ans,s[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5104 Fib数列]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-5104-Fib%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[二次剩余 + $BSGS$ . 这个题可以暴力水过去.先找出模 $P=10^9+9​$ 意义下的循环节,发现是 $\frac {P-1} 3​$ .于是 $O(\frac {P-1} 3)​$ 暴力判. 考虑正经一点的,比较优秀的做法.记 $\phi=\frac {\sqrt 5+1} 2​$ ,则数列第 $n​$ 项 $F_n=\frac 1 {\sqrt 5} \cdot (\phi^n-(-\frac 1 \phi)^n)​$ . 注意 $5$ 在模 $P$ 意义下可以开根号,记开出来的根为 $k=383008016$ ,答案为 $x$ ,那么要解的方程化为, $$\phi^x-(-\frac 1 \phi)^x=k\cdot n$$ 换元,令 $t=\phi ^x$ ,则方程化为, $$t^2-(-1)^x\cdot=(k\cdot n)t$$ 得到了 $t$ 的一元二次方程,对 $x$ 为奇数/偶数分别求解.若 $\Delta$ 不为二次剩余,则无解. 否则,求根公式解得 $t​$ ,再根据 $t=\phi ^x​$ 用 $BSGS​$ 解出最小 $x​$ . 瓶颈在 $BSGS​$ 上,时间复杂度 $O(\sqrt P)​$ . 暴力 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int solve(int n)&#123; if(n==1) return 1; int len=333333336; int a=0,b=1,c; for(int i=2;i&lt;=len;++i) &#123; c=add(a,b); if(c==n) return i; a=b; b=c; &#125; return -1;&#125;int main()&#123; int n=read(); cout&lt;&lt;solve(n)&lt;&lt;endl; return 0;&#125; 正经做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9,inv2=(P+1)&gt;&gt;1;const int k=383008016,phi=691504013;const int Len=(P+1)/3;inline int add(int a,int b)&#123; return ((a+b)%P+P)%P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;bool EulerJudge(int x)&#123; return fpow(x,(P-1)&gt;&gt;1)!=(P-1);&#125;int wi;struct Complex&#123; int x,y;//x+yw Complex(int x=0,int y=0):x(x),y(y) &#123;&#125; Complex operator * (const Complex &amp;rhs) const &#123; int tx=mul(mul(y,rhs.y),wi); tx=add(tx,mul(x,rhs.x)); int ty=add(mul(x,rhs.y),mul(y,rhs.x)); return Complex(tx,ty); &#125; friend Complex operator ^ (Complex a,int b) &#123; Complex res=Complex(1,0); while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res; &#125;&#125;;int Cipolla(int n)&#123; if(!EulerJudge(n)) return -1; srand(time(NULL)); int a; while("RLDAKIOI") &#123; a=rand()%P; wi=add(mul(a,a),-n); if(!EulerJudge(wi)) break; &#125; Complex res=Complex(a,1); res=res^((P+1)&gt;&gt;1); res.x=add(res.x,P); return min(res.x,P-res.x);&#125;map&lt;int,int&gt; mp;int BSGS(int a,int b)//a^x=b&#123; mp.clear(); int m=ceil(sqrt(P)); for(int j=0; j&lt;m; ++j) mp[mul(b,fpow(a,j))]=j; for(int i=1; i&lt;=m; ++i) &#123; int j,val=fpow(a,i*m); if(mp.find(val)!=mp.end()) &#123; j=mp[val]; return i*m-j; &#125; &#125; return P;&#125;int n;int solve(int b,int c,int t)&#123; if(t==-1) return P; t=add(t,-b); t=mul(t,inv2); int x=BSGS(phi,t); if(c==1 &amp;&amp; x%2==0) return P; if(c==-1 &amp;&amp; x%2==1) return P; return x;&#125;int calc(int b,int c)&#123; int Delta=add(mul(b,b),mul(-4,c)); int t=Cipolla(Delta); if(t==-1) return P; return min(solve(b,c,t),solve(b,c,add(P,-t)));&#125;int main()&#123; n=read(); int ans=P; int b=mul(P-k,n); ans=min(ans,calc(b,1));//odd ans=min(ans,calc(b,-1));//even if(ans&lt;P) printf("%d\n",ans); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>BSGS</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2305 游戏]]></title>
    <url>%2F2019%2F07%2F10%2FLoj-2305-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$2-SAT$ . 如果没有地图 $x$ ,每张地图只能选两种车,就是个裸的 $2-SAT$ 问题. 现在有地图 $x$ ,但不超过 $8$ 张.所以可以暴力枚举每张地图 $x$ 不能选哪种车,然后 $2-SAT$ 判断. 注意枚举不能选的车时,只用枚举两种,就已经包含了地图 $x$ 选车的所有情况. $2-SAT$ 问题若有解,输出一组合法解的方法,是对于每个状态 $i$ 与它的对立面 $inv(i)$ 比较所在 $scc$ 编号的大小,选择所在 $scc$ 编号小的状态.这样做是和缩点建反图后 $topsort$ 等价的. 时间复杂度 $O(2^d\cdot (n+m))$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,d;char buf[MAXN],s[10];bool flag[MAXN];int idx(int x,int type)&#123; return x*3+type;&#125;int inv(int id)&#123; int x=id/3; int t=id%3; if(flag[idx(x,0)]==false) return idx(x,3-0-t); if(flag[idx(x,1)]==false) return idx(x,3-1-t); if(flag[idx(x,2)]==false) return idx(x,3-2-t);&#125;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct Edge&#123; int x,y; int hx,hy;&#125;E[MAXN];int dfn[MAXN],low[MAXN],scc[MAXN],cnt,tot;int stk[MAXN],tp,in[MAXN];void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; stk[++tp]=u; in[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(!flag[v]) continue; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v; ++tot; do &#123; v=stk[tp--]; in[v]=0; scc[v]=tot; &#125;while(u!=v); &#125;&#125;bool solve(int st)&#123; for(int i=0;i&lt;n;++i) &#123; if(buf[i]=='x') &#123; int t=st&amp;1; flag[idx(i,0)]=true; flag[idx(i,1)]=true; flag[idx(i,t)]=false; st&gt;&gt;=1; &#125; &#125; memset(head,0,sizeof head); ecnt=0; for(int i=1;i&lt;=m;++i) &#123; int x=idx(E[i].x,E[i].hx); int y=idx(E[i].y,E[i].hy); if(x==y) continue; if(!flag[x]) continue; else if(!flag[y]) addedge(x,inv(x)); else &#123; addedge(x,y); addedge(inv(y),inv(x)); &#125; &#125; memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(scc,0,sizeof scc); memset(in,0,sizeof in); tp=0; tot=0; cnt=0; for(int i=0;i&lt;3*n;++i) if(flag[i] &amp;&amp; !dfn[i]) tarjan(i); for(int i=0;i&lt;3*n;++i) if(flag[i] &amp;&amp; scc[i]==scc[inv(i)]) return false; for(int i=0;i&lt;3*n;++i) &#123; if(flag[i] &amp;&amp; scc[i]&lt;scc[inv(i)]) putchar(i%3+'A'); &#125; puts(""); return true;&#125;int main()&#123; n=read(),d=read(); scanf("%s",buf); for(int i=0;i&lt;n;++i) &#123; flag[idx(i,0)]=true; flag[idx(i,1)]=true; flag[idx(i,2)]=true; if(buf[i]!='x') flag[idx(i,buf[i]-'a')]=false; &#125; m=read(); for(int i=1;i&lt;=m;++i) &#123; E[i].x=read()-1; scanf("%s",s); E[i].hx=s[0]-'A'; E[i].y=read()-1; scanf("%s",s); E[i].hy=s[0]-'A'; &#125; bool f=false; for(int i=0;i&lt;(1&lt;&lt;d);++i) if(solve(i)) &#123; f=true; break; &#125; if(!f) puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2302 整数]]></title>
    <url>%2F2019%2F07%2F09%2FLoj-2302-%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[线段树 + 压位. 可以用线段树维护 $x$ 的每个二进制位,一次加/减法可以拆成 $\log$ 次给某一位 $\pm 1$. 假设给第 $p$ 位 $+1$ ,就向高位找到第一个为 $0$ 的位置 $q$ ,将位置 $q$ 改为 $1$ , $p\sim q-1$ 改为 $0$ . 假设给第 $p$ 位 $-1$ ,就向高位找到第一个为 $1$ 的位置 $q$ ,将位置 $q$ 改为 $0$ , $p\sim q-1$ 改为 $1$ . 这样直接做是 $O(n\cdot \log^2n)$ 的,比较慢.因为只维护 $0/1$ 信息,所以一个比较自然的想法是压位. $b\le 30n$ ,为了方便,将 $30$ 位压在一个 $int$ 里面,这样每次操作只用拆成 $2$ 位. 线段树的第 $i$ 个位置维护了二进制位 $(i-1)\times 30\sim i\times 30-1$ 这些位置上的信息.时间复杂度 $O(n\cdot \log n)$. 细节巨多,巨烦.调了两节课. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;const int Base=30;const int s=(1&lt;&lt;30)-1;int n;struct SegTree&#123; struct node &#123; int val,tag; bool mi,mx; node()&#123;val=0;tag=-1;mi=true;mx=false;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mi=lson.mi&amp;rson.mi; root.mx=lson.mx&amp;rson.mx; &#125; void modifiy(int o,int c) &#123; root.tag=c; if(!c) &#123; root.val=0; root.mi=true; root.mx=false; &#125; else &#123; root.val=s; root.mi=false; root.mx=true; &#125; &#125; void pushdown(int o) &#123; if(root.tag!=-1) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int a,int b)//第b个大位第a小位 &#123; if(l==r) return (root.val&gt;&gt;a)&amp;1; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) return query(o&lt;&lt;1,l,mid,a,b); else return query(o&lt;&lt;1|1,mid+1,r,a,b); &#125; void Rejudge(int o) &#123; root.mi=(!root.val); root.mx=(root.val==s); &#125; void upd_fa(int o) &#123; while(o!=1) &#123; pushup(o&gt;&gt;1); o&gt;&gt;=1; &#125; &#125; int Access(int o,int l,int r,int pos) &#123; if(l==r) return o; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) return Access(o&lt;&lt;1,l,mid,pos); else return Access(o&lt;&lt;1|1,mid+1,r,pos); &#125; int First_Non_Mx(int o,int l,int r,int pos) &#123; if(root.mx) return -1; if(l==r) return l; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) &#123; int res=First_Non_Mx(o&lt;&lt;1,l,mid,pos); if(res==-1) return First_Non_Mx(o&lt;&lt;1|1,mid+1,r,pos); else return res; &#125; else return First_Non_Mx(o&lt;&lt;1|1,mid+1,r,pos); &#125; int First_Non_Mi(int o,int l,int r,int pos) &#123; if(root.mi) return -1; if(l==r) return l; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) &#123; int res=First_Non_Mi(o&lt;&lt;1,l,mid,pos); if(res==-1) return First_Non_Mi(o&lt;&lt;1|1,mid+1,r,pos); else return res; &#125; else return First_Non_Mi(o&lt;&lt;1|1,mid+1,r,pos); &#125; void Add(int o,int l,int r,int a,int b)//在第b个大位+a &#123; if(l==r) &#123; root.val+=a; if(root.val&gt;s) &#123; root.val&amp;=s; int p=First_Non_Mx(1,0,n,l+1); int t=Access(1,0,n,p); Tree[t].val++; Rejudge(t); if(Tree[t].val==1 || Tree[t].val==s) upd_fa(t); if(l+1&lt;=p-1) upd(1,0,n,l+1,p-1,0); &#125; Rejudge(o); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) Add(o&lt;&lt;1,l,mid,a,b); else Add(o&lt;&lt;1|1,mid+1,r,a,b); pushup(o); &#125; void Del(int o,int l,int r,int a,int b)//在第b个大位-a &#123; if(l==r) &#123; if(root.val&gt;=a) &#123; root.val-=a; Rejudge(o); return; &#125; root.val=s+1+root.val-a; Rejudge(o); int p=First_Non_Mi(1,0,n,l+1); int t=Access(1,0,n,p); Tree[t].val--; Rejudge(t); if(Tree[t].val==0 || Tree[t].val==s-1) upd_fa(t); if(l+1&lt;=p-1) upd(1,0,n,l+1,p-1,1); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) Del(o&lt;&lt;1,l,mid,a,b); else Del(o&lt;&lt;1|1,mid+1,r,a,b); pushup(o); &#125;&#125;T;int main()&#123; n=read(); read(),read(),read(); for(int i=1;i&lt;=n;++i) &#123; int tp=read(); if(tp==1) &#123; ll a; scanf("%lld",&amp;a); int b=read(); bool flag=(a&gt;0); a=abs(a); a&lt;&lt;=(b%Base); b/=Base; if(flag) &#123; if(a&amp;s) T.Add(1,0,n,a&amp;s,b); if(a&gt;&gt;Base) T.Add(1,0,n,a&gt;&gt;Base,b+1); &#125; else &#123; if(a&amp;s) T.Del(1,0,n,a&amp;s,b); if(a&gt;&gt;Base) T.Del(1,0,n,a&gt;&gt;Base,b+1); &#125; &#125; else &#123; int k=read(); int ans=T.query(1,0,n,k%Base,k/Base); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4161 Shlw loves matrixI]]></title>
    <url>%2F2019%2F07%2F09%2Fbzoj-4161-Shlw-loves-matrixI%2F</url>
    <content type="text"><![CDATA[常系数线性递推. 矩阵快速幂是 $O(k^3\cdot logn)$ 的,不够优秀.观察式子(后续用 $a$ 代替 $h$ ,用 $f$ 代替 $a$ ), $$a_n=\sum_{i=1}^k f_i\cdot a_{n-i}$$ 注意到任意一项 $a_i$ 都可以被 $\lbrace a_0,a_1,\dots,a_{k-1} \rbrace$ 线性表示,考虑已知 $a_n$ 的线性表示,如何求得 $a_{2n}$ 的线性表示.这里需要利用一个性质,若: $$a_n=\sum_{i=0}^{k-1}b_i\cdot a_i$$ 则, $$a_{n+x}=\sum_{i=0}^{k-1}b_i\cdot a_{i+x}$$ 证明应该是显然的,相当于将 $a_x$ 看做这个数列的首项,递推式都是一样的,所以对应系数也是一样的. 于是,连续用 $2$ 次该性质可得, 这样就用 $\lbrace a_0,a_1,a_2,\dots,a_{2k-2} \rbrace$ 线性表示了 $a_{2n}$ .那么只需要求得 $\lbrace a_k,a_{k+1},a_{k+2},\dots,a_{2k-2} \rbrace$ 的线性表示,然后代进去即可. 像快速幂那样做下去,只用做 $logn$ 次.时间复杂度 $O(k^2\cdot logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;int n,k,tmp[MAXN&lt;&lt;1];void Mul(int *a,int *b,int *f)&#123; memset(tmp,0,k&lt;&lt;3); for(int i=0;i&lt;k;++i) for(int j=0;j&lt;k;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=2*k-2;i&gt;=k;--i) for(int j=0;j&lt;k;++j) tmp[i-j-1]=add(tmp[i-j-1],mul(tmp[i],f[j])); memcpy(a,tmp,k&lt;&lt;2); &#125;int base[MAXN],ans[MAXN];int solve(int *a,int *f,int N)&#123; if(N&lt;k) return a[N]; base[1]=ans[0]=1; while(N) &#123; if(N&amp;1) Mul(ans,base,f); Mul(base,base,f); N&gt;&gt;=1; &#125; int res=0; for(int i=0;i&lt;k;++i) res=add(res,mul(a[i],ans[i])); return res;&#125;int f[MAXN],a[MAXN];int main()&#123; n=read(),k=read(); for(int i=0;i&lt;k;++i) f[i]=add(read(),P); for(int i=0;i&lt;k;++i) a[i]=add(read(),P); cout&lt;&lt;solve(a,f,n)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>常系数线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2304 泳池]]></title>
    <url>%2F2019%2F07%2F09%2FLoj-2304-%E6%B3%B3%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[$dp$ + 常系数线性递推. 面积恰好 $=K$ 的概率不太好求,考虑求出面积 $\le K$ 与面积 $\le K-1$ 的概率,两者相减即为答案. 设 $f(i,j)$ 表示矩形长为 $i$ ,最下面 $j$ 行都安全,而第 $j+1$ 行至少一个位置危险,最大面积不超过 $K$ 的概率. 记 $g(i,j)$ 表示矩形长为 $i$ ,最下面 $j$ 行都安全,最大面积不超过 $K$ 的概率.则 $g(i,j)=\sum_{p\ge j} f(i,p)$ . 边界为 $g(0,j)=f(0,j)=1,g(i,j)=f(i,j)=0\ (i\cdot j&gt;K)$ .我们需要求得 $g(n,0)$ . 枚举第 $j+1$ 行第一个危险的格子在 $r+1$ 列.那么要求前 $r$ 列 $j+1$ 行都安全, $r+2\sim i$ 列前 $j$ 行安全,第 $r+1$ 列前 $j$ 行安全, 第 $r+1$ 列第 $j+1$ 行危险,则转移有, $$f(i,j)=\sum_{r=0}^{i-1} g(r,j+1)\cdot g(i-r-1,j) \cdot q^j\cdot(1-q)$$ $4$ 个限制依次对应了转移方程中的 $4$ 项. 大力 $dp$ ,时间复杂度为 $O(n^2)$ . 考虑如何优化.注意到当 $n&gt;K$ 时,仅有 $f(i,0)$ 与 $g(i,0)$ 这些项不为 $0$ ,而我们要求的是 $g(n,0)$ . 所以只用考虑它们的转移.将 $j=0$ 代入原来的转移方程,可以发现, $$f(i,0)=g(i,0)=\sum_{r=0}^K g(r,1)\cdot g(i-r-1,0)\cdot (1-q)$$ $g(r,1)$ 最多只有前 $K+1$ 项非 $0$ ,这部分可以通过大力 $dp$ 求出.那么 $g(r,1)\cdot (1-q)$ 就可看做常系数. 求 $g(i,0)$ 就是一个常系数线性递推,递推式的长度为 $K$ .使用 $O(K^2\cdot logn)$ 的大力取模做法即可. 总时间复杂度 $O(K^2\cdot logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=1e3+10;int base[MAXN],ans[MAXN],tmp[MAXN&lt;&lt;1];void Mul(int *a,int *b,int *f,int k)&#123; memset(tmp,0,k&lt;&lt;3); for(int i=0;i&lt;k;++i) for(int j=0;j&lt;k;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=2*k-2;i&gt;=k;--i) for(int j=0;j&lt;k;++j) tmp[i-j-1]=add(tmp[i-j-1],mul(tmp[i],f[j])); memcpy(a,tmp,k&lt;&lt;2);&#125;int solve(int *a,int *f,int n,int k)&#123; memset(base,0,sizeof base); memset(ans,0,sizeof ans); base[1]=ans[0]=1; while(n) &#123; if(n&amp;1) Mul(ans,base,f,k); Mul(base,base,f,k); n&gt;&gt;=1; &#125; int res=0; for(int i=0;i&lt;k;++i) res=add(res,mul(a[i],ans[i])); return res;&#125;int n,q,pw[MAXN];int f[MAXN][MAXN],g[MAXN][MAXN];int a[MAXN],F[MAXN];int Solve(int k)&#123; memset(f,0,sizeof f); memset(g,0,sizeof g); memset(a,0,sizeof a); memset(F,0,sizeof F); for(int j=0;j&lt;=k+1;++j) g[0][j]=f[0][j]=1; for(int i=1;i&lt;=1000;++i) &#123; for(int j=k/i;j&gt;=0;--j) &#123; int L=j?(i-1-k/j):0; L=max(L,0); int R=min(i-1,k/(j+1)); for(int r=L;r&lt;=R;++r) &#123; int t=mul(pw[j],add(1,P-q)); t=mul(t,mul(g[r][j+1],g[i-1-r][j])); f[i][j]=add(f[i][j],t); &#125; g[i][j]=add(g[i][j+1],f[i][j]); &#125; &#125; if(n&lt;=1000) return g[n][0]; for(int i=0;i&lt;=k;++i) a[i]=g[i][0]; for(int r=0;r&lt;=k;++r) F[r]=mul(g[r][1],add(1,P-q)); return solve(a,F,n,k+1);&#125;int main()&#123; n=read(); int k=read(); int x=read(),y=read(); q=mul(x,inv(y)); pw[0]=1; for(int i=1;i&lt;=k;++i) pw[i]=mul(pw[i-1],q); cout&lt;&lt;add(Solve(k),P-Solve(k-1))&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>常系数线性递推</tag>
        <tag>概率/期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Berlekamp-Massey 算法学习笔记]]></title>
    <url>%2F2019%2F07%2F09%2FBerlekamp-Massey-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在李巨的指引下学了一发. 简称 $BM$ 算法,可以以 $O(n^2)$ 的时间复杂度求解一个长度为 $n$ 的数列的最短线性递推式. 对于数列 $\lbrace a_1,a_2,a_3,\dots,a_n \rbrace$ ,称数列 $\lbrace R_1,R_2,R_3,\dots,R_m \rbrace$ 为其线性递推式,当且仅当下式成立: $$\forall m+1\le i\le n,a_i=\sum_{j=1}^m R_j\cdot a_{i-j}$$ 若它是所有合法线性递推式中长度 $m$ 最小的线性递推式,则称它为数列 $\lbrace a_1,a_2,a_3,\dots,a_n \rbrace$ 的最短线性递推式. 若未特殊说明,接下来的递推式,线性递推式均指 最短线性递推式 , $BM$ 算法的主要思路是从前往后依次考虑每个数,修改当前递推式使其合法,并且满足最短. 尝试由 $\lbrace a_1,a_2,a_3,\dots,a_{i-1} \rbrace$ 的递推式 $\lbrace r_1,r_2,r_3,\dots,r_m \rbrace$ 得出 $\lbrace a_1,a_2,a_3,\dots,a_i \rbrace$ 的递推式. 记递推式被更改的次数为 $cnt$ ,第 $i$ 次修改后得到的递推式为 $R_i$ ,规定 $R_0$ 为空.记递推式 $\lbrace r_1,r_2,r_3,\dots,r_m \rbrace$ 为当前递推式,即 $R_{cnt}$ . 记 $delta_i=a_i-\sum_{j=1}^m r_{j}\cdot a_{i-j}$ ,即用当前递推式算得的值与真实值之间的误差.若 $delta_i=0$ ,则不需要对递推式进行修改,直接考虑下一个元素 $a_{i+1}$ . 否则说明 $R_{cnt}$ 在位置 $i$ 出错了,记 $R_{cnt}$ 第一次出错的位置为 $fail_i$ ,则 $fail_{cnt}=i$ .考虑对 $R_{cnt}$ 进行修改,得到 $R_{cnt+1}$ ,并使得它在位置 $i$ 也成立. 若当前 $cnt=0$ ,说明 $a_i$ 是第一个非零元素,直接将 $R_1$ 置为 $\lbrace 0,0,0,\dots0 \rbrace$ ( $i$ 个 $0$ ) 即可. 否则, $cnt&gt;0$ ,说明之前已经修改过递推式,即存在 $R_k$, 记录 $p=fail_k$ ,尝试在 $R_k$ 的基础上修改,在 $a_i$ 的位置上递推出一个 $-delta_{p}$ 每个位置乘上 $\frac {delta_i} {delta_p}$ ,每个位置再加上原来的 $R_{cnt}$ 就得到合法的 $R_{cnt+1}$ . 将 $R_k$ 的元素全部变成它的相反数,再在前面补上一个 $1$ , $-delta_p$ 就到 $p+1$ 位置上来了.再在前面补 $i-p-1$ 个 $0$ , $-delta_p$ 就到位置 $i$ 上来了. 于是得到 $R_{cnt+1}=\frac {delta_i} {delta_p}*\lbrace 0,0,0,\dots,1,-R_{k_1},-R_{k_2},\dots,-R_{k_M} \rbrace + R_{cnt}$ . $0$ 有 $i-p-1$ 个. 为了保证得到的递推式长度最短,我们需要选取恰当的 $k$ .容易看出,得到的 $R_{cnt+1}$ 的长度为 $\max(i-p+M,m)$ , $M$ 为 $R_k$ 的长度, $m$ 为 $R_{cnt}$ 的长度.于是记录 $M-p$ 最短的递推式作为 $R_k$ . 最坏情况需要更新 $n$ 次递推式,时间复杂度 $O(n^2)$ . 用 $BM$ 得到的最短递推式长度最好要明显小于 $n$ 的一半,否则需要再打些表. 为什么?因为若长度为 $\frac n 2$,可以看做 $\frac n 2$ 个变量列出 $\frac n 2$ 个方程,总能找到解. 所以一个随机数列解出的最短递推式长度就是 $n$ 的一半左右,长度在 $\frac n 2$ 左右说明原数列很可能并没有一定的规律,即,大概率对之后的数据不适用. 另,因为计算中涉及 $\frac {delta_i} {delta_p}$ ,所以 $BM$ 在实数域内求解可能有一定的精度误差.若在模质数意义下,则不用考虑. 板子. $vector$ 下标从 $0$ 开始,要注意处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int inf=P+1;inline int add(int a,int b)&#123; return (a+b)%P;&#125;inline int sub(int a,int b)&#123; return (a-b+P)%P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;#define len(A) A.size()typedef vector&lt;int&gt; poly;poly BerlekampMassey(poly a)&#123; poly R_k,R; int n=a.size(); int p=-inf,Delta; int fail,delta; for(int i=0;i&lt;n;++i) &#123; delta=a[i]; for(int j=0;j&lt;len(R);++j) delta=sub(delta,mul(R[j],a[i-(j+1)])); if(!delta) continue; fail=i; if(p==-inf) &#123; R.resize(i+1); p=fail; Delta=delta; continue; &#125; poly r; int tmp=mul(delta,inv(Delta)); for(int j=1;j&lt;=i-p-1;++j) r.push_back(0); r.push_back(tmp); for(int j=0;j&lt;len(R_k);++j) r.push_back(sub(0,mul(tmp,R_k[j]))); if(len(r)&lt;len(R)) r.resize(len(R)); for(int j=0;j&lt;len(R);++j) r[j]=add(r[j],R[j]); if(len(R)+p&lt;len(R_k)+fail) &#123; R_k=R; Delta=delta; p=fail; &#125; R=r; &#125; return R;&#125;int main()&#123; int n=read(); poly a; for(int i=1;i&lt;=n;++i) a.push_back(read()); poly R=BerlekampMassey(a); int m=R.size(); printf("%u\n",m); for(int i=0;i&lt;m;++i) printf("%d ",R[i]); puts(""); for(int i=m;i&lt;n;++i) &#123; int delta=a[i]; for(int j=0;j&lt;m;++j) delta=sub(delta,mul(R[j],a[i-(j+1)])); assert(!delta); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>BM</tag>
        <tag>常系数线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4557 侦察守卫]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4557-%E4%BE%A6%E5%AF%9F%E5%AE%88%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[树形 $dp$ . 设 $f(i,j)$ 表示将子树 $i$ 内除了最上面 $j$ 层,其余关键点都被覆盖的最小代价. $g(i,j)$ 表示子树 $i$ 内所有关键点都已被覆盖,并且还向上覆盖了 $j$ 层的最小代价. 当前处理节点为 $u$ ,其中一个儿子节点为 $v$ ,有转移 $g(u,j)=\min(g(u,j)+f(v,j), f(u,j+1)+g(v,j+1)),f(u,j)=\sum f(v,j-1)$ . 第一个转移表示让子树 $v$ 内的点来覆盖原来需要覆盖的 $j$ 层.第二个转移比较显然. 最后再贪心考虑 $f,g$ 的前缀/后缀和,即 $f(u,j)\leftarrow f(u,j-1),g(u,j)\leftarrow g(u,j+1)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;const int inf=1e9;const int MAXN=5e5+10;int n,m,d,w[MAXN],flag[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[MAXN][22],g[MAXN][22];void dfs(int u,int fa)&#123; if(flag[u]) f[u][0]=g[u][0]=w[u]; for(int i=1;i&lt;=d;++i) g[u][i]=w[u]; g[u][d+1]=f[u][d+1]=inf; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); for(int j=0;j&lt;=d;++j) g[u][j]=min(g[u][j]+f[v][j],f[u][j+1]+g[v][j+1]); for(int j=d-1;j&gt;=0;--j) upd(g[u][j],g[u][j+1]); f[u][0]=g[u][0]; for(int j=1;j&lt;=d;++j) f[u][j]+=f[v][j-1]; for(int j=1;j&lt;=d;++j) upd(f[u][j],f[u][j-1]); &#125;&#125;int main()&#123; n=read(),d=read(); for(int i=1;i&lt;=n;++i) w[i]=read(); m=read(); for(int i=1;i&lt;=m;++i) flag[read()]=1; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); cout&lt;&lt;g[1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2718 归程]]></title>
    <url>%2F2019%2F07%2F08%2FLoj-2718-%E5%BD%92%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最短路 + 可持久化并查集. 假设有一个新图,只保留当前没有积水的边,那么一个连通块内的点都可以用车直接到达. 询问出发点为 $v$ 时的答案,就是询问新图中 $v$ 所在联通块内的点到 $1$ 号节点的最短距离.可以先用 $Dijkstra$ 预处理出每个点到 $1$ 的距离. 如果不强制在线,可以将询问离线后按水位线从高到低排序,这样在新图中就只有加边的操作,直接用并查集维护联通情况以及联通块的答案. 强制在线的话,就换成可持久化并查集 (用主席树维护 $fa$ ) ,将边从大到小排序依次加入并更新联通块信息.询问时根据高度二分找到对应的版本,然后回答询问即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXN=4e5+10;int lastans,n,m,Q,K,S;struct Edge&#123; int fr,to,val,h; bool operator &lt; (const Edge &amp;rhs) const &#123; return h==rhs.h?val&gt;rhs.val:h&gt;rhs.h; &#125;&#125;E[MAXN&lt;&lt;1];int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;priority_queue&lt;pii&gt; q;int dis[MAXN],vis[MAXN];void Dijkstra()&#123; dis[1]=0; q.push(mp(0,1)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125;&#125;int rt[MAXN&lt;&lt;1];struct PreSegTree&#123; int nodeidx; struct node &#123; int ls,rs; int fa,dep,mn; &#125;Tree[MAXN*30];#define root Tree[o] void init()&#123;nodeidx=0;&#125; void BuildTree(int &amp;o,int l,int r) &#123; o=++nodeidx; if(l==r) &#123; root.fa=l; root.dep=1; root.mn=dis[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(root.ls,l,mid); BuildTree(root.rs,mid+1,r); &#125; void upd_fa(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++nodeidx; root=Tree[pre]; if(l==r) &#123; root.fa=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd_fa(root.ls,Tree[pre].ls,l,mid,pos,c); else upd_fa(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; void upd_dep(int o,int l,int r,int pos) &#123; if(l==r) &#123; ++root.dep; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd_dep(root.ls,l,mid,pos); else upd_dep(root.rs,mid+1,r,pos); &#125; int query_id(int o,int l,int r,int pos) &#123; if(l==r) return o; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_id(root.ls,l,mid,pos); else return query_id(root.rs,mid+1,r,pos); &#125; int query_fa(int o,int x) &#123; int p=query_id(o,1,n,x); if(Tree[p].fa==x) return p; else return query_fa(o,Tree[p].fa); &#125; void recall(int &amp;o,int pre,int l,int r,int pos) &#123; o=++nodeidx; root=Tree[pre]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) recall(root.ls,Tree[pre].ls,l,mid,pos); else recall(root.rs,Tree[pre].rs,mid+1,r,pos); &#125; void merge(int x,int y,int idx) &#123; if(Tree[x].dep&gt;Tree[y].dep) swap(x,y); upd_fa(rt[idx],rt[idx-1],1,n,Tree[x].fa,Tree[y].fa); recall(rt[idx],rt[idx],1,n,Tree[y].fa); int u=query_id(rt[idx],1,n,Tree[y].fa); int v=query_id(rt[idx],1,n,Tree[x].fa); Tree[u].mn=min(Tree[u].mn,Tree[v].mn); if(Tree[x].dep==Tree[y].dep) upd_dep(rt[idx],1,n,Tree[y].fa); &#125;&#125;T;int H[MAXN&lt;&lt;1];void init()&#123; Dijkstra(); sort(E+1,E+1+m); for(int i=1;i&lt;=m;++i) H[i]=E[m+1-i].h; T.BuildTree(rt[0],1,n); for(int i=1;i&lt;=m;++i) &#123; rt[i]=rt[i-1]; int x=E[i].fr,y=E[i].to; x=T.query_fa(rt[i],x); y=T.query_fa(rt[i],y); if(T.Tree[x].fa!=T.Tree[y].fa) T.merge(x,y,i); &#125;&#125;int solve(int v,int p)&#123; int idx=m+1-(upper_bound(H+1,H+1+m,p)-H); int x=T.query_fa(rt[idx],v); return T.Tree[x].mn;&#125;void Reset()&#123; lastans=0; ecnt=0; memset(head,0,sizeof head); memset(dis,0x7f,sizeof dis); memset(vis,0,sizeof vis); T.init(); rt[0]=0;&#125;int main()&#123; freopen("return.in","r",stdin); freopen("return.out","w",stdout); int T=read(); while(T--) &#123; Reset(); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=(E[i].fr=read()); int v=(E[i].to=read()); E[i].val=read(); E[i].h=read(); addedge(u,v,E[i].val); addedge(v,u,E[i].val); &#125; init(); Q=read(),K=read(),S=read(); while(Q--) &#123; int v=(read()+K*lastans-1)%n+1; int p=(read()+K*lastans)%(S+1); lastans=solve(v,p); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>最短路</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4555 求和]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4555-%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[第二类斯特林数 + $NTT$ . 第二类斯特林数 $S(n,m)$ 表示将 $n$ 个球放入 $m$ 个相同盒子的方案数. 递推式是 $S(n,m)=S(n-1,m-1)+m\cdot S(n-1,m)$ .即讨论第一个球是否单独占一个盒子. 也可利用容斥原理计算, $$S(n,m)=\frac 1 {m!} \sum_{k=0}^m (-1)^k{m\choose k}(m-k)^n$$ 意义是枚举空盒个数为 $k$ ,剩下的球任意放置.因为盒子相同,所以最后要除以 $m!$ . 回到这道题, $j&lt;i$ 时, $S(i,j)=0$ ,所以 $j$ 的枚举范围可以换成 $n$ .将上面的容斥计算式代到要求的式子里面, 仔细观察,发现第二个 $\sum$ 后面那一坨是一个卷积的形式,令 $a_i=\frac {(-1)^i} {i!},b_i=\frac {\sum_{j=0}^n i^j} {i!}$ , $c=a*b$ ,则 $ans=\sum_{j=0}^n 2^j\cdot j!\cdot c_j$ . 预处理 $a,b,2^j,j!$ ( $b_i$ 的分子是等比数列求和 ) ,用 $NTT$ 计算 $c$ . 空间要开够. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;const int MAXN=1e5+10;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int rev[MAXN&lt;&lt;2];void NTT_init(int n,int lim)&#123; for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;lim;++j) if((i&gt;&gt;j)&amp;1) rev[i]|=1&lt;&lt;(lim-j-1); &#125;&#125;void DFT(int *a,int n,bool invflag)&#123; for(int i=0;i&lt;n;++i) &#123; if(i&lt;rev[i]) swap(a[i],a[rev[i]]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int gi=fpow(G,(P-1)/l); if(invflag) gi=inv(gi); int m=l&gt;&gt;1; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int Invn=inv(n); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],Invn); &#125;&#125;int n;int a[MAXN&lt;&lt;2],b[MAXN&lt;&lt;2],c[MAXN&lt;&lt;2];int fac[MAXN],invfac[MAXN],pw[MAXN];void init()&#123; pw[0]=1; for(int i=1;i&lt;=n;++i) pw[i]=mul(pw[i-1],2); fac[0]=invfac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=inv(fac[n]); for(int i=n-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1); for(int i=0;i&lt;=n;++i) if(i&amp;1) a[i]=add(P,-invfac[i]); else a[i]=invfac[i]; b[0]=1; b[1]=n+1; for(int i=2;i&lt;=n;++i) &#123; b[i]=add(fpow(i,n+1),P-1); b[i]=mul(b[i],inv(i-1)); b[i]=mul(b[i],invfac[i]); &#125;&#125;int main()&#123; n=read(); init(); int N=1,lim=0; while(N&lt;=2*n) N&lt;&lt;=1,++lim; NTT_init(N,lim); DFT(a,N,false); DFT(b,N,false); for(int i=0;i&lt;N;++i) c[i]=mul(a[i],b[i]); DFT(c,N,true); int ans=0; for(int i=0;i&lt;=n;++i) &#123; int tmp=mul(pw[i],fac[i]); ans=add(ans,mul(tmp,c[i])); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4554 游戏]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4554-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[最大流. 比较明显是个网络流,考虑如何建模. 硬石头将每一行分成了若干块,每一块内最多放一个炸弹,每一列也同理.然后对每一行/列的块建出它们的点,每一块能通过的流量都是 $1$ .对于空地 $(x,y)$ ,就从 $(x,y)$ 所在的行块向 $(x,y)$ 所在的列块连流量为 $1$ 的边就好了. 再建出源汇点连上这些块,跑一个最大流即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e3+10,MAXM=3e5+10,N=51;int n,m,Map[N][N],bx[N][N],by[N][N],tx=0,ty=0;const int inf=1e9;char buf[N];struct Edge&#123; int nx,to,flow;&#125;E[MAXM];int head[MAXN],ecnt=-1;void addedge(int u,int v,int flow)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; head[u]=ecnt;&#125;void ins(int u,int v,int flow)&#123; addedge(u,v,flow); addedge(v,u,0);&#125;int trans(char c)&#123; if(c=='*') return 0; if(c=='x') return 1; return 2;&#125;int cur[MAXN],dis[MAXN],flow[MAXN],dep[MAXN];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=T;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,Flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; Flow+=f; limit-=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return Flow;&#125;int Dinic(int S,int T)&#123; int Maxflow=0; while(bfs(S,T)) Maxflow+=dfs(S,T,inf); return Maxflow;&#125;void solve()&#123; for(int i=1;i&lt;=n;++i) &#123; ++tx; for(int j=1;j&lt;=m;++j) &#123; bx[i][j]=tx; if(Map[i][j]==2) ++tx; &#125; &#125; for(int j=1;j&lt;=m;++j) &#123; ++ty; for(int i=1;i&lt;=n;++i) &#123; by[i][j]=ty; if(Map[i][j]==2) ++ty; &#125; &#125; int S=tx+ty+1,T=tx+ty+2; for(int i=1;i&lt;=tx;++i) ins(S,i,1); for(int i=1;i&lt;=ty;++i) ins(i+tx,T,1); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(!Map[i][j]) ins(bx[i][j],by[i][j]+tx,1); cout&lt;&lt;Dinic(S,T)&lt;&lt;endl;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) Map[i][j]=trans(buf[j]); &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4553 序列]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4553-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[$cdq$ 分治处理三维偏序. 记位置 $i$ 原本的值为 $a_i$ ,可能出现的最大值为 $mx_i$ ,可能出现的最小值为 $mn_i$ .像普通的 $LIS$ 那样,设 $f(i)$ 表示必须以第 $i$ 个数结尾的 $LIS$ 长度. 因为每次只能有一个位置被修改,不难发现完成转移 $f(i)\leftarrow f(j)+1$ 需要同时满足三个条件, $mx_j\leq a_i,a_j\leq mn_i,j&lt;i​$ . 就是一个三维偏序,贡献又是可结合的,于是用 $cdq$ 分治处理即可.时间复杂度 $O(n\cdot log^2n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,a[MAXN],mx[MAXN],mn[MAXN];int f[MAXN];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=max(bit[x],c); &#125; void rst(int x) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=0; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s=max(s,bit[x]); return s; &#125;&#125;T;struct opt&#123; int x,y,pos; bool operator &lt; (const opt &amp;rhs) const &#123; return y==rhs.y?pos&lt;=rhs.pos:y&lt;=rhs.y; &#125;&#125;q[MAXN];void cdq(int L,int R)&#123; if(L==R) return; int mid=(L+R)&gt;&gt;1; cdq(L,mid); int tot=0; for(int i=L;i&lt;=R;++i) &#123; q[++tot].pos=i; if(i&lt;=mid) q[tot].x=mx[i],q[tot].y=a[i]; else q[tot].x=a[i],q[tot].y=mn[i]; &#125; sort(q+1,q+1+tot); for(int i=1;i&lt;=tot;++i) &#123; if(q[i].pos&lt;=mid) T.add(q[i].x,f[q[i].pos]); else f[q[i].pos]=max(f[q[i].pos],T.sum(q[i].x)+1); &#125; for(int i=1;i&lt;=tot;++i) if(q[i].pos&lt;=mid) T.rst(q[i].x); cdq(mid+1,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; mx[i]=mn[i]=a[i]=read(); f[i]=1; &#125; for(int i=1;i&lt;=m;++i) &#123; int pos=read(),x=read(); mx[pos]=max(mx[pos],x); mn[pos]=min(mn[pos],x); &#125; cdq(1,n); cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 133]]></title>
    <url>%2F2019%2F07%2F08%2FAtcoder-Beginner-Contest-133%2F</url>
    <content type="text"><![CDATA[$F$ 没调出来,炸了. C Remainder Minimization 2019 可以直接大力枚举两个余数是多少,再判断它们是否合法,合法就计入贡献. 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;bool judge(int a,int b,int L,int R)&#123; if(R&lt;a || R&lt;b) return false; int L1=(L-a+2018)/2019,R1=(R-a)/2019; int L2=(L-b+2018)/2019,R2=(R-b)/2019; if(L1&gt;R1 || L2&gt;R2) return false; if(a&lt;b) return L1&lt;=R2; else return L1&lt;R2;&#125;int main()&#123; int L=read(),R=read(); int ans=2019; for(int i=0;i&lt;2019;++i) for(int j=0;j&lt;2019;++j) if(judge(i,j,L,R)) ans=min(ans,i*j%2019); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Rain Flows into Dams 设第 $i$ 座山收到的水为 $x_i$ ,可以把题目中所给的条件表示为方程组的形式. 题目保证 $x$ 有唯一的一组合法解,所以直接将这个方程组解出来,得到的就是那组合法解,过程中不必判断. 尝试手动解.首先将所有方程加起来可以得到 $\sum x_i$ .每两个相邻的方程相减可以得到 $x_3-x_1,x_4-x_2,x_5-x_3,x_6-x_4\dots$ 这些值. 求前缀和就可以得到每个奇数位置与 $x_1$ 的差值,每个偶数位置与 $x_2$ 的差值.再根据 $x_n+x_1$ 将 $x_1$ 以及所有奇数位置的 $x$ 解出,用 $\sum x_i$ 减去奇数位置的总和,得到偶数位置的总和,再根据求得的差分解出所有偶数位置 $x$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n;ll sum=0,a[MAXN],t[MAXN],x[MAXN];void pr()&#123; for(int i=1;i&lt;=n;++i) printf("%lld ",x[i]); puts("");&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) sum+=(a[i]=read()); for(int i=3;i&lt;=n;i+=2) &#123; t[i]=a[i-1]-a[i-2]; t[i]+=t[i-2]; &#125; x[1]=a[n]-t[n]; for(int i=1;i&lt;=n;i+=2) sum-=(x[i]=x[1]+2*(t[i])); if(n==3) &#123; x[2]=sum; pr(); return 0; &#125; ll tot=0,cnt=1; for(int i=4;i&lt;n;i+=2) &#123; t[i]=2*(a[i-1]-a[i-2]); t[i]+=t[i-2]; tot+=t[i]; ++cnt; &#125; x[2]=(sum-tot)/(cnt); for(int i=4;i&lt;n;i+=2) x[i]=x[2]+t[i]; pr(); return 0;&#125; E Virus Tree 2 只需满足每个点与它的父亲颜色不同,每个点与它父亲的父亲颜色不同,每个点的所有儿子颜色不同. 设 $f(i)$ 表示当节点 $i$ 的颜色已被确定时,子树 $i$ 内染色的方案数,随便 $dfs$ 一下即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],ecnt=0;void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int fac[MAXN],invfac[MAXN];int n,k,f[MAXN],Deg[MAXN];int fa[MAXN];int A(int N,int M)&#123; if(N&gt;M) return 0; return mul(fac[M],invfac[M-N]);&#125;int dfs(int u,int num,int Fa)&#123; fa[u]=Fa; if(num&lt;=0) return f[u]=0; int deg=(u==1?Deg[u]:Deg[u]-1); if(!deg) return f[u]=1; if(u==1) f[u]=A(deg,k-1); else f[u]=A(deg,k-2); if(!f[u]) return f[u]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; if(u==1) dfs(v,k-1,u); else dfs(v,k-2,u); f[u]=mul(f[u],f[v]); &#125; return f[u];&#125;int main()&#123; n=read(),k=read(); fac[1]=1; for(int i=2;i&lt;=k;++i) fac[i]=mul(fac[i-1],i); invfac[k]=fpow(fac[k],P-2); for(int i=k-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); ++Deg[u],++Deg[v]; &#125; cout&lt;&lt;mul(dfs(1,k,0),k)&lt;&lt;endl; return 0;&#125; F Colorful Tree 不难发现对于每个询问 $(x,y,u,v)$ 只需要找出 $u\to v$ 的路径上颜色为 $x$ 的边的数目 $cnt$ 以及这些边的总长度 $sum$ .答案就是 $dist(u,v)-sum+cnt\cdot y$ . 询问一段区间某种颜色的数目/权值和,用主席树进行维护.时间复杂度 $O(n\cdot log^n)$ . 树上的主席树并不需要像线段树那样维护 $dfs$ 序.直接在第一次 $dfs$ 时每个点复制父亲的信息,再修改即可.询问就是 $rt[u]+rt[v]-rt[LCA]-rt[LCA.fa]$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct Edge&#123; int nx,to;&#125;E[MAXN&lt;&lt;1];int head[MAXN],ecnt=0;int col[MAXN],val[MAXN];void addedge(int u,int v)&#123; ++ecnt; E[ecnt].nx=head[u]; E[ecnt].to=v; head[u]=ecnt;&#125;void ins(int u,int v)&#123; addedge(u,v); addedge(v,u);&#125;int n,m;int dfn[MAXN],idx=0;int dep[MAXN],fa[MAXN],top[MAXN];int siz[MAXN],mxson[MAXN],dist[MAXN];struct PreSegTree&#123; int nodeidx; struct node &#123; int cnt,sum; int ls,rs; &#125;Tree[MAXN*30]; PreSegTree()&#123;nodeidx=0;Tree[0].cnt=Tree[0].sum=0;&#125;#define root Tree[o] void upd(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++nodeidx; root=Tree[pre]; if(!pos) return; if(l==r) &#123; root.cnt++; root.sum+=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[pre].ls,l,mid,pos,c); else upd(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; int query_sum(int o,int l,int r,int pos) &#123; if(!o) return root.sum; if(l==r) return root.sum; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_sum(root.ls,l,mid,pos); else return query_sum(root.rs,mid+1,r,pos); &#125; int query_cnt(int o,int l,int r,int pos) &#123; if(!o) return root.cnt; if(l==r) return root.cnt; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_cnt(root.ls,l,mid,pos); else return query_cnt(root.rs,mid+1,r,pos); &#125;&#125;T;int rt[MAXN];void dfs1(int u,int Fa)&#123; fa[u]=Fa; dep[u]=dep[Fa]+1; siz[u]=1; T.upd(rt[u],rt[Fa],1,n,col[u],val[u]); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(v==Fa) continue; dist[v]=dist[u]+val[v]; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;void init()&#123; dfs1(1,0); dfs2(1,1);&#125;int getLCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int Solve(int c,int d,int x,int y)&#123; int LCA=getLCA(x,y); int cnt=0,sum=0; cnt+=T.query_cnt(rt[x],1,n,c)+T.query_cnt(rt[y],1,n,c); cnt-=T.query_cnt(rt[LCA],1,n,c)+T.query_cnt(rt[fa[LCA]],1,n,c); sum+=T.query_sum(rt[x],1,n,c)+T.query_sum(rt[y],1,n,c); sum-=T.query_sum(rt[LCA],1,n,c)+T.query_sum(rt[fa[LCA]],1,n,c); int res=dist[x]+dist[y]-dist[LCA]-dist[fa[LCA]]; return res-sum+d*cnt;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); col[n+i]=read(),val[n+i]=read(); ins(u,n+i); ins(v,n+i); &#125; n=2*n-1; init(); while(m--) &#123; int x=read(),y=read(); int u=read(),v=read(); printf("%d\n",Solve(x,y,u,v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>树形dp</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4551 树]]></title>
    <url>%2F2019%2F07%2F06%2Fbzoj-4551-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[并查集. 大力用树剖 + 树状数组维护是 $O(n\cdot log^3n)$ 的. 考虑先将操作先全部离线下来,每个标记都打上,对于没有被打标记的点,用并查集将它与它的父亲合并. 然后从后往前处理操作,遇到询问就直接回答,遇到修改,其实是给某个点的标记次数 $-1$ ,删除后用并查集合并. 时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,Q;char buf[2];int head[MAXN],to[MAXN],nx[MAXN],ecnt=0;void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct opt&#123; int tp,x;&#125;q[MAXN];struct dsu&#123; int fa[MAXN]; void init() &#123; for(int i=1;i&lt;=n;++i) fa[i]=i; &#125; int Find(int x) &#123; if(x==fa[x]) return x; return (fa[x]=Find(fa[x])); &#125; void Merge(int u,int v) &#123; u=Find(u),v=Find(v); if(u!=v) fa[u]=v; &#125;&#125;DSU;int flag[MAXN],Fa[MAXN];void dfs(int u,int f)&#123; Fa[u]=f; if(!flag[u]) DSU.Merge(u,f); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v,u); &#125;&#125;int ans[MAXN],tot=0;int main()&#123; n=read(),Q=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); &#125; flag[1]=1; for(int i=1;i&lt;=Q;++i) &#123; scanf("%s",buf); q[i].tp=(buf[0]=='C'); q[i].x=read(); if(q[i].tp) ++flag[q[i].x]; else ++tot; &#125; int pt=tot; DSU.init(); dfs(1,0); for(int i=Q;i&gt;=1;--i) &#123; int tp=q[i].tp,x=q[i].x; if(!tp) &#123; x=DSU.Find(x); ans[pt--]=x; &#125; else &#123; --flag[x]; if(!flag[x]) DSU.Merge(x,Fa[x]); &#125; &#125; for(int i=1;i&lt;=tot;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4552 排序]]></title>
    <url>%2F2019%2F07%2F04%2Fbzoj-4552-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[二分 + 线段树. 开始以为是中间有多次询问,想了两节课.读题发现,只在最后询问一次,那就很友好了. 操作/贡献都只与相对大小有关,经典套路就是二分答案,将数列变为 $0/1$ 数列,就可以直接用线段树维护了. 时间复杂度 $O(m\cdot log^2n)$ . 修改操作注意特判 $L&gt;R$ 的情况. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,q,a[MAXN];struct SegTree&#123; struct node &#123; int sum,tag; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void BuildTree(int o,int l,int r,int k) &#123; root.tag=-1; if(l==r) &#123; if(a[l]&gt;=k) root.sum=1; else root.sum=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid,k); BuildTree(o&lt;&lt;1|1,mid+1,r,k); pushup(o); &#125; void Modifiy(int o,int l,int r,int c) &#123; root.sum=(r-l+1)*c; root.tag=c; &#125; void pushdown(int o,int l,int r) &#123; if(root.tag!=-1) &#123; int mid=(l+r)&gt;&gt;1; Modifiy(o&lt;&lt;1,l,mid,root.tag); Modifiy(o&lt;&lt;1|1,mid+1,r,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,l,r,c); return; &#125; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;struct opt&#123; int op,L,R;&#125;Q[MAXN];bool check(int k)&#123; T.BuildTree(1,1,n,k); for(int i=1;i&lt;=m;++i) &#123; int L=Q[i].L,R=Q[i].R; int tot1=T.query(1,1,n,L,R); int tot0=R-L+1-tot1; if(Q[i].op==0) &#123; T.upd(1,1,n,L,L+tot0-1,0); T.upd(1,1,n,L+tot0,R,1); &#125; else &#123; T.upd(1,1,n,L,L+tot1-1,1); T.upd(1,1,n,L+tot1,R,0); &#125; &#125; return (bool)(T.query(1,1,n,q,q));&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=m;++i) &#123; Q[i].op=read(); Q[i].L=read(); Q[i].R=read(); &#125; q=read(); int L=1,R=n,ans=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4550 小奇的博弈]]></title>
    <url>%2F2019%2F07%2F02%2Fbzoj-4550-%E5%B0%8F%E5%A5%87%E7%9A%84%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[$Nimk$ 游戏 + $dp$ 计数. 最优策略下,白棋显然都选择右移,黑棋都选择左移.如果把每对棋子的间隔长度看做一堆石子的石子数目,那么此题就是一个 $Nim$ 游戏的变种,每次最多可以选 $d$ 堆石子进行操作.这个东西叫做 $Nimk$ 游戏. $Nimk$ 游戏先手必败条件:对于每个二进制位 $i$ ,所有石子数目的第 $i$ 位之和为 $d+1$ 的倍数. 即, $\forall i,(\sum_j(a_j&gt;&gt;i)\&amp;1)\mod d+1=0​$ . 转成 $Nimk$ 模型,有 $\frac k 2$ 堆石子,石子总数不超过 $n-k$ 个.求必胜方案数可以用总方案数 $n \choose k$ 减去必败方案数. 令 $f(i,j)$ 表示从第 $0$ 位开始算,已经考虑了二进制的前 $i$ 位,用掉了 $j$ 个石子的方案数.转移有: $$f(i+1,j+x\cdot (d+1)\cdot 2^i)+=f(i,j)\cdot {k/2 \choose x\cdot(d+1)}$$ 枚举 $x$ 进行转移,必败方案数就是 $\sum f(inf,j)\cdot {n-j-k/2\choose k/2}$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;inline void upd(int &amp;a,int b)&#123; a=add(a,b);&#125;const int MAXK=101,MAXN=1e4+10;int C[MAXN][MAXK],f[20][MAXN];int main()&#123; int n=read(),k=read(),d=read(); C[0][0]=1; for(int i=1;i&lt;=n;++i) &#123; C[i][0]=1; for(int j=1;j&lt;=i &amp;&amp; j&lt;=k;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125; f[0][0]=1; for(int i=0;i&lt;=16;++i) for(int j=0;j&lt;=n-k;++j) for(ll x=0;x*(d+1)&lt;=k/2 &amp;&amp; x*(d+1)*(1LL&lt;&lt;i)+j&lt;=n-k;++x) upd(f[i+1][x*(d+1)*(1&lt;&lt;i)+j],mul(f[i][j],C[k/2][x*(d+1)])); int ans=0; for(int j=0;j&lt;=n-k;++j) upd(ans,mul(f[16][j],C[n-j-k/2][k/2])); ans=add(-ans,C[n][k]); ans%=P,ans+=P,ans%=P; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4548 小奇的糖果]]></title>
    <url>%2F2019%2F06%2F29%2Fbzoj-4548-%E5%B0%8F%E5%A5%87%E7%9A%84%E7%B3%96%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[树状数组. 题面有些歧义,线段上/下方的点是指横坐标也落在线段范围内的点.不包含所有颜色是指不包含所有 $k$ 种颜色. 要求不包含所有颜色,即至少有一种颜色没有包含.可以枚举这个颜色 $c$ ,计算不包含 $c$ 时的最大收益. 把所有点按照 $y$ 坐标从小到大排序,依次处理.如果对某一个点,以它的 $y$ 坐标为下边界画矩形,贪心画最大的,往两边拓展,直到遇到不能选的颜色为止.这个就是在对应颜色的 $set$ 里面找一下前驱后继. 以它的 $y$ 坐标为上边界同理,将 $y$ 坐标从大到小排序做上面过程即可.画矩形时的收益用树状数组维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct node&#123; int x,y,col; bool operator &lt; (const node &amp;rhs) const &#123; return y&lt;rhs.y; &#125;&#125;a[MAXN];int n,m,ans=0,v[MAXN];struct FenwickTree&#123; int bit[MAXN]; void init()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;T;set&lt;int&gt; s[MAXN];set&lt;int&gt;::iterator it;void solve()&#123; T.init(); for(int i=1;i&lt;=m;++i) &#123; s[i].clear(); s[i].insert(0); s[i].insert(n+1); &#125; for(int i=1,j=1;i&lt;=n;i=j) &#123; while(j&lt;=n &amp;&amp; a[j].y==a[i].y) ++j; for(int k=i;k&lt;j;++k) &#123; int tmp=T.sum(*s[a[k].col].lower_bound(a[k].x)-1); tmp-=T.sum(*--s[a[k].col].upper_bound(a[k].x)); ans=max(ans,tmp); &#125; for(int k=i;k&lt;j;++k) &#123; T.add(a[k].x,1); s[a[k].col].insert(a[k].x); &#125; &#125; for(int i=1;i&lt;=m;++i) for(it=s[i].begin();*it!=n+1;) &#123; int j=*it; ++it; ans=max(ans,T.sum(*it-1)-T.sum(j)); &#125;&#125;int main()&#123; int C=read(); while(C--) &#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].x=read(); a[i].y=read(); a[i].col=read(); v[i]=a[i].x; &#125; sort(a+1,a+1+n); sort(v+1,v+1+n); int cnt=unique(v+1,v+1+n)-v-1; for(int i=1;i&lt;=n;++i) a[i].x=lower_bound(v+1,v+1+cnt,a[i].x)-v; ans=0; solve(); for(int i=1;i*2&lt;=n;++i) swap(a[i],a[n+1-i]); solve(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190629]]></title>
    <url>%2F2019%2F06%2F29%2Ftest20190629%2F</url>
    <content type="text"><![CDATA[$\%\ nicodafagood$ . $quadratic$ 给 $n$ 个二次项系数为 $1$ 的二次函数,分别求 $x=1\sim n$ 时这 $n$ 个函数中的最小值. $n\leq 10^5$ . 因为二次项贡献固定,所以只需要算一次项和常数项的贡献,就相当于 $n$ 条直线在某个位置的最小值. 用凸包或者李超线段树写一下就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n;int A[MAXN],B[MAXN];ll k[MAXN],b[MAXN];const ll inf=1e18;inline ll calc(int seg,int x)&#123; return k[seg]*x+b[seg];&#125;inline int sgn(ll x)&#123; if(!x) return 0; return x&lt;0?-1:1;&#125;ll ans;struct SegTree&#123; int nodecnt; SegTree()&#123;nodecnt=0;&#125; struct node &#123; int ls,rs,id; ll mi; node()&#123;ls=rs=id=0;mi=inf;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void BuildTree(int l,int r) &#123; int o=++nodecnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; root.ls=nodecnt+1; BuildTree(l,mid); root.rs=nodecnt+1; BuildTree(mid+1,r); &#125; void pushup(int o,int l,int r) &#123; if(root.id) root.mi=k[root.id]&lt;0?calc(root.id,r):calc(root.id,l); else root.mi=inf; if(l&lt;r) &#123; root.mi=min(root.mi,lson.mi); root.mi=min(root.mi,rson.mi); &#125; &#125; void upd(int o,int l,int r,int L,int R,int seg) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!root.id) &#123; root.id=seg; pushup(o,l,r); return; &#125; bool f1=calc(root.id,l)&lt;calc(seg,l); bool f2=calc(root.id,r)&lt;calc(seg,r); if(f1==f2 || l==r) &#123; if(!f1) &#123; root.id=seg; pushup(o,l,r); &#125; return; &#125; int mid=(l+r)&gt;&gt;1; bool f3=calc(root.id,mid)&lt;calc(seg,mid); if(f1==f3) &#123; if(f1) upd(root.rs,mid+1,r,L,R,seg); else upd(root.rs,mid+1,r,L,R,root.id),root.id=seg; &#125; else &#123; if(f1) upd(root.ls,l,mid,L,R,root.id),root.id=seg; else upd(root.ls,l,mid,L,R,seg); &#125; &#125; else &#123; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(root.ls,l,mid,L,R,seg); if(R&gt;mid) upd(root.rs,mid+1,r,L,R,seg); &#125; pushup(o,l,r); &#125; void query(int o,int l,int r,int pos) &#123; if(root.id) &#123; if(k[root.id]&lt;0) ans=min(ans,calc(root.id,min(r,pos))); else ans=min(ans,calc(root.id,max(l,pos))); &#125; if(l==r) &#123; ans=min(ans,root.mi); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) query(root.ls,l,mid,pos); else query(root.rs,mid+1,r,pos); &#125;&#125;T;int main()&#123; freopen("quadratic.in","r",stdin); freopen("quadratic.out","w",stdout); n=read(); b[0]=inf; for(int i=1;i&lt;=n;++i) A[i]=read(); T.BuildTree(1,n); for(int i=1;i&lt;=n;++i) &#123; B[i]=read(); k[i]=-2LL*A[i]; b[i]=1LL*A[i]*A[i]+B[i]; T.upd(1,1,n,1,n,i); &#125; for(int i=1;i&lt;=n;++i) &#123; ans=inf; T.query(1,1,n,i); printf("%lld\n",ans+1LL*i*i); &#125; return 0;&#125; $equation$ 给定 $a,b,p,x$ ,求解 $[1,x]$ 中,满足 $n\cdot a^n\equiv b \mod p$ 的 $n$ 的数目. $0\leq a,b&lt;p\leq 10^6.x\leq 10^{12}.$ 保证 $p$ 为质数. 根据费马小定理,指数可以对 $p-1$ 取模.而 $p$ 的范围比较小,于是直接枚举 $n$ 对 $p-1$ 取模的结果 $i$. 即,在 $[0,p-2]$ 内枚举 $i$ ,对应贡献为满足下面两个条件的 $n$ 的数目. $$n\equiv i (mod\ p-1),n\equiv b\cdot a^{-i}(mod\ p)$$ 用 $CRT$ 求解 $p\cdot (p-1)$ 内的 $n$ ,再计算 $[1,x]$ 内对应 $n$ 数目即可. 时间复杂度 $O(p\cdot logp)$ . $datastructure$ 给定一个长度为 $n$ 的正整数数列 $a$ ,要求支持下列操作,共 $m$ 次. 将区间 $[l,r]$ 内的元素加上 $x$ . 将区间 $[l,r]$ 内的元素开平方,向下取整. 询问区间 $[l,r]$ 内的元素平方总和. 询问区间 $[l,r]$ 内的元素总和. $n,m\leq 10^5,1\leq a_i,x\leq 10^9$ . 考虑用线段树维护询问的答案. 有一档部分分是没有操作 $1$ 的,可以直接做,对每个区间记录元素是否都是 $1$ ,开方时讨论即可. 正解做法类似,不过优化的方法不同.开方 $[l,r]$ 时,先询问 $[l,r]$ 内的最大值 $a$ 与最小值 $b$ . 开方时都向下取整,若 $\sqrt {a}=\sqrt {b}$ ,就将这个区间全部修改为 $\sqrt a$ .若 $a-\sqrt a=b-\sqrt b$ ,就给这个区间全部减去 $a-\sqrt a$ ,因为这个差是关于元素大小不下降的. 若两种情况都不满足,就暴力修改区间内所有元素. 因为一次区间加最多会使得 $logn$ 个结点的 $a-b$ 变化,而变化后我们最多暴力开 $6$ 次方它就变成 $1$ 了,所以操作 $1,2$ 复杂度均摊下来,一次为 $O(logn)$ .于是总时间复杂度 $O(nlogn)$ . $unsigned\ long\ long$ 输出指令是 $\%llu$ .考试写成 $\%u$ 了. $70\to 15$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>test</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1186]]></title>
    <url>%2F2019%2F06%2F29%2FCF1186%2F</url>
    <content type="text"><![CDATA[$Div.2$ 冲上来就 $pp$ 了前 $4$ 个题,感觉终于可以上个分,然后就 $Unrated$ 了. A Vus the Cossack and a Contest 签到题. 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),m=read(),k=read(); if(n&lt;=m &amp;&amp; n&lt;=k) puts("Yes"); else puts("No"); return 0;&#125; B Vus the Cossack and a Game 题已经被爆破了. 有一个 $n\times m$ 的网格,要在里面放上若干 $1\times 2$ 的骨牌,要求任意两个八连通的格子不能被同时占据,求最多放置的骨牌数目. $n,m\leq 10^9$ . 暂时还不知道有没有可行的做法. C Vus the Cossack and Strings 其实可以直接算 $1$ 的个数是否相同,若相同,则不同的位置一定是偶数个. 因为两个 $1$ 如果对齐放,没有贡献,如果错开放,贡献是 $2$ ,也相当于没有贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,m,a[MAXN],b[MAXN];char buf[MAXN];int k[MAXN];void init()&#123; scanf("%s",buf+1); n=strlen(buf+1); for(int i=1;i&lt;=n;++i) a[i]=buf[i]-'0'; scanf("%s",buf+1); m=strlen(buf+1); for(int i=1;i&lt;=m;++i) b[i]=buf[i]-'0';&#125;int query(int l,int r)&#123; return k[r]^k[l-1];&#125;int main()&#123; init(); for(int i=2;i&lt;=n;++i) if(a[i]!=a[i-1]) k[i]^=1; for(int i=1;i&lt;=n;++i) k[i]^=k[i-1]; int ans=0,s=0; for(int i=1;i&lt;=m;++i) if(a[i]!=b[i]) s^=1; if(s==0) ++ans; for(int i=2;i+m-1&lt;=n;++i) &#123; s^=query(i,i+m-1); if(s==0) ++ans; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Vus the Cossack and Numbers 考虑如果将所有数都向下取整,得到的和为 $-sum$ ,那么显然需要将 $sum$ 个数改成向上取整. 只要不是整数都能改,所以改掉 $sum$ 个就可以了. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const double eps=1e-8;int n;double a[MAXN],upv[MAXN],downv[MAXN],delta[MAXN];bool flag[MAXN];void pr()&#123; for(int i=1;i&lt;=n;++i) printf("%d\n",flag[i]?(int)ceil(a[i]):(int)floor(a[i]));&#125;int main()&#123; n=read(); double sum=0; for(int i=1;i&lt;=n;++i) &#123; scanf("%lf",&amp;a[i]); upv[i]=ceil(a[i])-a[i]; downv[i]=floor(a[i])-a[i]; delta[i]=upv[i]-downv[i]; sum-=downv[i]; &#125; for(int i=1;i&lt;=n &amp;&amp; fabs(sum)&gt;eps;++i) if(fabs(delta[i])&gt;eps) flag[i]=true,sum-=1.0; pr(); return 0;&#125; E Vus the Cossack and a Field 可以直接算二维前缀和再相减.记 $f(x,y)$ 表示以 $(1,1)$ 为左上角, $(x,y)$ 为右下角的子矩形的权值和. 那么答案就是 $f(x_2,y_2)-f(x_2,y_1-1)-f(x_1-1,y_2)+f(x_1-1,y_1-1)$ . 先预处理出 $x\leq n,y\leq m$ 内的 $f(x,y)$ ,就是二维前缀和. 然后计算所有的 $f(x,y)$ ,就可以将它分割成整的块的不整的块,不整的块用预处理的前缀和算就好了. F Vus the Cossack and a Graph 待更. 有个贪心的假做法,不知道为什么很多人都用这个水过去了.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4547 小奇的集合]]></title>
    <url>%2F2019%2F06%2F27%2Fbzoj-4547-%E5%B0%8F%E5%A5%87%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[贪心 + 矩阵快速幂. 显然可以贪心,每次取最大的两个数加起来.答案为初始所有元素之和加上每次操作加入的数. 记初始时最大数为 $a$ ,次大数为 $b$ ,因为题目保证答案非负,所以 $a,b$ 不可能都为负. 若 $a,b$ 都非负,那么加入的数就是一个类斐波那契数列,用矩阵快速幂加速计算就可以了. 若 $a&gt;0$ , $b&lt;0$ ,那么就先算出最少要加几次能使得有两个非负数.只要 $k$ 不为 $0$ ,又保证最终答案为非负,那么一定能在 $k$ 次之内得到两个非负数. 这部分贡献可以直接算出,然后再对剩余次数计算类斐波那契数列部分的贡献即可. 记得答案 $+$ 模数后再输出. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=0x7fffffff;const int P=1e7+7;const int inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct Matrix&#123; int A[3][3]; Matrix()&#123;memset(A,0,sizeof A);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=0;k&lt;3;++k) for(int i=0;i&lt;3;++i) for(int j=0;j&lt;3;++j) res.A[i][j]=add(res.A[i][j],mul(A[i][k],rhs.A[k][j])); return res; &#125;&#125;;Matrix fpow(Matrix a,int b)&#123; Matrix res; for(int i=0;i&lt;3;++i) res.A[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int calc(int a,int b,int k)&#123; assert(k&gt;=0); Matrix trans,st; trans.A[0][0]=trans.A[0][1]=1; trans.A[1][0]=1; trans.A[2][0]=trans.A[2][1]=trans.A[2][2]=1; st.A[0][0]=a; st.A[1][0]=b; st=fpow(trans,k)*st; return st.A[2][0];&#125;int main()&#123; int n=read(),k=read(),ans=0; int a=-inf,b=-inf; while(n--) &#123; int x=read(); ans=add(ans,x); if(x&gt;a) b=a,a=x; else if(x&gt;b) b=x; &#125; if(a&gt;=0 &amp;&amp; b&gt;=0) ans=add(ans,calc(a,b,k)); else &#123; int tmp=(-b+a-1)/a; ans=add(ans,mul(tmp,b)); ans=add(ans,mul(a,mul(inv2,mul(tmp+1,tmp)))); k-=tmp; b=tmp*a+b; if(b&gt;a) swap(a,b); ans=add(ans,calc(a,b,k)); &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1041 圆上的整点]]></title>
    <url>%2F2019%2F06%2F26%2Fbzoj-1041-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[有技巧的大力枚举. 求 $x^2+y^2=r^2$ 的整数解组数,只需要求出 $x,y&gt;0$ 的组数,再 $\times 4,+4$ 即为答案. 方程变形得到 $y^2=(r+x)(r-x)$ ,记 $d=gcd(r+x,r-x)$ ,则 $y^2=d^2\cdot \frac {r+x} d \cdot \frac {r-x} d$ . 记 $u^2=\frac {r+x} d,v^2=\frac {r-x} d,u&gt;v&gt;0$ .则 $2r=d(u^2+v^2),2x=d(u^2-v^2),y=uvd$ . 因为 $d$ 是 $2r$ 的约数,所以大力枚举 $d$ ,再大力枚举 $u$ ,计算出 $v$ 后再验证 $u&gt;v$ 及 $gcd(u,v)=1$ 是否成立即可. 时间复杂度 $O(r^{3\over 4} \cdot \log r)​$ .实际上跑不满,因为枚举 $d​$ 是 $O(r^{1\over 2})​$ 的,而只有 $d​$ 为 $2r​$ 约数时才枚举 $u​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll gcd(ll a,ll b)&#123; if(!b) return a; return gcd(b,a%b);&#125;int check(ll r,ll d,ll u)&#123; ll v2=2*r/d-u*u; ll v=sqrt(v2); if(v*v!=v2) return 0; if(u&lt;=v) return 0; ll x=d*(u*u-v*v); if(x&amp;1) return 0; x/=2; if(gcd(u,v)!=1) return 0; return 1;&#125;int main()&#123; ll r=read(); ll ans=0; for(ll d=1;d*d&lt;=2*r;++d) &#123; if(2*r%d==0) &#123; for(ll u=1;u*u&lt;2*r/d;++u) ans+=check(r,d,u); ll D=2*r/d; if(D!=d) &#123; for(ll u=1;u*u&lt;2*r/D;++u) ans+=check(r,D,u); &#125; &#125; &#125; ans*=4; ans+=4; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4538 网络]]></title>
    <url>%2F2019%2F06%2F25%2Fbzoj-4538-%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[整体二分 + 树状数组. 如果断掉一个点,将经过它的链给撤去,就会比较麻烦.换一个思路,二分答案 $mid$ ,如果所有权值 $\geq mid$ 的链都经过了它,那么真实答案就 $\leq mid$ ,否则 $\geq mid$ . 于是只加入权值 $\geq mid$ 的链,判断该点被覆盖的次数.链的覆盖有一个比较经典的套路,若一条链首尾是 $u,v$ ,就将 $u,v$ 处的权值 $+1$ ,将 $u,v$ 的 $lca$ 以及 $lca$ 的父亲节点的权值 $-1$ ,查询一个点 $x$ 被覆盖的次数,就是查询子树 $x$ 内所有点的权值和.这个可以用一个树状数组来实现. 这些操作是满足整体二分的要求的,所以再套一个整体二分一起处理.时间复杂度 $O(nlog^2n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,ans[MAXN],qcnt=0;struct Node&#123; int type,id; int a,b,v,t,x;&#125;q[MAXN&lt;&lt;2],ql[MAXN],qr[MAXN];struct FenwickTree&#123;#define lowbit(x) x&amp;(-x) int bit[MAXN]; void add(int x,int c) &#123; if(!x) return; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)-sum(l-1); &#125;&#125;T;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int fa[MAXN],mxson[MAXN],siz[MAXN];int dep[MAXN],dfnidx=0,dfn[MAXN],top[MAXN];void dfs1(int u,int Fa)&#123; dep[u]=dep[Fa]+1; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++dfnidx; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int val[MAXN],totv=0;int pcnt=0,pos[MAXN];void upd(int a,int b,int k)&#123; int lca=LCA(a,b); T.add(dfn[a],k); T.add(dfn[b],k); T.add(dfn[lca],-k); T.add(dfn[fa[lca]],-k);&#125;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type==2) ans[q[i].id]=val[l]; return; &#125; int mid=val[(l+r)&gt;&gt;1],cntl=0,cntr=0; int tot=0; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type==0) &#123; if(q[i].v&gt;mid) &#123; upd(q[i].a,q[i].b,1); ++tot; qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else if(q[i].type==1) &#123; if(q[i].v&gt;mid) &#123; upd(q[i].a,q[i].b,-1); --tot; qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else &#123; int x=q[i].x; int tmp=T.query(dfn[x],dfn[x]+siz[x]-1); if(tmp&gt;=tot) ql[++cntl]=q[i]; else qr[++cntr]=q[i]; &#125; &#125; for(int i=L;i&lt;=R;++i) if(q[i].type==0 &amp;&amp; q[i].v&gt;mid) upd(q[i].a,q[i].b,-1); else if(q[i].type==1 &amp;&amp; q[i].v&gt;mid) upd(q[i].a,q[i].b,1); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+i+cntl-1]=qr[i]; int Mid=(l+r)&gt;&gt;1; solve(l,Mid,L,L+cntl-1); solve(Mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=m;++i) &#123; q[i].type=read(); if(q[i].type==0) &#123; q[i].a=read(); q[i].b=read(); q[i].v=read(); val[++totv]=q[i].v; &#125; else if(q[i].type==1) &#123; int t=read(); q[i]=q[t]; q[i].type=1; &#125; else &#123; q[i].x=read(); q[i].id=++qcnt; &#125; &#125; val[++totv]=-1; sort(val+1,val+1+totv); totv=unique(val+1,val+1+totv)-val-1; solve(1,totv,1,m); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3110 K大数查询]]></title>
    <url>%2F2019%2F06%2F23%2Fbzoj-3110-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[整体二分. 整体二分. 因为修改操作对二分答案的贡献是给一段区间 $+1$ ,所以用线段树来维护即可. 一次分治结束后并不能直接重置线段树,因为这样每次操作就和整个序列长度线性相关了. 将修改操作 $+1$ 的部分都 $-1$ 撤回即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,ans[MAXN],qcnt=0;struct Node&#123; int a,b; ll c; int type,id;&#125;q[MAXN&lt;&lt;2],ql[MAXN],qr[MAXN];struct Segtree&#123; struct node &#123; ll sum,tag; node()&#123;sum=0;tag=0;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void modifiy(int o,int c,int l,int r) &#123; root.sum+=1LL*c*(r-l+1); root.tag+=c; &#125; void pushdown(int o,int l,int r) &#123; if(root.tag) &#123; int mid=(l+r)&gt;&gt;1; modifiy(o&lt;&lt;1,root.tag,l,mid); modifiy(o&lt;&lt;1|1,root.tag,mid+1,r); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(l&gt;R || L&gt;r) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c,l,r); return; &#125; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(l&gt;R || L&gt;r) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type==2) ans[q[i].id]=l; return; &#125; int cntl=0,cntr=0; int mid=(l+r)&gt;&gt;1; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type==1) &#123; if(q[i].c&gt;mid) &#123; T.upd(1,1,n,q[i].a,q[i].b,1); qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else &#123; ll tmp=T.query(1,1,n,q[i].a,q[i].b); if(tmp&gt;=q[i].c) qr[++cntr]=q[i]; else if(tmp&lt;q[i].c) &#123; q[i].c-=tmp; ql[++cntl]=q[i]; &#125; &#125; &#125; for(int i=L;i&lt;=R;++i) if(q[i].type==1 &amp;&amp; q[i].c&gt;mid) T.upd(1,1,n,q[i].a,q[i].b,-1); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+i+cntl-1]=qr[i]; solve(l,mid,L,L+cntl-1); solve(mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; q[i].type=read(); q[i].a=read(); q[i].b=read(); q[i].c=read(); if(q[i].type==2) q[i].id=++qcnt; &#125; solve(-n,n,1,m); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1901 Dynamic Rankings]]></title>
    <url>%2F2019%2F06%2F21%2Fbzoj-1901-Dynamic-Rankings%2F</url>
    <content type="text"><![CDATA[整体二分. $solve(l,r,L,R)$ 表示当前处理编号在 $L\sim R$ 内的询问与修改操作,询问的答案在 $l\sim r$ 内. 每次处理时,若当前 $l=r$ ,就回答 $L\sim R$ 内的询问. 否则,二分答案 $mid$ ,对于编号在 $L\sim R$ 内的修改操作,按照修改的权值分成 $\le mid,&gt;mid$ 两边,若 $\le mid$ ,就在树状数组里将它对应的位置 $+1$ . 对于编号在 $L\sim R$ 内的询问操作,按照在树状数组中询问区间的权值和 $sum\le k,&gt;k$ 分成两边,若 $&lt;k$ ,就将 $k$ 减去这个 $sum$ . 然后将分出的修改与询问操作分到左右两边,递归解决即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e5+10;int n,m,a[MAXN];int ans[MAXN];struct node&#123; int x,y,k,id,type; node()&#123;x=y=k=id=type=0;&#125; node(int x,int y,int k,int id,int type):x(x),y(y),k(k),id(id),type(type) &#123;&#125;&#125;q[MAXN*3],ql[MAXN*3],qr[MAXN*3];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)-sum(l-1); &#125;&#125;T;int cnt=0,qcnt=0;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type) ans[q[i].id]=l; return; &#125; int mid=(l+r)&gt;&gt;1,cntl=0,cntr=0; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type) &#123; int sum=T.query(q[i].x,q[i].y); if(sum&gt;=q[i].k) ql[++cntl]=q[i]; else &#123; q[i].k-=sum; qr[++cntr]=q[i]; &#125; &#125; else &#123; if(q[i].x&lt;=mid) &#123; T.add(q[i].id,q[i].y); ql[++cntl]=q[i]; &#125; else qr[++cntr]=q[i]; &#125; &#125; for(int i=1;i&lt;=cntl;++i) if(!ql[i].type) T.add(ql[i].id,-ql[i].y); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+cntl+i-1]=qr[i]; solve(l,mid,L,L+cntl-1); solve(mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); q[++cnt]=node(a[i],1,0,i,0); &#125; for(int i=1;i&lt;=m;++i) &#123; char buf[2]; scanf("%s",buf); if(buf[0]=='Q') &#123; int x=read(),y=read(),k=read(); q[++cnt]=node(x,y,k,++qcnt,1); &#125; else &#123; int x=read(),y=read(); q[++cnt]=node(a[x],-1,0,x,0); a[x]=y; q[++cnt]=node(a[x],1,0,x,0); &#125; &#125; solve(-inf,inf,1,cnt); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>整体二分</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4540 序列]]></title>
    <url>%2F2019%2F06%2F20%2Fbzoj-4540-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[线段树. 这道题显然有一个莫队的做法,但它是带根号的,不够优秀.考虑用一个 $O(nlogn)$ 的做法解决它. 考虑将询问离线下来,从 $1$ 到 $n$ 依次加入元素,当前已经加入了第 $p$ 个元素,对每个位置维护 $val_i,sum_i$ ,分别表示区间 $[i,p]$ 的最小值,以及 $val_i$ 所有历史版本值之和.若 $i&gt;p$ ,则当前 $val_i=0$ . 加入第 $p$ 个元素后,立即回答所有 $r=p$ 的询问,答案显然是 $\sum_{i=l}^r sum_i$ . 于是我们只需要用一颗线段树来维护 $val,sum$ 这两个值(的区间和)即可. 考虑加入第 $p$ 个元素后如何修改 $val,sum$ .可以通过单调栈求出最小的 $i$ ,使得 $[i,p]$ 内最小值都为 $a_p$ .需要将 $[i,p]$ 这个区间内的 $val$ 都修改成 $a_p$ ,并让区间 $[1,p]$ 内的 $sum$ 加上对应位置新的 $val$. 时间复杂度 $O(nlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,Q,A[MAXN];ll ans[MAXN];struct Query&#123; int l,id; Query(int l=0,int id=0):l(l),id(id) &#123;&#125;&#125;;vector&lt;Query&gt; V[MAXN];int stk[MAXN],tp=0;struct tag&#123; ll a,b,c,d; void init()&#123;a=1;b=c=d=0;&#125; tag(int a,int b,int c,int d):a(a),b(b),c(c),d(d) &#123;&#125; tag()&#123;init();&#125; bool valid() &#123; if(a==1 &amp;&amp; !b &amp;&amp; !c &amp;&amp; !d) return false; return true; &#125; tag operator + (const tag &amp;rhs) const &#123; tag Newtag; Newtag.a=rhs.a*a; Newtag.b=rhs.a*b+rhs.b; Newtag.c=rhs.c*a+c; Newtag.d=rhs.c*b+d+rhs.d; return Newtag; &#125;&#125;;struct SegTree&#123; struct node &#123; ll val,sum,len; tag t; bool TagValid() &#123; return t.valid(); &#125; &#125; Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void BuildTree(int o,int l,int r) &#123; root.val=root.sum=0; root.len=r-l+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void pushup(int o) &#123; root.val=lson.val+rson.val; root.sum=lson.sum+rson.sum; &#125; void Modifiy(int o,tag Newtag) &#123; root.sum+=Newtag.c*root.val+Newtag.d*root.len; root.val=Newtag.a*root.val+Newtag.b*root.len; root.t=root.t+Newtag; &#125; void pushdown(int o) &#123; if(root.TagValid()) &#123; Modifiy(o&lt;&lt;1,root.t); Modifiy(o&lt;&lt;1|1,root.t); (root.t).init(); &#125; &#125; void upd(int o,int l,int r,int L,int R,tag Newtag) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,Newtag); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,Newtag); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,Newtag); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; pushdown(o); int mid=(l+r)&gt;&gt;1; ll res=0; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;int main()&#123; n=read(),Q=read(); for(int i=1; i&lt;=n; ++i) A[i]=read(); for(int i=1; i&lt;=Q; ++i) &#123; int l=read(),r=read(); V[r].push_back(Query(l,i)); &#125; T.BuildTree(1,1,n); for(int p=1; p&lt;=n; ++p) &#123; while(tp &amp;&amp; A[p]&lt;A[stk[tp]]) --tp; int i=stk[tp]+1; stk[++tp]=p; tag Newtag=tag(0,A[p],0,0); T.upd(1,1,n,i,p,Newtag); Newtag=tag(1,0,1,0); T.upd(1,1,n,1,p,Newtag); int siz=V[p].size(); for(int j=0; j&lt;siz; ++j) ans[V[p][j].id]=T.query(1,1,n,V[p][j].l,p); &#125; for(int i=1; i&lt;=Q; ++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4537 最小公倍数]]></title>
    <url>%2F2019%2F06%2F19%2Fbzoj-4537-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[分块 + 并查集. 如果对于每个询问 $(u,v,a,b)$ ,我们都只加入 $a,b$ 均小于等于该询问的 $a,b$ 的边,那么答案为 $Yes$ 就等价于 $u,v$ 在同一个联通块中,并且这个连通块中有一条边的 $a$ 等于该询问的 $a$ ,有一条边的 $b$ 等于该询问的 $b$ . 若只有 $a$ 这一维的限制,可以将所有边,询问按 $a$ 排序后依次处理,用并查集维护. 但现在有 $a,b$ 两维的限制,而 $m$ 不是很大,考虑分块. 将所有边与询问按照 $a$ 的大小分成 $\sqrt m$ 块,按顺序处理每一块.处理第 $i$ 块的时候,将第 $1\sim i-1$ 块内的边和第 $i$ 块内的询问都拿出来,按照 $b$ 从小到大排序后依次处理,并用并查集维护连通性和联通块内最大的 $a,b$ . 第 $i$ 块内的边也可能产生贡献,因为它们的数量不超过 $\sqrt m$ ,所以每次遇到询问时,将这些边当中合法的加入,这个询问结束后再撤销就好了. 因为要实现可撤销的并查集,所以要按秩合并,不能路径压缩.时间复杂度 $O(m\sqrt m\cdot logm)$ . 注意 $a,b$ 可能为 $0$ ,所以初始化最大值要为 $-1$ .因为这个调了一节课. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;struct node&#123; int u,v,a,b,id; int type;&#125;eq[MAXN],tmp[MAXN];bool cmp1(node A,node B)&#123; return A.a&lt;B.a || (A.a==B.a &amp;&amp; A.type&lt;B.type);&#125;bool cmp2(node A,node B)&#123; return A.b&lt;B.b || (A.b==B.b &amp;&amp; A.type&lt;B.type);&#125;int ans[MAXN];int n,m,q,BlockSize,BlockNum;int L[MAXN],R[MAXN],lpos[MAXN],rpos[MAXN];struct Disjoint_Set_Union&#123; int fa[MAXN],siz[MAXN],maxa[MAXN],maxb[MAXN]; int OperationNum; struct Operation &#123; int x,NewFa,sizx,Orgmaxa,Orgmaxb; &#125;opt[MAXN]; void SaveOperation(int x,int NewFa,int sizx,int Orgmaxa,int Orgmaxb) &#123; int k=++OperationNum; opt[k].x=x; opt[k].NewFa=NewFa; opt[k].sizx=sizx; opt[k].Orgmaxa=Orgmaxa; opt[k].Orgmaxb=Orgmaxb; &#125; void Undo() &#123; while(OperationNum) &#123; int k=OperationNum--; int x=opt[k].x,NewFa=opt[k].NewFa; int sizx=opt[k].sizx; int Orgmaxa=opt[k].Orgmaxa; int Orgmaxb=opt[k].Orgmaxb; if(x!=NewFa) siz[NewFa]-=sizx; fa[x]=x; maxa[NewFa]=Orgmaxa; maxb[NewFa]=Orgmaxb; &#125; &#125; void init() &#123; OperationNum=0; for(int i=1;i&lt;=n;++i) &#123; fa[i]=i; siz[i]=1; maxa[i]=maxb[i]=-1; &#125; &#125; int Find(int x) &#123; if(fa[x]==x) return x; return Find(fa[x]); &#125; void addedge(int u,int v,int a,int b,bool flag) &#123; u=Find(u),v=Find(v); if(u!=v) &#123; if(siz[v]&gt;siz[u]) swap(u,v); if(flag) SaveOperation(v,u,siz[v],maxa[u],maxb[u]); siz[u]+=siz[v]; fa[v]=u; maxa[u]=max(maxa[u],a); maxa[u]=max(maxa[u],maxa[v]); maxb[u]=max(maxb[u],b); maxb[u]=max(maxb[u],maxb[v]); &#125; else &#123; if(flag) SaveOperation(u,u,siz[u],maxa[u],maxb[u]); maxa[u]=max(maxa[u],a); maxb[u]=max(maxb[u],b); &#125; &#125; bool check(int u,int v,int a,int b) &#123; u=Find(u),v=Find(v); if(u!=v) return false; if(maxa[u]!=a || maxb[u]!=b) return false; return true; &#125;&#125;DSU;void solve(int CurBlock)&#123; DSU.init(); int tot=0; for(int i=1;i&lt;L[CurBlock];++i) if(eq[i].type==1) tmp[++tot]=eq[i]; for(int i=L[CurBlock];i&lt;=R[CurBlock];++i) if(eq[i].type==2) tmp[++tot]=eq[i]; sort(tmp+1,tmp+1+tot,cmp2); for(int i=1;i&lt;=tot;++i) &#123; if(tmp[i].type==1) DSU.addedge(tmp[i].u,tmp[i].v,tmp[i].a,tmp[i].b,false); else &#123; if(tmp[i].id==44) &#123; int qq=1; &#125; for(int j=L[CurBlock];j&lt;=R[CurBlock];++j) if(eq[j].type==1 &amp;&amp; eq[j].a&lt;=tmp[i].a &amp;&amp; eq[j].b&lt;=tmp[i].b) DSU.addedge(eq[j].u,eq[j].v,eq[j].a,eq[j].b,true); ans[tmp[i].id]=DSU.check(tmp[i].u,tmp[i].v,tmp[i].a,tmp[i].b); DSU.Undo(); &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; eq[i].u=read(); eq[i].v=read(); eq[i].a=read(); eq[i].b=read(); eq[i].type=1; &#125; q=read(); for(int i=1;i&lt;=q;++i) &#123; eq[i+m].u=read(); eq[i+m].v=read(); eq[i+m].a=read(); eq[i+m].b=read(); eq[i+m].id=i; eq[i+m].type=2; &#125; sort(eq+1,eq+m+q+1,cmp1); BlockSize=sqrt(m+q); BlockNum=(m+q+BlockSize-1)/BlockSize; for(int i=1;i&lt;=BlockNum;++i) &#123; L[i]=R[i-1]+1; R[i]=L[i]+BlockSize-1; &#125; R[BlockNum]=m+q; for(int i=1;i&lt;=BlockNum;++i) solve(i); for(int i=1;i&lt;=q;++i) puts(ans[i]?"Yes":"No"); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>离线</tag>
        <tag>分块</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4518 征途]]></title>
    <url>%2F2019%2F06%2F18%2Fbzoj-4518-%E5%BE%81%E9%80%94%2F</url>
    <content type="text"><![CDATA[斜率优化 $dp$ . 推一下式子,记第 $i$ 天走的长度为 $t_i$ , $s=\sum t_i$ ,则 $S^2 \cdot m^2=(m\cdot \sum t_i^2)-s^2$ . 由于 $m,s$ 为定值,所以只需要最小化平方和 $\sum t_i^2$ . 设 $f(i,j)$ 表示走了 $i$ 天,恰好走了 $j$ 段路时的最小平方和, $sum_i$ 表示前 $i$ 段路的长度和. 暴力转移有 $f(i,j)=\min \lbrace f(i-1,k)+(sum_j-sum_k)^2,0\leq k&lt;j \rbrace$ ,可以看出暴力转移是 $O(n^3)$ 的. 若固定 $i$ ,可以看出 $j$ 这一维是满足斜率优化的,因为同时与 $j,k$ 有关的项是 $-2sum_j\cdot sum_k$ ,而 $sum_k$ 单调. 于是就可以进行斜率优化了.若用 $k_1$ 转移比 $k_2$ 更优 ( $k_1&gt;k_2$ ) ,由转移方程可得到: $$slope(k_1,k_2)={f(i-1,k_1)+sum_{k_1}^2-f(i-1,k_2)-sum_{k_2}^2 \over sum_{k_1}-sum_{k_2}} &lt; 2sum_j$$ 而斜率 $2sum_j$ 也是单调的,所以并不需要二分,直接暴力跳指针,用单调队列维护下凸壳即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e3+10;int n,m,sum[MAXN],s;ll f[MAXN][MAXN];double sqr(double x)&#123; return x*x;&#125;double slope(int i,int k1,int k2)&#123; return (f[i-1][k1]+sqr(sum[k1])-f[i-1][k2]-sqr(sum[k2]))/(1.0*sum[k1]-1.0*sum[k2]);&#125;int q[MAXN],head,tail;// [head,tail]int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+read(); memset(f,63,sizeof f); f[0][0]=0; for(int i=1;i&lt;=m;++i) &#123; head=tail=0; for(int j=1;j&lt;=n;++j) &#123; while(head&lt;tail &amp;&amp; slope(i,q[head+1],q[head])&lt;2*sum[j]) ++head; int k=q[head]; f[i][j]=f[i-1][k]+1LL*(sum[j]-sum[k])*(sum[j]-sum[k]); while(head&lt;tail &amp;&amp; slope(i,q[tail],q[tail-1])&gt;slope(i,q[tail],j)) --tail; q[++tail]=j; &#125; &#125; cout&lt;&lt;f[m][n]*m-1LL*sum[n]*sum[n]&lt;&lt;endl; return 0;&#125; 更了一个用 $WQS$ 二分的做法. 这道题用 $WQS$ 二分,也称凸优化,可以做到 $O(n\log s_n)$ 的时间复杂度. 定义 $g(i)$ 表示必须走 $i$ 段时的最小 $\sum t_j^2$ .那么我们就是要求 $g(m)$ 的值. 普通的斜率优化其实就是在枚举选了多少段. 二分一个权值 $mid$ ,表示每选一段带来的额外花费,此时得到新的函数 $f(x)=g(x)+mid\cdot x$ . 因为 $g(x)$ 是具有凸性的,所以 $g’(x)$ 是单调的,而 $f’(x)=g’(x)+mid$ ,相当于在左右移动 $g’(x)$ 的零点. 而 $f’(x)$ 的零点就是让 $f(x)$ 取得最小值的点,一次斜率 $dp$ 可以 $O(n)$ 求出,也同时求出了 $f(x)$ 的最小值. 通过二分不断调整 $mid$ ,直到 $f’(x)$ 的零点为 $m$ ,就得到了 $f(m)$ ,再根据 $g(m)=f(m)-mid\cdot m$ 得出答案. 因为实际问题中,这些函数只在整数处才有定义,所以二分权值时也只用在整数中二分. 时间复杂度 $O(n\log s_n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e3+10;ll sqr(ll x)&#123; return x*x;&#125;int n,m;ll f[MAXN],g[MAXN],s[MAXN];double slope(int k1,int k2)&#123; return (double)(f[k1]+sqr(s[k1])-f[k2]-sqr(s[k2]))/(double)(s[k1]-s[k2]);&#125;int q[MAXN],head,tail;bool check(ll mid)&#123; q[head=tail=0]=0; for(int i=1;i&lt;=n;++i) &#123; while(head&lt;tail &amp;&amp; slope(q[head+1],q[head])&lt;2*s[i]) ++head; int k=q[head]; f[i]=f[k]+sqr(s[i]-s[k])+mid; g[i]=g[k]+1; while(head&lt;tail &amp;&amp; slope(q[tail-1],q[tail])&gt;slope(q[tail],i)) --tail; q[++tail]=i; &#125; return g[n]&lt;=m;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) s[i]=s[i-1]+read(); ll L=0,R=s[n]*s[n]/m; ll res; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) &#123; res=m*(f[n]-mid*m)-sqr(s[n]); R=mid-1; &#125; else L=mid+1; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4516 生成魔咒]]></title>
    <url>%2F2019%2F06%2F18%2Fbzoj-4516-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%2F</url>
    <content type="text"><![CDATA[$SAM$ . 每次在末尾加入一个字符,再询问当前串本质不同的子串数目. 用 $SAM$ 维护,答案就是所有非根结点的 $maxlen-minlen+1$ 之和,即 $maxlen(u)-maxlen(fa_u)$ 之和. 由于字符集比较大,所以用 $map$ 存边,确定/更换父亲结点时更新答案即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct SuffixAutomaton&#123; map&lt;int,int&gt; ch[MAXN]; int idx,lst; int len[MAXN],fa[MAXN]; ll ans; SuffixAutomaton()&#123;idx=lst=1;ans=0;memset(fa,0,sizeof fa);&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1,ans+=len[np]; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) &#123; fa[np]=q; ans+=len[np]-len[q]; &#125; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; ans+=len[np]-len[nq]; ch[nq]=ch[q]; while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; printf("%lld\n",ans); &#125;&#125;SAM;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) SAM.Extend(read()); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1181]]></title>
    <url>%2F2019%2F06%2F18%2FCF1181%2F</url>
    <content type="text"><![CDATA[$Div.2$ 鸽了生物晚自习过来打. A Chunga-Changa 签到题.分类讨论一下就好了. 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll x,y,z;int main()&#123; x=read(),y=read(),z=read(); if((x+y)/z==x/z+y/z) cout&lt;&lt;(x+y)/z&lt;&lt;' '&lt;&lt;0&lt;&lt;endl; else &#123; ll s=x/z+y/z; x%=z,y%=z; if((x+y)/z) cout&lt;&lt;s+1&lt;&lt;' '&lt;&lt;min(z-x,z-y)&lt;&lt;endl; else cout&lt;&lt;s&lt;&lt;0&lt;&lt;endl; &#125; return 0;&#125; B Split a Number 显然应该贪心从最中间的位置切开. 有 $0$ 的话,就从中间往两边分别找第一个合法的位置就好了. 高精度用 $python$ 就很棒. 12345678910111213n = input()s = raw_input()fig = []for i in xrange(1, n): if s[i] != '0': fig.append((max(i, n - i), i))fig.sort()k = fig[0][0]ans = int(s)for i in xrange(min(10, len(fig))): j = fig[i][1] ans = min(ans, int(s[:j]) + int(s[j:]))print ans C Flag 记录 $D(i,j)$ 表示从 $(i,j)$ 往下走,并且满足颜色一直相同能走到的最远位置, $k(i,j)$ 表示从 $(i,j)$ 往右走,并且满足颜色一直相同能走的最远格数. 然后大力枚举 $(i,j)$ ,统计以 $(i,j)$ 为左上角的 $Flag$ 数目即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int n,m;int col[MAXN][MAXN];char buf[MAXN];int D[MAXN][MAXN];int k[MAXN][MAXN];const int inf=1e9;struct seg&#123; int val[MAXN&lt;&lt;2];#define root val[o]#define lson val[o&lt;&lt;1]#define rson val[o&lt;&lt;1|1] void bd(int y,int o,int l,int r) &#123; if(l==r) &#123; root=k[l][y]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(y,o&lt;&lt;1,l,mid); bd(y,o&lt;&lt;1|1,mid+1,r); root=min(lson,rson); &#125; int query(int o,int l,int r,int L,int R) &#123; assert(root); if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; int s=inf; if(L&lt;=mid) s=min(s,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) s=min(s,query(o&lt;&lt;1|1,mid+1,r,L,R)); assert(s&gt;=1 &amp;&amp; s&lt;=m); return s; &#125;&#125;T[MAXN];ll calc(int x,int y)&#123; int p1=x; int p2=D[p1][y]+1; if(p2&gt;n) return 0; int p3=D[p2][y]+1; if(p3&gt;n) return 0; int len=p2-p1; if(p3!=p2+len) return 0; if(p3+len-1&gt;n) return 0; if(D[p3][y]&lt;p3+len-1) return 0; return T[y].query(1,1,n,p1,p3+len-1);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) col[i][j]=buf[j]-'a'+1; &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=m;j&gt;=1;--j) if(col[i][j]!=col[i][j+1]) k[i][j]=1; else k[i][j]=k[i][j+1]+1; &#125; for(int j=1;j&lt;=m;++j) &#123; for(int i=n;i&gt;=1;--i) if(col[i][j]!=col[i+1][j]) D[i][j]=i; else D[i][j]=D[i+1][j]; &#125; for(int j=1;j&lt;=m;++j) T[j].bd(j,1,1,n); ll ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) ans+=calc(i,j); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Irrigation 容易发现当所有的城市次数都相等后举办地点一定会出现循环 $1,2,3,\dots,m$ . 记初始 $n$ 轮举办后,举办次数最多的一个城市举办了 $t$ 场,那么根据规则,再举办 $t\cdot m-n$ 场后,即从第 $t\cdot m+1$ 场开始举办城市就会开始出现循环 $1,2,3,\dots,m$ . 可以将询问离线下来,按照时间从前往后顺序进行回答. 一层一层填满下面这个图,边填边回答询问 ( $two\ pointer$ ),用 $treap$ 维护当前可能会被填到的元素就好了. 最后还剩下的询问的答案一定是出现在 $1,2,3,\dots,m$ 的循环中,答案容易得出. E A Story of One Country 尝试倒着做,每次水平或竖直地将一个子矩形切成两个,并且切的时候不能切断任意一个 $castle$ 区域. 如果经过若干次切割后,能使得每个子矩形内都包含了 恰好一个 $castle$ 区域,那么原图就是合法的. 注意到对于同一个子矩形,如果把它内部的 $castle$ 区域用这个 $castle$ 区域的一个非空子集代替,不会使结果变劣,即,若原子矩形是合法的,那么替换后的子矩形仍然是合法的. 又因为题目对切割次数没有限制,所以我们只要能找到一条切割线(水平或竖直)使得切割后得到的两个子矩形内部都含有 $castle$ 区域,且自身不穿过 $castle$ 区域,就称它是合法的,沿着它切开,不会影响最终的答案. 于是我们可以递归解决这个问题,对于当前的子矩形每次找到一条切割线,切割后递归处理得到的两个子矩形.若当前矩形不是恰好包含一个 $castle$ 区域,又找不到合法的切割线,则说明当前子矩形不合法,原图也不合法. 如果每次随意去找一条合法切割线执行上述操作,最坏情况是每次切割后,一个子矩形内只有 $1$ 个 $castle$ 区域,而另一个子矩形内含有剩下所有的 $castle$ 区域,此时的时间复杂度是 $O(n^2logn)$ ,只能通过简单版的数据. 用线段树来维护 $castle$ 区域,每次找出合适的切割使得得到的两个子矩形含有的 $castle$ 区域数目差尽可能小,此时时间复杂度为 $O(nlog^2n)$ ,可以通过所有数据.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>平衡树</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diverta 2019 Programming Contest 2]]></title>
    <url>%2F2019%2F06%2F17%2Fdiverta-2019-Programming-Contest-2%2F</url>
    <content type="text"><![CDATA[来的时候发现只有一个小时了.然而还是 头铁 开题,怒掉一波 $rating$ . 比赛链接. 官方题解. A Ball Distribution 签到题. 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),k=read(); if(k&gt;1) cout&lt;&lt;n-k; else cout&lt;&lt;0; return 0;&#125; B Picking Up 显然只需要枚举两个点,将它们的坐标差作为 $(p,q)$ 进行计算,其他的 $(p,q)$ 没有用. 然后用并查集或者记忆化搜索随便搞搞就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;int n;pii p[51];int ans=51;int f[51],A,B;map&lt;pii,int&gt; id;int dfs(int x)&#123; if(f[x]!=-1) return f[x]; int&amp; res=f[x]; res=0; if(id.find(make_pair(p[x].first-A,p[x].second-B))!=id.end()) &#123; int y=id[make_pair(p[x].first-A,p[x].second-B)]; if(f[y]!=-1) return 0; else &#123; res=0; return dfs(y); &#125; &#125; return res=1;&#125;void solve(int a,int b)&#123; if(a==-3 &amp;&amp; b==-2) &#123; int d=1; &#125; A=a,B=b; int res=0; memset(f,-1,sizeof f); for(int i=1;i&lt;=n;++i) if(f[i]==-1) res+=dfs(i); ans=min(ans,res);&#125;int main()&#123; n=read(); if(n==1) &#123; puts("1"); return 0; &#125; for(int i=1;i&lt;=n;++i) &#123; p[i].first=read(); p[i].second=read(); id[p[i]]=i; &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) if(i!=j) solve(p[i].first-p[j].first,p[i].second-p[j].second); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Successive Subtraction 构造 + 贪心. 首先可以将 $0$ 全部减掉,于是只剩下正/负数. 特判只有正数与只有负数的情况,只有正数就让最小的那个数贡献为负,只有负数就让最大的那个数贡献为负. 否则,正负数都有的情况,答案一定是 $\sum |a_i|$ . 证明的话,考虑只有一个正数的情况,用它去减其他所有数即得 $\sum |a_i|$ .只有一个负数的情况,留下一个正数后,让那个负数减其他所有数,再让留下的正数减它,答案也是 $\sum |a_i|$ . 否则,正负数都至少有 $2$ 个.每次取出两个正数 $x,y$ ,一个负数 $z$ ,连续操作两次,先得到 $z-y$ ,再得到 $x-(z-y)=x+y-z$ . 这样操作后正负数都减少了 $1$ 个,并且每个数的贡献还是 $|a_i|$ ,一直操作,直到正数只有一个或负数只有一个时,执行对应情况的操作即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define int llinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN];int res=0;void solve1()//-&#123; cout&lt;&lt;res+2*a[n]&lt;&lt;endl; int x=a[n]; for(int i=n-1;i&gt;=1;--i) &#123; printf("%lld %lld\n",x,a[i]); x-=a[i]; &#125;&#125;void solve2()//+&#123; cout&lt;&lt;res-2*a[1]&lt;&lt;endl; int x=a[1]; for(int i=2;i&lt;n;++i) &#123; printf("%lld %lld\n",x,a[i]); x-=a[i]; &#125; printf("%lld %lld\n",a[n],x);&#125;int stk1[MAXN],stk2[MAXN];int tp1=0,tp2=0;void solve3()//+,-&#123; cout&lt;&lt;res&lt;&lt;endl; int zr=0; for(int i=1;i&lt;=n;++i) &#123; if(a[i]&gt;0) stk1[++tp1]=a[i]; else if(a[i]&lt;0) stk2[++tp2]=a[i]; else ++zr; &#125; assert(zr!=n); while(zr--) printf("%lld 0\n",stk1[tp1]); assert(tp1 &amp;&amp; tp2); while(tp1!=1 &amp;&amp; tp2!=1) &#123; int x=stk1[tp1]; --tp1; int y=stk1[tp1]; --tp1; int z=stk2[tp2]; --tp2; printf("%lld %lld\n",z,y); printf("%lld %lld\n",x,z-y); stk1[++tp1]=x+y-z; &#125; if(tp1==1) &#123; int x=stk1[tp1]; while(tp2) &#123; printf("%lld %lld\n",x,stk2[tp2]); x-=stk2[tp2--]; &#125; &#125; else &#123; int x=stk2[tp2]; for(int i=1;i&lt;tp1;++i) &#123; printf("%lld %lld\n",x,stk1[i]); x-=stk1[i]; &#125; printf("%lld %lld\n",stk1[tp1],x); &#125;&#125;signed main()&#123; n=read(); bool f1=false,f2=false; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); res+=abs(a[i]); if(a[i]&gt;0) f1=true; if(a[i]&lt;0) f2=true; &#125; sort(a+1,a+1+n); if(!f1) solve1(); else if(!f2) solve2(); else solve3(); return 0;&#125; D Squirrel Merchant 贪心 + 背包. 显然到 $B$ 时可以先把先前在 $A$ 买的东西全部卖掉后再进行操作,不会使结果变劣. 于是就成了 $A$ 买 + $B$ 卖 与 $B$ 买 + $A$ 卖 两个过程.尝试最大化每一步的收益即可. 如 $A$ 买 + $B$ 卖 这个过程,就可以用 $g_A$ 的容量换取 $g_B-g_A$ 的收益.另外的两种同理. 做两次背包即可.时间复杂度 $O(N\cdot \max(g,s,b))$ . 注意开 $long\ long$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int w[4],c[4],V;const int MAXN=5001*5001;int f[MAXN];int solve_package()&#123; memset(f,0,sizeof f); int res=0; for(int j=1;j&lt;=3;++j) &#123; if(c[j]&lt;=0) continue; for(int i=w[j];i&lt;=V;++i) &#123; f[i]=max(f[i],f[i-w[j]]+c[j]); res=max(res,f[i]); &#125; &#125; return res;&#125;int pr[2][4];int main()&#123; V=read(); for(int i=0;i&lt;2;++i) for(int j=1;j&lt;=3;++j) pr[i][j]=read(); for(int i=1;i&lt;=3;++i) &#123; c[i]=pr[1][i]-pr[0][i]; w[i]=pr[0][i]; &#125; V+=solve_package(); for(int i=1;i&lt;=3;++i) &#123; c[i]=pr[0][i]-pr[1][i]; w[i]=pr[1][i]; &#125; V+=solve_package(); cout&lt;&lt;V&lt;&lt;endl; return 0;&#125; E Balanced Piles $dp$ . 先只考虑 $D=1$ 的情况.设 $f(i,j)$ 表示当前最大值为 $i$ ,最大值有 $j$ 个时,操作到最终状态的方案数. 预先给每块砖钦定一个两两不同的优先度,若可以操作多块砖,则优先操作优先度高的砖. 那么若 $i\not=H$ ,可以转移到 $f(i+1,1)$ ,若 $j\not=N$ ,可以转移到 $f(i,j+1)$ .新加入的那块砖插入到原来的 $j$ 块砖中,有 $j+1$ 种方案.所以 $f(i,j)=f(i+1,1)+(j+1)\cdot f(i,j+1)$ ( $i=H$ 或 $j=N$ 除外). 边界是 $f(H,N)=1$ ,答案是 $f(0,N)$ .钦定优先度会使方案数 $\times N!$ ,但我们转移时规定了顺序,即方案数是序列的方案数,所以又要 $/ N!$ ,两者就抵消掉了. 123456789101112131415161718192021int f[MAXN][MAXN];int dfs(int i,int j)&#123; if(f[i][j]!=-1) return f[i][j]; int&amp; res=f[i][j]; res=0; if(i!=H) res=add(res,dfs(i+1,1)); if(j!=N) res=add(res,mul(j+1,dfs(i,j+1))); return res;&#125;int main()&#123; N=read(),H=read(),D=read(); memset(f,-1,sizeof f); f[H][N]=1; cout&lt;&lt;dfs(0,N)&lt;&lt;endl; return 0;&#125; 观察转移形式 $f(i,j)=f(i+1,1)+(j+1)\cdot f(i,j+1)$ ,可发现答案 $f(0,N)$ 就对应了下面这个 $DAG$ 从 $(0,N)$ 到 $(H,N)$ 的路径条数. 边上的数字代表有几条重边 ,图中 $N=4,H=5$ . 经过 奥妙重重 的运算,答案 $f(0,N)=(\sum_{i=1}^N i!)^{H-1}\cdot N!$ . 再来考虑一般的 $D\geq 1$ 的情况. 考虑一个数列 $0=h_0&lt;h_1&lt;\dots &lt;h_K=H$ ,满足 $\forall 0\leq i&lt;K,h_{i+1}-h_i\leq D$ .那么现在要求每次操作的高度 $h$ 能依次构成上面形式的数列,答案就是 $(\sum_{i=1}^N i!)^{K-1}\cdot N!$ . 沿用 $D=1$ 时构造 $DAG$ 的思路,答案对应了下面的 $DAG$ 从 $0$ 到 $N$ 的路径数目. $weight$ 其实就是说重边的数目.图片均来自官方题解. 维护 $f(i)$ 表示 $0\to i$ 的路径条数,并维护 $f$ 的前缀和,即可在 $O(n)$ 内解决此题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int MAXN=1e6+10;int fac[MAXN];inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int N,H,D,sf=0;int f[MAXN],sum[MAXN];int main()&#123; N=read(),H=read(),D=read(); fac[0]=1; for(int i=1;i&lt;=N;++i) &#123; fac[i]=mul(fac[i-1],i); sf=add(sf,fac[i]); &#125; f[0]=1,sum[0]=1; for(int i=1;i&lt;=H;++i) &#123; if(i-D-1&gt;=0) f[i]=add(sum[i-1],P-sum[i-D-1]); else f[i]=sum[i-1]; f[i]=mul(f[i],sf); sum[i]=add(sum[i-1],f[i]); &#125; cout&lt;&lt;mul(mul(f[H],fac[N]),inv(sf))&lt;&lt;endl; return 0;&#125; F Diverta City 构造. 考虑数学归纳法,对于 $N=2$ 的情况,显然可以直接连一条长度 $1$ 的边完成构造. 否则,对于 $N\geq 3$ ,先构造一个 $N-1$ 个点的完全图满足要求,再加入第 $N$ 个点,则只需要考虑从第 $N$ 个点向前 $N-1$ 个点连边的长度. 令 $M$ 为先前构造出的 $N-1$ 个点的图中最长的哈密顿路径长度,令 $a=\lbrace 1,2,4,7,12,20,29,38,52\rbrace$ ,则第 $N$ 个点与第 $i$ 个点相连的边长度为 $(M+1)\cdot a_i$ 即可满足新得到的 $N$ 个点的图也符合要求. 为啥呢?因为任意一条新图的哈密顿路径中,只有 $1$ 条新加入的边( $N$ 为路径起点/终点) , 或 $2$ 条新加入的边( $N$ 不为路径起点/终点),而其余的边一定是 $N-1$ 个点的图中一条哈密顿路径的一部分. 所以新图中的每一条哈密顿路径长度都可以被表示为 $x+(M+1)\cdot a_i$ 或 $x+(M+1)\cdot(a_i+a_j)$ . 其中 $0\leq x\leq M$ .而我们构造的数列 $a$ 是满足所有 $a_i,a_i+a_j$ 都是互异的,所以新图的每条哈密顿路径长度也是互异的,于是得到的新图也满足条件. 当 $N=10$ 时,可以验证此时最长的边为 $96755758040&lt;10^{11}$ 满足限制.每次加点后暴力枚举 $i!/2$ 条哈密顿路径,计算 $M$ .时间复杂度 $O((N+1)!)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=11;const int a[]=&#123;0,1,2,4,7,12,20,29,38,52&#125;;int n,p[MAXN];ll w[MAXN][MAXN],M;void GetM(int x)&#123; M=0; for(int i=1;i&lt;=x;++i) p[i]=i; do &#123; ll res=0; for(int i=1;i&lt;x;++i) res+=w[p[i]][p[i+1]]; M=max(M,res); &#125;while(next_permutation(p+1,p+1+x));&#125;void solve(int x)&#123; for(int i=1;i&lt;x;++i) w[i][x]=w[x][i]=(M+1)*a[i];&#125;int main()&#123; n=read(); w[1][2]=w[2][1]=1; M=1; for(int i=3;i&lt;=n;++i) &#123; solve(i); GetM(i); &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%lld ",w[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>DAG</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4515 游戏]]></title>
    <url>%2F2019%2F06%2F14%2Fbzoj-4515-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[树链剖分 + 李超线段树. 显然可以先来一个树剖,就成了区间上的问题.每次修改 $(s,t)$ 就拆成 $(s,lca),(lca,t)$ 两段来做. 于是修改操作都是给一条区间加一条线段的形式,询问是问一个区间内点值的最小值. 用李超线段树维护优势线段与区间的答案即可. 时间复杂度 $O(nlog^3n)$ ,但常数比较小,所以能过. 强行上树系列. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll inf=123456789123456789;const int MAXN=1e5+10;int ecnt=0,head[MAXN];int to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll dist[MAXN];int mxson[MAXN],siz[MAXN],fa[MAXN],dep[MAXN];int idx=0,dfn[MAXN],rnk[MAXN],top[MAXN],distofa[MAXN];void dfs1(int u,int Fa)&#123; siz[u]=1; fa[u]=Fa; dep[u]=dep[Fa]+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; distofa[v]=val[i]; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp,ll CurDist)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; dist[idx]=CurDist; if(mxson[u]) dfs2(mxson[u],tp,CurDist+distofa[mxson[u]]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v,CurDist+distofa[v]); &#125;&#125;int Query_LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;ll tmp,k[MAXN*50],b[MAXN*50];ll calc(int seg,int x)&#123; return k[seg]*dist[x]+b[seg];&#125;int n,m,cnt=0;ll ans;struct SegTree&#123; int nodecnt; SegTree()&#123;nodecnt=0;&#125; struct node &#123; int ls,rs,id; ll mi; node()&#123;ls=rs=id=0;mi=inf;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void BuildTree(int l,int r) &#123; int o=++nodecnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; root.ls=nodecnt+1; BuildTree(l,mid); root.rs=nodecnt+1; BuildTree(mid+1,r); &#125; void pushup(int o,int l,int r) &#123; if(root.id) root.mi=k[root.id]&lt;0?calc(root.id,r):calc(root.id,l); else root.mi=inf; if(l&lt;r) &#123; root.mi=min(root.mi,lson.mi); root.mi=min(root.mi,rson.mi); &#125; &#125; void upd(int o,int l,int r,int L,int R,int seg) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!root.id) &#123; root.id=seg; pushup(o,l,r); return; &#125; bool f1=calc(root.id,l)&lt;calc(seg,l); bool f2=calc(root.id,r)&lt;calc(seg,r); if(f1==f2 || l==r) &#123; if(!f1) &#123; root.id=seg; pushup(o,l,r); &#125; return; &#125; int mid=(l+r)&gt;&gt;1; bool f3=calc(root.id,mid)&lt;calc(seg,mid); if(f1==f3) &#123; if(f1) upd(root.rs,mid+1,r,L,R,seg); else upd(root.rs,mid+1,r,L,R,root.id),root.id=seg; &#125; else &#123; if(f1) upd(root.ls,l,mid,L,R,root.id),root.id=seg; else upd(root.ls,l,mid,L,R,seg); &#125; &#125; else &#123; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(root.ls,l,mid,L,R,seg); if(R&gt;mid) upd(root.rs,mid+1,r,L,R,seg); &#125; pushup(o,l,r); &#125; void query(int o,int l,int r,int L,int R) &#123; if(root.id) &#123; if(k[root.id]&lt;0) ans=min(ans,calc(root.id,min(r,R))); else ans=min(ans,calc(root.id,max(l,L))); &#125; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; ans=min(ans,root.mi); return; &#125; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) query(root.ls,l,mid,L,R); if(R&gt;mid) query(root.rs,mid+1,r,L,R); &#125;&#125;T;void Modifiy1(int x,int lca,int A,int B)&#123; tmp=B; while(top[x]!=top[lca]) &#123; k[++cnt]=-A; b[cnt]=tmp+1LL*A*dist[dfn[x]]; int L=dfn[top[x]],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp+=1LL*(dist[R]-dist[L]+distofa[top[x]])*A; x=fa[top[x]]; &#125; k[++cnt]=-A; b[cnt]=tmp+1LL*A*dist[dfn[x]]; int L=dfn[lca],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp+=1LL*(dist[R]-dist[L])*A;&#125;void Modifiy2(int x,int lca,int A,int B)&#123; tmp+=1LL*(dist[dfn[x]]-dist[dfn[lca]])*A; while(top[x]!=top[lca]) &#123; k[++cnt]=A; b[cnt]=tmp-1LL*A*dist[dfn[x]]; int L=dfn[top[x]],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp-=1LL*(dist[R]-dist[L]+distofa[top[x]])*A; x=fa[top[x]]; &#125; if(x!=lca) &#123; k[++cnt]=A; b[cnt]=tmp-1LL*A*dist[dfn[x]]; int L=dfn[lca]+1,R=dfn[x]; T.upd(1,1,n,L,R,cnt); &#125;&#125;void Query(int x,int lca)&#123; while(top[x]!=top[lca]) &#123; int L=dfn[top[x]],R=dfn[x]; T.query(1,1,n,L,R); x=fa[top[x]]; &#125; int L=dfn[lca],R=dfn[x]; T.query(1,1,n,L,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs1(1,0); dfs2(1,1,0); T.BuildTree(1,n); while(m--) &#123; int tp=read(); int x=read(),y=read(); int lca=Query_LCA(x,y); if(tp==1) &#123; int A=read(),B=read(); Modifiy1(x,lca,A,B); Modifiy2(y,lca,A,B); &#125; else &#123; ans=inf; Query(x,lca); Query(y,lca); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树链剖分</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4514 数字配对]]></title>
    <url>%2F2019%2F06%2F12%2Fbzoj-4514-%E6%95%B0%E5%AD%97%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[费用流. 将每个数字 $a_i$ 拆成入点 $p_i$ 和出点 $q_i$,对于 $S\to p_i,q_i\to T$ 连费用为 $0$ ,容量为 $b_i$ 的边. 若 $a_i,a_j$ 之间可以配对,就对于 $p_i\to q_j,p_j\to q_i$ 连费用为 $-c_i\cdot c_j$ ,容量为 $inf$ 的边. 跑 $mcmf$ ,每次 $spfa$ 完之后判一下是否会使得费用 $&gt;0$ ,若会,就加上限制下的最大流量,然后退出即可. 这样做每对的贡献都被算了 $2$ 次,所以最后答案要 $/2$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;int head[MAXN],ecnt=-1,pcnt=0;struct Edge&#123; int to,nx; ll flow,val;&#125;E[MAXN];void addedge(int u,int v,ll flow,ll val)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; E[ecnt].val=val; head[u]=ecnt;&#125;void ins(int u,int v,ll flow,ll val)&#123; addedge(u,v,flow,val); addedge(v,u,0,-val);&#125;int n,a[MAXN],b[MAXN],c[MAXN];int p[MAXN],q[MAXN];bool is_prime(int x)&#123; if(x==1) return false; for(int i=2;i*i&lt;=x;++i) if(x%i==0) return false; return true;&#125;int vis[MAXN],pre[MAXN],lst[MAXN];ll dis[MAXN],flow[MAXN];bool spfa(int S,int T)&#123; for(int i=1;i&lt;=pcnt;++i) dis[i]=inf,flow[i]=inf,vis[i]=0; pre[T]=-1; queue&lt;int&gt; q; dis[S]=0; vis[S]=1; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dis[v]-dis[u]&gt;E[i].val) &#123; dis[v]=dis[u]+E[i].val; pre[v]=u; lst[v]=i; flow[v]=min(flow[u],E[i].flow); if(!vis[v]) &#123; q.push(v); vis[v]=1; &#125; &#125; &#125; &#125; return pre[T]!=-1;&#125;ll mcmf(int S,int T)&#123; ll maxflow=0,mincost=0; while(spfa(S,T)) &#123; if(mincost+flow[T]*dis[T]&gt;0) &#123; ll tmp=-mincost; maxflow+=tmp/dis[T]; return maxflow; &#125; maxflow+=flow[T]; mincost+=flow[T]*dis[T]; int now=T; while(now!=S) &#123; E[lst[now]].flow-=flow[T]; E[lst[now]^1].flow+=flow[T]; now=pre[now]; &#125; &#125; return maxflow;&#125;int main()&#123; memset(head,-1,sizeof head); int S=++pcnt,T=++pcnt; n=read(); for(int i=1;i&lt;=n;++i) p[i]=++pcnt,q[i]=++pcnt; for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) &#123; b[i]=read(); ins(S,p[i],b[i],0); ins(q[i],T,b[i],0); &#125; for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;i;++j) &#123; int x=max(a[i],a[j]),y=min(a[i],a[j]); if(x%y==0 &amp;&amp; is_prime(x/y)) &#123; ins(p[i],q[j],inf,-1LL*c[i]*c[j]); ins(p[j],q[i],inf,-1LL*c[i]*c[j]); &#125; &#125; int ans=mcmf(S,T); cout&lt;&lt;ans/2&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4584 赛艇]]></title>
    <url>%2F2019%2F06%2F12%2Fbzoj-4584-%E8%B5%9B%E8%89%87%2F</url>
    <content type="text"><![CDATA[$dp$ + 组合数学. 如果值域很小,那么可以直接设 $f(i,j)$ 表示考虑了前 $i$ 个人,第 $i$ 个人选 $j$ 的方案数. 于是考虑离散化.将这些区间离散化为 $O(n)$ 个区间,区间按 $l$ 从小到大排序,且互不相交. 设 $f(i,j)$ 表示考虑了前 $i$ 个人,第 $i$ 个人参了赛,且选择的数在第 $j$ 个区间内的方案数. 那么 $1\sim i-1$ 这些人选择的数有在区间 $j$ 内的,也有不在区间 $j$ 内的.若有 $m$ 个在区间 $j$ 内的,区间 $j$ 的长度为 $L$ ,那么方案数为 ${L+m-1\choose m}$ ,因为 $i$ 必须选.而不在区间 $j$ 内的部分就是个前缀和. 于是大力枚举从 $k$ 转移来,前 $p$ 个人都没选在区间 $j$ 内,用前缀和优化一下转移就好了. 时间复杂度 $O(n^3)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=500+10;int n,a[MAXN],b[MAXN],num[MAXN&lt;&lt;1],tot,g[MAXN],C[MAXN],inv[MAXN];void pre_inv()&#123; inv[1]=1; for(int i=2;i&lt;=n;++i) inv[i]=1LL*(P-P/i)*inv[P%i]%P;&#125;int main()&#123; n=read(); pre_inv(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); b[i]=read(); num[++tot]=a[i]; num[++tot]=b[i]+1; &#125; sort(num+1,num+1+tot); tot=unique(num+1,num+1+tot)-num-1; for(int i=1;i&lt;=n;++i) &#123; a[i]=lower_bound(num+1,num+1+tot,a[i])-num; b[i]=lower_bound(num+1,num+1+tot,b[i]+1)-num; &#125; C[0]=1; g[0]=1; for(int j=1;j&lt;tot;++j) &#123; int len=num[j+1]-num[j]; for(int i=1;i&lt;=n;++i) C[i]=mul(mul(C[i-1],len+i-1),inv[i]); for(int i=n;i&gt;=1;--i) &#123; if(a[i]&gt;j || b[i]&lt;j+1) continue; int f=0,m=1,c=len; for(int p=i-1;p&gt;=0;--p) &#123; f=add(f,mul(c,g[p])); if(a[p]&lt;=j &amp;&amp; j+1&lt;=b[p]) c=C[++m]; &#125; g[i]=add(g[i],f); &#125; &#125; int ans=0; for(int i=1;i&lt;=n;++i) ans=add(ans,g[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4596 黑暗前的幻想乡]]></title>
    <url>%2F2019%2F06%2F11%2Fbzoj-4596-%E9%BB%91%E6%9A%97%E5%89%8D%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[矩阵树定理 + 容斥原理. 如果把所有出现的边都加上,直接算生成树个数,可能会包括了有某些公司没有用边的情况. 于是减去 $1$ 个公司不修路,其他公司随便修的方案数.再加上 $2$ 个公司不修路的方案数… 二进制大力枚举每个公司的边考不考虑,用矩阵树定理算方案数,乘上容斥系数即可. 时间复杂度 $O(2^n\cdot n^3)$ . 二进制表示状态的题,下标从 $0$ 开始会方便一些. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;inline int count(int x)&#123; int s=0; while(x) s+=x&amp;1,x&gt;&gt;=1; return s;&#125;const int MAXN=20;typedef pair&lt;int,int&gt; pii;#define mp make_pairint n,ans=0;vector&lt;pii&gt; E[MAXN];int A[MAXN][MAXN];int sgn;void SwapRow(int x,int y,int k)&#123; for(int i=k;i&lt;n;++i) swap(A[x][i],A[y][i]);&#125;void GCD(int x,int y)&#123; if(!A[y][x]) return; int t=A[x][x]/A[y][x]; for(int i=x;i&lt;n;++i) A[x][i]=add(A[x][i],P-mul(t,A[y][i])); SwapRow(x,y,x); sgn*=-1; GCD(x,y);&#125;void Gauss(int x)&#123; if(x==n-1) return; if(!A[x][x]) &#123; for(int i=x+1;i&lt;n;++i) if(A[i][x]) &#123; SwapRow(x,i,x); sgn*=-1; break; &#125; &#125; if(!A[x][x]) return; for(int i=x+1;i&lt;n;++i) if(A[i][x]) GCD(x,i); Gauss(x+1);&#125;int det()&#123; int res=1; sgn=1; Gauss(1); for(int i=1;i&lt;n;++i) res=mul(res,A[i][i]); return add(P,sgn*res);&#125;int main()&#123; n=read(); for(int i=0;i&lt;n-1;++i) &#123; int m=read(); for(int j=1;j&lt;=m;++j) &#123; int u=read(),v=read(); E[i].push_back(mp(u-1,v-1)); &#125; &#125; int mx=1&lt;&lt;(n-1); for(int st=0;st&lt;mx;++st) &#123; memset(A,0,sizeof A); int tot=count(st); for(int i=0;i&lt;n-1;++i) &#123; if((st&gt;&gt;i)&amp;1) continue; int siz=E[i].size(); for(int j=0;j&lt;siz;++j) &#123; int u=E[i][j].first; int v=E[i][j].second; ++A[u][u],++A[v][v]; A[u][v]=add(A[u][v],P-1); A[v][u]=add(A[v][u],P-1); &#125; &#125; if(tot&amp;1) ans=add(ans,P-det()); else ans=add(ans,det()); &#125; cout&lt;&lt;add(ans%P,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190611]]></title>
    <url>%2F2019%2F06%2F11%2Ftest20190611%2F</url>
    <content type="text"><![CDATA[$noip$ 模拟题? $exam$ 贪心. 显然是每 $k$ 题安排错一次能使得分最小.若能通过安排使得没有 $k$ 个连续正确,那么答案就是 $m$ . 否则,一定会出现连续对 $k$ 次,我们尽量把它们安排在前面,错的题安排在后面.这样后面贡献就是做对的题目数,前面的贡献是连续做对 $x$ 道题目得分.这个得分单独算一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int n,m,k;int calc(int x)&#123; int t=x/k; int tmp=fpow(2,t+1); tmp=add(tmp,P-2-t); tmp=mul(tmp,k); return add(tmp,x);&#125;int main()//use dp to check&#123; freopen("exam.in","r",stdin); freopen("exam.out","w",stdout); n=read(),m=read(),k=read(); m=n-m; int tot=n/k; int ans=0; if(tot&lt;=m) &#123; ans=n-m; cout&lt;&lt;ans&lt;&lt;endl; &#125; else &#123; int x=n-m*k; ans=calc(x); ans=add(ans,mul(m,k-1)); cout&lt;&lt;add(ans%P,P)&lt;&lt;endl; &#125; return 0;&#125; $genes$ 线段树. 其实只有 $n$ 种情况,每次将第一个元素放到最后,并检验当前是否合法,做 $n$ 次即可. 用线段树来维护每个元素当前对应的前缀和就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int MAXN=1e6+10;int n,a[MAXN],sum[MAXN],tot;struct Segtree&#123; int val[MAXN&lt;&lt;2]; int tag[MAXN&lt;&lt;2];#define root val[o]#define lson val[o&lt;&lt;1]#define rson val[o&lt;&lt;1|1] void pushup(int o) &#123; root=min(lson,rson); &#125; void modifiy(int o,int c) &#123; root+=c; tag[o]+=c; &#125; void pushdown(int o) &#123; if(tag[o]) &#123; modifiy(o&lt;&lt;1,tag[o]); modifiy(o&lt;&lt;1|1,tag[o]); tag[o]=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; tag[o]=0; if(l==r) &#123; root=sum[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int pos) &#123; if(l==r) return root; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) return query(o&lt;&lt;1,l,mid,pos); else return query(o&lt;&lt;1|1,mid+1,r,pos); &#125; int check() &#123; return val[1]&gt;=0; &#125;&#125;T;int main()//use bf to check&#123; freopen("genes.in","r",stdin); freopen("genes.out","w",stdout); n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); sum[i]=sum[i-1]+a[i]; &#125; tot=sum[n]; T.BuildTree(1,1,n); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int tmp=T.query(1,1,n,i); T.upd(1,1,n,i,i,tot-tmp); if(i&gt;1) T.upd(1,1,n,1,i-1,-tmp); if(i&lt;n) T.upd(1,1,n,i+1,n,-tmp); ans+=T.check(); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; $paths$ $dp$ . 其实就是要求两条不相交路径总长最小值.设 $f(i,j)$ 表示当前一条路径的最后一个点是 $i$ ,另一条路径的最后一个点是 $j$ 时的最短长度. 每次用 $f(i,j)$ 去更新 $f(i,1+\max(i,j)),f(1+\max(i,j),j)$ 就可以保证每个点恰好被选一次了. 特殊点和起点终点特判一下就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=1e3+10;const double inf=1e18;int n,x[MAXN],y[MAXN],b1,b2;double dis[MAXN][MAXN],f[MAXN][MAXN];double calcModulus(int i,int j)&#123; return sqrt(1.0*(x[i]-x[j])*(x[i]-x[j])+1.0*(y[i]-y[j])*(y[i]-y[j]));&#125;int main()&#123; freopen("paths.in","r",stdin); freopen("paths.out","w",stdout); n=read(),b1=read()+1,b2=read()+1; for(int i=1; i&lt;=n; ++i) &#123; x[i]=read(); y[i]=read(); for(int j=1; j&lt;i; ++j) dis[i][j]=dis[j][i]=calcModulus(i,j); &#125; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) f[i][j]=inf; f[1][1]=0; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) &#123; if(i==n &amp;&amp; j==n) break; int k=max(i,j)+1; if(k&gt;n) --k; if(k!=b2) f[k][j]=min(f[k][j],f[i][j]+dis[i][k]); if(k!=b1) f[i][k]=min(f[i][k],f[i][j]+dis[j][k]); &#125; printf("%.2f\n",f[n][n]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4590 自动刷题机]]></title>
    <url>%2F2019%2F06%2F10%2Fbzoj-4590-%E8%87%AA%E5%8A%A8%E5%88%B7%E9%A2%98%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[二分答案. 不难发现 $n$ 增大,切题数不会增多, $n$ 减小,切题数不会减少. 于是分别二分 $n$ 的最小值与最大值,检验直接模拟操作就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k,x[MAXN];bool checkmin(ll mid)&#123; int tot=0; ll len=0; for(int i=1;i&lt;=n;++i) &#123; len+=x[i]; len=max(len,0LL); if(len&gt;=mid) len=0,++tot; &#125; if(len&gt;=mid) len=0,++tot; return tot&lt;=k;&#125;ll solvemin()&#123; ll L=1,R=1e18; ll ans=-1; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(checkmin(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; return ans;&#125;bool checkmax(ll mid)&#123; int tot=0; ll len=0; for(int i=1;i&lt;=n;++i) &#123; len+=x[i]; len=max(len,0LL); if(len&gt;=mid) len=0,++tot; &#125; if(len&gt;=mid) len=0,++tot; return tot&gt;=k;&#125;ll solvemax()&#123; ll L=1,R=1e18; ll ans=-1; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(checkmax(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; return ans;&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) x[i]=read(); ll a=solvemin(),b=solvemax(); if(a&gt;b || a&lt;0 || b&lt;0) puts("-1"); else cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1173]]></title>
    <url>%2F2019%2F06%2F08%2FCF1173%2F</url>
    <content type="text"><![CDATA[$Div.2$ 官方题解 A Nauuo and Votes 签到题. B Nauuo and Chess 构造题. 可以将所有数沿着第一列与最后一行放成一个 $L$ 形.容易验证一定是合法的. 这样构造, $m=\lfloor \frac n 2 \rfloor+1$ .而考虑首尾两个位置,有$$|r_1-r_n|+|c_1-c_n|\geq n-1$$ 而 $|r_1-r_n|\leq m-1,|c_1-c_n|\leq m-1$ ,所以 $2m-2\geq n-1$ , $m$ 为整数,可得到 $m\geq \lfloor \frac n 2 \rfloor+1$ . 所以这样构造一定是一个最优解. C Nauuo and Cards 策略是如果能不打 $0$ 直接完成,就直接完成,否则先打若干 $0$ ,然后再也不打 $0$ . 考虑如果已经打了若干 $0$ ,开始一直打数字牌,那么此时 $1$ 必定在手中, $2$ 必定在手中或在牌堆的第 $1$ 个位置(打了 $1$ 就会被摸到手中), $3$ 必定在手中或在第 $2$ 个位置,以此类推. 如果有一些牌的位置不合要求,那么我们需要先打空白牌来将他们加入到手中或是放到正确的位置. 在手中可以看做位置 $0$ ,记 $p_i$ 为 $i$ 的初始位置,那么答案就是 $n+\max\limits_{i=1}^n (p_i-i+1)$ . $n$ 是因为要连续打出 $1\sim n$ 这些牌,后面的部分是将 $p_i$ 调整到 $i-1$ 所需打出的 $0$ 的数目. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN],b[MAXN],p[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) p[b[i]=read()]=i; if(p[1]) &#123; int x; for(x=2;p[x]==p[1]+x-1;++x); if(p[x-1]==n) &#123; int y; for(y=x;y&lt;=n &amp;&amp; p[y]&lt;=y-x;++y); if(y&gt;n) &#123; cout&lt;&lt;n-x+1&lt;&lt;endl; return 0; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;++i) ans=max(ans,p[i]-i+1); cout&lt;&lt;ans+n&lt;&lt;endl; return 0;&#125; D Nauuo and Circle $dp$ 计数. 考虑 $dp$ ,设 $f_u$ 表示子树 $u$ 的方案数,先钦定根节点为 $1$ ,最后答案就是 $n\cdot f_1$ . 画子树时,先要给所有儿子,若不为根,还有自己排序,转移有 $f_u=(|son_u|+[u==1])!\cdot \prod\limits_{v \in son_u}f_v$ . 把 $dp$ 的式子展开,可以发现答案就是 $n\cdot \prod\limits _{i=1}^n deg_i$ , $deg$ 表示度数. 待续…]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>codeforces</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4805 欧拉函数求和]]></title>
    <url>%2F2019%2F06%2F08%2Fbzoj-4805-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[练习了min_25筛.跑得挺快的. 注意将所有数都当成质数时, $f(x)=x-1$ ,但它并不是个完全积性函数. 所以要拆成 $f(x)=1,g(x)=x$ 两个函数分别预处理,然后相减. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int cnt=0,prime[MAXN],ism[MAXN];ll sumphi[MAXN];void init_prime(int n)&#123; ism[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=n;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125; for(int i=1;i&lt;=cnt;++i) sumphi[i]=sumphi[i-1]+prime[i]-1;&#125;ll calcsum(int x)&#123; return 1LL*(2+x)*(x-1)/2;&#125;int tot=0,w[MAXN],id1[MAXN],id2[MAXN];ll f[MAXN],g[MAXN];int N,sqN;ll S(int n,int j)&#123; if(n&lt;=1 || prime[j]&gt;n) return 0; int id=n; if(id&lt;=sqN) id=id1[id]; else id=id2[N/id]; ll res=g[id]-sumphi[j-1]; for(int k=j;k&lt;=cnt &amp;&amp; 1LL*prime[k]*prime[k]&lt;=n;++k) &#123; ll pw1=prime[k],pw2=prime[k]*prime[k]; for(int e=1;pw2&lt;=n;++e) &#123; ll tmp=pw1/prime[k]*(prime[k]-1); tmp*=S(n/pw1,k+1); tmp+=pw2/prime[k]*(prime[k]-1); res+=tmp; pw1*=prime[k],pw2*=prime[k]; &#125; &#125; return res;&#125;int main()&#123; N=read(); sqN=(sqrt(N)); init_prime(sqN); for(int l=1,r;l&lt;=N;l=r+1) &#123; r=N/(N/l); w[++tot]=N/l; if(N/l&lt;=sqN) id1[N/l]=tot; else id2[N/(N/l)]=tot; &#125; for(int i=1;i&lt;=tot;++i) f[i]=w[i]-1,g[i]=calcsum(w[i]); for(int j=1;j&lt;=cnt;++j) for(int i=1;i&lt;=tot &amp;&amp; prime[j]*prime[j]&lt;=w[i];++i) &#123; int k=w[i]/prime[j]; if(k&lt;=sqN) k=id1[k]; else k=id2[N/k]; g[i]-=1LL*(prime[j])*(g[k]-sumphi[j-1]-j+1); f[i]-=f[k]-j+1; &#125; for(int i=1;i&lt;=tot;++i) g[i]-=f[i]; ll ans=S(N,1)+1; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[min_25筛学习笔记]]></title>
    <url>%2F2019%2F06%2F05%2Fmin-25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一篇比较详细的学习笔记. 由于渲染有点小问题,所以就直接传 $PDF$ 了.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4667 小y的密码]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4667-%E5%B0%8Fy%E7%9A%84%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[排列/组合计数. 限制是否满足只与 $0\sim 9$ 这些数字各自出现了多少次有关.所以可以 $dfs$ 大力枚举这些数字各自的出现次数. 若限制满足,再计算用这些数字能组合出多少 $\leq n$ 的数. 若这些数个数不足 $n$ 的位数,那么就是带重复元素的排列数.注意减掉有前导 $0$ 的情况. 若个数达到了 $n$ 的位数,就枚举从哪一位开始可以不用考虑限制(就相当于数位 $dp$ 里面那个 $limit$ ). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int n,k,limit;int t,pw[11];int a[11],tot[11],fig[11],m=0;int fac[11];ll ans=0;bool check()&#123; if(!m || !a[m]) return false; int mid=a[(m+1)&gt;&gt;1]; ll sum=0; for(int i=1;i&lt;=m &amp;&amp; sum&lt;=limit;++i) &#123; ll tmp=1; for(int j=1;j&lt;=k;++j) tmp*=a[i]-mid; sum+=tmp; &#125; return sum&lt;=limit;&#125;int calc(int x)&#123; int res=fac[x]; for(int i=0;i&lt;=9;++i) res/=fac[tot[i]]; return res;&#125;void solve()&#123; memset(tot,0,sizeof tot); for(int i=1;i&lt;=m;++i) ++tot[a[i]]; if(m&lt;t) &#123; ans+=calc(m); if(tot[0]) &#123; --tot[0]; ans-=calc(m-1); &#125; &#125; else &#123; bool flag=true; int tmp=t; for(int i=t;i&gt;=1;--i) &#123; for(int j=(i==t);j&lt;fig[i];++j) if(tot[j]) &#123; --tot[j]; --tmp; ans+=calc(tmp); ++tot[j]; ++tmp; &#125; if(!tot[fig[i]]) &#123; flag=false; break; &#125; --tot[fig[i]]; --tmp; &#125; ans+=(int)flag; &#125;&#125;void dfs(int x)&#123; if(check()) solve(); if(m==t) return; for(int i=x;i&lt;=9;++i) &#123; ++m; a[m]=i; dfs(i); --m; &#125;&#125;int main()&#123; fac[0]=1; for(int i=1;i&lt;=9;++i) fac[i]=fac[i-1]*i; n=read(),k=read(),limit=read(); while(n) fig[++t]=n%10,n/=10; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4606 DNA]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4606-DNA%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 求第 $R$ 大,可以想到把某一类的方案数全部算出来,用 $R$ 去减,就和用平衡树求第 $k$ 大,用 $k$ 减 $siz$ 的操作类似. 题面都明示了? 设 $f(i,j,k)$ 表示第 $i$ 个字符填 $j$ ,至少需要分成 $k$ 个不下降段的方案数.倒着 $dp$ 即可. 最后就从前往后匹配,一边匹配一边减就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,a[MAXN],id[400];char s[MAXN],invid[5]=&#123;'A','C','G','T'&#125;;ll f[MAXN][5][11],R;int main()&#123; for(int i=0;i&lt;4;++i) id[invid[i]]=i; id['N']=4; n=read(),m=read(); R=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i) a[i]=id[s[i]]; if(a[n]==4) for(int i=0;i&lt;4;++i) f[n][i][1]=1; else f[n][a[n]][1]=1; for(int i=n-1;i&gt;=1;--i) &#123; if(a[i]==4) &#123; for(int j=0;j&lt;4;++j) for(int k=1;k&lt;=m;++k) for(int l=0;l&lt;4;++l) f[i][j][k]+=f[i+1][l][k-(j&gt;l)]; &#125; else &#123; for(int k=1;k&lt;=m;++k) for(int l=0;l&lt;4;++l) f[i][a[i]][k]+=f[i+1][l][k-(a[i]&gt;l)]; &#125; &#125; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;4;++j) for(int k=1;k&lt;=m;++k) f[i][j][k]+=f[i][j][k-1]; a[0]=0; for(int i=1;i&lt;=n;++i) &#123; if(a[i]==4) &#123; for(int j=0;j&lt;4;++j) &#123; ll tmp=(j&lt;a[i-1])?f[i][j][m-1]:f[i][j][m]; if(R&gt;tmp) R-=tmp; else &#123; a[i]=j; break; &#125; &#125; &#125; if(a[i]&lt;a[i-1]) --m; printf("%c",invid[a[i]]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4600 硬币游戏]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4600-%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[博弈论. 操作一枚硬币,它只能影响到 $c$ 与自己相同的硬币.于是 $SG$ 函数就只需要 $a,b$ 两个状态. 而 $a,b$ 是指数,非常小,所以状态数目也很少,直接暴力计算 $SG$ 函数即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=25;int SG[MAXN][MAXN][MAXN];void init_SG(int maxq)&#123; vector&lt;int&gt; s; int tmp=0; for(int a=0;a&lt;=20;++a) for(int b=0;b&lt;=20;++b) &#123; s.clear(); for(int p=1;p&lt;=20;++p,tmp=0) for(int q=1;q&lt;=maxq &amp;&amp; p*q&lt;=a;++q) &#123; tmp^=SG[maxq][a-p*q][b]; s.push_back(tmp); &#125; for(int p=1;p&lt;=20;++p,tmp=0) for(int q=1;q&lt;=maxq &amp;&amp; p*q&lt;=b;++q) &#123; tmp^=SG[maxq][a][b-p*q]; s.push_back(tmp); &#125; sort(s.begin(),s.end()); int siz=s.size(); if(!siz || s[0]) &#123; SG[maxq][a][b]=0; continue; &#125; for(int i=1;i&lt;siz;++i) &#123; if(s[i]-s[i-1]&gt;=2) &#123; SG[maxq][a][b]=s[i-1]+1; break; &#125; &#125; if(!SG[maxq][a][b]) SG[maxq][a][b]=s[siz-1]+1; &#125;&#125;int n,maxq;int main()&#123; for(int i=1;i&lt;=20;++i) init_SG(i); int T=read(); while(T--) &#123; n=read(),maxq=read(); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int dir=read(); if(dir) continue; int x=i,a=0,b=0; while(x%2==0) ++a,x/=2; while(x%3==0) ++b,x/=3; ans^=SG[maxq][a][b]; &#125; if(ans) puts("win"); else puts("lose"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4602 齿轮]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4602-%E9%BD%BF%E8%BD%AE%2F</url>
    <content type="text"><![CDATA[图的 $dfs$ 遍历. 方向和速度显然可以分开判. 方向就是判二分图.而对于速度,走过一条边,相对速度可以看做乘了一个比值. 因为 $x,y\leq 100$ ,所以可以直接分解质因数,像染色那样做就可以了. 时间复杂度 $O(25m)$ . 另外一种更优雅的方法是直接在模大质数意义下做乘除法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;int ism[101],cnt=0,prime[101];void init_prime()&#123; ism[1]=1; for(int i=2;i&lt;=100;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=100;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int ecnt,head[MAXN];struct edge&#123; int to,nx; int dir; int x,y;&#125;E[MAXN&lt;&lt;1];void addedge(int u,int v,int x,int y)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].dir=(x*y&lt;0)?-1:1; E[ecnt].x=abs(x); E[ecnt].y=abs(y); head[u]=ecnt;&#125;int n,m;int dir[MAXN],factor[MAXN][26];void init()&#123; ecnt=0; memset(head,0,sizeof head); memset(dir,0,sizeof dir); memset(factor,0,sizeof factor);&#125;int transfac[26];void add(int x,int c)&#123; for(int i=1;i&lt;=cnt &amp;&amp; prime[i]&lt;=x;++i) while(x%prime[i]==0) &#123; x/=prime[i]; transfac[i]+=c; &#125;&#125;bool dfs(int u)&#123; bool flag=true; for(int i=head[u];i &amp;&amp; flag;i=E[i].nx) &#123; int v=E[i].to; memset(transfac,0,sizeof transfac); add(E[i].y,1); add(E[i].x,-1); if(dir[v]) &#123; if(dir[u]*E[i].dir!=dir[v]) return false; for(int i=1;i&lt;=25;++i) if(factor[u][i]+transfac[i]!=factor[v][i]) return false; &#125; else &#123; dir[v]=dir[u]*E[i].dir; for(int i=1;i&lt;=25;++i) factor[v][i]=factor[u][i]+transfac[i]; flag&amp;=dfs(v); &#125; &#125; return flag;&#125;int main()&#123; init_prime(); int T=read(); for(int casenum=1;casenum&lt;=T;++casenum) &#123; init(); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),x=read(),y=read(); addedge(u,v,x,y); addedge(v,u,y,x); &#125; bool flag=true; for(int i=1;i&lt;=n &amp;&amp; flag;++i) if(!dir[i]) &#123; dir[i]=1; flag&amp;=dfs(i); &#125; if(flag) printf("Case #%d: Yes\n",casenum); else printf("Case #%d: No\n",casenum); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4627 回转寿司]]></title>
    <url>%2F2019%2F06%2F03%2Fbzoj-4627-%E5%9B%9E%E8%BD%AC%E5%AF%BF%E5%8F%B8%2F</url>
    <content type="text"><![CDATA[线段树. 区间和可以转化为前缀和之差.记前缀和为 $sum$ ,从前往后加入数,加入到第 $i$ 个数的时候,就要算 $L\leq sum_i-sum_j\leq R,0\leq j&lt;i$ 的 $j$ 的数目. 不等式变一下,就是求 $sum_i-R\leq sum_j\leq sum_i-L$ 的数目.用权值线段树来维护,动态开点即可. 注意权值可能是负的,所以根节点的 $l,r$ 分别为 $-inf,inf$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e10;int n,L,R;struct Segtree&#123; int idx; struct node &#123; int cnt; int ls,rs; node()&#123;cnt=ls=rs=0;&#125; &#125;Tree[MAXN*50]; Segtree()&#123;idx=0;&#125;#define root Tree[o] void upd(int &amp;o,ll l,ll r,ll pos) &#123; if(!o) o=++idx; ++root.cnt; if(l==r) return; ll mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,l,mid,pos); else upd(root.rs,mid+1,r,pos); &#125; int query(int o,ll l,ll r,ll L,ll R) &#123; if(L&gt;R || R&lt;l || l&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.cnt; int res=0; ll mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125;&#125;T;int rt=0;ll ans=0,sum=0;int main()&#123; n=read(); L=read(),R=read(); T.upd(rt,-inf,inf,0); for(int i=1;i&lt;=n;++i) &#123; sum+=read(); ans+=T.query(rt,-inf,inf,sum-R,sum-L); T.upd(rt,-inf,inf,sum); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4662 snow]]></title>
    <url>%2F2019%2F06%2F02%2Fbzoj-4662-snow%2F</url>
    <content type="text"><![CDATA[线段树. 考虑将 $L$ 离散化后,用线段树来维护每个清理工当前的工作长度. 若一个人将区间 $[L,R]$ 清扫后,被影响的人 $i$ 应该满足 $L&lt;L_i\leq R$ 或 $R_i\geq L&gt;L_i$ ,编号是一个区间. 显然不能直接修改,因为对它们的影响是不一样的.但对于所有影响到的 $L_i$ 相同的 $i$ 或所有 $R_i$ 相同的 $i$ 的影响是一样的,而这些人的编号也是一个区间. 于是可以用一个 $set$ 存储所有的三元组 $(l,r,pos)$ 表示编号在区间 $l,r$ 内的人,均满足 $L_i=pos$ .再用一个 $set$ 存储 $R_i=pos$ 的所有三元组. 修改时暴力取出所有的三元组,在线段树上修改后将它们合并成一个三元组放回去.而合并只会使区间变大,操作总次数是 $O(n)$ 的,所以时间复杂度是对的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;const int inf=1e9;int n,t,L[MAXN],R[MAXN];struct Segtree&#123; struct node &#123; int tag,val; node()&#123;tag=val=0;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.val=min(lson.val,rson.val); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.tag=min(root.tag,inf); root.val+=c; root.val=min(root.val,inf); &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) &#123; root.val=R[l]-L[l]+1; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int L,int R,int c)//[L,R]+=c &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r) &#123; if(l==r) return l; pushdown(o); int mid=(l+r)&gt;&gt;1; if(lson.val&lt;=rson.val) return query(o&lt;&lt;1,l,mid); else return query(o&lt;&lt;1|1,mid+1,r); &#125;&#125;Seg;struct Fenwicktree&#123; int bit[MAXN]; Fenwicktree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c,bit[x]=min(bit[x],inf); &#125; int query(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x],s=min(s,inf); return s; &#125; void upd(int L,int R,int c) &#123; add(L,c); add(R+1,-c); &#125;&#125;Fenwick;struct interval&#123; int l,r,pos; interval(int l=0,int r=0,int pos=0):l(l),r(r),pos(pos) &#123;&#125; bool operator &lt; (const interval &amp;rhs) const &#123; return pos&lt;rhs.pos; &#125;&#125;;set&lt;interval&gt; SL,SR;set&lt;interval&gt;::iterator it,tt;int main()&#123; t=read(),n=read(); for(int i=1;i&lt;=n;++i) &#123; L[i]=read(); R[i]=read(); &#125; for(int i=1;i&lt;=n;++i) &#123; Fenwick.add(i,L[i]-L[i-1]); SL.insert(interval(i,i,L[i])); SR.insert(interval(i,i,R[i])); &#125; Seg.BuildTree(1,1,n); SL.insert(interval(0,0,0)); SL.insert(interval(0,0,t+1)); SR.insert(interval(0,0,0)); SR.insert(interval(0,0,t+1)); for(int i=1;i&lt;=n;++i) &#123; int x=Seg.query(1,1,n); printf("%d\n",x); int l=Fenwick.query(x); int r=l+Seg.Tree[1].val-1; if(l!=r) &#123; int lx=n+1,rx=1; interval tmp=interval(0,0,l); it=SL.lower_bound(tmp); while((*it).pos&lt;=r) &#123; rx=max(rx,(*it).r); lx=min(lx,(*it).l); Fenwick.upd((*it).l,(*it).r,r-(*it).pos); Seg.upd(1,1,n,(*it).l,(*it).r,(*it).pos-r); tt=it; ++it; SL.erase(tt); &#125; SL.insert(interval(lx,rx,r)); lx=n+1,rx=1; tmp=interval(0,0,r); it=SR.lower_bound(tmp); while((*it).pos&gt;l) &#123; rx=max(rx,(*it).r); lx=min(lx,(*it).l); Seg.upd(1,1,n,(*it).l,(*it).r,l-(*it).pos); tt=it; --it; SR.erase(tt); &#125; SR.insert(interval(lx,rx,l)); &#125; Seg.upd(1,1,n,x,x,inf); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4663 hack]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4663-hack%2F</url>
    <content type="text"><![CDATA[最小割. 如果没有只能经过 $1$ 条被 $hack$ 边的限制,就是个裸的最小割. 解决的方法就是反向边的权值建成 $inf$ .感性理解一下,看下面这个图(图来自出题人): 在没有建 $inf$ 边前,割掉图中两条红色标记边是最优方案.而加上 $inf$ 后,就会出现 $st\to b\to a\to ed$ 这条路径.还需要割掉其他的边. 这样一来,不同时割掉两条红色标记边(即在一条路径上的边)就不会变得更劣. 还要注意将 $st$ 原来到不了的点预处理出来,将它们打上标记删去.否则可能出现如下情况(图来自出题人): 本来 $st$ 到不了 $a$ ,但加了 $inf$ 边后就连通了,会导致割掉额外的边. 这大概是几个月前考试做的?犹记李巨随手切了此题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e2+10,MAXM=1e4+10;const ll inf=1e18;int ecnt=-1,head[MAXN];struct Edge&#123; int to,nx; ll flow;&#125;E[MAXM];void addedge(int u,int v,ll flow)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; head[u]=ecnt;&#125;int n,m;bool reachable[MAXN];void init()&#123; queue&lt;int&gt; q; reachable[1]=true; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(reachable[v] || E[i].flow&gt;=inf) continue; reachable[v]=true; q.push(v); &#125; &#125;&#125;int dep[MAXN],cur[MAXN];bool bfs(int S,int T)&#123; for(int i=1;i&lt;=n;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; queue&lt;int&gt; q; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(!reachable[v] || E[i].flow&lt;=0 || dep[v]!=-1) continue; dep[v]=dep[u]+1; q.push(v); &#125; &#125; return dep[T]!=-1;&#125;ll dfs(int u,int T,ll limit)&#123; if(u==T || !limit) return limit; ll f,flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(!reachable[v]) continue; if(E[i].flow&gt;0 &amp;&amp; dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; flow+=f; limit-=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return flow;&#125;ll Dinic(int S,int T)&#123; ll maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return maxflow;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read()+1; int v=read()+1; int w=read(); addedge(u,v,w); addedge(v,u,inf); &#125; init(); ll ans=Dinic(1,n); if(ans&lt;0 || ans&gt;=inf) puts("-1"); else cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4681 旅行]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4681-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[最短路. 这类点,边数目比较少,却有一些奇奇怪怪的条件的最短路,大多都是拆点.然而实现时并不需要真的拆点,只需要在做最短路的时候给 $dis$ 多加几维即可. 考虑暴力做法,应该是 $dfs$ 找出每一条路径,贪心地将不在路径上最短的边与在路径上最长的边交换,最多 $k$ 次. 然而路径条数可以被随便搞到指数级. 沿用贪心的思想,最后最优路径中的边一定会包含全部前 $L$ 小的边,可以将边排序,枚举 $L$ ,结合最短路解决. 设 $f(u,j,k)$ 表示从 $1$ 到 $u$ ,路径上有 $j$ 条前 $L$ 小的边,交换了 $k$ 次时的最短路.转移时分当前边不在前 $L$ 小与当前边在前 $L$ 小,用 $Dijkstra$ 转移即可. 注意正反加了两条边,实际排名需 $/2$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=151;int ans=0x7fffffff;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct Edge&#123; int u,v,len; bool operator &lt; (const Edge &amp;rhs) const &#123; return len&lt;rhs.len; &#125;&#125;E[MAXN];struct node&#123; int u,j,k,dis; bool operator &lt; (const node &amp;rhs) const &#123; return dis&gt;rhs.dis; &#125; node(int u=0,int j=0,int k=0,int dis=0):u(u),j(j),k(k),dis(dis) &#123;&#125;&#125;;int N,M,K;int dis[MAXN][MAXN][MAXN],vis[MAXN][MAXN][MAXN];priority_queue&lt;node&gt; q;void Dijkstra(int L)&#123; memset(vis,0,sizeof vis); memset(dis,63,sizeof dis); node p=node(1,0,0,0); dis[1][0][0]=0; q.push(p); while(!q.empty()) &#123; p=q.top(); q.pop(); int u=p.u,j=p.j,k=p.k; if(vis[u][j][k]) continue; vis[u][j][k]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(i&lt;=L*2) &#123; if(j&lt;L &amp;&amp; dis[v][j+1][k]-dis[u][j][k]&gt;E[j+1].len) &#123; dis[v][j+1][k]=dis[u][j][k]+E[j+1].len; p=node(v,j+1,k,dis[v][j+1][k]); q.push(p); &#125; &#125; else &#123; if(j&lt;L &amp;&amp; k&lt;K &amp;&amp; dis[v][j+1][k+1]-dis[u][j][k]&gt;E[j+1].len) &#123; dis[v][j+1][k+1]=dis[u][j][k]+E[j+1].len; p=node(v,j+1,k+1,dis[v][j+1][k+1]); q.push(p); &#125; if(dis[v][j][k]-dis[u][j][k]&gt;E[(i+1)&gt;&gt;1].len) &#123; dis[v][j][k]=dis[u][j][k]+E[(i+1)&gt;&gt;1].len; p=node(v,j,k,dis[v][j][k]); q.push(p); &#125; &#125; &#125; &#125; for(int i=0;i&lt;=K;++i) ans=min(ans,dis[N][L][i]);&#125;int main()&#123; N=read(),M=read(),K=read(); for(int i=1;i&lt;=M;++i) &#123; E[i].u=read(); E[i].v=read(); E[i].len=read(); &#125; sort(E+1,E+1+M); for(int i=1;i&lt;=M;++i) &#123; addedge(E[i].u,E[i].v); addedge(E[i].v,E[i].u); &#125; for(int i=0;i&lt;=M;++i) Dijkstra(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4669 抢夺]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4669-%E6%8A%A2%E5%A4%BA%2F</url>
    <content type="text"><![CDATA[二分答案 + 费用流. 答案显然可以二分,只需要如何验证一个答案 $mid$ 是否合法. 考虑第一波同时出发的人,他们会选择最优的路径,而后来的人选择的路径必定与他们相同. 于是可以通过增广计算出在 $mid$ 天内到达的人数.而退流操作对应的贡献也是正确的,所以不需要另外考虑. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;const int inf=1e9;int ecnt=-1,head[MAXN];struct edge&#123; int nx,to,flow,dis;&#125;E[MAXN];void addedge(int u,int v,int flow,int dis)&#123; ++ecnt; E[ecnt].nx=head[u]; E[ecnt].to=v; E[ecnt].flow=flow; E[ecnt].dis=dis; head[u]=ecnt;&#125;void ins(int u,int v,int flow,int dis)&#123; addedge(u,v,flow,dis); addedge(v,u,0,-dis);&#125;int n,m,k;int dis[MAXN],flow[MAXN],pre[MAXN],lst[MAXN],vis[MAXN];queue&lt;int&gt; q;bool spfa(int S,int T)&#123; while(!q.empty()) q.pop(); for(int i=1;i&lt;=n;++i) &#123; vis[i]=0; flow[i]=inf; dis[i]=inf; &#125; pre[T]=-1; vis[S]=1; dis[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dis[v]&gt;dis[u]+E[i].dis) &#123; dis[v]=dis[u]+E[i].dis; flow[v]=min(flow[u],E[i].flow); pre[v]=u; lst[v]=i; if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return pre[T]!=-1;&#125;int Dist[MAXN],Flow[MAXN],tot=0;int mcmf(int S,int T)&#123; while(spfa(S,T)) &#123; int now=T; while(now!=S) &#123; E[lst[now]].flow-=flow[T]; E[lst[now]^1].flow+=flow[T]; now=pre[now]; &#125; ++tot; Dist[tot]=dis[T]; Flow[tot]=flow[T]; &#125;&#125;void init()&#123; memset(head,-1,sizeof head); ecnt=-1; tot=0;&#125;bool check(int mid)&#123; ll tmp=k; for(int i=1;i&lt;=tot &amp;&amp; tmp&gt;0;++i) tmp-=1LL*(mid-Dist[i]+1)*Flow[i]; return tmp&lt;=0;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)) &#123; init(); for(int i=1;i&lt;=m;++i) &#123; int u=read()+1,v=read()+1,c=read(); ins(u,v,c,1); &#125; mcmf(1,n); int ans=-1,L=0,R=n+k+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; if(ans==-1) puts("No solution"); else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4621 Tc605]]></title>
    <url>%2F2019%2F05%2F29%2Fbzoj-4621-Tc605%2F</url>
    <content type="text"><![CDATA[$dp$ . 一个数字只可以往左右拓展,把周围的数变成和它一样的数.所以最终状态一定是一些数字段拼起来的,而且数字之间相对的前后顺序不会改变. 对最终状态进行 $dp$ .设 $f(i,j)$ 表示考虑了前 $i$ 个位置,操作了 $j$ 次的情况总数.一个数字段最多操作一次,处理出每个数字左右延伸的范围,枚举拓展的右端点进行转移即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=512;int n,m,a[MAXN],f[MAXN][MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); f[0][0]=1; for(int i=1;i&lt;=n;++i) &#123; int l=i; while(l&gt;1 &amp;&amp; a[l-1]&lt;a[i]) --l; int r=i; while(r&lt;n &amp;&amp; a[r+1]&lt;a[i]) ++r; f[i][m]=add(f[i][m],f[i-1][m]); for(int j=m;j&gt;=1;--j) &#123; int tmp=f[l-1][j-1]; for(int k=l;k&lt;=r;++k) &#123; f[k][j]=add(f[k][j],tmp); tmp=add(tmp,f[k][j-1]); &#125; f[i][j-1]=add(f[i][j-1],f[i-1][j-1]); f[i][j]=add(f[i][j],-f[i-1][j-1]); &#125; &#125; int ans=0; for(int i=0;i&lt;=m;++i) ans=add(ans,f[n][i]); cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4658 rescue]]></title>
    <url>%2F2019%2F05%2F29%2Fbzoj-4658-rescue%2F</url>
    <content type="text"><![CDATA[$dp$ + 线段树. 显然只有关键点有用.设 $f(i)$ 表示到了第 $i$ 个关键点时的最小损失.把起点看做第 $0$ 个关键点,转移有: $$f(i)=\min_{j=0}^{i-1}\lbrace f(j)+ \lceil \frac {T_i-T_j} D \rceil\cdot A\rbrace - b_i$$ 这样大力转移是 $O(n^2)$ 的.注意到 $D$ 是固定的,考虑把 $T$ 写成 $T=C\cdot D+E,0\leq E&lt;D$ . 那么原式就可以变成 $$f(i)=\min_{j=0}^{i-1}\lbrace f(j)+ A\cdot (C_i-C_j)+[E_i&gt;E_j]\cdot A\rbrace - b_i$$ 以 $E$ 为下标建一颗动态开点的线段树,在 $E_j&lt; E_i,E_j\geq E_i$ 两部分分别查询 $f_j-A\cdot C_j$ 的最小值即可. 注意把 $Tree[0].val$ 初始化为 $inf$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;struct Segtree&#123; int idx; Segtree()&#123;idx=0;Tree[0].ls=Tree[0].rs=0;Tree[0].val=inf;&#125; struct node &#123; int ls,rs; ll val; &#125;Tree[MAXN*30];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void pushup(int o) &#123; root.val=min(lson.val,rson.val); &#125; void ins(int &amp;o,int l,int r,int pos,ll c) &#123; if(!o) &#123; o=++idx; root.val=inf; root.ls=root.rs=0; &#125; if(l==r) &#123; root.val=min(root.val,c); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,l,mid,pos,c); else ins(root.rs,mid+1,r,pos,c); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(!o || L&gt;R) return inf; if(L&lt;=l &amp;&amp; r&lt;=R) return root.val; ll res=inf; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=min(res,query(root.ls,l,mid,L,R)); if(R&gt;mid) res=min(res,query(root.rs,mid+1,r,L,R)); return res; &#125;&#125;T;int n,rt=0;int A,B[MAXN],C[MAXN],D,E[MAXN],K,M;ll f[MAXN];void update_info(int x)&#123; T.ins(rt,0,D-1,E[x],f[x]-1LL*A*C[x]);&#125;int main()&#123; K=read(),M=read(),D=read(),A=read(); n=read(); C[0]=K/D,E[0]=K%D,B[0]=0; ++n; C[n]=M/D,E[n]=M%D,B[n]=0; f[0]=0; update_info(0); for(int i=1;i&lt;n;++i) &#123; int T=read(); C[i]=T/D; E[i]=T%D; B[i]=read(); &#125; for(int i=1;i&lt;=n;++i) &#123; f[i]=1LL*C[i]*A-B[i]; ll tmp=T.query(rt,0,D-1,0,E[i]-1)+A; tmp=min(tmp,T.query(rt,0,D-1,E[i],D-1)); f[i]+=tmp; update_info(i); &#125; cout&lt;&lt;(-f[n])&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4659 lcm]]></title>
    <url>%2F2019%2F05%2F28%2Fbzoj-4659-lcm%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 转化一下条件,数对 $(a,b)$ 符合要求等价于 $\mu(gcd(a,b))\not=0​$ . 为了方便,记 $m=\min(A,B)$ , 集合 $S=\lbrace x|\mu(x)\not=0\rbrace$ ,$sum(x)=\frac {x(x+1)} 2$ . 则答案 $ans$ 为: 到这一步,直接用两个整除分块算,时间复杂度 $O(T\cdot n^{\frac 3 4})$. 然而发现极限数据要跑 $10s+$ . 再变一步,将枚举 $x,d$ 变为先枚举 $D=xd$ ,再枚举 $x$. $$ans=\sum_{D=1}^{m}D \sum_{x|D} \mu(x)^2\mu(\frac D x)\frac D x \sum_{a=1}^{A/D}\sum_{b=1}^{B/D} ab$$ 设三个函数 $f,g,h$ : 函数 $g,h$ 显然都是积性函数.而 $f=g*h$ ,也为积性函数.于是可以线性筛预处理 $f$ ,然后对 $D$ 整除分块. 时间复杂度优化到 $O(T\cdot \sqrt n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1&lt;&lt;30;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;const int MAXN=4e6+10;int prime[MAXN],cnt=0,ism[MAXN],mu[MAXN];int f[MAXN],sumfx[MAXN];void init(int N)&#123; ism[1]=1,mu[1]=1; sumfx[1]=1; f[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; mu[i]=-1; f[i]=-i+1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=N;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]) &#123; mu[i*prime[j]]=-mu[i]; f[i*prime[j]]=mul(f[i],f[prime[j]]); &#125; else &#123; mu[i*prime[j]]=0; if((1LL*i)%(1LL*prime[j]*prime[j])==0) f[i*prime[j]]=0; else f[i*prime[j]]=mul(f[i/prime[j]],-prime[j]); break; &#125; &#125; sumfx[i]=add(sumfx[i-1],mul(i,f[i])); &#125;&#125;int sum(int x)&#123; return (1LL*x*(x+1)/2)%P;&#125;int main()&#123; init(4000000); int T=read(); while(T--) &#123; int ans=0; int A=read(),B=read(); int m=min(A,B); for(int LD=1,RD;LD&lt;=m;LD=RD+1) &#123; RD=min(A/(A/LD),B/(B/LD)); ans=add(ans,mul(sumfx[RD]-sumfx[LD-1],mul(sum(A/LD),sum(B/LD)))); &#125; printf("%d\n",add(ans,P)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4657 tower]]></title>
    <url>%2F2019%2F05%2F28%2Fbzoj-4657-tower%2F</url>
    <content type="text"><![CDATA[最小割. 想到网络流应该不难,但关键是怎样建模. 因为只有横向炮塔与竖向炮塔可能发生冲突,所以可以先套路地把一个点拆成一个横点和一个竖点,横点向对应竖点之间连一条边权为 $inf$ 的边.然后从源点 $S$ 向每个竖向攻击的炮塔的竖点连边权为 $inf$ 的边,从每个横向攻击的炮塔的横点向汇点 $T$ 连一条边权为 $inf$ 的边. 考虑每个炮塔,选择一个点进行攻击,这个点显然是从炮塔出发到最大贡献所在点这条路径 $p$ 上的某个点. 那么对于一个竖向攻击的炮塔,沿着路径 $p$ ,从炮塔到最大贡献点,相邻两点的竖点连上边. 对于一个横向攻击的炮塔,沿着路径 $p$ ,从最大贡献点到炮塔,相邻两点的横点连上边. 开始时钦定每个炮塔都打各自最大贡献点,收益为 $\sum max_i$ ,但这样会有路径相交,在图中表现为 $S$ 与 $T$ 连通.若一个炮塔改为打点 $u$ ,就把对应的路径 $p$ 上以 $u$ 为一端,另一端远离炮塔的点的边割掉就行了.减少的收益是 $max_i-val_u$ .可以发现,最后 $S$ 与 $T$ 不连通就与炮弹路径不相交是等价的. 于是在路径 $p$ 上连边时,将边权设置为 $max_i-val_u$ ,用 $\sum max_i$ 减去最小割即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=2e5+10;int ecnt=-1,head[MAXN],cur[MAXN],tot=0;struct edge&#123; int nx,to,flow;&#125;E[MAXN];void addedge(int u,int v,int w)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=w; head[u]=ecnt;&#125;void ins(int u,int v,int w)&#123; addedge(u,v,w); addedge(v,u,0);&#125;int dep[MAXN];bool bfs(int S,int T)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); for(int i=1;i&lt;=tot;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; limit-=f; flow+=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return flow;&#125;int Dinic(int S,int T)&#123; int maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return maxflow;&#125;int n,m;int node_id[51][51][2];//0:up/down 1:left/rightint org_graph[51][51];int S,T,ans=0;void build_graph(int x,int y,int tp)&#123; org_graph[x][y]=0; if(tp==1 || tp==2) &#123; ins(S,node_id[x][y][0],inf); int mx=0,maxpos=-1; if(tp==1) &#123; for(int i=x-1;i&gt;=1;--i) if(org_graph[i][y]&gt;mx) mx=org_graph[i][y],maxpos=i; if(maxpos==-1) return; for(int i=x-1;i&gt;=maxpos;--i) ins(node_id[i+1][y][0],node_id[i][y][0],mx-org_graph[i+1][y]); &#125; else &#123; for(int i=x+1;i&lt;=n;++i) if(org_graph[i][y]&gt;mx) mx=org_graph[i][y],maxpos=i; if(maxpos==-1) return; for(int i=x+1;i&lt;=maxpos;++i) ins(node_id[i-1][y][0],node_id[i][y][0],mx-org_graph[i-1][y]); &#125; ans+=mx; &#125; else &#123; ins(node_id[x][y][1],T,inf); int mx=0,maxpos=-1; if(tp==3) &#123; for(int j=y-1;j&gt;=1;--j) if(org_graph[x][j]&gt;mx) mx=org_graph[x][j],maxpos=j; if(maxpos==-1) return; for(int j=y-1;j&gt;=maxpos;--j) ins(node_id[x][j][1],node_id[x][j+1][1],mx-org_graph[x][j+1]); &#125; else &#123; for(int j=y+1;j&lt;=m;++j) if(org_graph[x][j]&gt;mx) mx=org_graph[x][j],maxpos=j; if(maxpos==-1) return; for(int j=y+1;j&lt;=maxpos;++j) ins(node_id[x][j][1],node_id[x][j-1][1],mx-org_graph[x][j-1]); &#125; ans+=mx; &#125;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; org_graph[i][j]=read(); node_id[i][j][0]=++tot; node_id[i][j][1]=++tot; ins(tot-1,tot,inf); &#125; S=++tot,T=++tot; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(org_graph[i][j]&lt;0) build_graph(i,j,-org_graph[i][j]); ans-=Dinic(S,T); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6053 简单的函数]]></title>
    <url>%2F2019%2F05%2F28%2FLoj-6053-%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[min_25 筛 . 除了 $2$ 之外的质数 $p$ 都是奇数, $f(p)=p-1$ ,而 $f(2)=3$ . 把 $f(p)$ 都当成 $f(p)=p-1$ ,用 min_25 筛法来做.有 $2$ 就特判一下, $+2$ 就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int P=1e9+7;const int inv2=(P+1)&gt;&gt;1;inline int add(ll a,ll b)&#123; a%=P; b%=P; return (a + b) % P;&#125;inline int mul(ll a,ll b)&#123; a%=P; b%=P; return 1LL * a * b % P;&#125;ll n,sqr,w[MAXN];int cnt=0,ism[MAXN],sump[MAXN],m;ll prime[MAXN];ll id1[MAXN],id2[MAXN];void init(int N)&#123; ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; sump[cnt]=add(sump[cnt-1],i); &#125; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=N;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int h[MAXN],g[MAXN],ans;int S(ll x,int y)&#123; if(x&lt;=1 || prime[y]&gt;x) return 0; int k=(x&lt;=sqr)?id1[x]:id2[n/x]; int res=add(g[k]-sump[y-1],y-h[k]-1); if(y==1) res+=2; for(int i=y;i&lt;=cnt &amp;&amp; 1LL*prime[i]*prime[i]&lt;=x;++i) &#123; ll pow1=prime[i],pow2=1LL*prime[i]*prime[i]; for(int e=1;pow2&lt;=x;++e,pow1=pow2,pow2*=prime[i]) &#123; int tmp=mul(S(x/pow1,i+1),prime[i]^e); tmp=add(tmp,prime[i]^(e+1)); res=add(res,tmp); &#125; &#125; return res;&#125;int main()&#123; n=read(); sqr=sqrt(n); init(sqr); for(ll l=1,r;l&lt;=n;l=r+1) &#123; ll &amp;i=l,&amp;j=r; r=n/(n/l); w[++m]=n/l; h[m]=add(w[m]%P,-1); g[m]=mul(w[m],w[m]+1); g[m]=mul(g[m],inv2); g[m]=add(g[m],-1); if(w[m]&lt;=sqr) id1[n/l]=m; else id2[r]=m; &#125; for(int j=1;j&lt;=cnt;++j) for(int i=1;i&lt;=m &amp;&amp; prime[j]*prime[j]&lt;=w[i];++i) &#123; int k=(w[i]/prime[j]&lt;=sqr)?id1[w[i]/prime[j]]:id2[n/(w[i]/prime[j])]; g[i]=add(g[i],-mul(prime[j],add(g[k],-sump[j-1]))); h[i]=add(h[i],j-h[k]-1); &#125; ans=add(S(n,1),1); cout&lt;&lt;(ans+P)%P&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4665 小w的喜糖]]></title>
    <url>%2F2019%2F05%2F27%2Fbzoj-4665-%E5%B0%8Fw%E7%9A%84%E5%96%9C%E7%B3%96%2F</url>
    <content type="text"><![CDATA[容斥 + $dp$ . 要求有重复元素的错排方案数. 设 $f(i,j)$ 表示考虑前 $i$ 种糖,钦定 $j$ 个人拿到原来的糖,其他 $(n-j)$ 个人乱拿的方案数. $cnt_x$ 表示第 $x$ 种糖的数目. 枚举第 $i$ 种糖被 $k$ 个原来的人拿到,有 $f(i,j)=\sum_{k\leq j,k\leq cnt_i} f(i-1,j-k)\times {cnt_i \choose k}\times [(cnt_i-k)!]^{-1}$ . 最终答案为 $ans=\sum_{i=0}^n (-1)^i \times f(n,i) \times (n-i)!$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a + b) % P; &#125; inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=2019;int n,cnt[MAXN],fac[MAXN],invfac[MAXN];int ans=0,f[MAXN][MAXN];void init()&#123; fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=inv(fac[n]); for(int i=n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)// M \choose N&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[M-N],invfac[N]));&#125;int main()&#123; n=read(); init(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); ++cnt[x]; &#125; f[0][0]=1; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum+=cnt[i]; for(int j=0;j&lt;=sum;++j) for(int k=0;k&lt;=cnt[i] &amp;&amp; k&lt;=j;++k) &#123; int tmp=mul(f[i-1][j-k],C(cnt[i],k)); tmp=mul(tmp,invfac[cnt[i]-k]); f[i][j]=add(f[i][j],tmp); &#125; &#125; for(int i=0;i&lt;=n;++i) &#123; int tmp=(i&amp;1)?(-1):(1); tmp=mul(tmp,f[n][i]); tmp=mul(tmp,fac[n-i]); ans=add(ans,tmp); &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190526]]></title>
    <url>%2F2019%2F05%2F26%2Ftest20190526%2F</url>
    <content type="text"><![CDATA[感觉 $T3$ 很假. $tweak$ 题面有误.题意是每次可以选一条边,权值修改为任意非负整数,问至少改多少条可以使 $1\to n$ 的最短路 $\leq c$ . 显然可以贪心,每次修改时都改成 $0$ .设 $f(i,j)$ 表示 $1\to i$ ,改了 $j$ 条边时的最短路.用 $spfa$ 转移即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int MAXN=1e3+10;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],val[MAXN];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int n,m,c;int f[MAXN][MAXN],tot=0;int vis[MAXN];queue&lt;int&gt; q;void spfa()&#123; memset(f,63,sizeof f); int inf=f[0][0]; f[1][0]=0; vis[1]=1; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; bool flag=false; for(int j=0;j&lt;=m;++j) &#123; if(f[u][j]&gt;=inf) break; if(f[u][j]&lt;=f[v][j+1]) &#123; f[v][j+1]=f[u][j]; &#125; if(f[u][j]+val[i]&lt;=f[v][j]) &#123; f[v][j]=f[u][j]+val[i]; if(!j) flag=true; &#125; &#125; if(flag &amp;&amp; !vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125;&#125;int main()&#123; freopen("tweak.in","r",stdin); freopen("tweak.out","w",stdout); n=read(),m=read(),c=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); &#125; spfa(); for(int i=0;i&lt;=m;++i) if(f[n][i]&lt;=c) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; return 0;&#125; $coins$ 把每个硬币看做多项式 $(x^{a_i}+1)$ ,如果每个硬币都可以用,方案数就是 $\prod (x^{a_i}+1)$ 这个多项式中系数非零的 $x^k(k&gt;0)$ 的个数. 限定某个硬币 $i$ 不能用,只需要在多项式 $\prod (x^{a_i}+1)$ 中把 $(x^{a_i}+1)$ 除去,然后统计答案. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;int n,a[101];const int MAXN=3e5+10;ll poly[MAXN],tmp[MAXN];ll stk[MAXN],sk[MAXN];int deg=0,tp=0;int query(int p)&#123; tp=0; int Deg=deg,res=0; while(Deg) &#123; ll s=poly[Deg]; if(!s) &#123; --Deg; continue; &#125; if(!tmp[Deg-p] &amp;&amp; Deg-p) ++res; tmp[Deg-p]+=s; stk[++tp]=Deg-p; poly[Deg-p]-=s; sk[tp]=s; --Deg; &#125; for(int i=1;i&lt;=tp;++i) &#123; tmp[stk[i]]=0; poly[stk[i]]+=sk[i]; &#125; return res;&#125;int main()&#123; freopen("coin.in","r",stdin); freopen("coin.out","w",stdout); n=read(); poly[0]=1; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); for(int j=deg;j&gt;=0;--j) poly[a[i]+j]+=poly[j]; deg+=a[i]; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",query(a[i])); return 0;&#125; $cakes$ $std:$ 维护一个堆,存储每种大小的元素数目.每次取出顶部三个,做最多的三元组,把剩余的放回去. 并不知道我的贪心哪里出了问题.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>STL</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4653 区间]]></title>
    <url>%2F2019%2F05%2F26%2Fbzoj-4653-%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[线段树. 可以先将区间按照大小从小到大排序,并将端点离散化. 枚举以第 $i$ 个区间为最短区间时的答案,从 $i$ 开始往后面添加区间,直到有个点被覆盖 $m$ 次. 更新答案后,下次枚举不需要重新加入,只需要把第 $i$ 个区间删除即可. 用线段树支持区间覆盖与撤销,并维护被覆盖次数的最大值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10,inf=2e9;int n,m,ans=inf;int A[MAXN&lt;&lt;1],cnt=0;struct interval&#123; int l,r,len; bool operator &lt; (const interval &amp;rhs) const &#123; return len &lt; rhs.len; &#125;&#125;I[MAXN];int rk(int x)&#123; return lower_bound(A+1,A+1+cnt,x)-A;&#125;struct Segtree&#123; struct node &#123; int tag,mx; node()&#123;tag=mx=0;&#125; &#125;Tree[MAXN&lt;&lt;3];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] int query() &#123; return Tree[1].mx; &#125; void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.mx+=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125;&#125;T;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; A[++cnt]=I[i].l=read(); A[++cnt]=I[i].r=read(); I[i].len=I[i].r-I[i].l; &#125; sort(I+1,I+1+n); sort(A+1,A+1+cnt); cnt=unique(A+1,A+1+cnt)-(A+1); for(int i=1;i&lt;=n;++i) &#123; I[i].l=rk(I[i].l); I[i].r=rk(I[i].r); &#125; int head=1,tail=0; while(head&lt;=n) &#123; while(T.query()&lt;m &amp;&amp; tail&lt;n) &#123; ++tail; T.upd(1,1,cnt,I[tail].l,I[tail].r,1); &#125; if(T.query()==m) ans=min(ans,I[tail].len-I[head].len); T.upd(1,1,cnt,I[head].l,I[head].r,-1); ++head; &#125; cout&lt;&lt;(ans==inf?-1:ans)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4767 两双手]]></title>
    <url>%2F2019%2F05%2F26%2Fbzoj-4767-%E4%B8%A4%E5%8F%8C%E6%89%8B%2F</url>
    <content type="text"><![CDATA[容斥 +$dp$ . 把两种移动方式看做两个向量 $\vec a,\vec b$ .因为题目保证它们不共线,所以每个点都可以被写成 $x\cdot \vec a+y\cdot \vec b$ . 那么以解出来的 $(x,y)$ 代替原来的坐标,问题就变成了每次可以向右或向上走一步,求方案数. 如果没有障碍,答案显然是 $C_{x+y}^x$ .但现在有障碍.直接递推显然不行,因为新坐标可以达到 $2\times 500^2$ . 考虑容斥.将障碍点,目标点视为关键点,做坐标转换(如果不是整数就直接舍去),然后排序.原点为第 $0$ 个关键点. 设 $f(i)$ 表示从原点到达第 $i$ 个关键点而不经过其他关键点的方案数. $g(i,j)$ 表示从第 $i$ 个关键点到第 $j$ 个关键点的所有方案数.转移有 $f(i)=g(0,i)-\sum_{j=1}^{i-1} g(j,i)\cdot f(j)$ .而 $g$ 不需要考虑障碍,显然就是组合数. 时间复杂度 $O(n^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;const int P=1e9+7;const int inf=1e9;inline int add(int a,int b)&#123; return (a + b &gt;= P) ? (a + b - P) : (a + b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;typedef pair&lt;int,int&gt; pii;const pii badp=make_pair(inf,inf);int n,k=0,ax,ay,bx,by;int ex=inf,ey=inf;pii p[MAXN];pii trans(int M,int N)&#123; int x,y; int up=ay*M-ax*N,down=bx*ay-by*ax; if(up%down || up/down&lt;0) return badp; y=up/down; up=M*by-N*bx,down=ax*by-ay*bx; if(up%down || up/down&lt;0) return badp; x=up/down; if(x&gt;ex || y&gt;ey) return badp; return make_pair(x,y);&#125;int fac[MAXN],invfac[MAXN];void init()&#123; int N=MAXN-10; fac[0]=1; for(int i=1;i&lt;=N;++i) fac[i]=mul(fac[i-1],i); invfac[N]=fpow(fac[N],P-2); for(int i=N-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int N,int M)&#123; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int g(int i,int j)&#123; int x=p[j].first-p[i].first,y=p[j].second-p[i].second; if(x&lt;0 || y&lt;0) return 0; return C(x,x+y);&#125;int f[MAXN];int main()&#123; init(); int Ex=read(),Ey=read(); n=read(),ax=read(),ay=read(),bx=read(),by=read(); p[++k]=trans(Ex,Ey); if(p[k]==badp) &#123; puts("0"); return 0; &#125; ex=p[k].first,ey=p[k].second; for(int i=1;i&lt;=n;++i) &#123; int x=read(),y=read(); pii tmp=trans(x,y); x=tmp.first,y=tmp.second; if(ex&lt;x || ey&lt;y) continue; assert(tmp!=badp); p[++k]=tmp; &#125; p[0]=make_pair(0,0); ++k; sort(p,p+k); f[0]=1; for(int i=1;i&lt;k;++i) &#123; f[i]=g(0,i); for(int j=1;j&lt;i;++j) f[i]=add(f[i],P-mul(g(j,i),f[j])); &#125; cout&lt;&lt;f[k-1]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 127]]></title>
    <url>%2F2019%2F05%2F25%2FAtcoder-Beginner-Contest-127%2F</url>
    <content type="text"><![CDATA[被 $E$ 给卡住了.数据范围读错还行. 前 $3$ 道题目主要考察读入和输出. D Integer Cards 贪心 + 二分. 显然可以随意安排操作的顺序.于是可以给操作按照 $c$ 从大到小排序,那么前面的操作就不会影响后面的操作. 于是每次操作的时候贪心选小的替换,替换后直接将那部分删去就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,a[MAXN];ll t[MAXN],sum[MAXN];struct opt&#123; int b,c; bool operator &lt; (const opt &amp;rhs) const &#123; return c&gt;rhs.c; &#125;&#125;q[MAXN];ll ans=0;int head,tail;int bs(int x)&#123; int L=head,R=tail,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(a[mid]&lt;x) L=mid+1,res=mid; else R=mid-1; &#125; return res;&#125;int main()&#123; n=read(); m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=m;++i) &#123; q[i].b=read(); q[i].c=read(); &#125; sort(q+1,q+1+m); head=1,tail=n; for(int i=1;i&lt;=m;++i) &#123; int pos=bs(q[i].c); if(pos==-1) continue; int tmp=min(q[i].b,pos-head+1); ans+=1LL*tmp*q[i].c; head=head+tmp; &#125; while(head&lt;=tail) &#123; ans+=a[head]; ++head; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Cell Distance $N\times M\leq 2\times 10^5$ ,我看成 $N,M\leq 2\times 10^5$ 了… 考虑一对点 $p,q$ ,它们显然会在 $C^{K-2}_{NM}$ 个方案中被计入贡献. 于是只需要枚举每个点,计算它到其他点的距离和,再乘上 $C_{NM}^{K-2}$ ,最后还要除以 $2$ . F Absolute Minima 平衡树 + 线段树. 那个 $b$ 显然没什么用,可以单独算. 问题就变成可以在数轴上插入点,每次询问到这些点距离和最小的位置与这个距离和. 若现在有 $k$ 个点,第一问,显然应该取中位数.这个可以用一颗平衡树维护答案. 第二问,把绝对值拆开,只需要询问当前比 $x$ 小的数总和,当前比 $x$ 大的数总和.用了离散化 + 权值线段树.感觉应该有更简单的方法? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct FhqTreap&#123;#define rt treap[o]#define ls treap[treap[o].lson]#define rs treap[treap[o].rson] int x,y,z,ans; int idx; FhqTreap() &#123; x=y=z=0; idx=0; &#125; struct node &#123; int lson,rson,key,weight,size; &#125; treap[MAXN]; inline int newnode(int key) &#123; ++idx; treap[idx].size=1; treap[idx].weight=rand(); treap[idx].key=key; return idx; &#125; inline void pushup(int o) &#123; rt.size=ls.size+rs.size+1; &#125; void split(int&amp; x,int&amp; y,int key,int o)//小于等于key的分在x中 &#123; if(!o) x=y=0; else &#123; if(rt.key&lt;=key) &#123; x=o; split(rt.rson,y,key,rt.rson); &#125; else &#123; y=o; split(x,rt.lson,key,rt.lson); &#125; pushup(o); &#125; &#125; int merge(int x,int y)//合并,保证x的权值小于y的权值. key_x&lt;key_y &#123; if(x==0||y==0) return x+y; if(treap[x].weight&lt;treap[y].weight) &#123; treap[x].rson=merge(treap[x].rson,y); pushup(x); return x; &#125; else &#123; treap[y].lson=merge(x,treap[y].lson); pushup(y); return y; &#125; &#125; inline int Rank(int&amp;root,int key)//get the node (which key equals to the key)'s rank. &#123; split(x,y,key-1,root); ans=treap[x].size+1; root=merge(x,y); return ans; &#125; inline int kth(int o,int rank)// find the id of the node which rank is the rank in the tree which root is o. &#123; while(1) &#123; if(ls.size&gt;=rank) o=rt.lson;//the answer must be in o's lson,search in it. else if(ls.size+1==rank) return treap[o].key;//o is the rank'th. else &#123; rank-=ls.size+1; o=rt.rson;//cannot find in o and o's lson,search in o's rson. &#125; &#125; &#125; inline void Insert(int&amp;root,int key)// insert a node which key is the key in whole the tree. &#123; split(x,y,key,root); root=merge(merge(x,newnode(key)),y); &#125;&#125; T;ll bsum=0;int Q,k=0,Rt=0;struct query&#123; int op,a,b;&#125;q[MAXN];int A[MAXN],cnt=0;struct Segtree&#123; struct node &#123; ll sum,tot; int l,r; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void BuildTree(int o,int l,int r) &#123; root.l=l,root.r=r; root.sum=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void upd(int o,int pos,int c) &#123; int l=root.l,r=root.r; if(l==r) &#123; root.sum+=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,pos,c); else upd(o&lt;&lt;1|1,pos,c); pushup(o); &#125; ll query(int o,int L,int R) &#123; if(L&gt;R) return 0; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(o&lt;&lt;1,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,L,R); return res; &#125;&#125;Seg;int rnk(int x)&#123; return lower_bound(A+1,A+1+cnt,x)-A;&#125;int main()&#123; Q=read(); for(int i=1;i&lt;=Q;++i) &#123; q[i].op=read(); if(q[i].op==1) &#123; A[++cnt]=q[i].a=read(); q[i].b=read(); &#125; &#125; sort(A+1,A+1+cnt); cnt=unique(A+1,A+1+cnt)-(A+1); Seg.BuildTree(1,1,cnt); for(int i=1;i&lt;=Q;++i) &#123; if(q[i].op==1) &#123; int a=q[i].a,b=q[i].b; ++k; bsum+=b; Seg.upd(1,rnk(a),a); T.Insert(Rt,a); &#125; else &#123; int rk=(k+1)&gt;&gt;1; int x=T.kth(Rt,rk); rk=T.Rank(Rt,x); int pos=rnk(x); ll res=1LL*(rk-1)*x-Seg.query(1,1,pos-1)-1LL*(k-rk+1)*x+Seg.query(1,pos,cnt); printf("%d %lld\n",x,res+bsum); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>平衡树</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4670 佛罗里达]]></title>
    <url>%2F2019%2F05%2F24%2Fbzoj-4670-%E4%BD%9B%E7%BD%97%E9%87%8C%E8%BE%BE%2F</url>
    <content type="text"><![CDATA[随机乱搞. 随机做很多次,每次 $random\ shuffle$ 出一个加点的序列,然后按照这个序列加点. 每次贪心判,加在哪个集合里面能使答案增加的量更小,就加在哪个里面. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int T=800;const int inf=0x7fffffff;const int MAXN=256;int n,val[MAXN][MAXN],p[MAXN];int A[MAXN],sizA,B[MAXN],sizB,mxA,mxB;ll ans;int main()&#123; srand(time(NULL)); while(~scanf("%d",&amp;n)) &#123; ans=inf; memset(val,0,sizeof val); for(int i=1;i&lt;n;++i) for(int j=i+1;j&lt;=n;++j) val[i][j]=val[j][i]=read(); for(int i=1;i&lt;=n;++i) p[i]=i; for(int t=1;t&lt;=T;++t) &#123; ll res=0; random_shuffle(p+1,p+1+n); sizA=sizB=0; mxA=mxB=0; for(int i=1;i&lt;=n;++i) &#123; int valA=0,valB=0; for(int j=1;j&lt;=sizA;++j) valA=max(valA,val[p[i]][A[j]]); for(int j=1;j&lt;=sizB;++j) valB=max(valB,val[p[i]][B[j]]); if(valA&lt;=mxA &amp;&amp; valB&lt;=mxB) &#123; int k=rand()&amp;1; if(k) A[++sizA]=p[i]; else B[++sizB]=p[i]; continue; &#125; if(valA-mxA&lt;=valB-mxB) &#123; if(valA-mxA&gt;0) &#123; res+=valA-mxA; mxA=valA; &#125; A[++sizA]=p[i]; &#125; else &#123; if(valB-mxB&gt;0) &#123; res+=valB-mxB; mxB=valB; &#125; B[++sizB]=p[i]; &#125; if(res&gt;=ans) break; &#125; ans=min(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>近似算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4675 点对游戏]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-4675-%E7%82%B9%E5%AF%B9%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[点分治. 表面上看是个期望的题,然而跟期望没多大关系. 每个人的答案显然是 能选的点对数目/总点对数目*幸运点对的总数目 . 只需要求幸运点对的总数目.由于 $m$ 很小,所以直接点分治就可以了.时间复杂度 $O(nmlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=5e4+10;int n,m,luckynum[11];ll sum=0;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int totsiz,siz[MAXN],mi,rt,vis[MAXN];void getroot(int u,int fa)&#123; siz[u]=1; int sonsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; getroot(v,u); siz[u]+=siz[v]; sonsiz=max(sonsiz,siz[v]); &#125; sonsiz=max(sonsiz,totsiz-siz[u]); if(sonsiz&lt;mi) mi=sonsiz,rt=u;&#125;int dis[MAXN],bucket[MAXN],stk1[MAXN],tp1=0,stk2[MAXN],tp2=0;void getdis(int u,int fa)&#123; stk2[++tp2]=u; dis[u]=dis[fa]+1; for(int i=1;i&lt;=m;++i) if(luckynum[i]&gt;=dis[u]) sum+=bucket[luckynum[i]-dis[u]]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; getdis(v,u); &#125;&#125;void solve(int u)&#123; while(tp1) bucket[dis[stk1[tp1--]]]=0; dis[u]=0;//先清空,再设dis[u]=0,否则可能清空错误 bucket[0]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; tp2=0; getdis(v,u); while(tp2) &#123; stk1[++tp1]=stk2[tp2]; ++bucket[dis[stk2[tp2]]]; --tp2; &#125; &#125;&#125;void divide(int u)&#123; solve(u); vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf,totsiz=siz[v]; getroot(v,0); divide(rt); &#125;&#125;void getsum()&#123; mi=inf,totsiz=n; getroot(1,0); divide(rt);&#125;double calc(ll pairs)&#123; return (double(pairs)) * (double(sum)) / (double(1LL * n * (n-1) )) ;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) luckynum[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; getsum(); int p=(n+2)/3; printf("%.2f\n",calc(1LL*p*(p-1))); p=(n+1)/3; printf("%.2f\n",calc(1LL*p*(p-1))); p=n/3; printf("%.2f\n",calc(1LL*p*(p-1))); return 0;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4698 Sandy的卡片]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-4698-Sandy%E7%9A%84%E5%8D%A1%E7%89%87%2F</url>
    <content type="text"><![CDATA[$SAM$ . 相同的定义比较奇怪,其实只需要差分一下就可以了,问题就是求这些串的最长公共子串.用 $SAM$ 解决. 答案就是求出的公共子串 $+1$ ?但有可能没有位置补,比如 $s_1=”23”,s_2=”23”$ ,答案应该是 $2$ 而不是 $3$ . 解决办法也很简单,在每个串后面加一个独特的且不在字符集中的标识符就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=1500,MAXN=2e3+10;int buf[MAXN];int L,n,T=0;struct SuffixAutoMation&#123; int idx,lst; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN],siz[MAXN]; int A[MAXN],t[MAXN]; int mxl[MAXN],res[MAXN]; SuffixAutoMation() &#123; idx=lst=1; &#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; res[np]=len[np]=len[p]+1; siz[np]=1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; res[nq]=len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1; i&lt;=idx; ++i) ++t[len[i]]; for(int i=1; i&lt;=idx; ++i) t[i]+=t[i-1]; for(int i=1; i&lt;=idx; ++i) A[t[len[i]]--]=i; &#125; void solve() &#123; L=read(); for(int i=1; i&lt;=L; ++i) buf[i]=read()-2; buf[L+1]=T+200,buf[L+2]=0; ++L; for(int i=1; i&lt;=L; ++i) buf[i]=buf[i+1]-buf[i]+1200; memset(mxl,0,sizeof mxl); int p=1,tmp=0; for(int i=1; i&lt;=L; ++i) &#123; int c=buf[i]; while(p &amp;&amp; ch[p][c]==0) p=fa[p]; if(p==0) p=1,tmp=0; else &#123; tmp=min(tmp,len[p])+1; p=ch[p][c]; &#125; mxl[p]=max(mxl[p],tmp); &#125; for(int i=idx; i&gt;=1; --i) &#123; int u=A[i]; mxl[fa[u]]=max(mxl[fa[u]],mxl[u]); &#125; for(int i=1; i&lt;=idx; ++i) res[i]=min(res[i],mxl[i]); &#125; void pr() &#123; int ans=0; for(int i=1; i&lt;=idx; ++i) ans=max(ans,res[i]); cout&lt;&lt;ans+1&lt;&lt;endl; &#125;&#125; SAM;int main()&#123; n=read(); L=read(); for(int i=1; i&lt;=L; ++i) buf[i]=read()-2; ++T; buf[L+1]=T+200,buf[L+2]=0; ++L; for(int i=1; i&lt;=L; ++i) &#123; buf[i]=buf[i+1]-buf[i]+1200; SAM.Extend(buf[i]); &#125; SAM.topsort(); for(int i=1; i&lt;n; ++i) &#123; ++T; SAM.solve(); &#125; SAM.pr(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4668 冷战]]></title>
    <url>%2F2019%2F05%2F22%2Fbzoj-4668-%E5%86%B7%E6%88%98%2F</url>
    <content type="text"><![CDATA[并查集按秩合并. 除了维护连通性,还需要维护每个点与它父亲的边被连上的时间. 用路径压缩会破坏树内部的结构,使用按秩合并就可以了.这样合并,树高不超过 $logn$ ,询问时,直接暴力跳到 $LCA$ ,路径上边被连上的最晚时间即为答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m,lastans=0;int fa[MAXN],siz[MAXN],t[MAXN],dep[MAXN],tid=0;int Find(int x)&#123; if(x==fa[x]) return x; int fx=Find(fa[x]); dep[x]=dep[fa[x]]+1; return fx;&#125;void merge(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(siz[x]&lt;siz[y]) swap(x,y); siz[x]+=siz[y]; fa[y]=x; t[y]=tid;&#125;int query(int x,int y)&#123; int fx=Find(x),fy=Find(y); if(fx!=fy) return 0; int res=0; while(x!=y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); res=max(res,t[x]); x=fa[x]; &#125; return res;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) siz[i]=1,fa[i]=i; for(int i=1;i&lt;=m;++i) &#123; int tp=read(); if(!tp) &#123; int u=read()^lastans,v=read()^lastans; ++tid; merge(u,v); &#125; else &#123; int u=read()^lastans,v=read()^lastans; lastans=query(u,v); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4700 适者]]></title>
    <url>%2F2019%2F05%2F22%2Fbzoj-4700-%E9%80%82%E8%80%85%2F</url>
    <content type="text"><![CDATA[李超线段树. 如果没有秒杀,就是个简单的贪心.算出第 $i$ 个敌人需要攻击的次数 $T_i$ ,考虑在攻击顺序中,交换两个相邻敌人带来的影响. 容易发现按照 $\frac {T_i} {A_i}$ 从小到大排序就可以了. 现在可以秒杀两个敌人,先按照 $\frac {T_i} {A_i}$ 从小到大排个序.但肯定不能贪心秒杀前两个.因为原来是考虑了击杀时间,而秒杀没有击杀时间.可以随意举出反例. 考虑秒杀 $i,j(i&lt;j)$ 时,答案会减少的值.记 $preT,sufA$ 分别表示 $T$ 的前缀和, $A$ 的后缀和.贡献就有 $i,j,[i+1,j-1],[j+1,n]$ 这四段. 发现如果固定 $i$ ,那么就是要求 $-A_j\cdot T_i+b_j$ 的最大值,其中 $b_j$ 是可以预处理的,是仅和 $j$ 有关的一个量. 那么就是求 $x=T_i$ 这条直线与 $j&gt;i$ 的这些直线 $(-A_j,b_j)$ 交点纵坐标最大值.枚举 $i$ 时从大到小,就只需要维护加入直线和询问这两个操作.用李超线段树维护一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,ATK;ll k[MAXN],b[MAXN],ans=0,delta=0;ll calc(int seg,int pos)&#123; return 1LL * k[seg] * pos + b[seg];&#125;bool is_cover(int a,int b,int pos)&#123; return calc(a,pos)&gt;=calc(b,pos);&#125;struct Segtree&#123; int v[MAXN&lt;&lt;2]; void ins(int o,int l,int r,int c) &#123; if(l==r) &#123; if(is_cover(c,v[o],l)) v[o]=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(k[c]&gt;k[v[o]]) &#123; if(is_cover(c,v[o],mid)) ins(o&lt;&lt;1,l,mid,c),v[o]=c; else ins(o&lt;&lt;1|1,mid+1,r,c); &#125; else &#123; if(is_cover(c,v[o],mid)) ins(o&lt;&lt;1|1,mid+1,r,c),v[o]=c; else ins(o&lt;&lt;1,l,mid,c); &#125; &#125; ll query(int o,int l,int r,int pos) &#123; ll res=calc(v[o],pos); if(l==r) return res; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,pos)); else res=max(res,query(o&lt;&lt;1|1,mid+1,r,pos)); return res; &#125;&#125;T;struct enemy&#123; int a,t; bool operator &lt; (const enemy &amp;rhs) const &#123; return a*rhs.t&gt;rhs.a*t; &#125;&#125;p[MAXN];ll preT[MAXN],sufA[MAXN];int main()&#123; n=read(),ATK=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].a=read(); int D=read(); p[i].t=(D+ATK-1)/ATK; &#125; sort(p+1,p+1+n); for(int i=1;i&lt;=n;++i) preT[i]=preT[i-1]+p[i].t; for(int i=n;i&gt;=1;--i) sufA[i]=sufA[i+1]+p[i].a; for(int i=1;i&lt;=n;++i) &#123; k[i]=-p[i].a; b[i]=sufA[i]*p[i].t+preT[i-1]*p[i].a-p[i].a; ans+=p[i].t*sufA[i]-p[i].a; &#125; T.ins(1,1,n,n); for(int i=n-1;i&gt;=1;--i) &#123; delta=max(delta,T.query(1,1,n,p[i].t)+b[i]); T.ins(1,1,n,i); &#125; ans-=delta; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3073 Journeys]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-3073-Journeys%2F</url>
    <content type="text"><![CDATA[线段树优化连边. 边是双向的.开两颗线段树, $A$ 里面节点表示一条有向边的起点,儿子向父亲连边, $B$ 里面节点表示一条有向边的终点,父亲向儿子连边, $B$ 向 $A$ 中对应的节点连边. 区间连边时,新建一个节点,将区间在线段树上拆成 $log$ 个区间进行连边就好了. 最后跑一次 $Dijkstra$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10,MAXM=2220000;int n,m,S;int ecnt=0,head[MAXM],to[MAXM],nx[MAXM],val[MAXM];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;struct node&#123; int ls,rs;&#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]int pos[MAXN],tot=0;void bd1(int &amp;o,int l,int r)&#123; o=++tot; if(l==r) &#123; pos[l]=o; return; &#125; int mid=(l+r)&gt;&gt;1; bd1(root.ls,l,mid); bd1(root.rs,mid+1,r); addedge(root.ls,o,0); addedge(root.rs,o,0);&#125;void bd2(int &amp;o,int l,int r)&#123; o=++tot; if(l==r) &#123; addedge(o,pos[l],0); return; &#125; int mid=(l+r)&gt;&gt;1; bd2(root.ls,l,mid); bd2(root.rs,mid+1,r); addedge(o,root.ls,0); addedge(o,root.rs,0);&#125;void upd1(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; addedge(o,tot,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd1(root.ls,l,mid,L,R); if(R&gt;mid) upd1(root.rs,mid+1,r,L,R);&#125;void upd2(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; addedge(tot,o,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd2(root.ls,l,mid,L,R); if(R&gt;mid) upd2(root.rs,mid+1,r,L,R);&#125;int rt1=0,rt2=0;int vis[MAXM],dis[MAXM];typedef pair&lt;int,int&gt; pii;#define mp make_pairpriority_queue&lt;pii&gt; q;void Dijkstra()&#123; memset(dis,0x7f,sizeof dis); dis[pos[S]]=0; q.push(mp(0,pos[S])); while(!q.empty()) &#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),S=read(); bd1(rt1,1,n); bd2(rt2,1,n); while(m--) &#123; int x1=read(),y1=read(),x2=read(),y2=read(); ++tot;upd1(rt1,1,n,x1,y1);upd2(rt2,1,n,x2,y2); ++tot;upd1(rt1,1,n,x2,y2);upd2(rt2,1,n,x1,y1); &#125; Dijkstra(); for(int i=1;i&lt;=n;++i) printf("%d\n",dis[pos[i]]&gt;&gt;1); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>线段树连边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4762 最小集合]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-4762-%E6%9C%80%E5%B0%8F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 如果把所有元素 $xor\ 1023$ ,那么就等价于集合内元素 $or$ 和为 $1023$ ,去掉任意一个后 $or$ 和不为 $1023$ . 设 $f(i,j,k)$ 表示考虑了前 $i$ 个数,前面已经选择的数 $or$ 和为 $j$ ,期望后面选出的数 $or$ 和包含 $k$ 时的方案数. 若第 $i+1$ 个数为 $x$ ,不选它,则有 $f(i+1,j,k)+=f(i,j,k)$ . 如果选了它,假设能转移到 $f(i+1,j|x,k’)$ ,那么 $k’$ 需要满足: $k’|x=k$ . $k’|j|x\not= k’|j$ .这是为了保证去掉 $x$ 后就不合法了. 如果只考虑满足第一个条件的,就有 $f(i+1,j|x,k\ xor\ (k\&amp;x) )+=f(i,j,k)$ .因为 $x,k$ 都为 $1$ 的位置上可以随便选. 还要减去满足第一个条件,但不满足第二个条件的部分. $f(i+1,j|x,(k\ xor\ (k\&amp;x))|(x\ xor (x\&amp; j)) )-=f(i,j,k)$ . 后面括号表示 $x$ 对 $j$ 产生的贡献,即将原来的 $0$ 变为了 $1$ .如果 $k’$ 的这些位上也是 $1$ ,就不满足第二个条件了. 初始有 $f(0,0,0)=1$ ,答案为 $f(n,1023,0)$ .这样做是 $O(n\cdot 4^{10})$ 的. 注意到若 $f(i,j,k)\not = 0$ ,则一定有 $k$ 是 $j$ 的子集.于是枚举 $k$ 时只用枚举 $j$ 的子集.时间复杂度 $O(n\cdot 3^{10})$ . 滚掉第一维,优化空间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b); &#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int N=1023;int n,a[N+10],f[2][N+10][N+10];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read()^N; int id=0; f[0][0][0]=1; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; memset(f[id^1],0,sizeof f[id^1]); for(int j=0;j&lt;=N;++j) &#123; for(int k=j;;k=(k-1)&amp;j) &#123; if(f[id][j][k]) &#123; f[id^1][j][k]=add(f[id^1][j][k],f[id][j][k]); f[id^1][j|x][k^(k&amp;x)]=add(f[id^1][j|x][k^(k&amp;x)],f[id][j][k]); f[id^1][j|x][(k^(k&amp;x))|(x^(x&amp;j))]=add(f[id^1][j|x][(k^(k&amp;x))|(x^(x&amp;j))],P-f[id][j][k]); &#125; if(!k) break; &#125; &#125; id^=1; &#125; cout&lt;&lt;f[id][N][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4754 独特的树叶]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-4754-%E7%8B%AC%E7%89%B9%E7%9A%84%E6%A0%91%E5%8F%B6%2F</url>
    <content type="text"><![CDATA[树 $hash$ . 要判断树的同构,自然要用到 $hash$ .但 $hash$ 的方法很多,我们要选取一种 优美 的方式.比如说字符串中,进制 $hash$ 就很优美,它可以 $O(1)$ 计算一个子串的 $hash$ 值. 在树中,一般是将一个点的 $hash$ 值设为所有儿子 $hash$ 值从小到大排序组成的串的进制 $hash$ 值,再乘上这个点的子树大小.若为叶子节点,则 $hash$ 值为 $1$ . 上面是对有根树的操作.然而这道题是无根树.找重心转成有根树十分麻烦(因为多了一个点),考虑换根,求出以每个点作为根节点的 $hash$ 值. 设 $f(i),g(i),h(i)$ 分别表示以 $1$ 为根时节点 $i$ 的 $hash$ 值,以 $fa_i$ 为根并去掉子树 $i$ 后 $fa_i$ 的 $hash$ 值,以 $i$ 为根时节点 $i$ 的 $hash$ 值. 对 $A,B$ 两棵树都做一次 $hash$ ,将 $A$ 中每个节点的 $h(i)$ 放入 $set$ 中,然后从小到大枚举 $B$ 树中度数为 $1$ 的点 $x$ .如果它连在 $y$ 上,由于我们 优美 的 $hash$ 定义,删去它后以 $y$ 为根, $y$ 的 $hash$ 值应该是 $\frac {h(x)} {n+1}$ .在 $set$ 中查询是否出现即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXN=1e5+10;const int P=998244353;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b); &#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int Pow[MAXN],Base=37,val[MAXN];int pre[MAXN],suf[MAXN];pii vp[MAXN];set&lt;int&gt; s;struct Tree&#123; int n; int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1]; int f[MAXN],g[MAXN],h[MAXN],siz[MAXN]; int deg[MAXN]; void addedge(int u,int v) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; &#125; void init() &#123; ecnt=0; for(int i=1;i&lt;=n;++i) head[i]=f[i]=g[i]=h[i]=deg[i]=0; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); ++deg[u],++deg[v]; &#125; &#125; void dfs1(int u,int fa) &#123; siz[u]=1; int tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; &#125; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa) val[++tot]=f[v]; &#125; sort(val+1,val+1+tot); int tmp=1; for(int i=1;i&lt;=tot;++i) &#123; f[u]=add(f[u],mul(tmp,val[i])); tmp=mul(tmp,Base); &#125; f[u]=mul(f[u],siz[u]); if(!tot) f[u]=1; &#125; void dfs2(int u,int fa) &#123; int tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; vp[++tot]=mp(f[v],v); &#125; if(fa) vp[++tot]=mp(g[u],-1); sort(vp+1,vp+1+tot); pre[0]=suf[tot+1]=0; for(int i=1;i&lt;tot;++i) pre[i]=add(pre[i-1],mul(Pow[i-1],vp[i].first)); for(int i=tot;i&gt;1;--i) suf[i]=add(suf[i+1],mul(Pow[i-2],vp[i].first)); for(int i=1;i&lt;=tot;++i) &#123; if(vp[i].second==-1) continue; g[vp[i].second]=mul(n-siz[vp[i].second],pre[i-1]+suf[i+1]); &#125; if(!fa &amp;&amp; tot==1) g[vp[1].second]=1; int tmp=1; for(int i=1;i&lt;=tot;++i) &#123; h[u]=add(h[u],mul(vp[i].first,tmp)); tmp=mul(tmp,Base); &#125; h[u]=mul(h[u],n); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa) dfs2(v,u); &#125; &#125; void solve(int id) &#123; dfs1(1,0); dfs2(1,0); if(!id) &#123; for(int i=1;i&lt;=n;++i) s.insert(h[i]); &#125; else &#123; int inv=fpow(n,P-2); for(int i=1;i&lt;=n;++i) &#123; if(deg[i]!=1) continue; int tmp=mul(h[i],inv); if(s.find(tmp)!=s.end()) &#123; cout&lt;&lt;i&lt;&lt;endl; return; &#125; &#125; &#125; &#125;&#125;A,B;int main()&#123; int n=read(); Pow[0]=1; for(int i=1;i&lt;=n+1;++i) Pow[i]=mul(Pow[i-1],Base); A.n=n,B.n=n+1; A.init(); B.init(); A.solve(0); B.solve(1); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190519]]></title>
    <url>%2F2019%2F05%2F20%2Ftest20190519%2F</url>
    <content type="text"><![CDATA[$T3$ 题意理解错了.直接爆炸. $sequence$ 考虑一段区间 $[l,r]$ 合法,则显然 $\forall\ l\leq i\leq r,b_i\geq \max_{j=l}^i a_j$ . 这个东西对于 $l,r$ 两边来说都是具有单调性的, $two\ pointer$ 扫一遍即可. 用线段树做 $RMQ$ 为 $O(nlogn)$ ,用 $ST$ 表则为 $O(n)$ . $circulate$ 考虑枚举循环节循环次数,对于每个确定的循环次数,二分出循环节数字的最大值. 为了计算不重不漏,容斥一下,该循环次数的质因子个数为奇数,则加上,否则减去. $2\times 10^{18}$ 有 $19$ 个数字…考试没加 $19$ 的情况,丢了 $20$ 分. $cannon$ 题意搞错了,没注意到一座山被轰了几次后高度减低,可以换其他的炮轰… $80pts$ 很简单.设 $f(i)$ 表示轰平一座高度为 $i$ 的山最少需要轰几次,然后从低到高判断能否轰即可. 转移就有 $\forall x\leq 0,f(x)=0.f(i)=1+f(i-max_D)$ , $max_D$ 表示 $A_j\geq i$ 中最大的 $D_j$ . $100pts$ 的做法就是在上面改一下.因为 $D\leq 300$ ,所以上面的 $f$ 数组有用的只有 $M\cdot D$ 个.用 $map$ 做即可.]]></content>
      <tags>
        <tag>二分</tag>
        <tag>STL</tag>
        <tag>test</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4755 扭动的回文串]]></title>
    <url>%2F2019%2F05%2F20%2Fbzoj-4755-%E6%89%AD%E5%8A%A8%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[二分 + $Hash​$ . 先补充上多余字符,将回文串全部弄成奇回文串.然后二分 + $Hash$ 预处理出每个位置的最大回文半径. 对于第三种情况,可以枚举回文中心,显然往两边拓展时,过了最大回文半径时就换到另一个串是最优的.于是可以二分在另一个串中的长度, $Hash$ 判断合法性.拼接位置的处理比较麻烦,可以调用补字符前的原串 $Hash$ 值. 时间复杂度 $O(nlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef unsigned long long ull;const int MAXN=2e5+10;const ull Base=137;ull Pow[MAXN],Hash[4][MAXN],revHash[4][MAXN];int n,ans=1;char s[2][MAXN],buf[2][MAXN];int cnt;ull calc(int k,int l,int r)&#123; return Hash[k][r]-Pow[r-l+1]*Hash[k][l-1];&#125;ull revcalc(int k,int l,int r)&#123; return revHash[k][l]-Pow[r-l+1]*revHash[k][r+1];&#125;bool check(int k,int pos,int len)&#123; ull Left=calc(k,pos-len,pos-1); ull Right=revcalc(k,pos+1,pos+len); return Left==Right;&#125;int r[2][MAXN];int solve(int L,int R)&#123; int l=1,r=min(L,n-R+1),res=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(calc(2,L-mid+1,L)==revcalc(3,R,R+mid-1)) res=mid,l=mid+1; else r=mid-1; &#125; return res;&#125;int main()&#123; n=read(); scanf("%s%s",s[0]+1,s[1]+1); for(int k=0;k&lt;2;++k) &#123; for(int i=1;i&lt;=n;++i) Hash[k+2][i]=Hash[k+2][i-1]*Base+s[k][i]; for(int i=n;i&gt;=1;--i) revHash[k+2][i]=revHash[k+2][i+1]*Base+s[k][i]; &#125; n=cnt; Pow[0]=1; for(int i=1;i&lt;=n;++i) Pow[i]=Pow[i-1]*Base; for(int k=0;k&lt;2;++k) &#123; for(int i=1;i&lt;=n;++i) Hash[k][i]=Hash[k][i-1]*Base+(buf[k][i]); for(int i=n;i&gt;=1;--i) revHash[k][i]=revHash[k][i+1]*Base+(buf[k][i]); &#125; for(int k=0;k&lt;2;++k) &#123; for(int pos=1;pos&lt;=n;++pos) &#123; int L=1,R=(n-1)&gt;&gt;1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(k,pos,mid)) r[k][pos]=mid,L=mid+1; else R=mid-1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; int L=(i-r[0][i]+1)&gt;&gt;1,R=(i+r[0][i])&gt;&gt;1; ans=max(ans,r[0][i]+solve(L-1,R)*2); &#125; for(int i=1;i&lt;=n;++i) &#123; int L=(i-r[1][i]+1)&gt;&gt;1,R=(i+r[1][i])&gt;&gt;1; ans=max(ans,r[1][i]+solve(L,R+1)*2); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4771 七彩树]]></title>
    <url>%2F2019%2F05%2F19%2Fbzoj-4771-%E4%B8%83%E5%BD%A9%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主席树. 询问的点要求在子树 $x$ 内,并且 $dep\leq dep_x+d$ ,这样就有 $dfn,dep$ 上的两维限制,所以可以用主席树把符合条件的点抠出来. 只需要考虑怎么计算不同颜色的种数.对于一种颜色,可以在每个点的位置让权值 $+1$ ,而在 $LCA$ 处让权值 $-1$ .只需要处理 $dfs$ 序相邻的两个点的 $LCA$ (因为最深)就可以保证询问子树时贡献不会被重复计算了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct PreSegtree&#123; int idx; void init()&#123;idx=0;Tree[0].siz=Tree[0].ls=Tree[0].rs=0;&#125; struct node &#123; int ls,rs,siz; &#125;Tree[MAXN*50];#define root Tree[o] void insert(int &amp;o,int lst,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[lst]; root.siz+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(root.ls,Tree[lst].ls,l,mid,pos,c); else insert(root.rs,Tree[lst].rs,mid+1,r,pos,c); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;r || l&gt;R || !o) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.siz; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125;&#125;T;int rt[MAXN];int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m;int dfnidx=0,dfn[MAXN],rnk[MAXN],siz[MAXN],dep[MAXN];int fa[MAXN][20],Log[MAXN];int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=Log[dep[x]-dep[y]];i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=Log[dep[x]];i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfs(int u)&#123; dfn[u]=++dfnidx; rnk[dfnidx]=u; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v); siz[u]+=siz[v]; &#125;&#125;set&lt;int&gt; S[MAXN];set&lt;int&gt;::iterator it;void init()&#123; ecnt=0; dfnidx=0; T.init(); memset(head,0,sizeof head); memset(rt,0,sizeof rt); memset(fa,0,sizeof fa); dep[1]=1;&#125;int pd[MAXN],v[MAXN];bool cmp(int x,int y)&#123; return dep[x]&lt;dep[y];&#125;void solve()&#123; int lastans=0; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; v[i]=read(); S[i].clear(); pd[i]=i; &#125; for(int i=2;i&lt;=n;++i) &#123; fa[i][0]=read(); addedge(fa[i][0],i); &#125; dfs(1); for(int j=1;j&lt;=Log[n];++j) for(int i=1;i&lt;=n;++i) fa[i][j]=fa[fa[i][j-1]][j-1]; sort(pd+1,pd+1+n,cmp); for(int i=1;i&lt;=n;++i) &#123; int j=pd[i]; int a=0,b=0; it=S[v[j]].lower_bound(dfn[j]); T.insert(rt[dep[j]],rt[dep[pd[i-1]]],1,n,dfn[j],1); if(it!=S[v[j]].end()) &#123; b=rnk[*it]; T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(b,j)],-1); &#125; if(it!=S[v[j]].begin()) &#123; --it; a=rnk[*it]; T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(a,j)],-1); &#125; if(a &amp;&amp; b) T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(a,b)],1); S[v[j]].insert(dfn[j]); &#125; while(m--) &#123; int x=read()^lastans; int d=read()^lastans; lastans=T.query(rt[min(dep[x]+d,dep[pd[n]])],1,n,dfn[x],dfn[x]+siz[x]-1); lastans-=T.query(rt[dep[x]-1],1,n,dfn[x],dfn[x]+siz[x]-1); printf("%d\n",lastans); &#125;&#125;int main()&#123; Log[1]=0; for(int i=2;i&lt;MAXN;++i) Log[i]=Log[i&gt;&gt;1]+1; int Testcases=read(); while(Testcases--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4773 负环]]></title>
    <url>%2F2019%2F05%2F19%2Fbzoj-4773-%E8%B4%9F%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[$floyd$ + 倍增. 写保卫王国那道题的时候学习了 Min-plus matrix multiplication ,即将矩阵乘法中的乘法换成加法,加法换成取 $\min$ .这东西还有其他的用法.若一个图的邻接矩阵的 $k$ 次方为 $A$ (在这样运算下), 则 $A_{i,j}$ 表示图中从 $i$ 到 $j$ ,经过 $k$ 条边的最短路长度. 为啥?因为这样运算其实就是 $floyd$ 的转移,只不过恰好也满足了结合律. 要找最短的负环,可以设 $f[k]$ 为原邻接矩阵的 $2^k$ 次方,倍增解决即可,环的大小即为边的数目. 时间复杂度 $O(n^3logn)$ . 注意要将邻接矩阵中自己到自己的距离设为 $0$ ,这样答案才满足单调性. 也可以直接二分答案,时间复杂度为 $O(n^3log^2n)$ ,但对于 $n\leq 300$ 来说差异不大. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=300+10;int n,m;struct Matrix&#123; int A[MAXN][MAXN]; Matrix()&#123;memset(A,63,sizeof A);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=1;k&lt;=n;++k) for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) res.A[i][j]=min(res.A[i][j],A[i][k]+rhs.A[k][j]); return res; &#125;&#125;f[10],cur,nx;int Log[MAXN];int main()&#123; Log[1]=0; for(int i=2;i&lt;MAXN;++i) Log[i]=Log[i&gt;&gt;1]+1; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); f[0].A[u][v]=w; &#125; for(int i=1;i&lt;=n;++i) cur.A[i][i]=f[0].A[i][i]=0; int mx=Log[n]; for(int i=1;i&lt;=mx;++i) f[i]=f[i-1]*f[i-1]; int ans=0; for(int i=mx;i&gt;=0;--i) &#123; bool flag=false; nx=f[i]*cur; for(int j=1;j&lt;=n &amp;&amp; !flag;++j) if(nx.A[j][j]&lt;0) flag=true; if(!flag) ans+=1&lt;&lt;i,cur=nx; &#125; printf("%d",ans+1&gt;n?0:ans+1); return 0;&#125;]]></content>
      <tags>
        <tag>floyd</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4774 修路]]></title>
    <url>%2F2019%2F05%2F17%2Fbzoj-4774-%E4%BF%AE%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[斯坦纳树 + 状压 . 开始感觉直接做一颗最小生成树出来,把没用的边割掉就好了.然而随手画几个图发现是错的. 然后学习了一波 最小斯坦纳树 .这东西可以看做是最小生成树的一般情况.生成树是求一个选边方案,将所有的点加入联通块中.斯坦纳树是把指定点集中的点加入联通块中,也可以加入不在点集中的点来辅助. 求解最小斯坦纳树是 $NP$ 的,没有多项式算法,用状压做.设 $f[S][i]$ 为指定点的连通状态为 $S$ ,最小斯坦纳树的根节点为 $i$ 时的最小权值.转移有两种.第一种是将当前集合拆成两个不相交的子集, $f[S][i]\leftarrow f[S_1][i]+f[S_2][i],S_1,S_2\subset S,S_1 \&amp; S_2=0$ .另一种是换根, $f[S][i]\leftarrow f[S][j]+val_{i,j}$ ,后者表示连接 $i,j$ 的边权.这东西有后效性,用 $Spfa$ 转移. 而这道题是指定点对间连通,可以看做最小斯坦纳森林.设 $g[S]$ 表示连通了点集 $S$ 的最小斯坦纳森林的权值. 转移有 $g[S]\leftarrow g[S_1]+g[S_2],S_1,S_2\subset S,S_1 \&amp; S_2=0​$ .即将 $S​$ 拆成两个不相交子集. $S_1,S_2​$ 都需要满足每对对应点要么都不在其中,要么都在其中. 最后答案就是 $g[S_0]$ , $S_0$ 表示将那 $2d$ 个点都连通的状态. 小心爆 $int$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10,MAXS=1&lt;&lt;8;int inf;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int f[MAXS][MAXN],g[MAXS];int n,m,D;queue&lt;int&gt; q;int vis[MAXN];void SPFA(int S)&#123; while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(f[S][v]-f[S][u]&gt;val[i]) &#123; f[S][v]=f[S][u]+val[i]; if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125;&#125;bool check(int S)&#123; return (S&amp;((1&lt;&lt;D)-1))==(S&gt;&gt;D);&#125;int main()&#123; n=read(),m=read(),D=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; memset(f,63,sizeof f); memset(g,63,sizeof g); inf=f[0][0]; for(int i=1;i&lt;=D;++i) f[1&lt;&lt;(i-1)][i]=f[1&lt;&lt;(D+i-1)][n-i+1]=0; int mx=1&lt;&lt;(2*D); for(int S=0;S&lt;mx;++S) &#123; for(int i=1;i&lt;=n;++i) &#123; for(int S1=(S-1)&amp;S;S1;S1=(S1-1)&amp;S) f[S][i]=min(f[S][i],f[S1][i]+f[S^S1][i]); if(f[S][i]&lt;inf) &#123; q.push(i); vis[i]=1; &#125; &#125; SPFA(S); for(int i=1;i&lt;=n;++i) g[S]=min(g[S],f[S][i]); &#125; for(int S=0;S&lt;mx;++S) for(int S1=(S-1)&amp;S;S1;S1=(S1-1)&amp;S) if(check(S1) &amp;&amp; check(S^S1)) g[S]=min(g[S],g[S1]+g[S^S1]); if(g[mx-1]&gt;=inf) puts("-1"); else cout&lt;&lt;g[mx-1]; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
        <tag>斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4735 你的生命已如风中残烛]]></title>
    <url>%2F2019%2F05%2F16%2Fbzoj-4735-%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B%2F</url>
    <content type="text"><![CDATA[一道短小精悍(指代码)的数学题. 把每个位置上的数都 $-1$ ,于是要求就变为每个位置的前缀和都是非负数. 如果在最后再加入一个 $-1$ ,那么就只有最后一个位置前缀和为 $-1$ ,其他位置都是非负数. 这样就可证明,对于一个序列的所有循环同构,有且仅有一种序列是合法的. 因为只有把多出来的 $-1$ 放在最后才合法.因为总和为 $-1$ ,若最后一个位置不是 $-1$ ,那么前面一个位置的前缀和一定为负. 而这个 $-1$ 可以是原有的与新加的共 $m-n+1$ 个 $-1$ 中的任意一个,所以应除去. $$ans=\frac {m!} {m-n+1}$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n=read(),m=0; for(int i=1;i&lt;=n;++i) m+=read(); int ans=1; for(int i=2;i&lt;=m;++i) ans=mul(ans,i); ans=mul(ans,fpow(m-n+1,P-2)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4860 树的难题]]></title>
    <url>%2F2019%2F05%2F16%2Fbzoj-4860-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[点分治 + 线段树合并. 英语月考的时候一直在想这个题… 有路径长度的限制,可以考虑点分治.然后发现在合并两条路径时有两种情况. 靠近当前分治中心的那两条边如果颜色不同,就直接将两条路径权值加起来.否则还要减去那条边的颜色权值. 分治时把子树按照与当前分支中心连接的边的颜色排序,扫一遍,维护两颗线段树,分别表示连到分治中心的边与当前颜色不同的最大权值与相同的最大权值. 处理完一种颜色的时候把两颗线段树合并起来就好了.时间复杂度 $O(nlog^2n)$ . bzoj 不支持 C++11​ 是真的毒瘤… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pairtypedef pair&lt;int,int&gt; pii;const ll inf=1e18;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,limL,limR,roota,rootb,cnt;struct node&#123; int ls,rs; ll mxv;&#125;Tree[MAXN*30];#define root Tree[o]int newnode()&#123; int o=++cnt; root.ls=root.rs=0; root.mxv=-inf; return o;&#125;void pushup(int o)&#123; root.mxv=max(Tree[root.ls].mxv,Tree[root.rs].mxv);&#125;int merge(int a,int b)&#123; if(!a || !b) return a+b; Tree[a].mxv=max(Tree[a].mxv,Tree[b].mxv); Tree[a].ls=merge(Tree[a].ls,Tree[b].ls); Tree[a].rs=merge(Tree[a].rs,Tree[b].rs); return a;&#125;void insert(int &amp;o,int l,int r,int pos,ll c)&#123; if(!o) o=newnode(); if(l==r) &#123; root.mxv=max(root.mxv,c); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(root.ls,l,mid,pos,c); else insert(root.rs,mid+1,r,pos,c); pushup(o);&#125;ll query(int o,int l,int r,int L,int R)&#123; if(!o) return -inf; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mxv; ll res=-inf; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query(root.ls,l,mid,L,R)); if(R&gt;mid) res=max(res,query(root.rs,mid+1,r,L,R)); return res;&#125;vector&lt;pii&gt; edge[MAXN];ll ans=-inf,mi;int rt=0,totsize,vis[MAXN],siz[MAXN];int val[MAXN];void Findrt(int u)&#123; siz[u]=1; vis[u]=1; int sonsize=0; int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second; if(vis[v]) continue; Findrt(v); siz[u]+=siz[v]; sonsize=max(sonsize,siz[v]); &#125; sonsize=max(sonsize,totsize-siz[u]); if(sonsize&lt;mi) rt=u,mi=sonsize; vis[u]=0;&#125;void getsize(int u)&#123; ++totsize; vis[u]=1; int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second; if(!vis[v]) getsize(v); &#125; vis[u]=0;&#125;ll mx[MAXN];void dfs(int u,ll c,int len,int curcol)&#123; if(len&gt;limR) return; vis[u]=1; mx[len]=max(mx[len],c); int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second,r=i.first; ll newc=c; if(r!=curcol) newc+=val[r]; if(!vis[v]) dfs(v,newc,len+1,r); &#125; vis[u]=0;&#125;void solve(int u)&#123; totsize=cnt=roota=rootb=0; mi=inf; getsize(u); Findrt(u); int Rt=rt; getsize(Rt); vis[Rt]=1; int precol=0; int SIZ=edge[Rt].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii e=edge[Rt][id]; int v=e.second,r=e.first; if(vis[v]) continue; for(int k=0;k&lt;=siz[v];++k) mx[k]=-inf; if(rootb &amp;&amp; r!=precol) &#123; roota=merge(roota,rootb); rootb=0; &#125; dfs(v,val[r],1,r); for(int i=1;i&lt;=siz[v] &amp;&amp; i&lt;limR &amp;&amp; mx[i]!=mx[0];++i) &#123; ll tmp=max(ans,i&gt;=limL &amp;&amp; i&lt;=limR? mx[i]:-inf); tmp=max(tmp,query(roota,1,limR,max(1,limL-i),limR-i)+mx[i]); tmp=max(tmp,query(rootb,1,limR,max(1,limL-i),limR-i)-val[r]+mx[i]); ans=max(ans,tmp); &#125; for(int i=1;i&lt;=siz[v] &amp;&amp; i&lt;limR &amp;&amp; mx[i]!=mx[0];++i) &#123; insert(rootb,1,limR,i,mx[i]); &#125; precol=r; &#125; for(int id=0;id&lt;SIZ;++id) &#123; pii e=edge[Rt][id]; int v=e.second; if(!vis[v]) solve(v); &#125;&#125;int main()&#123; Tree[0].mxv=-inf; n=read(),m=read(),limL=read(),limR=read(); for(int i=1;i&lt;=m;++i) val[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),c=read(); edge[u].push_back(mp(c,v)); edge[v].push_back(mp(c,u)); &#125; for(int i=1;i&lt;=n;++i) sort(edge[i].begin(),edge[i].end()); solve(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树合并</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4916 神犇与蒟蒻]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4916-%E7%A5%9E%E7%8A%87%E4%B8%8E%E8%92%9F%E8%92%BB%2F</url>
    <content type="text"><![CDATA[杜教筛小水题. 根据 $\mu$ 的定义,第一个式子显然为 $1$ . 根据 $\varphi$ 的定义,第二个式子显然为 $\sum_{i=1}^N i\cdot \varphi(i)$ ,直接杜教筛即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv2,inv6;inline int sumh(int x)&#123; int s=mul(x,x+1); s=mul(s,2*x+1); s=mul(s,inv6); return s;&#125;inline int sumg(int l,int r)&#123; return mul(mul(l+r,r-l+1),inv2);&#125;const int N=32000,MAXN=N+10;int phi[MAXN],cnt=0,prime[MAXN],ism[MAXN],sum[MAXN];void init()&#123; phi[1]=1,ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=N;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=mul(phi[i],prime[j]); break; &#125; phi[i*prime[j]]=mul(phi[i],prime[j]-1); &#125; &#125; for(int i=1;i&lt;=N;++i) sum[i]=add(sum[i-1],mul(i,phi[i]));&#125;map&lt;int,int&gt; mp;int calc(int n)&#123; if(n&lt;=N) return sum[n]; if(mp.find(n)!=mp.end()) return mp[n]; int res=sumh(n); for(int l=2,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); res=add(res,P-mul(sumg(l,r),calc(n/l))); &#125; return mp[n]=res;&#125;int main()&#123; inv2=fpow(2,P-2); inv6=fpow(6,P-2); init(); int n=read(); printf("%d\n%d\n",1,calc(n)); return 0;&#125;]]></content>
      <tags>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4926 皮皮妖的递推]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4926-%E7%9A%AE%E7%9A%AE%E5%A6%96%E7%9A%84%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[构造. 发现这个迭代过程与斐波那契数列有相似之处,构造 $g(i)=g(i-1)+g(i-m),g(0)=1$ . 把 $n$ 拆成 $k$ 个 $g_i$ 的和, $n=\sum_{i=1}^k g(a_i)$ ,则 $f_n=\sum_{i=1}^k g(a_i-1)$ . 证明:将 $f$ 定义式变形得到 $f(n)+f^m(n-1)=n$ .而 $n=\sum_{i=1}^k g(a_i),f_n=\sum_{i=1}^k g(a_i-1)$ . $f^2(n)=\sum_{i=1}^k g(a_i-2)$ ,依次计算,可得 $f^m(n)=\sum_{i=1}^k g(a_i-m)$ . 而现在需要的是 $f^m(n-1)$ ,而 $n$ 只比 $n-1$ 多了个 $1$ ,把 $g(0)$ 设为 $1$ 即可. 那么就有 $\sum_{i=1}^k g(a_i-1)+\sum_{i=1}^k g(a_i-m)=\sum_{i=1}^k g(a_i)$ .于是 $g(i)=g(i-1)+g(i-m),g(0)=1$ . 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e6+10;ll g[MAXN];int main()&#123; ll n=read(),m=read(); for(int i=0;i&lt;=m;++i) g[i]=1; int mx=m+1; for(;;++mx) &#123; g[mx]=g[mx-1]+g[mx-m]; if(g[mx]&gt;n) break; &#125; --mx; ll ans=0; for(int i=mx;i&gt;=1 &amp;&amp; n;--i) if(n&gt;=g[i]) n-=g[i],ans+=g[i-1]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4962 简单的字符串]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4962-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$Manacher$ . 不知道性质的话应该挺难做的… 先枚举子串中心,往两侧拓展,将走到的位置的字符交替写下来,记作 $S$ . 比如字符串是 $abcdacce$ ,以 $d$ 右侧的那个位置为中心,则 $S=daccbcae$ (此处先写左边). 若中心的两侧长度为 $L$ 的两个子串循环同构,则 $S$ 中对应的长度为 $2L$ 的前缀能被 $1$ 或 $2$ 个偶回文串拼接成. 证明:如果左右两个子串完全相同,那么这个长度为 $2L$ 的前缀自身就是一个偶回文串.否则,若左右两个子串不同,但循环同构,那么设右边的串为 $s_1,s_2,\dots s_L$ ,左边的串为 $s_i,s_{i+1},\dots,s_L,s_1,s_2\dots,s_{i-1}$ . 那么这个长度为 $2L$ 的前缀就应该是 $(s_{i-1},s_1,s_{i-2},s_2,\dots,s_1,s_{i-1})+(s_L,s_i,s_{L-1},s_{i+1},\dots,s_i,s_L)$ . 显然加号两边的串都是偶回文串. 还有一个性质,若 $S=u+v$ , $u$ 和 $v$ 都是偶回文串,那么要么 $u$ 是 $S$ 的最长偶回文前缀,要么 $v$ 是 $S$ 的最长偶回文后缀.Claris的证明 于是用 $Manacher$ 跑出每个位置的最长回文半径 $rmax$ ,对于每个前缀判断一下拆成 最长偶回文前缀 + 偶回文串 与拆成 偶回文串 + 最长偶回文后缀 是否有一个合法即可. 时间复杂度 $O(n^2)$ . 若用 $Hash$ 代替 $Manacher$ 则为 $O(n^2 logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e3+10;int ch[MAXN],s[MAXN];int n,rmax[MAXN],pre[MAXN];int solve(int p)&#123; int len=0; for(int i=p,j=p+1;i&gt;=1 &amp;&amp; j&lt;=n;--i,++j) s[++len]=ch[i],s[++len]=ch[j]; fill(pre+1,pre+2+len,0); int r=0,pos=1; for(int i=1;i&lt;=len;++i) &#123; int mx=min(max(r-i,0),rmax[2*pos-i]); while(i+mx+1&lt;=n &amp;&amp; i-mx&gt;0 &amp;&amp; s[i+mx+1]==s[i-mx]) ++mx; rmax[i]=mx; if(i+mx&gt;=r) r=i+mx,pos=i; pre[i+rmax[i]]=max(pre[i+rmax[i]],rmax[i]); &#125; for(int i=len;i&gt;=1;--i) pre[i]=max(pre[i],pre[i+1]-1); for(int i=len;i&gt;=1;i-=2) pre[i]&lt;&lt;=1; int mx=0,res=0; for(int i=2;i&lt;=len;i+=2) &#123; if(rmax[i/2]==i/2) mx=i; if(rmax[(i+mx)/2]&gt;=(i-mx)/2 || rmax[(i-pre[i])/2]&gt;=(i-pre[i])/2) ++res; &#125; return res;&#125;int main()&#123; int ans=0; n=read(); for(int i=1;i&lt;=n;++i) ch[i]=read(); for(int i=1;i&lt;n;++i) ans+=solve(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4985 评分]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4985-%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[二分答案 + $dp$ . 这种只有比较大小的操作的题,套路大多是二分答案 $x$ ,将大于等于 $x$ 的视作 $1$ ,其余视作 $0$ ,再考虑判断. 此题二分答案后,可以设 $f(i)$ 表示要将位置 $i$ 上的数确定为 $1$ ,至少需要在前面填几个 $1$ (已确定的位置不算). 那么初始时,若 $i$ 的值未确定,则 $f(i)=1$ ,若 $\geq x$ ,则为 $0$ ,若 $&lt;x$ ,则为 $inf$ . 转移时用队列,将前三个取出来,将最小的两个值加起来放在最后.因为要让最后一个为 $1$ ,则这三个中至少有两个 $1$ . 只剩下一个数时,判断它是否不超过可以随便填的 $1$ 的数目即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;const int inf=1e9;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m;int d[MAXN];int fd[MAXN];queue&lt;int&gt; q;bool check(int x)&#123; while(!q.empty()) q.pop(); int fcnt=0; for(int i=1;i&lt;=n-m;++i) if(fd[i]&gt;=x) ++fcnt; for(int i=1;i&lt;=n;++i) &#123; if(d[i]==0) q.push(1); else if(d[i]&gt;=x) q.push(0); else q.push(inf); &#125; while(1) &#123; int a=q.front(); q.pop(); if(q.empty()) return a&lt;=fcnt; int b=q.front(); q.pop(); int c=q.front(); q.pop(); q.push(min(inf,min(a+b,min(a+c,b+c)))); &#125;&#125;int main()&#123; n=read(),m=read(); int L=1,R=0; for(int i=1;i&lt;=m;++i) &#123; int x=read(),pos=read(); d[pos]=x; R=max(R,x); &#125; for(int i=1;i&lt;=n-m;++i) &#123; fd[i]=read(); R=max(R,fd[i]); &#125; int ans=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4998 星球联盟]]></title>
    <url>%2F2019%2F05%2F13%2Fbzoj-4998-%E6%98%9F%E7%90%83%E8%81%94%E7%9B%9F%2F</url>
    <content type="text"><![CDATA[离线,并查集维护点双. 一个比较直接的做法是将点双缩点,然后用 $LCT$ 维护缩点后的树. 其实也可以直接用并查集做.因为只有加边的操作,所以可以离线处理出最后图的一颗生成树. 然后加边时,若为树边,答案显然是 $No$ .否则用并查集将那两个点合并起来,同时维护 $siz$ 就好了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;2],nx[MAXN&lt;&lt;2];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[MAXN],siz[MAXN];int Find(int x)&#123; return x==f[x]?x:(f[x]=Find(f[x]));&#125;int U[MAXN&lt;&lt;1],V[MAXN&lt;&lt;1];int fa[MAXN],dep[MAXN];void dfs(int u,int Fa)&#123; fa[u]=Fa; dep[u]=dep[Fa]+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=Fa) dfs(v,u); &#125;&#125;int treeedge[MAXN&lt;&lt;1];void merge(int x,int y)&#123; x=Find(x),y=Find(y); while(x!=y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); int fx=Find(fa[x]); f[x]=fx; siz[fx]+=siz[x]; x=fx; &#125;&#125;int main()&#123; n=read(),m=read(),q=read(); for(int i=1;i&lt;=n;++i) f[i]=i; for(int i=1;i&lt;=m+q;++i) &#123; int u=read(),v=read(); U[i]=u,V[i]=v; int x=Find(u),y=Find(v); if(x!=y) &#123; f[x]=y; addedge(u,v); addedge(v,u); treeedge[i]=1; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!fa[i]) dfs(i,i); for(int i=1;i&lt;=n;++i) f[i]=i,siz[i]=1; for(int i=1;i&lt;=m;++i) if(!treeedge[i]) merge(U[i],V[i]); for(int i=m+1;i&lt;=m+q;++i) &#123; if(treeedge[i]) puts("No"); else &#123; merge(U[i],V[i]); printf("%d\n",siz[Find(U[i])]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190512]]></title>
    <url>%2F2019%2F05%2F12%2Ftest20190512%2F</url>
    <content type="text"><![CDATA[普及组套题.可能就 $AK$ 了. 前两题很 $sb$ ,没啥可说的. 考后发现 $T3$ 是个普及组模拟赛的题?还是入门 $OJ$ 上的… Link 考试做法:考虑枚举答案为 $t$ ,那么前 $t$ 天不割的总长是确定的,为 $\sum h_i+t\cdot grow_i$ .需要最大化 $t$ 次割草割去的长度总和. 一株草显然可以只割一次,割多次和只割最后一次是等价的.那么枚举范围就可以设为 $1\sim n$ . 而同一天也不能割两株草.所以 $n$ 株草, $t$ 天就形成了一个 $n\times t$ 的矩阵,每个点有权值,现在每一行每一列最多选 $1$ 个,要求共选 $t​$ 个的最大收益,就成了经典模型. 用一个大数 $inf$ 减去原权值作为权值,就是最小费用最大流,最后算一下就可以了.由于 $n\leq 50​$ ,肯定能过. 大家的做法:枚举答案 $t$ ,将草按 $grow$ 排序,先割 $grow$ 小的,再割大的,总共割 $t$ 次. 然后设 $f(i,j)$ 表示前 $i$ 株草割了 $j$ 株能获得的最大收益就好了. 贪心部分的正确性可以用经典套路证明,尝试交换两株草被割的次序,答案不会变得更优. 顿时感觉自己好 $sb​$ 啊.如果这题把数据出大点今天可能就凉了…]]></content>
      <tags>
        <tag>test</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5479 tree]]></title>
    <url>%2F2019%2F05%2F12%2Fbzoj-5479-tree%2F</url>
    <content type="text"><![CDATA[欧拉序 + 贪心 + 二分. $LCA$ 问题首先可以处理出欧拉序,将树上问题转化成序列问题. 于是就变成了给出一些 $A$ 类点,一些 $B$ 类点,选两个不同类的点作为区间,求区间内 $dep$ 的最小值的最大值. 看上去可以直接二分,然而没什么用,因为区间数目是 $|A|\cdot |B|$ 的. 考虑贪心.对于一个 $B$ 类点,如果我们钦定它作为左端点,那么那个作为右端点的 $A$ 类点应该越靠左越好.如果钦定它为右端点,那么那个 $A$ 类点应该越靠左越好. 于是对每个 $B$ 类点二分出左/右最近的 $A$ 类点,将这两个区间的 $dep$ 最小值加入贡献. 预处理 $ST$ 表,时间复杂度 $O(\sum |B| \cdot log|A|)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dep[MAXN],dfn[MAXN],idx;int a[MAXN&lt;&lt;1];void dfs(int u,int fa)&#123; dep[u]=dep[fa]+1; dfn[u]=++idx; a[idx]=dep[u]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); a[++idx]=dep[u]; &#125;&#125;const int LogN=20;int st[MAXN&lt;&lt;1][LogN];int Log[MAXN&lt;&lt;1];void init_ST()&#123; for(int i=1;i&lt;=2*n-1;++i) st[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=2*n-1;++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=2*n-1;++i) st[i][j]=min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);&#125;int query(int l,int r)&#123; int k=Log[r-l+1]; return min(st[l][k],st[r-(1&lt;&lt;k)+1][k]);&#125;void reset()&#123; ecnt=0; idx=0; for(int i=1;i&lt;=n;++i) head[i]=0;&#125;int dfnset[MAXN&lt;&lt;1],A;int pre(int x)&#123; return dfnset[upper_bound(dfnset,dfnset+A,x)-dfnset-1];&#125;int suf(int x)&#123; return dfnset[lower_bound(dfnset,dfnset+A,x)-dfnset];&#125;int main()&#123; Log[1]=0; for(int i=2;i&lt;=200000;++i) Log[i]=Log[i&gt;&gt;1]+1; int T=read(); while(T--) &#123; n=read(),m=read(); reset(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); init_ST(); while(m--) &#123; int ans=0; A=read(); for(int i=1;i&lt;=A;++i) dfnset[i]=dfn[read()]; sort(dfnset+1,dfnset+1+A); dfnset[0]=0,dfnset[A+1]=2*n; A+=2; int B=read(); for(int i=1;i&lt;=B;++i) &#123; int x=dfn[read()]; int lx=pre(x),rx=suf(x); if(lx) ans=max(ans,query(lx,x)); if(rx!=2*n) ans=max(ans,query(x,rx)); &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5478 gcd]]></title>
    <url>%2F2019%2F05%2F11%2Fbzoj-5478-gcd%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 题面有误, $a$ 应该是 $1\sim n$ 的一个排列.因为这个卡了好久… 用 $\varphi$ 反演就很好做. $O(n)$ 大力枚举 $d$ ,因为 $a$ 是个排列,所以可以大力枚举集合中的每个数的约数,对 $1\sim n$ 中每个数记录一下有 $f(i)$ 个数是它的倍数,那么后面那坨就是 $\sum f(i)^2$ 了. 集合大小总和是个调和级数,总时间复杂度应该是 $O(nlog^3n)$ .(其实我不会证) 直接 $memset$ 会 $T$ ,可能需要一点卡常的奇技淫巧. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int MAXN=1e5+10;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int n,a[MAXN];int phi[MAXN],ism[MAXN],cnt=0,prime[MAXN];vector&lt;int&gt; factor[MAXN];void init()&#123; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;j+=i) factor[j].push_back(i); ism[1]=1,phi[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=n;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=mul(phi[i],prime[j]); break; &#125; phi[i*prime[j]]=mul(phi[i],prime[j]-1); &#125; &#125;&#125;int f[MAXN],vis[MAXN];int main()&#123; n=read(); init(); for(int i=1;i&lt;=n;++i) a[i]=read(); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int res=0; for(int j=i;j&lt;=n;j+=i) &#123; int p=a[j]; int siz=factor[p].size(); for(int k=0;k&lt;siz;++k) &#123; int q=factor[p][k]; if(vis[q]!=i) &#123; f[q]=1; vis[q]=i; &#125; else ++f[q]; res=add(res,mul(2*f[q]-1,phi[q])); &#125; &#125; res=mul(res,phi[i]); ans=add(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5477 星际穿越]]></title>
    <url>%2F2019%2F05%2F10%2Fbzoj-5477-%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A%2F</url>
    <content type="text"><![CDATA[$dfs$ 序 + 树状数组. 由于路径的权是点权,可以考虑每个点被多少条路径经过,乘上它的点权即为贡献. 假设当前询问是在子树 $p$ 内,考虑一个点 $i$ ,在子树 $i$ 内与不在子树 $i$ 内的点形成了 $siz[i]\cdot (siz[p]-siz[i]+1)$ 条路径,都经过了点 $i$ . 还有一部分路径是将 $i$ 作为 $LCA$ 经过.显然每两个在 $i$ 的不同儿子形成的子树内的点都会经过 $i$ .这部分路径数目可以在 $dfs$ 时利用前缀和算出,记作 $k[i]$ . 由于修改只会单点修改点权,不改变树的形态,把那个 $siz[p]$ 拆出去算,预处理出每个点的剩下的系数. 直接利用 $dfs$ 序,树状数组维护答案. 记 $w[i]=k[i]+siz[i]\cdot (1-siz[u])​$ . 那么每次询问的答案就是子树 $p​$ 内的 $siz[p]\cdot (\sum siz[i]\cdot val[i])+(\sum w[i]\cdot val[i])​$ . 开两个树状数组分别维护前缀 $\sum siz\cdot val$ 与 $\sum siz\cdot w$ 就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int P=1e9+7;int n,m;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct FenwickTree&#123; #define lowbit(x) x&amp;(-x) int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125; void upd(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=add(bit[x],c); &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s=add(s,bit[x]); return s; &#125; int query(int l,int r) &#123; return add(sum(r),P-sum(l-1)); &#125;&#125;;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int siz[MAXN],dfn[MAXN],idx=0;int k[MAXN],w[MAXN];void dfs(int u,int fa)&#123; dfn[u]=++idx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); k[u]=add(k[u],mul(siz[v],siz[u])); siz[u]+=siz[v]; &#125; siz[u]++;&#125;FenwickTree T1;//siz*valFenwickTree T2;//w*valvoid init()&#123; for(int i=1;i&lt;=n;++i) &#123; T1.upd(dfn[i],mul(siz[i],val[i])); w[i]=add(k[i],mul(siz[i],P+1-siz[i])); T2.upd(dfn[i],mul(w[i],val[i])); &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; val[i]=1; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; val[n]=1; dfs(1,0); init(); while(m--) &#123; int op=read(); if(op==1) &#123; int p=read(),x=read(); T1.upd(dfn[p],mul(siz[p],x)); T2.upd(dfn[p],mul(w[p],x)); &#125; else &#123; int p=read(); int ans=T2.query(dfn[p],dfn[p]+siz[p]-1); ans=add(ans,mul(siz[p],T1.query(dfn[p],dfn[p]+siz[p]-1))); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5476 位运算]]></title>
    <url>%2F2019%2F05%2F09%2Fbzoj-5476-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[树状数组. 如果直接离散化 + 莫队,时间复杂度 $O(m\sqrt n)$ ,无法通过. 如果在计算异或和时,一个数在区间内出现了 $k$ 次,使最后一次不计入贡献,那么就只算了 $k-1$ 次. 这样得到的答案就是出现偶数次的数的异或和. 将询问离线,并按照 $r$ 排序,于是可以从前往后一个个加入数.加入一个数 $a_i$ 后,就处理所有 $r=i$ 的询问. 每次加入数 $x$ 时,在它的上一次出现的位置(若有)加入贡献即可.用树状数组维护前缀异或和. $bzoj$ 上数据有点毒.还需要开 $long\ long$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;ll a[MAXN],A[MAXN];int n,m,tot;ll res[MAXN];struct qry&#123; int l,r; int id; bool operator &lt; (const qry &amp;rhs) const &#123; return r==rhs.r?l&lt;rhs.l:r&lt;rhs.r; &#125;&#125;q[MAXN];#define lowbit(x) x&amp;(-x)ll bit[MAXN];void add(int x,ll c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]^=c;&#125;ll sum(int x)&#123; ll s=0; for(;x&gt;0;x-=lowbit(x)) s^=bit[x]; return s;&#125;ll query(int l,int r)&#123; return sum(r)^sum(l-1);&#125;int lstpos[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); tot=unique(A+1,A+1+n)-A-1; m=read(); for(int i=1;i&lt;=m;++i) &#123; q[i].l=read(),q[i].r=read(); q[i].id=i; &#125; sort(q+1,q+1+m); for(int i=1,j=1;i&lt;=n;++i) &#123; int x=lower_bound(A+1,A+1+tot,a[i])-A; if(lstpos[x]) add(lstpos[x],A[x]); lstpos[x]=i; for(;j&lt;=m &amp;&amp; q[j].r==i;++j) res[q[j].id]=query(q[j].l,q[j].r); &#125; for(int i=1;i&lt;=m;++i) printf("%lld\n",res[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>位运算</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5496 字符串问题]]></title>
    <url>%2F2019%2F05%2F09%2Fbzoj-5496-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$SAM$ 优化连边 + $DAG$ 上 $dp$ . 首先可以搞一个 $n_a+n_b$ 个节点的图.如果一个 $A$ 串支配了一个 $B$ 串,就从这个 $A$ 串对应的点向 $B$ 串对应的点连一条有向边.如果一个 $B$ 串是一个 $A$ 串的前缀,就从这个 $B$ 串对应的点向 $A$ 串对应的点连一条有向边. 然后判环,如果没有环就在 $DAG$ 上 $dp$ 找最长路径.节点数目为 $O(n_a+n_b)$ ,可以接受. 但是暴力连边的时间复杂度高达 $O(n_an_b)$ ,于是获得 $40$ 分好成绩. 考虑利用 $SAM$ 的 $parent$ 树自带的树形结构来优化连边. 第一类边,对于一个 $A$ 串,我们可以在 $SAM$ 上倍增找到它对应的节点,然后对于每个它支配的 $B$ 串也用倍增找到节点,从 $A$ 串节点向 $B$ 串节点连一条有向边. 第二类边,要求 $B$ 串是 $A$ 串前缀.我们如果把主串反过来,就变成了 $B$ 串是 $A$ 串的后缀.在 $parent$ 树上显然表现为 $B$ 对应的节点是 $A$ 对应的节点的祖先.那么建 $parent$ 树时就从父亲到儿子连有向边,边自动就连好了. 这样连边的时间复杂度为 $O(|S|log|S|)$ ,节点数目为 $O(|S|)$ ,均可以接受. 但还存在一个问题. $parent$ 树上一个节点对应的子串不止一个.可能出现两个 $A$ 串都被定位到一个节点上.于是每次 $A$ 串定位到一个位置时就新建一个节点栽上去.新建 $n_a​$ 个节点,不会爆炸. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;const int Siz=26,MAXN=1e6+10;int lst,idx,tmp;int n,m,K;int siz[MAXN],pos[MAXN];int ch[MAXN][Siz],fa[MAXN];int len[MAXN];void Extend(int c,int id)&#123; int p=lst,np=++idx; lst=np; pos[id]=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int L;int Lg[MAXN];int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],eval[MAXN],indeg[MAXN];ll dp[MAXN];int val[MAXN],dep[MAXN],g[MAXN];vector&lt;pii&gt; d[MAXN];vector&lt;int&gt; v[MAXN];set&lt;pii&gt; s;int l[MAXN],r[MAXN],p[MAXN];int A[MAXN],t[MAXN];void topsort()&#123; for(int i=1;i&lt;=idx;++i) t[len[i]]++; for(int i=1;i&lt;=L;++i) t[i]+=t[i-1]; for(int i=idx;i&gt;=1;--i) A[t[len[i]]--]=i; for(int i=1;i&lt;=idx;++i) &#123; int u=A[i]; dep[u]=dep[fa[u]]+1; v[fa[u]].push_back(u); &#125; for(int i=1;i&lt;=L;++i) t[i]=0;&#125;inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; ++indeg[v]; eval[ecnt]=w; head[u]=ecnt;&#125;const int Logn=20;int f[MAXN][Logn];int jump(int u,int l)&#123; for(int i=Lg[dep[u]];i&gt;=0;--i) if(len[f[u][i]]&gt;=l) u=f[u][i]; pii t=make_pair(u,l); if(s.find(t)==s.end()) &#123; g[u]++; s.insert(t); &#125; return u;&#125;void dfs(int u,int Fa)&#123; if(Fa) addedge(Fa,u,0); int h=0; sort(d[u].begin(),d[u].end()); if(d[u].size()) &#123; p[d[u][0].second]=u; for(int i=1;i&lt;d[u].size();++i) &#123; if(d[u][i].first!=d[u][i-1].first) &#123; h=i; break; &#125; p[d[u][i].second]=u; &#125; &#125; int pre=u; while(g[u]&gt;1) &#123; ++idx; --g[u]; p[d[u][h].second]=idx; for(int i=h+1;i&lt;d[u].size();++i) &#123; if(d[u][i].first!=d[u][i-1].first) &#123; h=i; break; &#125; p[d[u][i].second]=idx; &#125; addedge(pre,idx,0); pre=idx; &#125; for(int i=0;i&lt;v[u].size();++i) dfs(v[u][i],pre);&#125;char buf[MAXN];void init()&#123; s.clear(); ecnt=0; for(int i=1;i&lt;=idx;++i) &#123; dep[i]=0; head[i]=0; indeg[i]=0; dp[i]=0; val[i]=0; &#125; for(int i=1;i&lt;=tmp;++i) &#123; v[i].clear(); d[i].clear(); memset(ch[i],0,sizeof ch[i]); fa[i]=0; g[i]=0; &#125; lst=idx=1;&#125;int q[MAXN];void solve()&#123; scanf("%s",buf+1); L=strlen(buf+1); for(int i=L;i&gt;=1;--i) Extend(buf[i]-'a',i); topsort(); for(int i=2;i&lt;=idx;++i) f[i][0]=fa[i]; for(int j=1;j&lt;=Lg[L];++j) for(int i=2;i&lt;=idx;++i) f[i][j]=f[f[i][j-1]][j-1]; n=read(); for(int i=1;i&lt;=n;++i) &#123; l[i]=read(); r[i]=read(); p[i]=jump(pos[l[i]],r[i]-l[i]+1); &#125; m=read(); for(int i=n+1;i&lt;=n+m;++i) &#123; l[i]=read(); r[i]=read(); p[i]=jump(pos[l[i]],r[i]-l[i]+1); &#125; for(int i=1;i&lt;=n+m;++i) d[p[i]].push_back(make_pair(r[i]-l[i]+1,i)); tmp=idx; dfs(1,0); for(int i=1;i&lt;=n;++i) val[p[i]]=r[i]-l[i]+1; K=read(); for(int i=1;i&lt;=K;++i) &#123; int x=read(),y=read(); addedge(p[x],p[y+n],r[x]-l[x]+1); &#125; int tot=0; ll ans=0; q[++tot]=1; for(int i=1;i&lt;=tot;++i) &#123; int U=q[i]; ans=max(ans,dp[U]+val[U]); for(int j=head[U];j;j=nx[j]) &#123; int V=to[j]; indeg[V]--; dp[V]=max(dp[V],dp[U]+eval[j]); if(!indeg[V]) q[++tot]=V; &#125; &#125; if(tot&lt;idx) puts("-1"); else printf("%lld\n",ans);&#125;int main()&#123; for(int i=2;i&lt;MAXN;++i) Lg[i]=Lg[i&gt;&gt;1]+1; int T=read(); while(T--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
        <tag>SAM</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5358 快速查询]]></title>
    <url>%2F2019%2F05%2F08%2FLuogu-5358-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[乱搞 $STL$ + 线性筛乘法逆元. 乱搞 $STL$ + 线性筛乘法逆元. 因为只有 $10^5$ 种操作,所以被单独赋值的位置最多也就 $10^5$ 个,这些可以开 $map$ 记录,其他位置可以整体维护. 维护 $mul,add,sum,v$ 四个标记, $mul,add$ 表示 $map$ 中存储的值为 $x$ ,实际上是 $mul\cdot x+add$ . $sum$ 表示当前所有元素的和. $v$ 表示不在 $map​$ 中的数统一的值. 初始 $mul=1,add=sum=v=0.​$ 几种操作仔细推一下就好了: 操作 $1$ :先用操作 $5$ 查询 $a_i$ ,算出新的 $sum$ ,再将 $map$ 中位置 $i$ 改为 $(val-add)\cdot mul^{-1}$ . 操作 $2$ : $sum+=val\cdot n,add+=val,v+=val.$ 操作 $3$ : 若 $val\not = 0,sum\times =val,mul\times =val,add\times =val,v\times =val.$ 若 $val=0$ ,执行操作 $4$ ,将所有值都赋为 $0$,否则会使 $mul=0$ ,要用到 $mul^{-1}​$ 时就炸了 . 操作 $4$ : 将 $map$ 清空, $sum=val\cdot n,mul=1,add=0,v=val$ . 操作 $5$ : 若 $a_i$ 在 $map$ 中有权值 $x$ ,那么就是 $mul\cdot x+add$ ,否则为 $v$ . 操作 $6$ : 当前的 $sum​$ . $O(P)$ 预处理乘法逆元,并使用 $unordered$_$map$ ,时间复杂度即为 $O(tq)$ .123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e7+19;int inv[P+10];void init()&#123; inv[1]=1; for(int i=2;i&lt;P;++i) &#123; inv[i]=1LL*(P-P/i)*inv[P%i]%P;// assert(1LL*inv[i]*i%P==1); &#125;&#125;inline int Add(int a,int b)&#123; return (a+b)%P;&#125;inline int Mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10;unordered_map&lt;int,int&gt; mp;int n,q,t;int opt[MAXN],qx[MAXN],qy[MAXN];int add=0,mul=1,sum=0,v=0;int ans=0;int query(int x)&#123; if(mp.find(x)!=mp.end()) &#123; int key=mp[x]; return Add(add,Mul(key,mul)); &#125; else return v;&#125;void operate(int id)&#123; int val,op=opt[id],i; if(op==1) &#123; i=qx[id]; val=qy[id]; int org=query(i); sum=Add(sum,val-org); mul=Add(mul,P); int curv=Mul(inv[mul],Add(val,-add)); mp[i]=curv; return; &#125; if(op==2) &#123; val=qx[id]; sum=Add(sum,Mul(val,n)); add=Add(add,val); v=Add(v,val); return; &#125; bool trans=false; if(op==3) &#123; val=qx[id]; if(val) &#123; sum=Mul(sum,val); mul=Mul(mul,val); add=Mul(add,val); v=Mul(v,val); return; &#125; else op=4,trans=true; &#125; if(op==4) &#123; val=trans?0:qx[id]; mp.clear(); sum=Mul(val,n); mul=1,add=0; v=val; return; &#125; if(op==5) &#123; i=qx[id]; ans=Add(ans,query(i)); return; &#125; if(op==6) &#123; ans=Add(ans,sum); return; &#125;&#125;int main()&#123; init(); n=read(),q=read(); for(int i=1;i&lt;=q;++i) &#123; opt[i]=read(); if(opt[i]!=6) qx[i]=read(); if(opt[i]==1) qy[i]=read(); &#125; t=read(); while(t--) &#123; int a=read(),b=read(); for(int j=1;j&lt;=q;++j) operate((a+1LL*j*b)%q+1); &#125; printf("%d\n",(ans%P+P)%P); return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1149]]></title>
    <url>%2F2019%2F05%2F07%2FCF1149%2F</url>
    <content type="text"><![CDATA[$Div.1$ CF1149A Prefix Sum Primes 构造 + 贪心. 可以先线性筛预处理一个质数表.于是就变成了用一定数量的 $1,2​$ 来填每个位置差分的值. 从前往后填,如果当前能放 $2​$ 的话肯定不会劣于放两个 $1​$ .于是能放 $2​$ 就放,否则放 $1​$ ,直到放完为止. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int prime[MAXN],cnt=0,ism[MAXN];void init(int N)&#123; ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=N;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int bgs[3];void solve()&#123; for(int i=1;i&lt;=cnt;++i) &#123; int dif=prime[i]-prime[i-1]; int us2=min(bgs[2],dif/2); for(int j=1;j&lt;=us2;++j) printf("2 "); bgs[2]-=us2; dif-=2*us2; int us1=min(bgs[1],dif); for(int j=1;j&lt;=us1;++j) printf("1 "); bgs[1]-=us1; if(bgs[1]+bgs[2]==0) return; &#125;&#125;int main()&#123; init(1000000); int n=read(); for(int i=1;i&lt;=n;++i) bgs[read()]++; solve(); return 0;&#125; CF1149B Three Religions 贪心 + $dp$ . 首先可以发现如果三个串匹配到了一定位置,最后在原串中用的字符位置肯定越靠前越好. 于是可以设 $f(i,j,k)$ 表示三个串分别匹配了 $i,j,k$ 的长度时,最后用的字符在原串中的位置. 可以预处理 $nx(i,j)$ 表示原串中第 $i$ 个字符往后跳,跳到的第一个字符为 $j$ 的位置.跳不到设为 $n+1$ .那么就可以借助 $nx$ 来完成 $f$ 的转移. 那么计算完成后,只需要判断 $f(len_1,len_2,len_3)\leq n$ 是否成立.成立则为 $YES$ ,否则为 $NO$ . 并不能 $O(q\cdot 250^3)$ 暴力 $dp$ .注意每次加一个字符时(假定加在第一个串上),前面的 $dp$ 值不会被影响,只需计算 $f(len_1+1,j,k)$ 这 $250^2$ 个状态.每次删字符时直接让 $len$ 减 $1$ 就可以了.下次会覆盖掉多余的值. 时间复杂度 $O(q\cdot 250^2)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,L=251;const int Siz=26;char buf[MAXN];int n,Q,nx[MAXN][Siz];int minpos[Siz];int f[L][L][L];int len[4];int s[4][L];int main()&#123; n=read(); Q=read(); scanf("%s\n",buf+1); for(int i=0;i&lt;Siz;++i) minpos[i]=n+1; buf[0]='a'; for(int i=n+1;i&gt;=0;--i) &#123; memcpy(nx[i],minpos,sizeof minpos); minpos[buf[i]-'a']=i; &#125; f[0][0][0]=0; while(Q--) &#123; char tp[2],newchar[2]; int id; scanf("%s%d",tp,&amp;id); if(tp[0]=='+') &#123; scanf("%s",&amp;newchar); s[id][++len[id]]=newchar[0]-'a'; if(id==1) &#123; for(int i=len[1];i&lt;=len[1];++i) for(int j=0;j&lt;=len[2];++j) for(int k=0;k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; else if(id==2) &#123; for(int i=0;i&lt;=len[1];++i) for(int j=len[2];j&lt;=len[2];++j) for(int k=0;k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; else &#123; for(int i=0;i&lt;=len[1];++i) for(int j=0;j&lt;=len[2];++j) for(int k=len[3];k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; &#125; else --len[id]; puts(f[len[1]][len[2]][len[3]]&lt;=n?"YES":"NO"); &#125; return 0;&#125; CF1149C Tree Generator™ 给的括号序列就是一个欧拉序(进出都记录). 容易处理出每个点的 $dep​$ ,遇见 $(​$ 就 $+1​$ ,否则 $-1​$ . 考虑两个点的距离为 $dep_u+dep_v-2dep_{lca}​$ ,在欧拉序中.和用 $RMQ​$ 做 $LCA​$ 一样,两个点的 $lca​$ 一定位于这两个点的中间,且深度最小. 那么找直径就转化为找三个位置 $u\leq lca\leq v$ ,使得 $dep_u+dep_v-2dep_{lca}$ 最大. 每次修改交换两个括号,中间那一段 $dep$ 都会 $+2/-2$ .于是用线段树维护每个位置的 $dep$ , $dep_l-2dep_i$ , $dep_r-2dep_i$ 的 $max$ 即可. 注意合并节点,标记的细节. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,Q;int dep[MAXN];struct SegTree&#123; struct node &#123; int res;//dep[l]+dep[r]-2dep[i] int tag; int mxdep,negdep;//dep[i],-2dep[i] int ldep,rdep;//dep[l]-2dep[i],dep[r]-2dep[i] &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mxdep=max(lson.mxdep,rson.mxdep); root.negdep=max(lson.negdep,rson.negdep); root.ldep=max(lson.ldep,rson.ldep); root.ldep=max(root.ldep,lson.mxdep+rson.negdep); root.rdep=max(lson.rdep,rson.rdep); root.rdep=max(root.rdep,lson.negdep+rson.mxdep); root.res=max(lson.res,rson.res); root.res=max(root.res,lson.mxdep+rson.rdep); root.res=max(root.res,lson.ldep+rson.mxdep); &#125; void BuildTree(int o,int l,int r) &#123; root.tag=0; if(l==r) &#123; root.mxdep=dep[l]; root.negdep=-2*dep[l]; root.rdep=root.ldep=-dep[l]; root.res=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.mxdep+=c; root.negdep-=2*c; root.ldep-=c; root.rdep-=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void update(int o,int l,int r,int L,int R,int c) &#123; if(L&gt;r || l&gt;R || L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125;&#125;T;#define pr printf("%d\n",T.Tree[1].res);char buf[MAXN];int main()&#123; n=read(),Q=read(); scanf("%s",buf+1); for(int i=1;i&lt;=2*n-2;++i) &#123; dep[i]=dep[i-1]; if(buf[i]=='(') ++dep[i]; else --dep[i]; &#125; T.BuildTree(1,1,2*n-2); pr; while(Q--) &#123; int L=read(),R=read(); if(L&gt;R) swap(L,R); if(buf[L]=='(') T.update(1,1,2*n-2,L,R-1,-2); else T.update(1,1,2*n-2,L,R-1,2); pr; swap(buf[L],buf[R]); &#125; return 0;&#125; CF1149D Abandoning Roads 最小生成树 + 状压 $dp$. 用 $kruskal$ 做最小生成树的时候,会先考虑权值为 $a$ 的边,那么可以先预处理出由 $a$ 边连接出的联通块. 从 $1$ 到 $p$ 跑最短路,每条 $b$ 边会连接两个联通块,将联通块状压,就可以记录哪些联通块已经走过了. 注意到对一个点数 $\leq 3$ 的联通块,不可能进入它后再走出去,因为这样的长度至少为 $2b$ ,而它内部长度最长才 $2a$ .所以可以不记这些联通块.状态数目在 $O(2^{n/4}m)$ 级别,就可以直接做了. CF1149E Election Promises 博弈论. 结论: $SG_u=mex(SG_v),sum(x)=\oplus_{SG_i=x}h_i$ , $\oplus$ 表示异或和.先手能胜,当且仅当 $\exists x ,sum(x)\not=0​$ . 如果所有的 $sum$ 都为 $0$ ,那么先手随意操作一次,都会使得有 $sum$ 变为非 $0$ .然后后手再操作一次,所有 $sum$ 又可以被修改为 $0$ :找到最大的 $x$ , $sum(x)&gt;0$ 进行修改.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>博弈论</tag>
        <tag>状压dp</tag>
        <tag>dfs序</tag>
        <tag>最小生成树</tag>
        <tag>自动机dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2286 消耗战]]></title>
    <url>%2F2019%2F05%2F06%2Fbzoj-2286-%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[虚树 + 树形 $dp$ . 考虑最暴力的树形 $dp$.设 $f_u$ 表示使得子树 $u$ 中所有关键点都与 $1$ 断开的最小代价. 那么对于 $u$ 的所有儿子 $v$ ,如果 $v$ 是关键点,代价为 $val(u,v)$ ,否则为 $min(val(u,v),f_v)$ . $f_u$ 就是所有儿子的代价之和,最终答案即为 $f_1$ . 这样暴力 $dp$ 是 $O(nm)$ 的,无法通过.但注意到关键点数目总和 $\sum k\leq 5\times 10^5$ ,所以可以使用 虚树 进行处理. 虚树 就是新建出的一颗树,只保留原树中所有关键节点与它们所有的 $LCA$ ,而原图中其它的链被简化成边或点. 这样一颗 虚树 的节点数目不会超过 $2k-1$.因为 $k$ 个关键节点所有不同的 $LCA$ 最多 $k-1$ 个. 构造时,先在原树中预处理 $dfs$ 序,子树大小 $siz$ ,并预处理倍增数组,以快速查找 $LCA$ 以及一条链上最小边. 然后将所有关键点加入一个数组中,按照 $dfs$ 序排序,再将相邻两个点的 $LCA$ 也放入数组中,再放入 $1$ . 再按照 $dfs$ 序排序,去重,就得到了我们在虚树上的 $dfs$ 遍历顺序.按照这个顺序进行 $dfs$ ,判断下个点是继续$dfs$ 还是回溯回来,只需用预处理的 $dfs$ 序和 $siz$ 判断下个点是否在当前的子树中. 在虚树上 $dfs$ 的同时像原来一样进行树形 $dp$ .不过虚树中两个点的边在原图中实际是一条链.在虚树中直接割断两个点的花费是连接这两个点的链上所有边的最小边权.用预处理的倍增数组进行查询即可. 时间复杂度 $O(\sum klogk)$ . 开始写的时候预处理倍增数组居然没有按拓扑序,而是直接按照节点编号顺序处理.这样居然还能有 $90pts$ .出计数不好吗,非要出最优化让人水过去. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=250010;int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; val[ecnt]=w; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,k;int tid=0,marked[MAXN];int fa[MAXN][20],minc[MAXN][20];void init()&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=19;++j) &#123; fa[i][j]=fa[fa[i][j-1]][j-1]; minc[i][j]=min(minc[i][j-1],minc[fa[i][j-1]][j-1]); &#125;&#125;int dfsidx=0,dfn[MAXN],siz[MAXN],dep[MAXN];void dfs(int u,int f)&#123; siz[u]=1; dep[u]=dep[f]+1; dfn[u]=++dfsidx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; fa[v][0]=u; minc[v][0]=val[i]; dfs(v,u); siz[u]+=siz[v]; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;--i) if(dep[x]-(1&lt;&lt;i)&gt;=dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int minval(int x,int lca)&#123; int res=1e9; for(int i=19;i&gt;=0;--i) if(dep[x]-(1&lt;&lt;i)&gt;=dep[lca]) &#123; res=min(res,minc[x][i]); x=fa[x][i]; &#125; return res;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;int q[MAXN&lt;&lt;1],tot;int id;ll f[MAXN];void dfs_vtree()&#123; int u=q[id]; f[u]=1e18; ll res=0; while(1) &#123; if(id==tot) break; if(dfn[q[id+1]]&lt;=dfn[u]+siz[u]-1) &#123; int v=q[++id]; if(marked[v]==tid) &#123; dfs_vtree(); f[v]=minval(v,u); &#125; else &#123; dfs_vtree(); f[v]=min(f[v],1LL*minval(v,u)); &#125; res+=f[v]; &#125; else break; &#125; if(res) f[u]=min(f[u],res);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs(1,0); init(); m=read(); while(m--) &#123; tot=0; k=read(); ++tid; for(int i=1;i&lt;=k;++i) &#123; int x=read(); marked[x]=tid; q[++tot]=x; &#125; sort(q+1,q+1+tot,cmp); for(int i=1;i&lt;k;++i) q[++tot]=LCA(q[i],q[i+1]); q[++tot]=1; sort(q+1,q+1+tot,cmp); tot=unique(q+1,q+1+tot)-q-1; id=1; dfs_vtree(); printf("%lld\n",f[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4556 字符串]]></title>
    <url>%2F2019%2F05%2F04%2Fbzoj-4556-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 倍增 + 线段树合并. 这里有两个小性质需要注意. 答案是可二分的.这个应该比较显然. 两个子串的最长公共后缀就是它们在 $SAM$ 上状态节点 $LCA$ 的 $maxlen$ .想象两个串都从前往后缩短,当两者缩到同一个串,即公共后缀时,节点也跳到了它们的 $LCA$ .长度即为 $maxlen$ . 于是把整个串翻转,询问前缀相关问题就变成了询问后缀相关问题.询问时,可以二分答案 $x$ ,转化为判定问题. 从 $d$ 对应的位置用倍增往上跳,找到 $maxlen\geq x$ 的 $dep$ 最小的祖先(其 $right$ 集合最大,为最优),判断它的 $right$ 集合中是否出现了 $[a+x-1,b]$ 中的某个位置. 如果出现了,那么从这个位置往前的 $x$ 个字符就是要找的子串,否则就找不到. 可以看出 $c$ 的作用就是限制了二分答案 $x$ 的范围,显然不能超过 $d-c+1$ 与 $b-a+1​$ . 一个点的 $right$ 集合是它所有儿子节点 $right$ 集合的并集.所以可以用线段树合并来维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e5+10;int lst=1,idx=1;int n,m;int siz[MAXN],pos[MAXN],leafright[MAXN];int ch[MAXN][Siz],fa[MAXN];int len[MAXN];void Extend(int c,int id)&#123; int p=lst,np=++idx; lst=np; pos[id]=np; leafright[np]=id; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int tot=0;struct node&#123; int sum,ls,rs;&#125;Tree[MAXN*30];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void update(int &amp;o,int l,int r,int pos)&#123; o=++tot; ++root.sum; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(root.ls,l,mid,pos); else update(root.rs,mid+1,r,pos);&#125;void pushup(int o)&#123; root.sum=lson.sum+rson.sum;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; int o=++tot; root.ls=merge(Tree[x].ls,Tree[y].ls); root.rs=merge(Tree[x].rs,Tree[y].rs); pushup(o); return o;&#125;int query(int o,int l,int r,int L,int R)&#123; if(L&gt;r || l&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res;&#125;int f[MAXN][18];int rt[MAXN];void mergeright(int u)&#123; f[u][0]=fa[u]; for(int i=1;i&lt;=17;++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; mergeright(v); rt[u]=merge(rt[u],rt[v]); &#125;&#125;bool check(int x,int L,int R,int u)&#123; if(!x) return true; if(L&gt;R) return false; for(int i=17;i&gt;=0;--i) if(len[f[u][i]]&gt;=x) u=f[u][i]; return query(rt[u],1,n,L,R)&gt;0;&#125;char buf[MAXN];int main()&#123; n=read(),m=read(); scanf("%s",buf+1); for(int i=1;i&lt;(n+1-i);++i) swap(buf[i],buf[n+1-i]); for(int i=1;i&lt;=n;++i) Extend(buf[i]-'a',i); for(int i=1;i&lt;=idx;++i) addedge(fa[i],i); for(int i=1;i&lt;=idx;++i) if(leafright[i]) update(rt[i],1,n,leafright[i]); mergeright(1); while(m--) &#123; int a=read(),b=read(),c=read(),d=read(); swap(a,b),swap(c,d); a=n+1-a,b=n+1-b,c=n+1-c,d=n+1-d; int L=0,R=min(d-c+1,b-a+1); int res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid,a+mid-1,b,pos[d])) res=max(res,mid),L=mid+1; else R=mid-1; &#125; printf("%d\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>倍增</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2555 substring]]></title>
    <url>%2F2019%2F05%2F04%2Fbzoj-2555-substring%2F</url>
    <content type="text"><![CDATA[$SAM+LCT$ . 如果没有修改,就直接建出 $SAM$ ,询问时从根出发走到对应状态,该状态的 $siz$ 即为答案. 现在要支持修改,沿用上面思路,只不过要动态维护 $parent$ 树的形态,需要加边,删边. 套一个 $LCT$ 进行维护就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e6+10;int lst=1,idx=1;int siz[MAXN],tag[MAXN];int stk[MAXN],tp=0;struct Link_Cut_Tree&#123; struct node &#123; int ch[2],fa; node()&#123;ch[0]=ch[1]=fa=0;&#125; &#125;Tree[MAXN];#define root Tree[x] bool isroot(int x) &#123; return Tree[root.fa].ch[0]!=x &amp;&amp; Tree[root.fa].ch[1]!=x; &#125; void modifiy(int x,int c) &#123; if(x) &#123; siz[x]+=c; tag[x]+=c; &#125; &#125; void pushdown(int x) &#123; if(tag[x]) &#123; modifiy(root.ch[0],tag[x]); modifiy(root.ch[1],tag[x]); tag[x]=0; &#125; &#125; void rotate(int x) &#123; int y=Tree[x].fa; int z=Tree[y].fa; if(!isroot(y)) Tree[z].ch[Tree[z].ch[1]==y]=x; Tree[x].fa=z; int k=(x==Tree[y].ch[1]); Tree[y].ch[k]=Tree[x].ch[k^1]; Tree[Tree[x].ch[k^1]].fa=y; Tree[x].ch[k^1]=y; Tree[y].fa=x; &#125; void splay(int x) &#123; stk[++tp]=x; for(int pos=x;!isroot(pos);pos=Tree[pos].fa) stk[++tp]=Tree[pos].fa; while(tp) pushdown(stk[tp--]); while(!isroot(x)) &#123; int y=Tree[x].fa; int z=Tree[y].fa; if(!isroot(y)) (Tree[z].ch[0]==y)^(Tree[y].ch[0]==x)?rotate(x):rotate(y); rotate(x); &#125; &#125; void Access(int x) &#123; for(int y=0;x;y=x,x=Tree[x].fa) &#123; splay(x); Tree[x].ch[1]=y; &#125; &#125; void link(int x,int y) &#123; Tree[x].fa=y; Access(y); splay(y); modifiy(y,siz[x]); &#125; void cut(int x) &#123; Access(x); splay(x); modifiy(Tree[x].ch[0],-siz[x]); Tree[x].ch[0]=Tree[Tree[x].ch[0]].fa=0; &#125;&#125;LCT;struct SuffixAutoMation&#123; int ch[MAXN][Siz],fa[MAXN]; int len[MAXN]; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) &#123; fa[np]=1; LCT.link(np,1); &#125; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) &#123; fa[np]=q; LCT.link(np,q); &#125; else &#123; int nq=++idx; len[nq]=len[p]+1; LCT.link(nq,fa[q]); LCT.cut(q); LCT.link(q,nq); LCT.link(np,nq); fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125;&#125;SAM;int L;char buf[MAXN];void getinfo(int mask)&#123; scanf("%s",buf); L=strlen(buf); for(int i=0; i&lt;L; ++i) &#123; mask=(mask*131+i) % L; swap(buf[i],buf[mask]); &#125;&#125;int mask=0;int main()&#123; int Q=read(); scanf("%s",buf); L=strlen(buf); for(int i=0;i&lt;L;++i) SAM.Extend(buf[i]-'A'); while(Q--) &#123; scanf("%s",buf); if(buf[0]=='A') //Add &#123; getinfo(mask); for(int i=0;i&lt;L;++i) SAM.Extend(buf[i]-'A'); &#125; else //Query &#123; getinfo(mask); int p=1; for(int i=0;i&lt;L;++i) &#123; p=SAM.ch[p][buf[i]-'A']; &#125; if(!p) puts("0"); else &#123; LCT.splay(p); printf("%d\n",siz[p]); mask^=siz[p]; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>LCT</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190504]]></title>
    <url>%2F2019%2F05%2F04%2Ftest20190504%2F</url>
    <content type="text"><![CDATA[据说 是 $noip$ 难度. 题面 $find$ 比较简单.按照 $x$ 坐标排序后,就是以 $y$ 坐标为关键字做一个 $LIS​$ . $O(nlogn)​$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=x*10+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=1e6+10;int n=0,my,y[MAXN],Y[MAXN];pair&lt;int,int&gt; p[MAXN];int bit[MAXN];#define lowbit(x) x&amp;(-x)inline void add(int x,int c)&#123; for(; x&lt;=my; x+=lowbit(x)) bit[x]=max(bit[x],c);&#125;inline int sum(int x)&#123; int s=0; for(; x; x-=lowbit(x)) s=max(s,bit[x]); return s;&#125;int main()&#123; freopen("find.in","r",stdin); freopen("find.out","w",stdout); int N=read(); for(int i=1; i&lt;=N; ++i) &#123; int a=read(),b=read(); if(a&lt;0 || b&lt;0) continue; ++n; p[n].first=a; Y[n]=y[n]=b; &#125; sort(Y+1,Y+1+n); my=unique(Y+1,Y+1+n)-Y-1; for(int i=1; i&lt;=n; ++i) p[i].second=lower_bound(Y+1,Y+1+my,y[i])-Y; sort(p+1,p+1+n); int ans=0; for(int i=1; i&lt;=n; ++i) &#123; int ky=p[i].second; int mx=sum(ky); ans=max(ans,mx+1); add(ky,mx+1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; $walk$ 是个套路题. 标算套路:因为询问给出的 $v$ 最大是 $10^{18}$ ,所以走不为 $1$ 的边,最多走 $60$ 次就会变成 $0$ . 于是只需要用并查集把边权为 $1$ 连接的两个点并在一起,然后跳的时候暴力跳,跳成 $0$ 或者到终点就退出. 这样最多跳 $60$ 次,而且大多数时候跳不满,所以可以过. 我的做法相当假.注意到这个操作是可合并的,直接树剖 + 线段树维护区间边权乘积. 但是区间乘积可能会爆掉 $long\ long$ . 于是每次 $pushup$ 的时候都让乘积与 $0$ 取 $max$ .这样一段爆掉的区间乘积(大概率)是 $0$ .跳的时候遇到了就直接输出 $0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=x*10+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=2e5+10;int n,Q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],fa[MAXN];int dep[MAXN];inline void addedge(int u,int v,ll w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll wp[MAXN];int dfn[MAXN],dfnidx=0,rnk[MAXN],siz[MAXN],mxson[MAXN],top[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; dep[u]=dep[f]+1; for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++dfnidx; rnk[dfnidx]=u; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v!=mxson[u] &amp;&amp; v!=fa[u]) dfs2(v,v); &#125;&#125;ll prod[MAXN&lt;&lt;2];#define root prod[o]#define lson prod[o&lt;&lt;1]#define rson prod[o&lt;&lt;1|1]void pushup(int o)&#123; root=lson*rson; root=max(root,0LL);&#125;void bd(int o,int l,int r)&#123; if(l==r) &#123; root=wp[rnk[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(o&lt;&lt;1,l,mid); bd(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void update(int o,int l,int r,int pos,ll c)&#123; if(l==r) &#123; root=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(o&lt;&lt;1,l,mid,pos,c); else update(o&lt;&lt;1|1,mid+1,r,pos,c); pushup(o);&#125;ll query(int o,int l,int r,int L,int R)&#123; ll res=1; if(l&gt;R || L&gt;r) return 1; if(L&lt;=l &amp;&amp; r&lt;=R) return max(0LL,root); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) &#123; res*=query(o&lt;&lt;1,l,mid,L,R); res=max(res,0LL); &#125; if(R&gt;mid) &#123; res*=query(o&lt;&lt;1|1,mid+1,r,L,R); res=max(res,0LL); &#125; return res;&#125;void solve()&#123; int idx=n; for(int i=1; i&lt;n; ++i) &#123; int u=read(),v=read(); ll w=read(); ++idx; addedge(u,idx,0); addedge(idx,u,0); addedge(idx,v,0); addedge(v,idx,0); wp[idx]=w; &#125; for(int i=1; i&lt;=n; ++i) wp[i]=1; dfs1(1,0); dfs2(1,1); bd(1,1,idx); while(Q--) &#123; int tp=read(); if(tp==1) &#123; int x=read(),y=read(); ll v=read(); while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ll p=query(1,1,idx,dfn[top[x]],dfn[x]); if(p&lt;=0) &#123; puts("0"); continue; &#125; v/=p; x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); ll p=query(1,1,idx,dfn[y],dfn[x]); if(p&lt;=0) &#123; puts("0"); continue; &#125; v/=p; printf("%lld\n",v); &#125; else &#123; int p=read(); ll c=read(); update(1,1,idx,dfn[p+n],c); &#125; &#125;&#125;int main()&#123; freopen("walk.in","r",stdin); freopen("walk.out","w",stdout); n=read(); Q=read(); solve(); return 0;&#125; $sunset$ 想出了正确做法,但今天是按照 $5$ 个小时的节奏在打的,实际是 $3.5h$ ,只剩了 $20min$ ,就没写了. 显然每个联通块可以分开做.对于一个联通块,做一颗 $dfs​$ 树,因为是无向图,所以除了树边之外就只有返祖边. 返祖边会形成一个环,如果这个环的大小为偶(通过 $dep​$ 之差判断),显然没有作用.若为奇,就把环上的边都打上标记. 询问时,若 $dep_x,dep_y$ 奇偶性不同,直接走树边长度就是奇数.否则如果两者路径上有被标记的边,走一个奇环再出来,长度也是奇数. 如果两种情况都不满足,就无法找到长度为奇数的路径.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>tarjan</tag>
        <tag>树链剖分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3926 诸神眷顾的幻想乡]]></title>
    <url>%2F2019%2F05%2F03%2Fbzoj-3926-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[广义 $SAM$ . 广义 $SAM$ ,就是在 $Trie$ 树上建 $SAM$ .注意到树上的每个串都可以看成以某个叶子节点为根的 $Trie$ 树上的一条路径. 而叶子节点数 $\leq 20$ ,所以可以以每个叶子节点为根建 $Trie$ 树,建的时候需要注意插入一个点时,将 $lst$ 置为其父亲在 $SAM​$ 上对应的节点. 注意判重,即处理插入一个字符时, $lst$ 对应的转移边已经有点的情况.建好后就是问有多少个不同子串,每个点的贡献都是 $Max-Min+1$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e7+10;const int Siz=10;int n;struct SuffixAutoMation&#123; int idx,lst; SuffixAutoMation()&#123;lst=idx=1;&#125; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN]; int Extend(int p,int c) &#123; if(ch[p][c]) &#123; int q=ch[p][c]; if(len[q]==len[p]+1) lst=q; else &#123; int nq=++idx; lst=nq; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; else &#123; int np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; return lst; &#125; void solve() &#123; ll ans=0; for(int i=2;i&lt;=idx;++i) ans+=len[i]-len[fa[i]]; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;SAM;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],deg[MAXN];void addedge(int u,int v)&#123; ++deg[u]; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int col[MAXN];void dfs(int u,int fa,int lst)&#123; int newlst=SAM.Extend(lst,col[u]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u,newlst); &#125;&#125;int main()&#123; n=read(); int c=read(); for(int i=1;i&lt;=n;++i) col[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==1) dfs(i,0,1); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TJOI2019 选做]]></title>
    <url>%2F2019%2F05%2F02%2FTJOI2019-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[向 $CQOI\ 2018$ 致敬? 甲苯先生的字符串 矩阵快速幂. 板子题.处理相邻两个字符时改一下转移矩阵里的系数就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=26;struct matrix&#123; int v[MAXN][MAXN]; matrix()&#123;memset(v,0,sizeof v);&#125; matrix operator * (const matrix &amp;rhs) const &#123; matrix res; for(int i=0;i&lt;MAXN;++i) for(int j=0;j&lt;MAXN;++j) for(int k=0;k&lt;MAXN;++k) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;matrix fpow(matrix a,ll b)&#123; matrix res; for(int i=0;i&lt;MAXN;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;(1LL)) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;ll n;char buf[100005];int main()&#123; scanf("%lld%s",&amp;n,buf); matrix st,trans; for(int i=0;i&lt;MAXN;++i) st.v[i][0]=1; for(int i=0;i&lt;MAXN;++i) for(int j=0;j&lt;MAXN;++j) trans.v[i][j]=1; int len=strlen(buf); for(int i=1;i&lt;len;++i) &#123; int p=buf[i-1]-'a'; int q=buf[i]-'a'; trans.v[q][p]=0; &#125; st=fpow(trans,n-1)*st; int ans=0; for(int i=0;i&lt;MAXN;++i) ans=add(ans,st.v[i][0]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 甲苯先生的滚榜 平衡树. 又是板子题.随便上个啥平衡树写一下插入,删除,查询排名. 唱、跳、rap 和篮球 顶风作案,律师函警告. 容斥原理+ $dp$ 计数. 为了方便,称题目中所说的一组同学为 位置 $k$ 在讨论蔡徐坤 ,要求出没有位置在讨论蔡徐坤的方案数. 显然可以容斥原理搞一搞,只需对每个 $i$ 求出钦定 $i$ 个位置在讨论蔡徐坤,其它不涉及的位置乱选的方案数. 其它位置乱选方案数就是有重复元素的排列数,但每个元素使用次数有限制.可以构造多项式 $(x+y+z+w)^{tot}$ , $tot=n-4i$ ,将次数符合要求的对应系数求和. 二项式定理套两次,多项式展开为$$\begin{aligned}(x+y+z+w)^{tot}&amp;=\sum C_{tot}^j (x+y)^j(z+w)^{tot-j}\\&amp;=\sum C_{tot}^j(\sum C_j^p x^p y^{j-p})(\sum C_{tot-j}^q z^q w^{tot-j-q})\end{aligned}$$ 预处理组合数前缀和,把 $x,y,z,w​$ 系数都符合限制的那一段取出来计算即可. 考虑怎么求钦定 $i​$ 个位置在讨论蔡徐坤的方案数. 抽象一下就是选出 $i$ 个位置,相邻两个位置之差至少为 $4$ .需要求出每个 $i$ 的方案数. 可以设计一个三维的 $dp​$ ,状态需要记录考虑的数目,选的数目,最后一个选的位置. 注意到最后一个选的位置其实只有四种情况有区别,设 $f(j,i,0/1/2/3)$ 表示已经考虑了前 $j$ 个位置,选了 $i$ 个位置,最后选的位置分别是 $j,j-1,j-2,\leq j-3$ 时的方案数.将 $f(n-3,i,0/1/2/3)$ 求出即可. 时间复杂度 $O(n^2)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void upd(int x,int &amp;y)&#123; y=add(x,y);&#125;const int MAXN=1e3+10;int n,mx;int C[MAXN][MAXN],sumc[MAXN][MAXN];int f[MAXN][MAXN][4];void init()&#123; for(int i=0;i&lt;=n;++i) C[i][0]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); for(int i=0;i&lt;=n;++i) &#123; sumc[i][0]=1; for(int j=1;j&lt;=i;++j) sumc[i][j]=add(sumc[i][j-1],C[i][j]); &#125; f[0][0][3]=1; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=mx;++j) for(int k=0;k&lt;4;++k) &#123; if(!f[i][j][k]) continue; upd(f[i][j][k],f[i+1][j][k==3?k:k+1]); if(k==3) upd(f[i][j][k],f[i+1][j+1][0]); &#125;&#125;int lim[4];int main()&#123; n=read(); for(int i=0;i&lt;4;++i) lim[i]=read(); sort(lim,lim+4); mx=min(lim[0],n/4);//最多mx个位置讨论蔡徐坤 init(); int ans=0,sgn=1; for(int i=0;i&lt;=mx;++i) &#123; int res=0,tmp=0; if(n&lt;4) tmp=1; else &#123; for(int k=0;k&lt;4;++k) tmp=add(tmp,f[n-3][i][k]); &#125; for(int k=0;k&lt;4;++k) lim[k]-=i; int tot=n-i*4; for(int j=0;j&lt;=tot;++j) &#123; int lp=max(0,j-lim[1]); int rp=min(lim[0],j); int lk=max(0,tot-j-lim[3]); int rk=min(lim[2],tot-j); if(lp&gt;rp || lk&gt;rk) continue; int t1=lp?sumc[j][rp]-sumc[j][lp-1]:sumc[j][rp]; int t2=lk?sumc[tot-j][rk]-sumc[tot-j][lk-1]:sumc[tot-j][rk]; res=add(res,mul(C[tot][j],mul(t1,t2))); &#125; res=mul(res,tmp); ans=add(ans,res*sgn); for(int k=0;k&lt;4;++k) lim[k]+=i; sgn*=-1; &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125; 甲苯先生与线段树 位运算,数位 $dp$ . 大概是个原题. 甲苯先生和大中锋的字符串 $SAM$ + 差分. 建出 $SAM$ 后在 $parent$ 树上递推 $right$ 集合的大小,若其为 $k$ ,则对 $[Minlen,Maxlen]$ 内的计数器都加 $1$ . 最后询问一次计数器最大值.可以修改差分,最后求前缀和,就可以做到 $O(n)$ 了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26;const int MAXN=2e5+10;int n,k;int ans,mxt;int dif[MAXN];struct SuffixAutoMation&#123; int lst,idx; int fa[MAXN],siz[MAXN]; int ch[MAXN][Siz],len[MAXN]; int A[MAXN],t[MAXN]; SuffixAutoMation()&#123;lst=idx=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; fa[nq]=fa[q]; fa[q]=fa[np]=nq; for(int i=0;i&lt;Siz;++i) ch[nq][i]=ch[q][i]; len[nq]=len[p]+1; siz[nq]=0; while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=n;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; &#125; void solve() &#123; topsort(); for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; if(siz[u]==k &amp;&amp; u!=1) &#123; int mx=len[u],mi=len[fa[u]]+1; ++dif[mi]; --dif[mx+1]; &#125; &#125; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum+=dif[i]; if(sum&gt;=mxt) mxt=sum,ans=i; &#125; printf("%d\n",mxt==0?-1:ans); &#125; void reset() &#123; for(int i=1;i&lt;=n+1;++i) dif[i]=0; for(int i=0;i&lt;=n;++i) t[i]=0; for(int i=1;i&lt;=idx;++i) memset(ch[i],0,sizeof ch[i]); mxt=0; lst=idx=1; &#125;&#125;SAM;char buf[MAXN];int main()&#123; int T=read(); while(T--) &#123; scanf("%s",buf); n=strlen(buf); scanf("%d",&amp;k); cout&lt;&lt;k&lt;&lt;endl; for(int i=0;i&lt;n;++i) SAM.Extend(buf[i]-'a'); SAM.solve(); SAM.reset(); &#125; return 0;&#125; 读入格式很诡异.用快读读 $k​$ 会炸两个点,原因不明. 大中锋的游乐场 最短路. 记 $dis[i][j]$ 表示从起点出发到节点 $i$ ,经过的 $1$ 减去经过的 $2$ 的数目为 $j$ 时的最短路长度. 用 $Dijkstra$ 进行转移即可.]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>平衡树</tag>
        <tag>矩阵优化</tag>
        <tag>容斥原理</tag>
        <tag>差分</tag>
        <tag>最短路</tag>
        <tag>位运算</tag>
        <tag>SAM</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1137]]></title>
    <url>%2F2019%2F04%2F28%2FCF1137%2F</url>
    <content type="text"><![CDATA[$Div.1​$ CF1137A Skyscrapers 二分. 通过观察可以发现,对于每个询问,如果交点位置的值是 $x$ ,那么答案就是该列比 $x$ 小的数字种数与该行比 $x$ 小的数字种数的较大值+该列比 $x$ 小的数字种数与该行比 $x$ 小的数字种数的较大值 + $1$ . 离散化后二分一下就可以求出了. CF1137B Camp Schedule 贪心 + $kmp$ . 这个东西显然可以贪心,构造字符串时先放一个目标串,然后后面从最长 $border$ 那里接上去继续放,直到放完或者 $0/1$ 不够用. 用 $kmp$ 搞一下最长 $border$ 长度就好了. CF1137C Museums Tour $tarjan$ 缩点, $DAG$ 上 $dp$ . 注意到 $d$ 较小,所以首先可以把原来的每个点拆成 $d$ 个点,并连上合法的转移边.这样每个点有两个值 $(x,t)$ ,如果城市 $x$ 在当天有展览,这个点权值为 $1$ ,否则为 $0$ . 用 $tarjan$ 搞出每个强连通分量,缩成一个点,那么这个新点的权值就是这个 $SCC$ 内有展览的城市数目和. 注意到同一个城市拆出来的点 $(x,t)$ 与 $(x,t’)$ 路径可逆(连续走 $d-1$ 次),要么彼此都不可达,对应的两个 $SCC$ 不连通;要么彼此都可达.在同一个 $SCC$ 内. 所以在 $DAG$ 上 $dp$ 的话,两个 $SCC$ 内相同城市拆出来的点贡献不会叠加. 那么就可以直接从 $(1,0)$ 所在的强连通分量出发,在 $DAG$ 上找一条点权和最大的路径,可以 $dp$ 解决. 时间复杂度 $O(nd)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=1e5+10;const int MAXN=5e6+10;int n,m,d;vector&lt;int&gt; graph[MAXN];int eu[N],ev[N];int on_display[MAXN];char schedule[51];bool vis[N];int low[MAXN],dfn[MAXN],idx=0;int stk[MAXN],tp=0;int scc[MAXN],scc_cnt=0,sccval[MAXN];void tarjan(int u)&#123; stk[++tp]=u; dfn[u]=low[u]=++idx; for(auto v:graph[u]) &#123; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(!scc[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; ++scc_cnt; while(tp) &#123; int v=stk[tp--]; scc[v]=scc_cnt; if(on_display[v]) &#123; sccval[scc_cnt]+=(int)(!vis[(v/d)+1]); vis[(v/d)+1]=true; &#125; if(v==u) break; &#125; &#125;&#125;int f[MAXN];int dfs(int u)&#123; if(f[u]!=-1) return f[u]; f[u]=0; for(auto v:graph[u]) f[u]=max(f[u],dfs(v)); f[u]+=sccval[u]; return f[u];&#125;int main()&#123; n=read(),m=read(),d=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); eu[i]=u,ev[i]=v; for(int ut=0;ut&lt;d;++ut) &#123; int vt=(ut+1)%d; graph[(u-1)*d+ut].push_back((v-1)*d+vt); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; scanf("%s",schedule); for(int j=0;j&lt;d;++j) on_display[(i-1)*d+j]=schedule[j]-'0'; &#125; tarjan((1-1)*d+0); for(int i=0;i&lt;n*d;++i) graph[i].clear(); for(int i=1;i&lt;=m;++i) &#123; int u=eu[i],v=ev[i]; for(int ut=0;ut&lt;d;++ut) &#123; int vt=(ut+1)%d; if(scc[(u-1)*d+ut] &amp;&amp; scc[(u-1)*d+ut]!=scc[(v-1)*d+vt]) graph[scc[(u-1)*d+ut]].push_back(scc[(v-1)*d+vt]); &#125; &#125; memset(f,-1,sizeof f); int ans=dfs(scc[(1-1)*d+0]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 然而需要卡空间.懒得卡了. CF1137D Cooperative Game 交互题. 这个模型可以考虑 $floyd$ 判圈算法.即 $A$ 的速度是 $2$ , $B$ 的速度是 $1$ ,同时从起点出发,当两人重新相遇时,快的那个人比慢的那个人多走了 $k$ 圈,即 $k\cdot c$ 步.操作时可以让 $A,B$ 一起走一步,再让 $A$ 走一步. 相遇时, $B$ 肯定还没有走完一圈.记此时 $B$ 在圈内走了 $x$ 步( $x&lt;c$ ),那么 $B$ 一共走了 $t+x$ 步, $A$ 一共走了 $t+x+kc$ 步.而 $A$ 走的步数恰好是 $B$ 的二倍. 所以可以得到 $kc=t+x$ .那么此时这两个人再一起往前走 $t$ 步就可以一起到达环的起点. 而剩余的人还在出发点,也是再往前走 $t$ 步到达环的起点.于是相遇后所有人一起走,到达同一个位置时就结束了. 分析一下总步数. $A,B$ 相遇前要进行 $2(t+x)$ 个操作,相遇后要进行 $t$ 个操作.总操作数不会大于 $3(t+c)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int groups;char buf[10][10];void getinfo()&#123; groups=read(); for(int i=0;i&lt;groups;++i) scanf("%s",buf[i]);&#125;void moveA()&#123; puts("next 0"); fflush(stdout);&#125;void moveAB()&#123; puts("next 0 1"); fflush(stdout);&#125;void moveAll()&#123; puts("next 0 1 2 3 4 5 6 7 8 9"); fflush(stdout);&#125;void Done()&#123; puts("done"); fflush(stdout);&#125;void stage_catch()&#123; while(1) &#123; moveAB(); getinfo(); moveA(); getinfo(); for(int i=0;i&lt;groups;++i) &#123; bool fa=false,fb=false; int len=strlen(buf[i]); for(int j=0;j&lt;len;++j) &#123; if(buf[i][j]=='0') fa=true; if(buf[i][j]=='1') fb=true; if(fa &amp;&amp; fb) return; &#125; &#125; &#125;&#125;void stage_meet()&#123; while(1) &#123; moveAll(); getinfo(); if(groups==1) &#123; Done(); return; &#125; &#125;&#125;int main()&#123; stage_catch(); stage_meet(); return 0;&#125; CF1137F Matches Are Not a Child’s Play 树剖 + 线段树. $compare$ 询问显然不用单独考虑,做两次 $when$ 询问就可以了. 初始的删点序列我们可以暴力搞出,只需要考虑每次 $up$ 操作带来的影响. 首先可以发现在一条路径上,只能从两边往中间删.,若 $up$ 当前权值最大的节点,就没有影响.否则,如果把 $u$ 改成了最大, $v$ 是原来最大的点, $v\not = u$ ,那么 $v-u$ 这条路径一定是最后被删除的,且删除顺序是严格按照 $v\rightarrow u$ 这条单向路径. 不在这条路径上的点被删除的相对顺序显然不会变.即, $up$ 操作一次之后,先删除不在这条路径上的点,顺序是操作前被删除的相对顺序,再沿路径 $v\rightarrow u$ 顺次删除. 实现可以通过染色,第 $i$ 次 $up$ 操作时把 $v_i\rightarrow u_i$ 这条路径上的点颜色染为 $i$ .那么询问 $when(x)$ 的答案就是颜色序号比 $col_x$ 小的节点数加上路径 $v_{colx} \rightarrow x$ 的节点数目.初始化可以看做进行了 $n$ 次 $up$ 操作. 染色用树剖+线段树实现,答案的两部分,前者用线段树维护每种颜色的节点数目,后者只需要记录每次的 $v_i$ ,利用树剖维护的 $dep,top$ 计算. 时间复杂度 $O(qlog^2n)$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>DAG</tag>
        <tag>二分</tag>
        <tag>codeforces</tag>
        <tag>kmp</tag>
        <tag>tarjan</tag>
        <tag>非传统题</tag>
        <tag>floyd判圈</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNA分子计数]]></title>
    <url>%2F2019%2F04%2F28%2FDNA%E5%88%86%E5%AD%90%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[怎么生物课也遇到计数题啊… 今天生物课老师直接说: $n$ 个碱基对的 $DNA$ 种类数目就是 $4^n$ ,如果还要考虑对称的话太麻烦了… 于是就想了一下考虑对称同构怎么算.讨论前后翻转,两条链交换,中心对称都算一种的话的情况. 考虑 $Burnside$ 引理,显然可以构造出置换群 ${ \text{不变,左右翻转,上下翻转,中心对称}}$ ,中心对称其实就是左右翻转与上下翻转都操作了一次. 那么现在只需要计算出每种变换的不动点数目,求其平均数即可. 不变 的不动点数目显然是 $4^n$ . 左右翻转 的不动点数目显然是 $0$ .因为碱基互补,不可能两条链相同. 上下翻转 的不动点数目其实就是回文串的数目. $n$ 为偶数时为 $2^n$ , $n$ 为奇数时为 $2^{n+1}$ . 中心对称 的不动点数目,其实就是第 $i$ 个位置恰好与第 $n+i-1$ 个位置互补的数目. $n$ 为偶数时为 $2^n$ . $n$ 为奇数时,中间那个位置要求与自己互补,这是不可能的,数目为 $0$ . 对 $4$ 种变换的不动点数目求平均值,得到答案 $4^{n-1}+2^{n-1}$ . 其实 $DNA$ 分子好像只有中心对称这一种变换?因为左右翻转和上下翻转后其实裸露的那两个磷酸分子旁边的东西的是不一样的???但总之无论考虑哪些变换都可以用 $Burnside$ 像上面那样直接搞吧…]]></content>
      <tags>
        <tag>Burnside/Polya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2946 公共串]]></title>
    <url>%2F2019%2F04%2F28%2Fbzoj-2946-%E5%85%AC%E5%85%B1%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ 解决多个串的最长公共子串. $SAM$. 显然可以 二分 + $hash$ 做,时间复杂度 $O(logL\cdot L \cdot n)$. 考虑 $SAM$ 的做法.对第一个串建个 $SAM$ ,然后每读入一个新串就把它放在自动机上匹配. 匹配时维护每个状态能与每个串都匹配的最大长度.最后的答案就是所有状态能匹配长度的最大值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=4e3+10;char buf[MAXN];int L,n;struct SuffixAutoMation&#123; int idx,lst; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN],siz[MAXN]; int A[MAXN],t[MAXN]; int mxl[MAXN],res[MAXN]; SuffixAutoMation()&#123;idx=lst=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; res[np]=len[np]=len[p]+1; siz[np]=1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; res[nq]=len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; &#125; void solve() &#123; scanf("%s",buf+1); memset(mxl,0,sizeof mxl); L=strlen(buf+1); int p=1,tmp=0; for(int i=1;i&lt;=L;++i) &#123; int c=buf[i]-'a'; while(p &amp;&amp; ch[p][c]==0) p=fa[p]; if(p==0) p=1,tmp=0; else &#123; tmp=min(tmp,len[p])+1; p=ch[p][c]; &#125; mxl[p]=max(mxl[p],tmp); &#125; for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; mxl[fa[u]]=max(mxl[fa[u]],mxl[u]); &#125; for(int i=1;i&lt;=idx;++i) res[i]=min(res[i],mxl[i]); &#125; void pr() &#123; int ans=0; for(int i=1;i&lt;=idx;++i) ans=max(ans,res[i]); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;SAM;int main()&#123; n=read(); scanf("%s",buf+1); L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a'); SAM.topsort(); for(int i=1;i&lt;n;++i) SAM.solve(); SAM.pr(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1396 识别子串]]></title>
    <url>%2F2019%2F04%2F27%2Fbzoj-1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 线段树. 先建出 $parent$ 树,按照题意,我们只需要处理 $right$ 集合大小为 $1$ 的节点. 如下图,先算出这样的一个节点合法长度的 $max,min$ ( $min$ 可以用 $max(fa)+1$ 计算). 那么区域 $I$ 内每个点的贡献就是区域 $II$ 的长度加上这个点到区域 $II$ 的距离. 区域 $II$ 内每个点的贡献就是区间 $II$ 的长度.开两颗线段树分别修改就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e5+10;const int inf=1e9;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]struct SegTree&#123; struct node &#123; int l,r; int mi,tag; &#125;Tree[MAXN&lt;&lt;2]; void pushup(int o) &#123; root.mi=min(lson.mi,rson.mi); &#125; void modifiy(int o,int c) &#123; root.mi=min(root.mi,c); root.tag=min(root.tag,c); &#125; void pushdown(int o) &#123; if(root.tag&lt;inf) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=inf; &#125; &#125; void BuildTree(int o,int l,int r) &#123; root.mi=root.tag=inf; root.l=l,root.r=r; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void update(int o,int L,int R,int c) &#123; int l=root.l,r=root.r; if(L&gt;r || l&gt;R || L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) update(o&lt;&lt;1,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,L,R,c); pushup(o); &#125;&#125;T1,T2;int ans[MAXN];void query(int o,int l,int r)&#123; if(l==r) &#123; int res=min(T1.Tree[o].mi-l,T2.Tree[o].mi); ans[l]=res; return; &#125; int mid=(l+r)&gt;&gt;1; T1.pushdown(o); T2.pushdown(o); query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r);&#125;char buf[MAXN];int L;int t[MAXN],A[MAXN];struct SuffixAutomation&#123; int lst,idx; int ch[MAXN][Siz],fa[MAXN]; int siz[MAXN],len[MAXN]; int pos[MAXN]; SuffixAutomation()&#123;lst=idx=1;&#125; void Extend(int c,int curl) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; pos[np]=curl; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void solve() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; T1.BuildTree(1,1,L); T2.BuildTree(1,1,L); for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; pos[fa[u]]=pos[u]; if(u==1 || siz[u]&gt;1) continue; int l=pos[u]-len[u]+1,r=pos[u]-(len[fa[u]]+1)+1; T1.update(1,l,r-1,pos[u]+1); T2.update(1,r,pos[u],pos[u]-r+1); &#125; query(1,1,L); for(int i=1;i&lt;=L;++i) printf("%d\n",ans[i]); &#125;&#125;SAM;int main()&#123; scanf("%s",buf+1); L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a',i); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3998 弦论]]></title>
    <url>%2F2019%2F04%2F27%2Fbzoj-3998-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[$SAM​$ 的入门练习题. 先把 $SAM​$ 建出来,每个节点的 $right​$ 集合大小就是走到这个节点时对应的子串出现次数. 如果 $t=0​$ ,那么这些位置只能被算一次,把每个点的 $right​$ 集合大小都置为 $1​$ ,否则就拓扑排序后(桶排),在$parent​$ 树上递推得出真正的 $right​$ 集合大小. 注意根节点处对应的子串都是空串,不能算入贡献,要把根节点的 $siz$ 置为 $0$ . 再在转移图中递推得到每个点能转移到的所有点的子串出现次数 $sum$ ,然后从根节点出发贪心走就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e6+10;int t[MAXN],A[MAXN];int T,K;struct SuffixAutomation&#123; int idx,lst; int ch[MAXN][Siz]; int siz[MAXN],len[MAXN]; int fa[MAXN]; int sum[MAXN]; SuffixAutomation()&#123;idx=lst=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void solve() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; if(T==0) &#123; for(int i=1;i&lt;=idx;++i) siz[i]=1; &#125; else &#123; for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; &#125; &#125; siz[1]=0;//在根节点处的串都是空串,不能计入 for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; sum[u]=siz[u]; for(int j=0;j&lt;26;++j) if(ch[u][j]) sum[u]+=sum[ch[u][j]]; &#125; int u=1; if(sum[u]&lt;K) &#123; puts("-1"); return; &#125; while(K) &#123; for(int i=0;i&lt;Siz;++i) &#123; if(K&lt;=sum[ch[u][i]]) &#123; putchar('a'+i); K-=siz[ch[u][i]]; u=ch[u][i]; break; &#125; else K-=sum[ch[u][i]]; &#125; &#125; puts(""); &#125;&#125;SAM;char buf[MAXN];int main()&#123; scanf("%s",buf+1); int L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a'); T=read(),K=read(); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1151]]></title>
    <url>%2F2019%2F04%2F25%2FCF1151%2F</url>
    <content type="text"><![CDATA[一场难度略高于普及组的 $Div.2$ . CF1151C Problem for Nazar 二分. 转化成求前缀和 $sum(r)-sum(l-1)$ .算每个前缀和的时候二分出整的前 $2^k$ 个数,剩下的单独算就好了. CF1151D Stas and the Queue at the Buffet 贪心. 考虑当前的两个位置 $i,j\ (i&lt;j)$ , 有 $x,y$ 两个元素,若交换这两个元素,对答案的影响. 化简出来发现只需要将所有元素按 $a_i-b_i$ 从大到小排序就好了. 这种判定贪心的可行性及怎样贪心的方法很常见,就是考虑交换两个元素对答案的影响. CF1151E Number of Components 构造. 考虑若当前计算的权值区间是 $(l,r)$ ,那么把在这个范围内的点权值赋为 $1$ ,否则赋为 $0$. 再在位置 $0$ 处补上一个权值 $0$ ,可以发现此时对于这对 $(l,r)$ 的答案就是相邻的 $(0,1)$ 对数. 那么我们直接来算每两个相邻位置的贡献,即 $a_i,a_{i+1}$ 在多少组 $(l,r)$ 中被赋的权值不同就好了. CF1153F Sonya and Informatics 概率+矩阵快速幂. 设 $f(i,j)$ 表示操作了 $j$ 次,当前最后一个 $1$ 在位置 $i$ 的概率. 每次 $j\rightarrow j+1$ 转移的时候分类讨论一下选了哪两个位置,写出转移矩阵,转移 $k$ 次,矩阵快速幂加速即可. 时间复杂度 $O(n^3logk)$ .]]></content>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>codeforces</tag>
        <tag>概率/期望</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GXOI/GZOI2019 选做]]></title>
    <url>%2F2019%2F04%2F21%2FGXOI-GZOI2019-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[广西/贵州 $OI$ . 题面Day 1Day 2 与或和 显然可以每一位分开做. 或就是用总子矩阵数目减去全 $0$ 子矩阵数目.与就是全 $1$ 子矩阵数目.单调栈经典问题. 时间复杂度 $O(32n^2)​$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7,inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e3+10;int n,a[MAXN][MAXN];int d[MAXN][MAXN];int ansand=0,ansor=0;int stk[MAXN],tp;int calc(int k,int v)//submatrix all of v&#123;#define val ((a[i][j]&gt;&gt;k)&amp;1) for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; if(val!=v) d[i][j]=0; else d[i][j]=d[i-1][j]+1; &#125; &#125; int s,res=0; for(int i=1;i&lt;=n;++i) &#123; tp=0; s=0; for(int j=1;j&lt;=n;++j) &#123; s=add(s,d[i][j]); while(tp &amp;&amp; d[i][stk[tp]]&gt;=d[i][j]) &#123; int del=mul(add(stk[tp],P-stk[tp-1]),add(d[i][stk[tp]],P-d[i][j])); s=add(s,P-del); --tp; &#125; res=add(res,s); stk[++tp]=j; &#125; &#125; return res;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) a[i][j]=read(); int tot=mul(n,n+1); tot=mul(tot,inv2); tot=mul(tot,tot); for(int k=0;k&lt;31;++k) &#123; int tmpand=calc(k,1); tmpand=mul(tmpand,1&lt;&lt;k); ansand=add(ansand,tmpand); int tmpor=add(tot,P-calc(k,0)); tmpor=mul(tmpor,1&lt;&lt;k); ansor=add(ansor,tmpor); &#125; cout&lt;&lt;ansand&lt;&lt;' '&lt;&lt;ansor&lt;&lt;endl; return 0;&#125; 宝牌一大堆 怎么又是 $mahjong$ …是不是可以专门出一类 麻将 $dp$ 啊. 七对子和国士无双可以单独做.七对子可以 $dp$ , $g(i,j)$ 表示考虑前 $i$ 种牌,组成 $j$ 个对子的最大得分.国士无双可以大力枚举一下哪张幺九牌有两张. 对于普通的 $3\times 4+2$ 的胡牌,把牌搞上标号,使得顺子的标号是连续的.记 $f[i][j][k][l][m][n]$ 表示考虑了前 $i$ 种牌,形成了 $j$ 个面子, $k$ 个雀头, $i-2,i-1,i$ 已经选了 $l,m,n$ 个时,前 $i-3$ 种牌能获得的最大得分. 转移时枚举一下 $i$ 这张牌不选/成刻子/成杠子/与 $i-2,i-1$ 成顺子的几种情况即可,注意判断合法性. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll g[35][35];ll f[35][5][2][5][5][5],ans;int a[35],c[5][5],d[35];bool shunend[]=&#123;0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0&#125;;void init()&#123; memset(f,0,sizeof f); memset(g,0,sizeof g); ans=0; for(int i=1;i&lt;=34;++i) d[i]=0,a[i]=4;&#125;// 1m 2m ... 9m 1p 2p ... 9p 1s 2s ... 9s E S W N Z B Fint id(char s[])&#123; if(s[0]=='E') return 28; if(s[0]=='S') return 29; if(s[0]=='W') return 30; if(s[0]=='N') return 31; if(s[0]=='Z') return 32; if(s[0]=='B') return 33; if(s[0]=='F') return 34; if(s[1]=='m') return s[0]-'0'; if(s[1]=='p') return s[0]-'0'+9; if(s[1]=='s') return s[0]-'0'+18; return 0;&#125;void upd(ll &amp;x,ll y)&#123; if(y&gt;x) x=y;&#125;ll dora(int idx,int cnt)&#123; if(d[idx]) return 1LL&lt;&lt;cnt; return 1LL;&#125;ll MaHu()&#123; ll res=0; f[1][0][0][0][0][0]=1; for(int i=1;i&lt;=34;++i) for(int j=0;j&lt;=4;++j) for(int k=0;k&lt;=1;++k) for(int l=0;l&lt;=4;++l) for(int m=0;m&lt;=4;++m) for(int n=0;n&lt;=4;++n) &#123; ll cur=f[i][j][k][l][m][n]; if(!cur) continue; if(i&lt;34) upd(f[i+1][j][k][m][n][0],cur*(i&gt;2?c[a[i-2]][l]*dora(i-2,l):1));//give up if(j&lt;4 &amp;&amp; a[i]-n&gt;=3) upd(f[i][j+1][k][l][m][n+3],cur);//kezi if(j&lt;4 &amp;&amp; a[i]-n&gt;=4) upd(f[i][j+1][k][l][m][n+4],cur);//gangzi if(j&lt;4 &amp;&amp; shunend[i] &amp;&amp; a[i]-n &amp;&amp; a[i-1]-m &amp;&amp; a[i-2]-l) upd(f[i][j+1][k][l+1][m+1][n+1],cur);//shunzi if(!k &amp;&amp; a[i]-n&gt;=2) upd(f[i][j][k+1][l][m][n+2],cur); if(i==34 &amp;&amp; j==4 &amp;&amp; k==1) &#123; ll s=cur*c[a[i]][n]*c[a[i-1]][m]*c[a[i-2]][l]; s*=dora(i,n)*dora(i-1,m)*dora(i-2,l); upd(res,s); &#125; &#125; return res;&#125;ll QiDuizi()&#123; g[0][0]=1; for(int i=1;i&lt;=34;++i) for(int j=0;j&lt;=7;++j) &#123; if(!g[i-1][j]) continue; upd(g[i][j],g[i-1][j]); if(j&lt;7) upd(g[i][j+1],g[i-1][j]*c[a[i]][2]*dora(i,2)); &#125; return g[34][7]*7;&#125;int yao[13]=&#123;1,9,10,18,19,27,28,29,30,31,32,33,34&#125;;ll GSWS()&#123; ll res=0; for(int i=0;i&lt;13;++i) &#123; if(a[yao[i]]==0) return 0; if(a[yao[i]]==1) continue; ll tmp=c[a[yao[i]]][2]*dora(yao[i],2); for(int j=0;j&lt;13;++j) &#123; if(i==j) continue; tmp*=c[a[yao[j]]][1]*dora(yao[j],1); &#125; upd(res,tmp); &#125; return res*13;&#125;int main()&#123; for(int i=0;i&lt;=4;++i) c[i][0]=1; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=4;++j) c[i][j]=c[i-1][j]+c[i-1][j-1]; int T=read(); while(T--) &#123; init(); char s[5]; while(1) &#123; scanf("%s",s); int x=id(s); if(x) --a[x]; else break; &#125; while(1) &#123; scanf("%s",s); int x=id(s); if(x) d[x]=1; else break; &#125; upd(ans,MaHu()); upd(ans,QiDuizi()); upd(ans,GSWS()); printf("%lld\n",ans); &#125; return 0;&#125; 特技飞行 无论怎样决策,所有交点的位置是确定的.所以 $c$ 的贡献可以和 $a,b$ 分开算. 所有合法决策最值,一定是一个使 对向交换 的次数最多,另一个使 对向交换 的次数最少. 计算 $a,b$ 的贡献时,交点的具体位置不重要,先只考虑 $y$ 的相对大小. 对于最多的情况,我们可以在 每个 交点处都选择 对向交换 .因为每个交点其实就是二元组 $(y_0,y_1)$ 的一个逆序对产生的.那么将每个逆序对的 $y_1$ 都交换,最后就不会有逆序对(交换排序),即满足要求. 对于最少的情况,可以发现对于 $y_1$ 中的每个置换,内部需要交换大小 $-1$ 次,各个置换独立,那么总交换次数为 $n-​$ 置换数目.找到的证明. 再来算 $c$ 的贡献.可以把所有点按 $y_1$ 从大到小依次加入 $set$ 中,以 $y_0$ 为关键字,这样能产生交点的点在 $set$ 中是一个前缀部分,合法就计算交点,不合法时就跳出,加入下一个点. 曼哈顿距离不太好搞,经典套路,转化成切比雪夫距离,就变成了问每个交点是否被一些矩形中的至少一个覆盖. 把点加入 $kdtree$ 中,每个矩形给其中的点打一打标记就好了.也可以离线后扫描线+树状数组. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-10;int fcmp(double x)&#123; if(fabs(x)&lt;=eps) return 0; return x&gt;0?1:-1;&#125;const int MAXN=5e5+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairint n,Y0[MAXN],Y1[MAXN],st,ed,is[MAXN],tot,id[MAXN],to[MAXN],k,vis[MAXN];ll A,B,C;double mn[MAXN][2],mx[MAXN][2];int flag[MAXN],D,ch[MAXN][2],marked[MAXN];// flag表示这个点以及其管辖的点都被标记了 marked表示这个点被标记了 set&lt;pii&gt; s;set&lt;pii&gt;::iterator it;struct point&#123; double p[2]; point()&#123;p[0]=p[1]=0;&#125; point(double x,double y)&#123;p[0]=x,p[1]=y;&#125; bool operator &lt; (const point &amp;rhs) const &#123; return p[D]==rhs.p[D]?p[D^1]&lt;rhs.p[D^1]:p[D]&lt;rhs.p[D]; &#125;&#125;a[MAXN];bool cmp(int a,int b)&#123; return Y1[a]&lt;Y1[b];&#125;void pushup(int o,int x)&#123; for(int i=0;i&lt;2;++i) &#123; mn[o][i]=min(mn[o][i],mn[x][i]); mx[o][i]=max(mx[o][i],mx[x][i]); &#125;&#125;int BuildTree(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; D=d; nth_element(a+l,a+mid,a+r+1); int o=mid; for(int i=0;i&lt;2;++i) mn[o][i]=mx[o][i]=a[o].p[i]; if(l&lt;=mid-1) &#123; ch[o][0]=BuildTree(l,mid-1,d^1); pushup(o,ch[o][0]); &#125; if(mid+1&lt;=r) &#123; ch[o][1]=BuildTree(mid+1,r,d^1); pushup(o,ch[o][1]); &#125; return o;&#125;void update(int x,int y,int r,int o)&#123; if(!o || flag[o] || x+r&lt;mn[o][0] || x-r&gt;mx[o][0] || y+r&lt;mn[o][1] || y-r&gt;mx[o][1]) return; double mxd=0; mxd=max(mxd,fabs(x-mn[o][0])); mxd=max(mxd,fabs(x-mx[o][0])); mxd=max(mxd,fabs(y-mn[o][1])); mxd=max(mxd,fabs(y-mx[o][1])); if(fcmp(mxd-r)&lt;=0) &#123; flag[o]=1; return; &#125; double curd=max(fabs(x-a[o].p[0]),fabs(y-a[o].p[1])); if(!marked[o] &amp;&amp; fcmp(curd-r)&lt;=0) marked[o]=1; update(x,y,r,ch[o][0]); update(x,y,r,ch[o][1]);&#125;int dfs(int o)&#123; if(flag[o]) &#123; marked[o]=1; marked[ch[o][0]]=marked[ch[o][1]]=1; flag[ch[o][0]]=flag[ch[o][1]]=1; &#125; int res=marked[o]; if(ch[o][0]) res+=dfs(ch[o][0]); if(ch[o][1]) res+=dfs(ch[o][1]); return res;&#125;int main()&#123; n=read(),A=read(),B=read(),C=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;++i) Y0[i]=read(); for(int i=1;i&lt;=n;++i) Y1[i]=read(); for(int i=n;i&gt;=1;--i) &#123; for(it=s.begin();it!=s.end() &amp;&amp; it-&gt;first &lt; Y1[i];++it) &#123; int j=it-&gt;second; double t=(double)(Y0[j]-Y0[i])/(Y1[i]-Y1[j]); double ox=(t*ed+st)/(t+1); double oy=(t*Y1[j]+Y0[j])/(t+1); double x=ox+oy,y=ox-oy; a[++tot]=point(x,y); &#125; s.insert(mp(Y1[i],i)); &#125; int rt=BuildTree(1,tot,0); k=read(); for(int i=1;i&lt;=k;++i) &#123; int ox=read(),oy=read(),r=read(); int x=ox+oy,y=ox-oy; update(x,y,r,rt); &#125; ll ans=dfs(rt)*C; ll ans1=ans+tot*A; for(int i=1;i&lt;=n;++i) id[i]=i; sort(id+1,id+1+n,cmp); ll rep=n; for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123; --rep; for(int j=i;!vis[j];j=id[j]) vis[j]=1; &#125; ll ans2=ans1+(tot-rep)*(B-A); if(ans1&gt;ans2) swap(ans1,ans2); printf("%lld %lld\n",ans1,ans2); return 0;&#125; 逼死强迫症 求必须用两块 $1\times 1$ 的方案,转化一下,设 $f_i$ 表示任意用砖,铺满前 $i$ 列的方案数, $g_i$ 表示只用 $1\times 2$ 的砖铺满前 $i$ 列的方案数.那么最后的答案就是 $f_n-g_n$ . $g$ 的转移很简单, $g_i=g_{i-1}+g_{i-2},g_0=1,g_1=1​$ . $f$ 的转移呢?多出来一列时,若不在这一列用 $1\times 1$ 的砖,那么方案数为 $f_{i-1}+f_{i-2}$ . 若在这一列用 $1\times 1$ 的砖,那么为了填满前 $i$ 列,另外一块 $1\times 1$ 也必须用,并且只能放在第 $1\sim i-2​$ 列. 若这两块砖中间还有偶数列,那么它们只能在同一行,否则,只能在不同的一行.看下面的图片感性理解: 那么左边那块 $1\times 1$ 的左边只能用 $1\times 2$ 填满,方案数用 $g$ 计算,右边只能有 $1$ 种填法. 枚举右边那块 $1\times 1$放在第 $1,2$ 行,左边那块 $1\times 1$ 放在第 $j$ 列. 整理一下,就有 $f_i=f_{i-1}+f_{i-2}+2\times \sum_{j=1}^{i-2} g_{j-1}$ . 边界有 $f_1=1,f_2=2$ .把 $g$ 的前缀和, $g,f$ 一起用矩阵快速幂优化转移即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct matrix&#123; int v[6][6]; matrix()&#123;memset(v,0,sizeof v);&#125; matrix operator * (const matrix &amp;rhs) const &#123; matrix res; for(int i=0;i&lt;6;++i) for(int j=0;j&lt;6;++j) for(int k=0;k&lt;6;++k) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;matrix fpow(matrix a,int b)&#123; matrix res; for(int i=0;i&lt;6;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;matrix trans,st;void setv(int x,int y)&#123; trans.v[x][y]+=1;&#125;void init()&#123; st.v[0][0]=5; st.v[1][0]=2; st.v[2][0]=3; st.v[3][0]=2; st.v[4][0]=1; st.v[5][0]=1;&#125;int main()&#123; setv(0,0),setv(0,1),setv(0,4),setv(0,5),setv(0,4),setv(0,5); setv(1,0); setv(2,2),setv(2,3); setv(3,2); setv(4,3); setv(5,4),setv(5,5); int T=read(); while(T--) &#123; int n=read(); if(n&lt;=3) &#123; if(n==1) cout&lt;&lt;0&lt;&lt;endl; else if(n==2) cout&lt;&lt;0&lt;&lt;endl; else if(n==3) cout&lt;&lt;2&lt;&lt;endl; continue; &#125; init(); st=fpow(trans,n-3)*st; printf("%d\n",add(st.v[0][0],P-st.v[2][0])); &#125; return 0;&#125; 旅行者 考虑将所有 感兴趣的城市 划分到两个集合 $A,B$ 中,从 $S$ 向 $A$ 中每个点连 $0$ 边,从 $B$ 中每个点向 $T$ 中连 $0$ 边. 这样从 $S$ 到 $T$ 的最短路长度就是 $A$ 与 $B$ 中两两最短路的最小值. 怎样划分才能使每对 感兴趣的城市 都被算入贡献中呢? 考虑划分 $logn$ 轮,每一轮将二进制第 $i$ 位上为 $0$ 的点划入 $A$ 中,否则划入 $B$ 中.这样两个不同的城市在至少一轮中被划分进了不同的集合,一定能产生贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll inf=1e18;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,MAXM=7e5+10;int ecnt,head[MAXN],to[MAXM],nx[MAXM],val[MAXM];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;void init()&#123; ecnt=0; memset(head,0,sizeof head);&#125;int n,m,k;int city[MAXN],orghead[MAXN];ll dis[MAXN];bool vis[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairll dij(int S,int T)&#123; for(int i=1;i&lt;=n+2;++i) &#123; dis[i]=inf; vis[i]=false; &#125; dis[S]=0; priority_queue&lt;pli&gt; q; q.push(mp(0,S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=true; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[u]+val[i]&lt;dis[v]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125; return dis[T];&#125;int main()&#123; int Cases=read(); while(Cases--) &#123; init(); n=read(),m=read(),k=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); &#125; for(int i=1;i&lt;=k;++i) city[i]=read(); int rounds=1+(int)log2(n); int S=n+1,T=n+2; ll ans=inf; for(int p=0;p&lt;=rounds;++p) &#123; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) orghead[i]=head[city[i]]; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) addedge(city[i],T,0); else addedge(S,city[i],0); ans=min(ans,dij(S,T)); head[S]=0; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) head[city[i]]=orghead[i]; ecnt-=k; &#125; printf("%lld\n",ans); &#125; return 0;&#125; 旧词 先来考虑 $k=1$ 的部分,做法是将 $lca$ 处 $dep$ 的贡献摊到这个点到根的路径上. 具体来说将询问离线下来,按 $x$ 排序后就可以从小到大一个个加入点.每加入一个点的时候就把这个点到根的路径上点的权值都 $+1$ ,询问时就查询 $y$ 到根的路径上点的权值和. 考虑拓展到 $k&gt;1$ 的部分,沿用上面的思路,发现每次给路径上每个点权值 $+\ (dep_i^k-(dep_i-1)^k)$ 就好了. 这样就可以使 $lca$ 的权值恰好被摊到路径上,查询时仍然查询路径权值和就好了. 树剖+线段树维护一下,时间复杂度 $O(nlog^2n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=5e4+10;int n,k,Q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int siz[MAXN],mxson[MAXN],top[MAXN],fa[MAXN],dep[MAXN],dfn[MAXN],rnk[MAXN],idx=0;void dfs1(int u,int Fa)&#123; dep[u]=dep[Fa]+1; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;struct SegTree&#123; struct node &#123; int l,r; int sum,delta,tag; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=add(lson.sum,rson.sum); &#125; void modifiy(int o,int c) &#123; root.tag=add(root.tag,c); root.sum=add(root.sum,mul(c,root.delta)); &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; root.l=l,root.r=r; root.tag=0; root.sum=0; if(l==r) &#123; root.delta=add(fpow(dep[rnk[l]],k),P-fpow(dep[rnk[l]]-1,k)); return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); root.delta=add(lson.delta,rson.delta); &#125; void update(int o,int L,int R,int c) &#123; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; if(l&gt;R || L&gt;r) return; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) update(o&lt;&lt;1,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,L,R,c); pushup(o); &#125; int query(int o,int L,int R) &#123; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; if(l&gt;R || L&gt;r) return 0; int mid=(l+r)&gt;&gt;1; pushdown(o); int res=0; if(L&lt;=mid) res=add(res,query(o&lt;&lt;1,L,R)); if(R&gt;mid) res=add(res,query(o&lt;&lt;1|1,L,R)); return res; &#125;&#125;T;int ans[MAXN];struct query&#123; int x,y,id; bool operator &lt; (const query &amp;rhs) const &#123; return x&lt;rhs.x; &#125;&#125;q[MAXN];void path_upd(int x)&#123; while(top[x]!=1) &#123; T.update(1,dfn[top[x]],dfn[x],1); x=fa[top[x]]; &#125; T.update(1,dfn[top[x]],dfn[x],1);&#125;int path_query(int x)&#123; int res=0; while(top[x]!=1) &#123; res=add(res,T.query(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; res=add(res,T.query(1,dfn[top[x]],dfn[x])); return res;&#125;int main()&#123; n=read(),Q=read(),k=read(); for(int i=2;i&lt;=n;++i) &#123; int f=read(); addedge(f,i); &#125; for(int i=1;i&lt;=Q;++i) &#123; q[i].x=read(); q[i].y=read(); q[i].id=i; &#125; sort(q+1,q+1+Q); dfs1(1,0); dfs2(1,1); T.BuildTree(1,1,n); int lstx=0; for(int i=1;i&lt;=Q;++i) &#123; int x=q[i].x,y=q[i].y; for(int j=lstx+1;j&lt;=x;++j) path_upd(j); ans[q[i].id]=path_query(y); lstx=x; &#125; for(int i=1;i&lt;=Q;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>矩阵优化</tag>
        <tag>差分</tag>
        <tag>最短路</tag>
        <tag>位运算</tag>
        <tag>kdtree</tag>
        <tag>单调栈</tag>
        <tag>棋牌</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest 2019]]></title>
    <url>%2F2019%2F04%2F21%2FTenka1-Programmer-Contest-2019%2F</url>
    <content type="text"><![CDATA[感觉这场打得好烂… C Stones 比较弱智.最后一定是连续一段黑之后连续一段白.枚举一下这个分界位置就好了. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;char s[MAXN];int sum1[MAXN],sum2[MAXN];int main()&#123; int n=read(); scanf("%s",s+1); int ans; for(int i=1;i&lt;=n;++i) &#123; if(s[i]=='.') ++sum1[i];//white else ++sum2[i]; sum1[i]+=sum1[i-1]; sum2[i]+=sum2[i-1]; &#125; ans=sum2[n]; for(int i=1;i&lt;=n;++i) ans=min(ans,i-sum1[i]+n-i-(sum2[n]-sum2[i-1])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Three Colors 两个颜色一起 $dp$ 状态数目可能很大,考虑能不能每次只 $dp$ 一种颜色. 用所有染色方案 $3^n$ 减去不合法的方案数就好了. 记所有数的和为 $sum$ ,那么不合法的方案有 $R\geq sum/2,G\geq sum/2,B\geq sum/2$ 三种. 记 $f(i,j)$ 表示前 $i$ 个数,红色数之和为 $j$ 的方案数.另外两种颜色计算方法一样,直接 $\times 3$ . 注意若 $sum$ 为偶数,这里有两个颜色都恰好等于 $sum/2$ 的方案被减了两次,要加回来,这部分是 $g(n,sum/2)\cdot {3\choose 2}$ . $f$ 转移时可以填三种颜色,而 $g$ 只能填两种. 时间复杂度为 $O(n\cdot sum)$ ,实际肯定跑不满.空间可以滚动优化一下(其实 $f,g$ 用一个数组也就 $100\ MB$). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;void upd(int &amp;x,int y)&#123; x+=y; x=(x%P+P)%P;&#125;const int MAXN=329;int a[MAXN],sum[MAXN],n;int ans=0;int f[2][MAXN*MAXN],g[2][MAXN*MAXN];int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) sum[i]=sum[i-1]+(a[i]=read()); ans=fpow(3,n); int cur=0; g[cur][0]=f[cur][0]=1; for(int i=1;i&lt;=n;++i) &#123; for(int j=0;j&lt;=sum[i];++j) f[cur^1][j]=g[cur^1][j]=0; for(int j=0;j&lt;=sum[i-1];++j) if(f[cur][j]) &#123; upd(f[cur^1][j+a[i]],f[cur][j]); upd(f[cur^1][j],mul(2,f[cur][j])); upd(g[cur^1][j+a[i]],g[cur][j]); upd(g[cur^1][j],g[cur][j]); &#125; cur^=1; &#125; for(int i=(sum[n]+1)&gt;&gt;1;i&lt;=sum[n];++i) upd(ans,-mul(3,f[cur][i])); if(!(sum[n]&amp;1)) upd(ans,mul(3,g[cur][sum[n]&gt;&gt;1])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Polynomial Divisors 比赛时一直 $WA$ 后面几个点.心态有些崩.后来改了些莫名其妙的地方就过了??? 结论:题述性质成立当且仅当这个多项式在模 $p$ 意义下能被 $x^p-x$ 整除.于是只需要验证 $[2,n]$ 以内的质数,再加上所有 $a_i$ 的 $gcd$ 的质因数就好了. 证明:充分性显然.必要性:在模 $p$ 意义下, $0,1,\dots p-1$ 都是 $f$ 的根. 那么这个多项式一定有因式 $x(x-1)(x-2)\dots (x-(p-1))$. 这个因式的根与 $x^p-x$ 的根完全相同,而它们最高项系数也相同,在模 $p$ 意义下这两个式子是等价的.于是多项式 $f$ 就一定有因式 $x^p-x$ . 这部分的证明好像在 $math$ 那个题里面有? F Banned X 咕了.]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>dp计数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烷烃计数]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[大概 $OIer$ 上化学课都会想到这个吧? 今天化学课教烷烃的同分异构体,我:这烷烃不就是颗树嘛?同分异构体数目不就是无标号树的个数嘛? $prufer$ 序列随便搞一下就能算吧??? 然后发现一个碳旁边最多连四个碳,度数还要 $\leq 4$. 然后我就问旁边数竞小哥:你知道这个东西的通项嘛?他:我来找下规律.我:这东西(指数树)的规律大概率找不出来吧…他不信邪,结果找了一节课,未果,寻病终… 然后在 $dalao$ 们的博客中学习了一下.记 $f(i,j)$ 表示 $i$ 个点的有根树,根节点的度数为 $j$ 的方案数目. 在枚举儿子节点时,为了避免算重,按照子树大小从大到小来枚举.先枚举儿子中最大的子树大小 $size$ ,再枚举有 $k$ 个这样大小的儿子.记 $s=\sum_{i=0}^{j-1} f(size,i)$ ,即每个这样的子树都有 $s$ 种方案可选.那么给 $k$ 个子树安排一下方案,就相当于把 $k$ 个球放入 $s$ 个无差别盒子中,方案数为 ${s+k-1\choose k}$ . 那么转移方程就有 $f(i,j)=\sum f(i-k\times size,j-k)\cdot {s+k-1\choose k}$ . 如果是数烷基,就是无根树,直接就像上面这样算, $ans=\sum_{k=0}^3 f(n,k).​$ 如果数的是烷烃,就是无根树,所以钦定树的重心作为根节点.那么在转移时就要注意 $2\cdot size&lt;i$ ,保证根为重心. 另外,在最后计算答案时,注意到当 $n$ 为偶数时,它有两个重心,那么两边的子树可以交换,多乘上 $p_k={\sum_{k’=0}^{k-1}f(\frac n 2,k’)+1\choose 2}$. 最后就有 $ans=\sum_{k=0}^3 f(n,k)+[n\equiv 0\mod2]\cdot p_k$ .]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1140]]></title>
    <url>%2F2019%2F04%2F18%2FCF1140%2F</url>
    <content type="text"><![CDATA[$Div.2$ CF1140C Playlist 将元素按 $b$ 从大到小排序,然后从后往前依次加入,每加入一个元素时它的 $b$ 都是当前最小的. 此时需要钦定选择这个元素作为最小的 $b$ ,并在已有元素中选出 $k-1$ 个 $t$ 值最大的. 这个东西用个堆维护一下当前前 $k-1$ 大的 $t$ 值就好了. CF1140D Minimum Triangulation 肯定会有一个很直观的想法:全部都以 $1$ 为一个顶点,然后 $(1,2,3),(1,3,4) \dots (1,n-1,n)$ 这样来剖. 这样做的确是正确的,即权值一定是最小的.为什么呢? 考虑若有 $x&lt;y$ ,那么把方案 $(1,n,x),(n,x,y)$ 换成 $(1,n,y),(1,x,y)$ ,总权值会减小. 于是可以直接将 $x$ 换到 $n-1$ ,然后将 $(1,n-1,n)$ 这个三角形直接割掉,对剩下的 $n-1$ 边形继续做上述操作. 这样做的话,所有的方案就一定是 $(1,2,3),(1,3,4) \dots (1,n-1,n)$ 这样的形式了. 另一个做法是 $O(n^3)$ 的区间 $dp$ ? CF1140E Palindrome-less Arrays 任意位置都不能出现长度 $\geq 3$ 的奇回文串,其实也就等价于不出现长度为 $3$ 的回文串. 也就是说总有 $a_i\not=a_{i+2}$ .这样显然可以奇偶分开算,将两个序列各自的合法方案数目乘起来. 把奇(偶)数位置拿出来,就是要求相邻两个位置都不同的方案数. 把连续的一段 $-1$ 看成一块,考虑每一块 $(a,-1,-1,\dots,-1,b)$ 怎么算方案数.首尾可能会出现没有 $a,b$ 的情况,枚举第一个/最后一个元素,算中间的就可以了(其实这部分细节挺多的?).所以下面都假定 $a,b$ 存在. 每块的方案数只与 $-1$ 的个数 $x$ 以及 $a,b$ 是否相等有关.记 $f(x)$ 表示 $a\not =b$ 时的方案数, $g(x)$ 表示相等时. 若 $x$ 为奇,枚举最中间的元素,就有:$g(x)=g(x/2)^2+(k-1)f(x/2)^2,f(x)=2f(x/2)g(x/2) + (k-2)f(x/2)^2$ . 若 $x$ 为偶,枚举第一个元素即可将 $x$ 变为奇.$g(x)=(k-1)f(x-1),f(x)=g(x-1)+(k-2)f(x-1)$ . 边界显然有 $f(0)=1,g(0)=0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e5+10;int k;int f[MAXN],g[MAXN];int F(int);int G(int);int calc(int l,int r,int *a,int n)&#123; if(r&gt;=n) &#123; int len=r-l-1,res=1; if(l&lt;0) --len,res=k; if(len==0) return res; int fx=F(len-1),gx=G(len-1); return mul(res,add(gx,mul(k-1,fx))); &#125; if(l&lt;0) &#123; if(r-l==1) return 1; int fx=F(r-l-2),gx=G(r-l-2); return add(gx,mul(k-1,fx)); &#125; return a[l]==a[r]?G(r-l-1):F(r-l-1);&#125;int solve(int *a,int n)&#123; int res=1,lst=-1; for(int i=0;i&lt;n;++i) &#123; if(a[i]==-1) continue; res=mul(res,calc(lst,i,a,n)); lst=i; &#125; res=mul(res,calc(lst,n,a,n)); return res;&#125;int n,a[MAXN],b[MAXN],siza,sizb;int main()&#123; n=read(); k=read(); for(int i=1;i&lt;=n;++i) &#123; f[i]=g[i]=-1; int x=read(); if(i&amp;1) a[siza++]=x; else b[sizb++]=x; &#125; int ans=1; ans=mul(ans,solve(a,siza)); if(ans) ans=mul(ans,solve(b,sizb)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;int F(int x)&#123; if(!x) return 1; if(f[x]!=-1) return f[x]; int &amp;res=f[x]; if(x&amp;1) &#123; res=mul(2,mul(F(x&gt;&gt;1),G(x&gt;&gt;1))); res=add(res,mul(k-2,mul(F(x&gt;&gt;1),F(x&gt;&gt;1)))); return res; &#125; else return res=add(G(x-1),mul(k-2,F(x-1))); &#125;int G(int x)&#123; if(!x) return 0; if(g[x]!=-1) return g[x]; int &amp;res=g[x]; if(x&amp;1) &#123; res=mul(G(x&gt;&gt;1),G(x&gt;&gt;1)); res=add(res,mul(k-1,mul(F(x&gt;&gt;1),F(x&gt;&gt;1)))); return res; &#125; else return res=mul(k-1,F(x-1));&#125; CF1140F Extending Set of Points 可以发现它的 $Extend$ 操作就是将每三个点加一个点补成一个矩形,直到每个可补的位置都有点为止.这里的三个点必须要有两个点的连线是平行于坐标轴的. 给每个 $x,y$ 坐标都建一个节点,加入 $(x,y)$ 就将对应的两个节点连起来,容易发现每个连通分量的贡献为不同的 $x$ 坐标个数乘上不同的 $y$ 坐标个数,此时的答案就是每个连通分量的贡献之和. 这个东西用个并查集维护,插入点很简单,删除点似乎不太好做?此时可以想到线段树分治,用线段树给每个点影响的时间区间 $(l,r)$ 打上对应的标记就好了. 打好标记,算答案的时候,递归到一个节点时,就让上面的所有标记生效,退出时再撤销就好了. 注意这里有撤销操作,需要避免路径压缩的使用.用按秩合并优化就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;const int MAXN=6e5+10;int siz[MAXN],sizx[MAXN],sizy[MAXN];#define tot(x) 1LL*sizx[x]*sizy[x]int fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:Find(fa[x]);&#125;pii stk[MAXN];int tp=0;ll ans=0;void Merge(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(siz[x]&lt;siz[y]) swap(x,y); ans-=tot(x); ans-=tot(y); fa[y]=x; siz[x]+=siz[y],sizx[x]+=sizx[y],sizy[x]+=sizy[y]; ans+=tot(x); stk[++tp]=make_pair(x,y);&#125;void Split(int x,int y)&#123; ans-=tot(x); fa[y]=y; siz[x]-=siz[y],sizx[x]-=sizx[y],sizy[x]-=sizy[y]; ans+=tot(x); ans+=tot(y);&#125;int n;map&lt;pii,int&gt; mp;vector&lt;pii&gt; Tree[MAXN&lt;&lt;1];set&lt;pii&gt; s;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void modifiy(int o,int l,int r,int L,int R,pii c)&#123; if(l&gt;R || L&gt;r) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.push_back(c); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) modifiy(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) modifiy(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void solve(int o,int l,int r)&#123; int curt=tp; int sz=root.size(); for(int i=0;i&lt;sz;++i) Merge(root[i].first,root[i].second); if(l==r) printf("%I64d ",ans); else &#123; int mid=(l+r)&gt;&gt;1; solve(o&lt;&lt;1,l,mid); solve(o&lt;&lt;1|1,mid+1,r); &#125; while(tp&gt;curt) &#123; Split(stk[tp].first,stk[tp].second); --tp; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(),y=read()+300001; fa[x]=x,siz[x]=1,sizx[x]=1; fa[y]=y,siz[y]=1,sizy[y]=1; pii k=make_pair(x,y); if(s.find(k)==s.end()) &#123; mp[k]=i; s.insert(k); &#125; else &#123; modifiy(1,1,n,mp[k],i-1,k); mp[k]=0; s.erase(k); &#125; &#125; set&lt;pii&gt;::iterator it; for(it=s.begin();it!=s.end();++it) &#123; pii k=*it; modifiy(1,1,n,mp[k],n,k); &#125; solve(1,1,n); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190417]]></title>
    <url>%2F2019%2F04%2F18%2Ftest20190417%2F</url>
    <content type="text"><![CDATA[测试. $heap$ 有多少个节点数目为 $n​$ ,权值为 $1\sim n​$ 且互不相同的二叉堆?答案对 $10^9+7​$ 取模. $n\leq 10^9​$ . $O(n)$ 的做法十分简单, 先搞出每个节点的 $siz$ ,记 $f(i)$ 表示子树 $i$ 内用 $siz_i$ 个权值能形成的合法二叉堆数目. 转移显然有 $f(i)={siz_i\choose siz_{2i}}\cdot f(2i)\cdot f(2i+1)$ ,叶子节点 $f(i)=1$ . 把组合数拆开,算算贡献,可以发现 $f(1)=\frac {n!} {\prod siz_i}$ .考虑 $siz$ 连乘积怎么算. 注意到一个点的左右子树至少有一个是满的二叉树(每一层填满),那么就可以先求出每种满二叉树的答案,此时递归入另一个子树继续计算就可以了.这部分的时间复杂度为 $O(logn)​$ . 还有一个 $n!​$ 需要计算.分块打下表,就能很快求出啦. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int m=1000000;int calcfac(int x) &#123; int pos=x/m; int s=blockfac[pos]; for(int i=pos*m+1;i&lt;=x;++i) s=mul(s,i); return s;&#125;int n;map&lt;int,int&gt; mp;int solve(int x)//x个点,x个互异权值,siz连乘积&#123; if(x&lt;=1) return 1; if(mp.find(x)!=mp.end()) return mp[x]; int z=(int)(log2(x)); z=1&lt;&lt;z; int y=min(z-1,x-z/2); return mp[x]=mul(x,mul(solve(y),solve(x-y-1)));&#125;int main()&#123; freopen("heap.in","r",stdin); freopen("heap.out","w",stdout); n=read(); cout&lt;&lt;mul(calcfac(n),(inv(solve(n))))&lt;&lt;endl; return 0;&#125; 这里用了另一种等价的做法,意义不是很明显?略去了表的数据. $secret$ 待更. $tree$ 待更.]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>test</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190416]]></title>
    <url>%2F2019%2F04%2F17%2Ftest20190416%2F</url>
    <content type="text"><![CDATA[来自 $GDOI​$ 的模拟题? 题面 $graph$ 貌似是第一次在考试中遇到提答题? 这题看上去十分正常,却出成提答,就是让你乱搞的…题解给的做法就是退火之类的乱搞. 随便估价乱搞一下就可以获得 $80+$ 的好成绩? $guess$ 自己的联想发散能力还是有问题,没看出可以建网络流模型,只会打暴力… 正解:要求的就是所有合法配对方案中,出现原来配对情况的最小数目. 先离散化一下数字大小,建一个费用流的模型,从 $S$ 向左边每个数字连其在 $x$ 坐标中出现的次数作为流量, $0$ 作为费用的边. $y$ 坐标连类似的边连向 $T$ .中间对于每个原来有的配对,连一条流量为 $1$ ,费用为 $1$ 的边.这样就限制了不会出现重复的配对. 跑一遍 $mcmf$ 即为答案. $room$ 最开始想到最小割去了..然后发现好像不太现实,暴力转移的 $dp$ 倒是很普及… 设 $f[i][j][k]$ 表示已经走了前 $i$ 层,第 $i$ 层开的门分别为 $j,k​$ 时的最小体力花费. 这个东西显然可以 $O(nm^4)$ 大力转移. $f[1][j][k]=t[1][j]+t[1][k]$$f[i][j][k]=\min_{x\not = y} f[i-1][x][y]+K\cdot (|j-x|+|k-y|),2\leq i \leq n.​$ 后两维交换是没有影响的,所以在枚举是可以直接钦定 $j&lt;k,x&lt;y$ ,优化了 $16$ 倍常数.这样就有 $60pts$ 了. $100pts?$ 转移时允许在同层转移,形成一个类似前缀 $\min$ 的优化,即可做到 $O(nm^2)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;typedef long long ll;const int inf=1e9;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=329;int n,m,K;int t[MAXN][MAXN];int f[MAXN][MAXN][MAXN];void solve()&#123; int ans=inf; memset(f,0x7f,sizeof f); for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) f[1][j][k]=t[1][j]+t[1][k]; for(rg int i=2;i&lt;=n;++i) &#123; for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) f[i][j][k]=min(K+min(f[i][j-1][k],f[i][j][k-1]),f[i-1][j][k]); for(rg int j=m-1;j&gt;=1;--j) for(int k=m;k&gt;j;--k) f[i][j][k]=min(f[i][j][k],K+min(f[i][j+1][k],f[i][j][k+1])); for(rg int j=1;j&lt;=m;++j) for(rg int k=j+1;k&lt;=m;++k) f[i][j][k]+=t[i][j]+t[i][k]; &#125; for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) ans=min(ans,f[n][j][k]); cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; freopen("room.in","r",stdin); freopen("room.out","w",stdout); n=read(),m=read(),K=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) t[i][j]=read(); solve(); return 0;&#125; 可以滚掉第一维?空间没卡的话就随便吧…]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>test</tag>
        <tag>近似算法</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1153]]></title>
    <url>%2F2019%2F04%2F16%2FCF1153%2F</url>
    <content type="text"><![CDATA[$Div.2$ CF1153B Serval and Toy Bricks 贪心+构造. 能放行 $\max$ 而不爆列 $\max$ 的位置都放行 $\max$ , 能放列 $\max$ 而不爆行 $\max$ 的位置都放列 $\max$ . 这样每个位置显然不会被定为两个不同的值.对于其他有而未放的位置直接都放 $1$ 就好了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;int n,m,H;int a[MAXN],b[MAXN];int c[MAXN][MAXN],h[MAXN][MAXN];int main()&#123; n=read(),m=read(),H=read(); for(int i=1;i&lt;=m;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) b[i]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) h[i][j]=read(); for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; if(h[i][j]) &#123; if(a[j]&lt;=b[i]) c[i][j]=a[j]; else c[i][j]=b[i]; &#125; printf("%d ",c[i][j]); &#125; puts(""); &#125; return 0;&#125; CF1153C Serval and Parenthesis Sequence 贪心+构造.显然可以将左括号,右括号的权值分别赋为 $1,-1$. 那么容易发现题中限制条件就是权值前缀和 $sum(n)=0,sum(i)&gt;0,\forall i&lt;n$. 将所有未确定的位置赋为 $1$ ,可以算出 $sum(n)=k$ ,需要将 $\frac k 2$ 个位置改为 $-1$. 从后往前贪心改,能改的位置就改.判一下不合法的情况, $k$ 为奇数,负数或不够改. 改完后再从前往后 $check$ 一次就可以了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define GG return puts(":("),0;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n;char buf[MAXN];int a[MAXN];int main()&#123; n=read(); scanf("%s",buf+1); int k=0,tot=0; for(int i=1;i&lt;=n;++i) &#123; if(buf[i]==')') --k,a[i]=-1; else if(buf[i]=='(') ++k,a[i]=1; else ++k,a[i]=1,++tot; &#125; if(k&lt;0 || k%2==1 || k/2&gt;tot) GG for(int i=n;i&gt;=1 &amp;&amp; k&gt;0;--i) &#123; if(buf[i]=='?') a[i]=-1,k-=2; &#125; int sum=0; for(int i=1;i&lt;n;++i) &#123; sum+=a[i]; if(sum&lt;=0) GG &#125; for(int i=1;i&lt;=n;++i) &#123; if(a[i]==1) putchar('('); else putchar(')'); &#125; puts(""); return 0;&#125; CF1153D Serval and Rooted Tree 树形 $dp$ .(一定思维难度?) 考虑一颗子树,若其中有 $p$ 个叶子节点,任意选择 $p$ 个互不相同的权值,经过最优排列后,这个根节点的权值的相对大小,即排名,一定是确定的,即与选择了哪些权值无关. 那么记 $f_i$ 表示给子树 $i$ 中的叶子节点最优赋值后,节点 $i$ 上的权值是这些叶子节点权值中的第 $f_i$ 大. 对于叶子节点 ,显然 $f_u=1$ . 若操作符为 $\min$ ,可以证明感性理解, $f_u=\sum f_v$ .若操作符为 $\max$ ,可以证明感性理解, $f_u=\min f_v$ ,其中 $v$ 为 $u$ 的儿子. 共有 $k$ 个叶子节点,最后答案即为 $k+1-f_1$ ,即全部可用的权值的第 $f_1$ 大. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int head[MAXN],nx[MAXN],to[MAXN],ecnt=0;inline void addedge(int u,int v)&#123; ++ecnt; nx[ecnt]=head[u]; to[ecnt]=v; head[u]=ecnt;&#125;int n;int opt[MAXN],f[MAXN],outdeg[MAXN],k=0;void dfs(int u)&#123; if(!outdeg[u]) &#123; ++k; f[u]=1; return; &#125; if(opt[u]==1) f[u]=MAXN+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v); if(!opt[u]) f[u]+=f[v]; else f[u]=min(f[u],f[v]); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) opt[i]=read(); for(int i=2;i&lt;=n;++i) &#123; int fa=read(); addedge(fa,i); ++outdeg[fa]; &#125; dfs(1); cout&lt;&lt;k+1-f[1]&lt;&lt;endl; return 0;&#125; CF1153F Serval and Bonus Problem 概率/期望,计数, $dp$ . 随便在线段上钦定 $2n$ 个点,分割成 $2n+1$ 段区间,所以每段区间的期望长度就是 $\frac l {2n+1}$ .于是只需要再乘上一段区间至少被 $k$ 条线段覆盖的概率就好了. 设 $f(i,j)$ 表示考虑 $i$ 个端点,第 $i$ 个端点后面的区间恰好被 $j$ 条线段所覆盖的方案数.转移时枚举 $i$ 是作为左端点还是右端点, $O(n^2)$ 大力转移. 最后将所有合法方案数目求和,除以 $f(2n,0)$ 得到概率. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=2019&lt;&lt;1;int n,l,k;int fac[MAXN];int f[MAXN][MAXN];int main()&#123; n=read(),k=read(); l=read(); int perl=mul(l,inv(2*n+1)); fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); f[0][0]=1; for(int i=0;i&lt;2*n;++i) &#123; for(int j=n&lt;i?n:i;j&gt;=0;--j) &#123; f[i+1][j+1]=add(f[i+1][j+1],f[i][j]); if(j) f[i+1][j-1]=add(f[i+1][j-1],mul(f[i][j],j)); &#125; &#125; int ans=0; for(int i=1;i&lt;2*n;++i) for(int j=k;j&lt;=n;++j) &#123; int tmp=mul(f[i][j],f[2*n-i][j]); tmp=mul(tmp,fac[j]); ans=add(ans,tmp); &#125; cout&lt;&lt;mul(ans,mul(perl,inv(f[2*n][0]))); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>树形dp</tag>
        <tag>概率/期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2019游记]]></title>
    <url>%2F2019%2F04%2F11%2FSCOI2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[风中寻觅 $Day\ -3$ $NamelessOIer$ 在写退役记 .毕姥爷:你写一篇退役记,进队了来看,岂不是很爽? 奶一口 NamelessOIer 进队. $Day\ -2$ 怎么回事啊,考前天天考一些奥妙重重的数学题,自闭了. 我:省选前打几道数据结构题练练手.旁边的 achen :我刚刚写到数据结构写多了让人退役. 被钦点退役了. $Day\ -1$ 背了背笔试,据说 $SCOI$ 不上机笔试?快捷键警告. $Day\ 0$ 早上破天荒地去食堂吃了顿饭,也遇到了很多熟人.但大家的心境似乎不太一样呢… $noip$ 考完后还说着有半年才省选,转眼间也就到了呢… 怎么有点感冒啊,头倒不是很昏,就是一直流鼻涕… $Day\ 1$ 看完题,啥思路都没有…先写了后两个题的暴力,然后再看第一题. 发现其实就是一个像九连环或者汉诺塔之类的递归式子的题目？迅速写完 $50$ 分,然后开始想后面的部分. 可能这就是思维江化吧,觉得输入可能很大,就以为是读入的时候取模,高精是啥?推了很久,感觉很不可做.(不是自己都说了像九连环嘛…) 于是又把后面的部分分写了一点,大概还有 $15$ 分钟下考的样子?发现 $T1$ 的复杂度跑所有点都是可以的,带个高精就好了… 于是迅速 $rush$ 了一个高精,并且和前面的部分分情况做,又过了一次大样例. 预计 $50/100+20+30=100/150$ ,下午看分: $0+20+20=40$. $T3$ 挂了 $10分$ ,$T1$ 直接 $fst$ 了???怎么目前为止每次 $D1T1$ 都 $fst$ 啊??? 心态有些炸裂. $Day\ 2$ 也不指望能翻盘了.把自己能打的打好就可以了吧. 开题之后,误以为 $T1$ 非常普及,打了将近个一小时后发现是假的… 迅速写了个最暴力的 $O(n^3)$ 暴力,去看后面两个题. 姿势水平不够,依然只能打暴力. $T2$ 的暴力写了 $6kb$ , $T3$ 写了个暴力+线性基的部分分. 回过来看 $T1$ ,发现直接用最大子段和做是 $O(nm)$ 的,但我觉得直接把前面的线段树改一下,也就多个 $log$ 啊? 写完之后才发现这一档是 $n,m\leq 10^4$…测了一下自己的 $O(nmlogn)$ ,跑了 $7s,O2\ 1.7s$ ,但 $T1$ 偏偏 $2s$ ,无优化? 钦定卡常可还行?觉得自己改成 $O(nm)$ 也不太稳,于是就没有写,把 $T2$ 的树剖+树状数组的暴力再看了几遍… 预估 $20+40+40=100$ ,实际: $20+40+20=80$. $T3$ 线性基求秩咋挂的啊…感觉暴力挂掉的可能更大啊… 后记 已编辑并删除部分过激言论. 今年我们学校 achen 以女选手的身份进队,虽然以她的水平这次其实也有一些失误的? NamelessOIer 和 autoint都在 $40$ 名左右,刚好可以买 $D$ 的样子??? 各位, $NOIP\ 2019$ ,有缘再会.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F11%2F11%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[序幕 $Day\ -1$ 上午考试…打开一看是noip2017的题,心态崩了…. xjb敲了一会,最后我的模拟 $FST$ 了… 下午开始巨tm难受,感冒了…头昏脑胀,慌得一匹… $Day\ 0$ 上午还是考试…结果是神仙题… 三道数学,T1压位高精努力打了一下,后面就乱搞了… 今天不应该出所有人都AK的题吗??? 下午坐车去成都… 晚上一直在看费用流和数学相关的东西,恍恍惚惚混过去了,感觉很慌… $Day\ 1$ 进了考场不让碰键盘鼠标就很难受… 开考的时候反而不是很紧张,因为在那里干坐了许久… 大致浏览了一遍…怎么没有%你题? 开始搞T1…搞不出来自己乱想了个东西,锤了一发,秒过大样例,就不管了… T2 像是大凯的疑惑…不过这题wys给我讲过升级版的…那道题是转化成图论跑最短路… 这道题连边权都不用考虑,一个 $bfs$ +时间戳优化卡常. 然后看 $T3​$ ,不会做. 开始打 $subtask$ ,打到11点的样子,打完了55分的 $subtask$ ,然后写个暴力开始逐个拍… day1 预估 $100+100+55=255.$ upd: T1我作了大死: 12while(!d[curp]) ++curp; 没有限制$curp\leq n$.在本机上这样写,溢出之后会访问奇怪的内存,不为0,就会自动跳出…所以我才丝毫没有发觉… 然而在Noi Linux环境下这样写就会导致全部RE… 这下凉的透彻.1=都很难说了. $Day\ 2$ T1先写了个树的 $60pts$ .然后基环树没想出来…一直在想 $O(nlogn)$ 的算法…据说是有的,但是我太菜了… T2我的状压,猜的结论是错的,死活过不了 $n=3$ 的样例…找了一波 $n=2$ 的规律,手算前面部分,$50pts$… T3 动态dp啊…然而时间不多了,也不太敢写…就写了个 $50pts$ 的暴力更新和 $18pts$ 的 $subtask$ . day2 预估 $60+50+68=178.​$ 后记 所以本来上个400应该还是没啥问题吧,然后T1原地爆炸… 目标从保$400pts$变到保1=…这是何等的凄凉… 现在只能给$CCF$上香…保住我的1=不爆炸….T1不RE还是别奢求了 等1920号公布成绩了. upd:凉凉.289.求不被卡1=. $D1T1$ 爆零,意料之中; $D1T3$ 被少爷机卡了 $25pts$ , $D2T3$ 的子任务应该是打炸了,只有 $44pts$ 的弱智分…]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
