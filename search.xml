<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[置顶-NOI2019同步赛游记]]></title>
    <url>%2F9102%2F07%2F16%2FNOI2019%E5%90%8C%E6%AD%A5%E8%B5%9B%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[同步爆零. $Day -\infty$划水,摸鱼,被虐. $Day\ 1$做题顺序 $1\to 2\to 3$ . $T1$ 感觉 $70$ 分很可做,大力 $O(\max q\cdot n)$ 来 $dp$ . 不是 $DAG​$ 也没有关系,时间那一维是没有后效性的,先枚举时间就好了. 然后又感觉后面的 $15$ 分也可以做,每个点按照所有的上/下车时间,将 $n$ 个点拆成 $O(m)$ 个点,这部分 $A=0$ ,贡献是线性的,所以对于原来一个点拆出来的所有点,连边时不需要两两连,按时间排序,相邻的才连边,然后跑 $Dijkstra​$ . 感觉这个玩意细节处理起来比较麻烦,只有 $15$ 分,就先放着,去看后面两个题. $T2$ 无想法,写了 $20$ 分暴力就放着了. $T3$ 无想法,写了个 $28$ 分的 $O(n^4)$ 大力 $dp$ 就放着了. 回过去看 $T1$ ,发现 $\max q$ 只有 $1000$ . 算了一下,发现答案不会爆 $int$ ,这样开一个 $\max q\cdot n$ 的二维数组需要 $400\ MB$ 左右?空间限制是 $512\ MB$ ? 那直接 $O(\max q\cdot n)$ 行不行啊,感觉还有很多无效状态的样子.写了一发,开上 $O2$ ,发现大样例要跑 $2s$ .感觉可以寻址优化,于是把二维数组的两个维度交换一下,就只用跑 $0.5s$ 了.这东西能过?虽然不太清楚但也只能先这样了… $T2$ 还是没有什么想法,但发现 $T3$ 费用流应该可以做 $n\le 150$ 的点,说不定 $n\le 2000$ 也可以过. 迅速建了个模,码码码…发现不对.肉眼调试了一会,发现没加反边.(蠢得离谱) 改过来,发现还是不对.调了一会,发现我求的是最小值.把费用改成负的,还是不对? 小数据调了一下,发现建模有问题,流量可以偷偷流走.调整了几波模型,发现流量还是偷偷流走. 可能就没什么时间了.费用流就破产了,把三道题的三个暴力检查了一下,卡了下常数,今天就结束了. 然后出去吃饭,黄学长还吃过敏了… 下午 $4$ 点左右有数据了.测了一下, $100+20+28=148$ ,没挂, 成功 获得暴力分. $Day\ 2$做题顺序 $1\to 2\to 3$ . $T1$ 感觉用 $kdt$ 建图就好了?然后发现空间 128 MB .跑了一波边数,发现开不下. 意识到出题人安排这个空间就是卡 $kdt$ 的?但是貌似想不出其他比较优秀的做法了… 只好头铁写了一波 $kdt$ . 看 $T2$ ,怎么又是 $landlords$ …先写了个 $10$ 分暴力,写 $dp$ 的部分分时候思路很乱,胡乱写了一发,过不了样例.调了一会,未果,只好放着了… $T3$ 是个交互?自己似乎是第一次做这种带端口的交互(之前只在 $CF/ATC$ 上遇到输出命令来交互的题). 有点被吓到,冷静下来分析一波,发现前面 $5$ 个点就是暴力分,每个点改一次,再询问所有点,变了的就是与它有边的. 度数 $=1$ 的部分也比较可做,图是 $N/2$ 个点对,询问次数是 $N\log N$ ,提示得比较明显,每个二进制位都做一次,将当前二进制位为 $1$ 的点 $modify$ 一次,再询问所有点,若它的状态改变,说明它连的点这一位上与它相同,否则不同. 于是就有 $36$ 分的暴力了. 回过去再卡了一下 $T1$ 的空间,就结束了… 下午测了一波, $76+10+36=122$ . 后记果然自己还是菜的真实,打 $\color{brown} {Cu}$ 了.希望明年能作为正式选手取得令自己满意的成绩吧.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190829]]></title>
    <url>%2F2019%2F08%2F29%2Ftest20190829%2F</url>
    <content type="text"><![CDATA[我上当了. $path$典故 枚举出发点 $S$ ,建出以 $S$ 为起点的最短路图,即只保留 $dis(u)+val(i)=dis(v)$ 的边 $i$ . 在最短路图上 $dp$ ,拓扑排序后求出 $f(i)$ 表示 $S\to i$ 的路径条数, $g(i)$ 表示以 $i$ 为起点的路径条数. 那么对于在最短路图上的一条边 $u\to v$ ,以 $S$ 为起点时的所有贡献为 $f(u)\cdot g(v)$ . 时间复杂度 $O(nm\log n)$ . $seq$典故 ,来自电子神大的 $OJ$. 由于题面没说清楚,就认为规定 $j&gt;i$ ,把数据修了. 就是要找到右边第一个严格大于 $a_x$ 的位置 $y$ ,那么 $[x+1,y-1]$ 这一段都可以作为答案,可以在线段树上二分. 然后加上从 $y$ 开始,最长单调不下降子序列的长度,这可以分块. 分成 $\sqrt n$ 个块后,维护每一块内部的不下降子序列和块边界处的不下降子序列. 然而直接 $O(n^2)$ 暴力可以过 $80\sim 100$ 分? 我上当了,写了个线段树 + 定期重构,比暴力的分还少一些,而且我发现去掉重构之后还是差不多慢. $area$求圆环的面积并, $n\le 1000$ . 留坑. 我上当了,写了个撒点,精度太垃圾了,甚至要开 $0$ 位小数才能过前两个点.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
        <tag>test</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190828]]></title>
    <url>%2F2019%2F08%2F28%2Ftest20190828%2F</url>
    <content type="text"><![CDATA[原题大战. $dna$典故 学了回文自动机再来更. $color$其实应该算是原题的弱化版. 典故 记 $dist(x)$ 表示根节点到 $x$ 的距离, $dis(x,y)$ 表示 $x,y​$ 之间的距离.$$\begin{aligned}ans&amp;=\sum_{y=1}^{k} dis(x,y) \\&amp;=\sum_{y=1}^k dist(x)+dist(y)-2\cdot dist(LCA_{x,y}) \\&amp;=dist(x)\cdot k+\sum_{y=1}^{k} dist(y)-2\cdot\sum_{y=1}^k dist(LCA_{x,y})\end{aligned}$$前面两项都容易维护,考虑如何计算最后一项的贡献. $dist(LCA_{x,y})$ 其实就是 $x$ 到根的路径与 $y$ 到根的路径交集部分的长度. 每新染黑一个 $y$ ,就将 $y$ 到根节点上的每条边标记 $+1$ . 询问时,最后那一项就是 $x$ 到根节点路径上每条边的 标记次数 $\times​$ 边长. 可以用树链剖分 + 线段树来维护,时间复杂度 $O(n\log^2 n)$ . $land$典故 题目中已经告诉我们怎么判断一个格子是否在多边形内部,这个判断条件只跟穿过次数奇偶性有关. 可以利用它进行状压 $dp$. 给每个格子选一条射线,在转移的过程中更新有宝藏和陷阱的格子那条射线穿过边的奇偶性状态. $f(i,j,S)$ 表示当前在格子 $(i,j)$ ,宝藏和陷阱的射线奇偶性状态为 $S$ 时,多边形最小周长. 转移时直接 $bfs$ ,最后枚举哪些宝藏被圈了起来,统计答案.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>状压dp</tag>
        <tag>test</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190827]]></title>
    <url>%2F2019%2F08%2F27%2Ftest20190827%2F</url>
    <content type="text"><![CDATA[roll 制出题人. 大样例没有,小样例极水,权值范围也没有,题意还没说清楚. $guard$每个武器只能打死一个人.我以为能将小于等于它的的全部打死,就保龄了. 将所有武器按 $a$ 从小到大排序. 第一次枚举确定哪些武器用精灵,如果用精灵能打死的怪的 $b&gt; a_i​$ ,就用精灵打. 然后剩下的武器都不用精灵,直接贪心匹配. 时间复杂度 $O(T\cdot n\log n)$ $phase$直接用树剖 + 线段树维护区间内所有点权值的异或和,时间复杂度是 $O(n\log^2 n)$ . 但用一下异或的性质,就能做到 $O(n\log n)$ . 记 $dist(i)​$ 表示从 $i​$ 到根节点的路径上经过的所有点权值异或和. 每次询问 $(x,y)$ ,先求出它们的 $lca$ ,答案就是 $dist(x)\text{ xor }dist(y)\text{ xor }dist(lca)\text{ xor }dist(fa(lca))$ . 树剖后用线段树来维护每个点的 $dist$ ,每次修改时,子树 $x$ 内深度奇偶性与 $x$ 不同的点 $dist$ 会被异或上 $y$ . 线段树中维护两个标记,分别表示深度为奇/偶的点需要异或上的值,时间复杂度 $O(n\log n)$ . $refuse$$50$ 分的做法是状压 $dp$ ,设 $f(r,c)$ 表示行覆盖情况为 $r$ ,列覆盖情况为 $c$ 时的期望,时间复杂度 $O(2^{n+m}\cdot nm)$ . 但不知道怎么回事写挂了,就保龄了. 下面是正解. 设 $f(i)$ 为恰好经过 $i$ 次操作后成功的概率,根据期望定义,答案 $ans=\sum_{i=0}^{+\infty} f(i)\cdot i$ . 再设 $P(i)$ 表示经过了 $i$ 次操作后还没有成功的概率.那么就等价于在之后成功的概率之和, $P(i)=\sum_{j=i+1}^{+\infty} f(i)$ . 可以发现 $ans=\sum_{i=0}^{+\infty} P(i)$ ,因为这样计算,每个 $f(i)$ 都恰好被计算了 $i$ 次. 于是需要考虑如何求出 $P(i)$ . 枚举哪些行和列在前 $i$ 次操作都没有被标记,记它们形成的集合为 $s$ . 设 $p(s)$ 表示选中集合 $s$ 中的行列中的格子 $1$ 的概率,那么 $i$ 次都没选中就是 $(1-p(s))^i$ ,利用容斥原理计算,$$P(i)=\sum_s (-1)^{|s|+1} \cdot (1-p(s))^i$$代入答案 $ans$ ,$$\begin{aligned}ans&amp;=\sum_{i=0}^{+\infty} P(i) \\&amp;=\sum_{i=0}^{+\infty} \sum_s (-1)^{|s|+1} \cdot (1-p(s))^i \\&amp;=\sum_s (-1)^{|s|+1}\cdot \frac 1 {p(s)}\end{aligned}$$设 $tot$ 为格子 $1$ 的总数目, $sum(s)$ 表示集合 $s$ 的行列含有的 $1$ 的数目,那么答案为$$ans=\sum_{s}(-1)^{|s|+1}\cdot \frac {tot} {sum(s)}$$于是只需要计算 $sum(s)$ .因为 $sum(s)$ 相同的状态有很多,可以设 $num(x)=\sum_s [sum(s)=x]\cdot (-1)^{|s|+1}$ . 则答案为$$ans=\sum_{x=1}^{tot} num(x)\cdot \frac {tot} {x}$$考虑如何计算 $num(x)$ ,由于 $n\cdot m\le 200$ ,所以 $\min(n,m)\le 14$ . 假设 $n\le m$ ,否则只需交换行与列. 暴力 $2^n$ 枚举选了哪些行,对列做 $dp$ ,设 $dp(i,j,k)$ 表示考虑了前 $i$ 列, $|s|$ 的奇偶性为 $j$ , $sum(s)=k$ 的方案数. 最后根据奇偶性计算出每个 $num(x)​$ ,统计答案即可. 时间复杂度为 $O(2^n\cdot m^2\cdot n )​$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>概率/期望</tag>
        <tag>容斥原理</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190826]]></title>
    <url>%2F2019%2F08%2F26%2Ftest20190826%2F</url>
    <content type="text"><![CDATA[两个简单题 + 一个比较难的原题. $Gene$有一个十分简单的 $O(n\log n)$ 的做法,字符串 $hash$ + 二分,用自然溢出常数比较小,是可以过的. $O(n)$ 的一个做法是 $SAM$ ,对反串建后缀自动机,答案就是每个点的 $siz$ 之和,但空间很容易炸. 另一个做法是利用 $kmp$ 的 $fail$ 数组,每个位置不断往前跳,每跳一次就说明有一个合法的匹配. 暴力跳会超时,记忆化一下,用 $f(i)$ 表示从 $i$ 开始能往前跳几次,则 $f(i)=f(fail_i)+1$ . $Shield$因为给出的两个向量线性无关,可以它们为一组基底,解出每个点在这组基底下的坐标. 于是一个点可以转移到 $x,y$ 都不小于它的点. 将点按 $x$ 为第一关键字, $y$ 为第二关键字排序,将 $y$ 离散化后用树状数组做一个类似于 $LIS$ 的 $dp$ 即可. 时间复杂度 $O(n\log n)$ . 坐标太大,精度爆掉了一个点.其实可以在比较元素时再转换坐标,避免小数运算. $Chronosphere$典故 首先可以建出源汇点 $S,T​$ ,源点向所有点连边,所有点向汇点连边. 问题转化为最小化删去一个点后 $S\to T$ 的最长路长度. 拓扑排序 + $dp$ 处理出 $f(i),g(i)$ 分别表示 $S\to i$ 的最长链与 $i\to T$ 的最长链经过的点数. 那么对于一条边 $u\to v$ ,它的的贡献就是 $f(u)+g(v)-1$ . 若有一个 $S\to T$ 的割,那么所有 $S\to T$ 路径一定会经过至少一条割集中的边,只需要考虑割集中的边贡献. 一开始让 $s$ 集只有 $S$ , $T$ 集包含剩余的所有点,这是一个合法的割. 按照拓扑序枚举删掉 $x$ 后的答案,依次进行如下操作,以将点 $x$ 从 $T$ 集合中取出,放入 $S$ 集中. $1.$ 将 $x$ 的所有入边从割集中删掉. $2.$ 所有割集的边的最大贡献就是删掉点 $x$ 的答案. $3.$ 将 $x$ 的所有出边加入割集. 正确性可以利用数学归纳法证明. 执行第 $1$ 步之前,割是整张图的一个割,假设它不含从 $x$ 出发能到的任何边. 所以删掉 $x$ 的入边后,割就是去掉 $x$ 的图的一个合法割,此时可以更新答案. 若将 $x$ 放回图中, $S\to T$ 的路径就一定经过 $x$ ,所以割掉 $x$ 的所有出边,又成了一个合法割. 因为是按照拓扑序依次处理的,所以加入的 $x$ 的入边在之后一定不能被到达,满足了先前的假设. 而初始状态也是满足假设的,所以可以归纳证得以上算法的正确性. 割集只需要记录边的贡献,不记录边的编号,所以可以用一棵权值线段树进行维护,时间复杂度 $O(m\log m)$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>kmp</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190825]]></title>
    <url>%2F2019%2F08%2F25%2Ftest20190825%2F</url>
    <content type="text"><![CDATA[我的线段树自带 $10$ 倍常数. $Count$对于每一种 $\prod a_i\not=n^m​$ 的选法,都恰好存在另一种对应的选法 $\prod \frac n {a_i}​$ . 随便选的方案数为 $(\sigma(n))^{2m}$ ,再加上 $\prod a_i=n^m$ 的方案数,除以 $2$ 就是答案. 于是只需要算 $\prod a_i=n^m$ 的方案数. 将 $n$ 分解质因数,显然每个质因子可以分开算方案,答案是每个质因子的贡献乘积. 每个质因子的贡献就是一个整数划分问题, $dp$ 一下,因为方案数只与质因子质数有关,所以可以最后一起加入贡献. $Delete$每次删掉最长的一个单调序列,直到删完. 假设当前的序列长度为 $n$ ,最长上升子序列长度为 $a$ ,最长下降子序列长度为 $b$ . 根据 $Dilworth$ 定理,用最长上升子序列覆盖这个序列至少需要的子序列数目也是 $b$ . 所以就有 $a\cdot b\ge n$ ,得到 $\max(a,b)\ge \sqrt n$ . 于是每次操作至少会使得一个长度为 $n$ 的序列长度减少 $\sqrt n$ ,当 $n=64000$ 时,一定可以在 $500$ 次内删完. $Floor\ it$考虑斐波那契数列的两个特征根 $\phi_1=\frac {1+\sqrt 5} 2,\phi_2=\frac {1-\sqrt 5} 2$ ,其中 $\phi_1$ 就是题目中给出的 $x$ . 构造数列 $a_i=\phi_1^i+\phi_2^i$ ,则 $a$ 有递推式 $a_i=a_{i-1}+a_{i-2},a_1=1,a_2=3$ ,可知 $\forall i\in \mathbb N+,a_i\in \mathbb N+ $. 当 $n$ 为偶数时, $0&lt;\phi_2^n&lt;1,\lfloor x^n\rfloor=a_n-1$ . 当 $n$ 为奇数时, $-1&lt;\phi_2^n&lt;0,\lfloor x^n \rfloor=a_n$ . 用矩阵快速幂 $O(\log n)​$ 求 $a_n​$ 即可.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>构造</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Japanese Student Championship 2019 Qualification]]></title>
    <url>%2F2019%2F08%2F25%2FJapanese-Student-Championship-2019-Qualification%2F</url>
    <content type="text"><![CDATA[$\text{+9 rating}$ 可还行. A Takahashi Calendar签到题,按题意暴力枚举一下. B Kleene Inversion贡献可以分成两部分,两个数在同一块中的贡献与两个数在不同块中的贡献,分开算一下. C Cell Inversion操作顺序对答案没有影响,将操作视作一个二元组 $(l,r)$ ,我们可以规定按 $l$ 从小到大的顺序操作,最后答案乘上 $n!$ . 将黑色看为 $1$ ,白色看为 $0$ ,显然只需要将偶数位置上的状态取反,然后答案就是前面的 $1$ 与后面的 $0$ 配对的方案数. 开始没判 $1$ 和 $0$ 个数不等的情况,卡了挺久的. D Classified题意读错了.意思是走回来时,走过的长度为偶数,不是每条边经过的次数都为偶数. 于是就要求同一种边权的边形成的图是二分图. 如果用到最大的边权为 $k$ ,那么最多只能构造出 $n=2^k$ 的情况. 首先证最大边权为 $k​$ 时, $n=2^k+1​$ 不可行. 考虑使用数学归纳法,当 $k=1,n=2^1+1=3$ 时,显然不可行.否则,假定 $k=x-1,n=2^{x-1}+1$ 时不可行. 那么当 $k=x,n=2^x+1$ 时,二分图中黑色的节点至少有 $2^{x-1}+1$ 个,否则白色的节点至少有 $2^{x-1}+1$ 个. 假设黑色节点至少有 $2^{x-1}+1$ 个,对于黑色节点内部,因为用前 $x-1$ 种边权无合法解,所以一定会有权值为 $x$ 的边. 这与二分图的定义相矛盾了,所以结论成立,即最大边权为 $k$ 时, $n=2^k+1$ 不可行. 再来证 $n\le2^k$ 时一定存在最大边权不超过 $k$ 的合法解,尝试直接构造方案. 对于节点 $i,j$ ,若它们的二进制位从低到高第 $x$ 位不同,就将它们之间的边权设为 $x$ . 这样对于任意一个 $0\le x&lt;k$ ,边权为 $k$ 的边一定只存在于第 $x$ 位为 $0$ 与第 $x$ 位为 $1$ 的点之间,形成了二分图. E Card Collector考虑像网络流那样,每一行每一列都建出一个点,读入的每个点向所在行列连边,权值都是 $A_i$ . 于是需要选出一些边使得它们的权值最大,并且任意两条边不能有公共点. 分析性质后,发现就是在求解加权拟阵的最大权值独立子集,贪心求解即可. 即将所有边按权值从大到小排序后,依次遍历,若当前的边能加入,就加入. F Candy Retribution留坑.]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>数学</tag>
        <tag>构造</tag>
        <tag>二分图</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4245 OR-XOR]]></title>
    <url>%2F2019%2F08%2F24%2Fbzoj-4245-OR-XOR%2F</url>
    <content type="text"><![CDATA[贪心. 因为答案的形式是每一段的权值 $\text {or}$ 起来,从高位到低位考虑,贪心地让高位尽可能为 $0$ . 尝试让答案的第 $i$ 位为 $0$ ,就要求选出的 $m$ 个权值的第 $i$ 位都为 $0$ . 因为这 $m$ 段是连续的,所以就等价于选出 $m$ 个右端点,且最后一个必须选 $n$ . 求出原数列的前缀异或和,容易发现这 $m$ 个右端点处的前缀异或和第 $i$ 位都必须为 $0$ . 于是从高位往低位做,若当前位有至少 $m$ 个可选的位置(必须包含 $n$ ),则这一位对答案的贡献为 $0$, 否则为 $1$ . 每次贡献为 $0$ 时,将前缀异或和这一位为 $1$ 的位置标记出来,表示以后都不能再选了,否则会使得这一位为 $1$ . 注意要用 $\text{1LL}$ 参与位运算. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m;ll sum[MAXN];bool vis[MAXN];bool check(int k)&#123; if((sum[n]&gt;&gt;k)&amp;1LL) return false; int cnt=0; for(int i=1;i&lt;=n;++i) if(!((sum[i]&gt;&gt;k)&amp;1LL) &amp;&amp; !vis[i]) ++cnt; return cnt&gt;=m;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]^read(); ll ans=0; for(int k=62;k&gt;=0;--k) &#123; if(check(k)) &#123; for(int i=1;i&lt;=n;++i) if((sum[i]&gt;&gt;k)&amp;1LL) vis[i]=true; &#125; else ans|=(1LL&lt;&lt;k); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4299 FRBSUM]]></title>
    <url>%2F2019%2F08%2F24%2Fbzoj-4299-FRBSUM%2F</url>
    <content type="text"><![CDATA[主席树. 考虑如何计算一个集合的 $\text{Forbidden Sum}​$ . 将集合内的数从小到大排序,依次加入.若当前可以表示出 $[0,s]$ 内的所有数,再加入一个数 $x$ . 若 $x\le s+1$ ,则可以表示出 $[0,s+x]$ 内的所有数.若 $x&gt; s+1$ ,则 $s+1$ 无法被表示出,答案为 $s+1$ . 实际做的时候可以换一种思路,将枚举 $x$ 变为不断更新 $s$ . 初始令 $s=1​$ ,每次在区间 $[l,r]​$ 内询问所有 $\le s​$ 的数之和,即上面分析的前缀和.若询问到的 $x&lt;s​$ ,则答案为 $s​$ . 否则令 $s=x+1$ ,继续询问. 询问一段区间内 $\le s​$ 的所有数之和可以用主席树实现. 考虑时间复杂度,若每次都 $x\ge s$ ,每次询问 $s$ 至少翻一倍,所以在主席树上查询了 $O(\log \sum a_i)$ 次. 总时间复杂度为 $O(m\cdot \log \max a_i\cdot \log \sum a_i)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct PreSegtree&#123; int idx; struct node &#123; int ls,rs; int sum; node()&#123;ls=rs=sum=0;&#125; &#125;Tree[MAXN*30]; PreSegtree()&#123;idx=0;&#125;#define root Tree[o] void ins(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[pre]; root.sum+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,Tree[pre].ls,l,mid,pos,c); else ins(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; int query(int o,int l,int r,int val)// \le val &#123; if(l&gt;val) return 0; if(r&lt;=val) return root.sum; int mid=(l+r)&gt;&gt;1; return query(root.ls,l,mid,val)+query(root.rs,mid+1,r,val); &#125;&#125;T;int n,m,a[MAXN],mx=0,rt[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) mx=max(mx,a[i]=read()); for(int i=1;i&lt;=n;++i) T.ins(rt[i],rt[i-1],1,mx,a[i],a[i]); m=read(); for(int i=1;i&lt;=m;++i) &#123; int L=read(),R=read(); for(int s=1,x;;s=x+1) &#123; x=T.query(rt[R],1,mx,s)-T.query(rt[L-1],1,mx,s); if(x&lt;s) &#123; printf("%d\n",s); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4289 Tax]]></title>
    <url>%2F2019%2F08%2F23%2Fbzoj-4289-Tax%2F</url>
    <content type="text"><![CDATA[构造建图 + 最短路. 先将无向边拆成两条有向边,于是可以将原图中的每条有向边看成一个点,建一个新图. 枚举中继点 $x$ ,则对 $a\to x,x\to b$ 这两条边在新图中连上对应有向边,权值为两者最大值. 在新图中建立源汇点 $S,T$ ,从 $S$ 向所有在原图中以 $1$ 为起点的边连边,从所有在原图中以 $n$ 为终点的边向 $T$ 连边,权值均为原来的权值,那么答案就是新图中 $S\to T$ 的最短路. 但这样边数可以被菊花图这样的东西卡到 $O(m^2)$ 去,需要利用差分的思想优化连边. 对于每个点 $u$ ,将所有以它为起点的边按照权值从小到大排序,对于相邻的两条边 $x,y$ ,假设 $val_x&lt;val_y$ ,就在新图中从 $x$ 向 $y$ 连权值为 $val_y-val_x$ 的边,从 $y$ 向 $x$ 连权值为 $0$ 的边, $S,T$ 相关的边连法不变. 这样连边边数就是 $O(m)$ 了,在新图上跑 $Dijkstra$ 求出最短路. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=1e5+10,M=4e5+10;const int MAXM=2e6+10;int n,m;typedef pair&lt;ll,int&gt; pli;priority_queue&lt;pli&gt; q;const ll inf=1e18;struct Graph&#123; int ecnt,head[MAXM],to[MAXM],nx[MAXM],vis[MAXM]; ll val[MAXM],dis[MAXM]; void addedge(int u,int v,ll w) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt; &#125; Graph()&#123;ecnt=0;memset(head,0,sizeof head);&#125; ll Dijkstra(int S,int T,int tot) &#123; for(int i=1;i&lt;=tot;++i) vis[i]=0,dis[i]=inf; dis[S]=0; q.push(make_pair(-dis[S],S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-val[i]&gt;dis[u]) &#123; dis[v]=dis[u]+val[i]; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125; return dis[T]; &#125;&#125;G;int ecnt,head[N],to[M],nx[M];ll val[M];void addedge(int u,int v,ll w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;bool cmp(int x,int y)&#123; return val[x]&lt;val[y];&#125;int S,T,tmp[MAXM],cnt;void BuildGraph()&#123; S=ecnt+1,T=ecnt+2; for(int i=1;i&lt;=ecnt;i+=2) &#123; G.addedge(i,i+1,val[i]); G.addedge(i+1,i,val[i]); &#125; for(int u=1;u&lt;=n;++u) &#123; cnt=0; for(int i=head[u];i;i=nx[i]) tmp[++cnt]=i; sort(tmp+1,tmp+1+cnt,cmp); for(int i=1;i&lt;cnt;++i) &#123; int x=tmp[i],y=tmp[i+1]; G.addedge(x,y,val[v]-val[u]); G.addedge(y,x,0); &#125; &#125; for(int i=head[1];i;i=nx[i]) G.addedge(S,i,val[i]); for(int i=head[n];i;i=nx[i]) G.addedge((i&amp;1)?i+1:i-1,T,val[i]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); ll w=read(); addedge(u,v,w); addedge(v,u,w); &#125; BuildGraph(); printf("%lld\n",G.Dijkstra(S,T,T)); return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3516 国王奇遇记加强版]]></title>
    <url>%2F2019%2F08%2F23%2Fbzoj-3516-%E5%9B%BD%E7%8E%8B%E5%A5%87%E9%81%87%E8%AE%B0%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[推式子题目. 设 $s_x=\displaystyle \sum_{i=1}^n i^x\cdot m^i$ ,则答案 $ans=s_m$ . 考虑构造出 $s_x$ 的递推式. $$\begin{aligned}s_x+(n+1)^x\cdot m^{n+1}&amp;=m\cdot\sum_{i=1}^n (i+1)^x \cdot m^i+m \\&amp;=m\cdot \sum_{i=1}^n \sum_{j=0}^x {x\choose j} i^j \cdot m^i+m\\&amp;=m\cdot \sum_{i=0}^x s_i\cdot {x\choose i} + m\\(1-m)s_x&amp;=m\cdot \sum_{i=0}^{x-1}s_i\cdot {x\choose i}+m-(n+1)^x\cdot m^{n+1}\end{aligned}$$ 特判 $m=1$ 的情况,其余情况利用等比数列求和公式算出 $s_0$ ,再 $O(m^2)$ 递推求得 $s_m$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; a=(a%P+P)%P; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int n,m,C[MAXN][MAXN];int s[MAXN];int main()&#123; n=read(),m=read(); if(m==1) return printf("%d\n",mul(mul(n,n+1),inv(2)))&amp;0; for(int i=0;i&lt;=m;++i) C[i][0]=1; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j-1],C[i-1][j]); s[0]=fpow(m,n)-1; s[0]=mul(s[0],inv(m-1)); s[0]=mul(s[0],m); for(int x=1;x&lt;=m;++x) &#123; int &amp;tmp=s[x]; for(int i=0;i&lt;x;++i) upd(tmp,mul(s[i],C[x][i])); tmp=mul(tmp,m); upd(tmp,m); upd(tmp,P-mul(fpow(n+1,x),fpow(m,n+1))); tmp=mul(tmp,inv(1-m)); &#125; cout&lt;&lt;s[m]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5343 混合果汁]]></title>
    <url>%2F2019%2F08%2F20%2Fbzoj-5343-%E6%B7%B7%E5%90%88%E6%9E%9C%E6%B1%81%2F</url>
    <content type="text"><![CDATA[二分答案 + 主席树. 将美味度离散化,并将所有果汁按照美味度从小到大排序. 可以用主席树维护单价区间能购买到的最大体积之和与总金额之和,对美味度可持久化. 对于每个询问,二分答案 $ans$ ,只考虑美味度 $\ge ans$ 的果汁. 显然应该贪心地选,尽可能选便宜的凑够体积. 于是查询时在主席树上将美味度 $\ge ans$ 的部分抠出来,进行二分. 若左儿子内的体积够,就返回左儿子的答案. 否则将需要的体积减去左儿子内的体积,返回右儿子的答案加上左儿子的所有价格. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;int n,m,td,tp;ll D[MAXN],P[MAXN];struct Juice&#123; int d,p,lim; bool operator &lt; (const Juice &amp;rhs) const &#123; return d&lt;rhs.d; &#125;&#125;a[MAXN];int rt[MAXN];struct PreSegtree&#123; int idx; struct node &#123; int ls,rs; ll sumv,sumc; node()&#123;ls=rs=sumv=sumc=0;&#125; &#125;Tree[MAXN*30]; PreSegtree()&#123;idx=0;&#125; void upd(int &amp;cur,int pre,int l,int r,int cost,ll v,ll c) &#123; cur=++idx; Tree[cur]=Tree[pre]; Tree[cur].sumv+=v; Tree[cur].sumc+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(cost&lt;=mid) upd(Tree[cur].ls,Tree[pre].ls,l,mid,cost,v,c); else upd(Tree[cur].rs,Tree[pre].rs,mid+1,r,cost,v,c); &#125;#define root1 Tree[Lrt]#define root2 Tree[Rrt] ll query(int Lrt,int Rrt,int l,int r,ll tmpv) &#123; if(root2.sumv-root1.sumv&lt;tmpv) return inf; if(root2.sumv-root1.sumv==tmpv) return root2.sumc-root1.sumc; if(l==r) return tmpv*P[l]; int mid=(l+r)&gt;&gt;1; ll totl=Tree[root2.ls].sumv-Tree[root1.ls].sumv; if(totl&gt;=tmpv) return query(root1.ls,root2.ls,l,mid,tmpv); return Tree[root2.ls].sumc-Tree[root1.ls].sumc+query(root1.rs,root2.rs,mid+1,r,tmpv-totl); &#125;&#125;T;int pos[MAXN];bool check(int k,ll budget,ll tmpv)&#123; int rt1=rt[pos[k]-1],rt2=rt[n]; ll cost=T.query(rt1,rt2,1,tp,tmpv); return cost&lt;=budget;&#125;void init()&#123; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) &#123; int x=a[i].d; if(!pos[x]) pos[x]=i; T.upd(rt[i],rt[i-1],1,tp,a[i].p,a[i].lim,1LL*a[i].lim*P[a[i].p]); &#125;&#125;void solve()&#123; for(int i=1;i&lt;=m;++i) &#123; ll budget=read(),tmpv=read(); int L=1,R=td,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid,budget,tmpv)) res=mid,L=mid+1; else R=mid-1; &#125; if(res==-1) puts("-1"); else printf("%lld\n",D[res]); &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; D[i]=a[i].d=read(); P[i]=a[i].p=read(); a[i].lim=read(); &#125; sort(D+1,D+1+n); td=unique(D+1,D+1+n)-D-1; for(int i=1;i&lt;=n;++i) a[i].d=lower_bound(D+1,D+1+td,a[i].d)-D; sort(P+1,P+1+n); tp=unique(P+1,P+1+n)-P-1; for(int i=1;i&lt;=n;++i) a[i].p=lower_bound(P+1,P+1+tp,a[i].p)-P; init(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我复习 noip 数据结构这件小事]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%85%B3%E4%BA%8E%E6%88%91%E5%A4%8D%E4%B9%A0-noip-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[平衡树与 $LCT$ 待更. $STL$关键是会用.比较常用的有 $set,mutiset,priority\ queue,map$ 这几个. 简单说一下 $bitset$ . 1bitset&lt;MAXN&gt; s; 这样就定义了一个 $bitset$ .默认所有位置都是 $0$ . 可以把它看成是一个长度为 $MAXN$ 的布尔数组,也可以看成是有 $MAXN$ 位的二进制数. 它支持直接调用/修改某一位上的值, 12s[0]=1;s[1]=1; 也可以用它直接进行位运算, 1s=s|(s&lt;&lt;10); 一次位运算耗时是长度/系统位数,一般是 $32$ 或者 $64$ . 这个东西就可以把一些只有 $0/1$ 运算的做法给优化 $32/64$ 倍. 原理也很好理解,就是把每 $32/64$ 位压成一个整数参与运算,所以也可以手写它,不过会比较麻烦. 贪心只能过样例 sol 并查集一定记得要初始化. 优化的方式主要有两种,路径压缩和按秩合并.按秩合并就是把小的合并进大的里面. 如果需要支持退回上一步操作,那么就只能选用按秩合并. 单独使用路径压缩或者按秩合并,查询一次的时间复杂度是 $O(\log n)$ ,同时使用是 $O(\alpha(n))$ . 但大多数情况我们都只写路径压缩,因为很难将它卡到 $\log$ 的级别去. 有些并查集会顺带维护这个块内的其他信息,合并的时候一起合并就可以了. 树状数组一维的树状数组比起线段树的优势就是代码容易编写与常数较小,而功能远不如线段树全面. 它的优点是可以比较简单的拓展到高维,而二维线段树就已经比较难写了. 如二维平面上的数点/求和,但坐标可能需要离散化. 上帝造题的七分钟 线段树经典数据结构,使用的方法也很多. 经典应用线段树的经典应用,维护区间内的信息,并支持单点/区间修改.如维护区间和,支持区间加,区间乘. 本质上只有这三个点是会根据不同的题而产生差别的. 如何将两个小区间内的信息合并起来得到大区间. 一个修改操作执行后,区间内的各个信息分别会怎样变化. 如何合并两个懒标记(如果有区间修改). 如果你发现这三点都能在很短的时间内做到,那么这个信息就可以用线段树来维护. 算术天才⑨与等差数列 sol 排序 sol 序列 sol 动态开点线段树就是新到一个点的时候,如果没有,你再新建一个节点作为这个节点. 回转寿司 sol 可持久化线段树 又称主席树,因为发明者的姓名拼音缩写为 hjt ,与中华人民共和国前国家主席的缩写一样… 可以存储 $m$ 个版本的线段树信息,要求每次修改都只是单点修改,每颗线段树的管辖范围都是 $[1,n]$ . 考虑线段树的一次单点修改操作,影响到的节点只有对应叶子节点到根节点路径上的所有节点. 这些节点数目是 $O(\log n)$ 的,所以在维护新版本的线段树时,只用新建出这些节点,其它节点沿用上个版本的. 并不用每次都把上个版本的所有节点拷贝出来,因为每个节点只需要知道儿子节点,直接将儿子节点指过去. 显然需要使用动态开点. 经典的使用方法是利用主席树对 $[1,1],[1,2],[1,3]\dots,[1,n]$ 这 $n$ 个前缀建出 $m$ 颗线段树. 这样在查询可减的信息时(如某数的个数),就可以直接用 $[1,R]$ 的线段树答案减去 $[1,L-1]$ 的线段树答案了. Kth number sol 混合果汁 sol 李超线段树解决的经典问题是每次可以在平面内添加一条 $y=kx+b​$ 的线段,或者询问当 $x=x_0​$ 时,各个线段中最大的 $y​$ . 如果是先添加完所有线段,再进行若干次询问,可以求出上凸壳, $O(n\log n)$ 解决. 李超线段树维护的是各段区间内 优势线段 的编号. 优势线段 是指,这段区间内能成为最优线段的长度最大的那条线段. 往区间 $(l,r)$ 插入一条线段 $c$ 时,就与当前区间 $(l,r)$ 内维护的优势线段 $s$ 比较. 若这两条线段在 $(l,r)$ 内满足一条完全覆盖了另一条,就直接更新优势线段并返回. 否则,就递归下去,用 $c$ 去更新两个子区间. 因为至少在 $[l,mid]$ 与 $[mid+1,r]$ 这两个区间中的一者, $c$ 完全覆盖了 $s$ ,或 $s$ 完全覆盖了 $c$ . 所以更新一个线段树上的区间的时间复杂度是 $O(\log n)$ ,插入一条线段的总时间复杂度是 $O(\log^2 n)$ . 查询时就在线段上向下走,经过一个区间时,就用这个区间的优势线段来更新答案,每次的时间复杂度是 $O(\log n)$ . 适者 sol 游戏 sol) 吉司机线段树区间取最值问题维护一个长度为 $n$ 的整数序列 $a$ ,支持以下 $m$ 次操作: 区间 $[L,R]$ 内的所有数 $a_i$ 与 $x$ 取 $\min$ . 区间 $[L,R]$ 内所有数加上 $x$ . 询问区间 $[L,R]$ 中 $a_i$ 的最大值. 询问区间 $[L,R]$ 中 $a_i​$ 的和. 对线段树每个区间维护最大值 $mx$ ,最大值的个数 $cnt$ ,次大值 $se$ ,区间和 $sum$ . 询问操作可以定位后直接做. 对于修改操作,若将一个线段树区间对 $x$ 取 $\min$ ,可以分情况讨论: $mx\le x$ ,无效果,直接返回. $se&lt;x&lt;mx$ .效果就是将所有 $mx$ 改为 $x$ ,其它不变.新的区间和 $sum’=sum-(mx-x)\cdot cnt​$ 可以直接算出,再打上修改标记,返回. $x\le se​$ .递归下去,分别修改左右儿子. 复杂度为 $O(n\log^2 n)$ ,但实现效果接近 $O(n\log n)$ .如果没有操作 $2$ ,复杂度就是 $O(n\log n)$ . 最假女选手 历史最值问题维护一个长度为 $n$ 的数列 $a$ ,支持以下 $m$ 次操作: 区间 $[L,R]$ 内所有数加上 $x$ . 区间 $[L,R]$ 内所有数变为 $x$ . 询问 $[L,R]$ 内数的最大值. 询问 $[L,R]$ 内数的历史最大值. 修改操作的 $x$ 可能 $&lt;0$ . 尝试将两种修改操作归纳为一种修改操作 $(a,b)$ ,表示先加上 $a$ ,再与 $b$ 取 $\max$ . 那么修改 $1$ 对应的操作就是 $(x,-\inf)$ ,修改 $2$ 对应的操作就是 $(-\inf,x)$ . 考虑两个标记如何合并,假设当前权值为 $v$ ,依次经过 $(a,b),(c,d)$ 两次修改的效果:$$\begin{aligned}v&amp;\to \max{\max{v+a,b}+c,d} \\&amp;=\max{v+a+c,b+c,d} \\&amp;=\max{v+a+c,\max{b+c,d}}\end{aligned}$$可以看出就等价于一次修改操作 $(a+c,\max{b+c,d})$ ,于是两个标记就合并为了一个. 为了能查询历史信息,维护一个意义一样的标记 $(a,b)$ ,表示区间内历史的最大增加量 $a$ ,历史最大与 $b$ 取 $\max$ . 将两个标记的 $+$ 定义为两个标记的合并,两个标记取 $\max$ 定义为两个元素分别取 $\max$ . 每次更新标记后,若当前标记为 $x$ ,历史标记为 $y$ ,则让 $y=\max(x,y)$ . 每个结点需要维护当前标记,历史标记,当前最大值,历史最大值 $4$ 个信息. CPU监控 线段树分治题目也是让你维护一些信息,每次可以询问,可以执行一种操作,也可以将之前的某个操作撤回. 操作容易维护,但撤回操作不容易维护. 需要将操作,询问都离线下来.将时间轴画出来,那么每个操作只在时间轴上的一个区间内生效. 用线段树给这个区间打上这个操作的标记,维护信息. 数学计算 sol 洞穴勘测 sol 线段树合并其实就是两颗权值线段树的合并,都使用动态开点. 如果合并到一个位置时,其中一者没有这个位置上的节点,就直接返回另一者. 否则将这个位置的信息合并后,还要递归合并它们的儿子. 树的难题 sol $kd-tree$处理二维/高维上点的信息.其实就是一棵二叉树. 注意它是二叉树,所以信息的存储与线段树不同. $kd-tree$ 每个结点存储的是整个子树的信息和自己的信息. 每个点有若干个维度,可以表示为 $(p_1,p_2,p_3,\dots,p_k)$ . 建树时,选择按照当前维度排序后的中点作为根,递归建左右子树,每次进入下一层是更换当前维度. 每个节点需要维护自己的坐标,以及每个维度的管辖范围. 查找平面上最近点是爆搜 + 剪枝,复杂度为玄学. 如果提出一个范围内所有点进行修改/询问,复杂度为 $O(n^{1-\frac 1 k})$ ,其中 $k$ 为维度. 这里的范围是指每一维的坐标都在某个特定的区间中,如二维平面中的矩形. 巧克力王国 弹跳 莫队经典莫队需要离线,且无修改操作. 问题是给出 $m$ 个询问,每次询问序列上一个区间 $[l,r]$ 内的信息. 特点是如果维护了 $[l,r]$ 内的所有信息与答案,则可以 $O(1)$ 得出 $[l,r+1],[l,r-1],[l-1,r],[l+1,r]$ 这些区间的信息与答案. 做法是将长度为 $n$ 的序列分块,每 $B$ 个数分为一块. 再将询问排序,排序时以 $l$ 所属块的编号为第一关键字,以 $r$ 为第二关键字. 然后维护当前区间 $[L,R]$ 中的信息,遍历每个询问,不断移动当前区间端点并更新信息,当前区间与询问区间重合时,就得到了答案. 考虑这样做的时间复杂度. 对于同一块内的询问, $L$ 移动 $O(B)$ 次, $R$ 只会往右侧移动,移动 $O(n)$ 次. 对于不同块内的询问, 在每次块改变时, $L$ 移动 $O(B)$ 次, $R$ 移动 $O(n)$ 次. 所以总移动次数为 $O(mB+\frac {n^2} B)$ 取 $B=\frac n {\sqrt m}$ 时最优. 再加上给询问排序,整个算法时间复杂度为 $O(n\sqrt m+m\log m)$ . mex sol permu sol 带修莫队就是支持修改的莫队. 做法是将每次询问的时间也考虑进去,形成一个三元组 $(l,r,t)$ 排序时加入 $t$ 作为第三关键字. 若移动端点的同时时间跨越了某个修改操作,那么就执行/撤回修改. 为了便于分析,视 $n,m$ 同阶,时间复杂度 $O(n^{\frac 5 3})$ . 树上莫队分块方式 定义这里的取反是指,若当前节点的信息在贡献中,则除去,否则加入. 若从$(pu,pv)$ 移动到 $(u,v)$ ,则只需对路径 $(pu,u),(pv,v)$ 的点是否包含情况取反, $LCA​$ 不处理. 保存答案前对 $(u,v)$ 的 $LCA$ 取反,答案保存后再将它取反回去. 若有修改操作,则还需记录每个询问的时间. 时间复杂度与序列上的莫队完全一致. 糖果公园 扫描线最经典的是求矩形面积并.将每个矩形按照 $x$ 坐标排序,从左往右扫过来,看成两个事件,加入和删除. 每次发生了加入事件就去更新答案. 需要注意边界的处理问题,加入和删除操作需要分出前后顺序,根据题目而定. 花火 sol $cdq$ 分治一段区间 $[l,r]$ 内的元素两两之间可能产生贡献,要计算出所有贡献. 取区间中点 $mid$ 将区间分为左右两段. 贡献可以分为左边对左边的贡献,右边对右边的贡献,左边对右边的贡献. 前两者可以递归下去处理,所以只需要考虑左边对右边的贡献. 注意每次处理左边对右边的贡献时,时间复杂度必须是与 $[L,R]$ 的长度相关,而不是与整个序列长度 $n$ 相关. 陌上花开 sol 稻草人 sol]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2956 模积和]]></title>
    <url>%2F2019%2F08%2F19%2Fbzoj-2956-%E6%A8%A1%E7%A7%AF%E5%92%8C%2F</url>
    <content type="text"><![CDATA[整除分块. 可以把 $i=j$ 的贡献算上,后面再减掉. 假设 $n\le m$ . $$\begin{aligned}ans&amp;=\sum_{i=1}^n \sum_{j=1}^m (n\bmod i)(m\bmod j)-\sum_{i=1}^n (n\bmod i)(m\bmod i) \\&amp;=\sum_{i=1}^n \sum_{j=1}^m (n-\lfloor\frac n i \rfloor\cdot i)(m-\lfloor\frac m j \rfloor\cdot j)-\sum_{i=1}^n (n-\lfloor\frac n i \rfloor\cdot i)(m-\lfloor\frac m i \rfloor\cdot i) \\&amp;=\sum_{i=1}^n (n-\lfloor\frac n i \rfloor\cdot i)\sum_{i=1}^m (m-\lfloor\frac m i \rfloor\cdot i) -\sum_{i=1}^n nm+i^2\cdot \lfloor\frac n i \rfloor\lfloor\frac m i \rfloor-n\cdot \lfloor\frac m i \rfloor\cdot i-m\cdot \lfloor\frac n i \rfloor \cdot i\end{aligned}$$整除分块计算即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=19940417;const int inv2=(P+1)&gt;&gt;1,inv6=3323403;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int S1(int l,int r)&#123; return mul(mul(l+r,r-l+1),inv2);&#125;int s2(int x)&#123; return mul(mul(x,mul(x+1,2*x+1)),inv6);&#125;int S2(int l,int r)&#123; return add(s2(r),P-s2(l-1));&#125;int calc(int n)&#123; int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); upd(ans,mul(n,r-l+1)); upd(ans,P-mul(S1(l,r),n/l)); &#125; return ans;&#125;int main()&#123; int n=read(),m=read(); if(n&gt;m) swap(n,m); int ans=0; upd(ans,mul(calc(n),calc(m))); for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); upd(ans,P-mul(mul(n,m),r-l+1)); upd(ans,P-mul(mul(n/l,m/l),S2(l,r))); upd(ans,mul(mul(n,m/l),S1(l,r))); upd(ans,mul(mul(m,n/l),S1(l,r))); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3105 新Nim游戏]]></title>
    <url>%2F2019%2F08%2F19%2Fbzoj-3105-%E6%96%B0Nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[贪心求解最大权值线性无关组. $A$ 先拿走一堆石子, $B$ 再拿走一堆石子,然后做 $Nim$ 游戏. 如果 $A$ 拿了之后给 $B$ 留下的石子中存在一个子集,它们的异或和为 $0$ , $B$ 就可以把其它的石子拿走, $A$ 就败了. 所以 $A$ 要拿走最少的石子,使剩下的石子在异或意义下线性无关. 那么就是要求解最大权值线性无关组,用拟阵的那一套理论,贪心处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=100+10;int n,a[MAXN],c[32];ll ans=0;void ins(int x,int val)&#123; for(int i=31;i&gt;=0;--i) if((x&gt;&gt;i)&amp;1) &#123; if(!c[i]) &#123; c[i]=x; break; &#125; else x^=c[i]; &#125; if(!x) ans+=val;&#125;int main()&#123; n=read(); if(!n) return puts("-1")&amp;0; for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); reverse(a+1,a+1+n); for(int i=1;i&lt;=n;++i) ins(a[i],a[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190818]]></title>
    <url>%2F2019%2F08%2F19%2Ftest20190818%2F</url>
    <content type="text"><![CDATA[沙茶出题人数据造出锅了,还要大家来帮他修. 甚至连个题解都没有. $A$考虑换根,若当前根节点从 $u$ 换到 $v$ ,显然只有 $u$ 和 $v$ 的贡献会改变. 预处理一大堆东西,从 $u$ 换到 $v$ 时更新贡献,回溯时撤回. 时间复杂度 $O(n)$ . $B$将每次变换看做一个矩阵,转化为矩阵的 $BSGS$ . 由于矩阵可能没有逆,所以最后再判一下解是否合法. 时间复杂度 $O(T\cdot \sqrt P\cdot \log \sqrt P )$ . $C$将每个数看做 $0/1$ 串,正着建一棵字典树,反着建一棵字典树. 那么每个前缀武器就能在前缀的字典树树上割下一颗子树,每个后缀武器能的后缀的字典树上割下一颗子树. 每个给出的点在两棵树上至少被割掉一次,可以将两颗树拼在一起,建立一个最小割模型.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>BSGS</tag>
        <tag>test</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拟阵学习笔记]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%8B%9F%E9%98%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[可用于解决一些最大权重独立子集的问题. 拟阵的定义一个有限 拟阵 是满足以下条件的二元组 $M=(S,I)$ : $S$ 是有限集. $I$ 是由 $S$ 的一些子集组成的有限非空集合(非空族) ,这些子集称为 $S$ 的 独立子集 . $I​$ 有 遗传性 ,即,若 $B\in I,A\subset B​$ ,则 $A\in I​$ .又因为 $I​$ 非空,所以一定有 $\emptyset \in I​$ . $M$ 有 交换性 ,即,若 $A,B\in I,|B|&gt;|A|$ ,则 $\exists x\in B-A$ ,使得 $A\cup \lbrace x \rbrace \in I$ . 举个例子, $M=(S,I)​$ 是一个拟阵,其中 $S=\lbrace 1,2,3 \rbrace ,I=\lbrace A\subset S:|A|\le 2 \rbrace​$ . 容易验证 $M$ 满足以上的 $4$ 个条件. 拓展有拟阵 $M=(S,I)$ ,若 $A\in I,x\not \in A,A\cup { x } \in I$ ,则称 $x$ 是独立子集 $A$ 的一个 拓展 . 最大独立子集若一个独立子集 $A$ 不存在拓展,则称它为 最大独立子集 . 由这个定义与拟阵的交换性质可以得出一条重要性质:拟阵中所有 最大独立子集 都具有相同的大小. 线性无关与拟阵设 $S$ 是一个行向量组, $I$ 是由所有 $S$ 的线性无关子集组成的集合,有定理: 二元组 $M=(S,I)$ 是一个拟阵. 证明该定理只需要证明 $M=(S,I)$ 满足拟阵的 $4$ 个条件.前 $2$ 个条件显然满足,只需证遗传性和交换性. 遗传性的证明一个线性无关组的子集,显然也线性无关.即,若 $A\in I,B\subset I$ ,则 $B\in I$ ,满足遗传性. 交换性的证明令 $X,Y\in I,|X|&gt;|Y|$ . 考虑反证法,假设 $\forall x\in X-Y​$ ,都有 $Y\cup {x} \not \in I​$ 成立. 则说明将任意一个在 $X$ 集合中,而不在 $Y$ 集合中的向量 $x$ 添加到 $Y$ 集合中,都会使得 $Y$ 变为线性相关. 说明任意一个这样的 $x$ 都可以被 $Y$ 中向量线性组合表示. 而 $X$ 中其它向量也被 $Y$ 包含,也可以被 $Y$ 中向量线性组合表示. 于是 $X$ 中的所有向量都可以被 $Y$ 中向量线性组合表示.但 $X$ 线性无关,不可能被更小的集合完全表示,矛盾. 交换性得证. 加权拟阵若一个拟阵 $M=(S,I)$ 关联了一个权重函数 $w$ ,它为 $S$ 中的每一个元素 $x$ 赋予了一个 严格大于0 的权重 $w(x)$. 则称拟阵 $M$ 是加权的,即 加权拟阵 . $S$ 的子集 $A$ 的权值就是$$w(A)=\sum_{x\in A}w(x)$$ 最大权重独立子集定义在加权拟阵 $M=(S,I)$ 中,权值最大的 独立子集 . 即所有 $A\in I$ 中, $w(A)$ 最大的 $A$ . 贪心求解 将 $S$ 中所有元素按照 $w(x)$ 降序排列. 初始有一个集合 $A=\emptyset​$ ,按照第 $1​$ 步排好的顺序依次遍历 $S​$ 中的每个元素 $x​$ ,若 $A\cup {x}\in I​$ ,则令 $A=A\cup {x}​$ . 遍历结束后,此时的 $A$ 就是要求的最大权重独立子集的一个解. 贪心正确性证明若 $I= { \emptyset }$ ,正确性显然,考虑 $I\not= { \emptyset }$ 的情况. 只需要考虑加权拟阵 $M=(S,I)$ 的 $3$ 条优美性质. 贪心选择性若 $S$ 中的元素已按 $w(x)$ 降序排列,令 $x$ 为 $S$ 中第一个 ${x}\in I$ 的元素. 那么存在一个最大权重独立子集 $A$ ,使得 $x\in A$ . 元素只考虑一次如果一个元素 $x$ 被遍历到时, $A\cup {x}\not \in I$ ,那么之后 $A$ 增大时,也总是有 $A\cup {x}\not \in I$ . 反证,由拟阵的遗传性即可得出矛盾. 最优子结构性质若 $x$ 是求解过程中第一个被选出的元素,那么选出剩下的元素就归结为一个子问题. 即求解加权拟阵 $M’=(S’,I’)$ 的最大权重独立子集,其中,$$S’={y\in S:{x,y}\in I}\I’={B\subset S-{x}:B\cup {x}\in I}$$ 应用根据线性无关与拟阵的关系,一个常见的应用是求解向量组的 最大权值线性无关组 . 直接套用贪心求解的过程即可. 对于其它的问题,如果能构造出对应的拟阵,也可以套用上述贪心求解的过程.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4237 稻草人]]></title>
    <url>%2F2019%2F08%2F17%2Fbzoj-4237-%E7%A8%BB%E8%8D%89%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[$cdq$ 分治 + 单调栈. 将所有点先按照 $y$ 排序,然后 $cdq$ 分治,每次只考虑上面的一部分点作为右上角,下面的一部分点作为左下角的贡献. 将上下两部分的点分别按照 $x$ 排序,从左往右枚举上面的点. 发现上面的一个点在只会受到 $y$ 比自己小的点中, $x$ 最大的点的制约,维护一个 $y$ 递增的单调栈来找出这个点. 然后在下面的点中统计有哪些点是合法的,对下面的点维护一个 $y$ 不增的单调栈. 每次在上面加入点后,就将下面 $x$ 小于等于它的点加入下面的栈. 在下面的单调栈中使用二分,找出合法点的区间,时间复杂度 $O(n\log^2 n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct node&#123; int x,y;&#125;a[MAXN],up[MAXN],down[MAXN];bool cmpy(node a,node b)&#123; return a.y==b.y?a.x&lt;b.x:a.y&gt;b.y; &#125;bool cmpx(node a,node b)&#123; return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;int n,stk1[MAXN],stk2[MAXN],tp1,tp2;ll ans=0;void cdq(int l,int r)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; cdq(l,mid); tp1=tp2=0; int ls=mid-l+1,rs=r-mid; for(int i=l;i&lt;=mid;++i) up[i-l+1]=a[i]; for(int i=mid+1;i&lt;=r;++i) down[i-mid]=a[i]; sort(up+1,up+1+ls,cmpx); sort(down+1,down+1+rs,cmpx); int p=1; for(int i=1;i&lt;=ls;++i) &#123; while(tp1&gt;0 &amp;&amp; up[stk1[tp1]].y&gt;=up[i].y) --tp1; stk1[++tp1]=i; while(p&lt;=rs &amp;&amp; down[p].x&lt;=up[i].x) &#123; while(tp2&gt;0 &amp;&amp; down[stk2[tp2]].y&lt;down[p].y) --tp2; stk2[++tp2]=p; ++p; &#125; if(!tp2) continue; if(tp1==1) &#123; ans+=tp2; continue; &#125; int L=1,R=tp2,lim=up[stk1[tp1-1]].x,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(down[stk2[mid]].x&gt;=lim) res=mid,R=mid-1; else L=mid+1; &#125; if(res!=-1) ans+=tp2-res+1; &#125; cdq(mid+1,r);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].x=read(); a[i].y=read(); &#125; sort(a+1,a+1+n,cmpy); cdq(1,n); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>cdq分治</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190816]]></title>
    <url>%2F2019%2F08%2F16%2Ftest20190816%2F</url>
    <content type="text"><![CDATA[点分治爆栈祭. $phantasm$将每次选择的位置看成一个数列,第一个位置必定是 $1$ ,所以只需要求出它的差分序列方案数. 差分序列中共 $m-1$ 个元素,每个元素必须 $\le k$ ,总和为 $n-1$ . 调整一下后用隔板法处理,答案是组合数,在模 $2$ 意义下,根据 $Lucas$ 定理,只需判断二进制位即可. $skylines$直接大力点分治预处理所有点的答案. 枚举子树时正反顺序都做一次,再考虑上分治中心. 时间复杂度 $O(n\log n+T)$ . $kiseki$题面写得太垃圾了. 每次从已有的数中选一个,得到它的权值,并获得它的后继,存档可以重复获得. 考虑 $dp$ ,状态只与当前有的存档集合有关,与顺序无关. 而从小到大排序后,相邻两项的差分值只可能是 $0/1$ ,所以可以用一个二进制数 $S$ 来记录. 设 $f(i,S)$ 表示有 $i$ 个存档,差分值的状态是 $S$ 的方案数,转移时枚举增加的存档. 总方案数是 $m!$ ,预处理差分状态 $S$ 对应的序列权值是 $val(S)$ ,答案就为 $$\sum_{S} \frac {f(m,S)} {m!} \cdot val(S)$$ 时间复杂度 $O(m\cdot 2^m)$ .]]></content>
      <tags>
        <tag>数学</tag>
        <tag>概率/期望</tag>
        <tag>Lucas定理</tag>
        <tag>状压dp</tag>
        <tag>点分治</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4236 JOIOJI]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-4236-JOIOJI%2F</url>
    <content type="text"><![CDATA[$map$ . 用 $sum(i,0/1/2)$ 分别表示三种字母出现次数的前缀和. 一段区间 $[L+1,R]$ 合法的充要条件是 $sum(r,0)-sum(l,0)=sum(r,1)-sum(l,1),sum(r,1)-sum(l,1)=sum(r,2)-sum(l,2)$ . 将两种差看成两个权值,加入每个元素后询问两个权值都与它相等的元素出现的第一个位置,可以用 $map$ 维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;typedef pair&lt;int,int&gt; pii;map&lt;pii,int&gt; mp;int n,sum[MAXN][3];char buf[MAXN];int trans(char c)&#123; if(c=='J') return 2; return c&lt;'J';&#125;int main()&#123; n=read(); scanf("%s",buf+1); int ans=0; mp[make_pair(0,0)]=0; for(int i=1;i&lt;=n;++i) &#123; int x=trans(buf[i]); for(int j=0;j&lt;3;++j) sum[i][j]=sum[i-1][j]; ++sum[i][x]; int u=sum[i][0]-sum[i][1],v=sum[i][1]-sum[i][2]; pii tmp=make_pair(u,v); if(mp.find(tmp)!=mp.end()) ans=max(ans,i-mp[tmp]); else mp[tmp]=i; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1143 祭祀]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-1143-%E7%A5%AD%E7%A5%80%2F</url>
    <content type="text"><![CDATA[$floyd$ 传递闭包 + 二分图的相关理论. 先用 $floyd$ 做传递闭包,预处理每两点间的连通性. 每个点拆成入点和出点,再枚举点 $a,b$ ,若 $a$ 能到 $b$ ,就从 $a$ 的入点向 $b$ 的出点连边. 然后就是要求新建出来的二分图的最大独立集,就等于原来的点数减去它的最大匹配数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;int n,m;bool f[MAXN][MAXN];void floyd()&#123; for(int k=1;k&lt;=n;++k) for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) f[i][j]|=(f[i][k]&amp;f[k][j]);&#125;int par[MAXN],vis[MAXN];int dfs(int u)&#123; for(int v=1;v&lt;=n;++v) &#123; if(v!=u &amp;&amp; !vis[v] &amp;&amp; f[u][v]) &#123; vis[v]=1; if(!par[v] || dfs(par[v])) &#123; par[v]=u; return 1; &#125; &#125; &#125; return 0;&#125;int Hungarian()&#123; int ans=0; for(int i=1;i&lt;=n;++i) &#123; memset(vis,0,sizeof vis); ans+=dfs(i); &#125; return ans;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) f[i][i]=true; for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); f[u][v]=true; &#125; floyd(); int ans=Hungarian(); printf("%d\n",n-ans); return 0;&#125;]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4358 permu]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-4358-permu%2F</url>
    <content type="text"><![CDATA[莫队. 使用莫队,考虑加入一个数 $x$ 造成的影响,发现需要用到 $x-1,x+1$ 的信息. 需要对每个数维护当前它所在的最大连续区间长度,但修改时可能会修改很多数的答案. 简单粗暴的办法是用线段树维护最大子段和,但多一个 $\log$ ,而且常数比较大,跑不过去. 用 $pre_i,nxt_i$ 分别表示 $i$ 在值域上往左/右走最多有几个数, $pre_i+nxt_i-1$ 可以更新答案. 插入数 $i$ 的时候,用 $i-1$ 的 $pre$ 更新 $i$ 的 $pre$ ,用 $i+1$ 的 $nxt$ 更新 $i$ 的 $nxt$ . 然后再更新 $i$ 所在最长连续区间左端点的 $nxt$ 和右端点的 $pre$ . 中间不用管,因为不可能再在中间插入数,也就不可能再用到它们的 $pre,nxt$ 了. 发现删除操作不好维护,我们可以保证右端点不删除,只可能撤销左端点的插入操作,就可以维护了. 对于 $l$ 在同一块内的询问,若 $r​$ 也在这一块内,可以暴力做. 对于 $r$ 在这一块外的,将它们按照 $r$ 从小到大排序. 先将 $L$ 设置为当前块的末尾,右移 $R$ 到询问的 $r$ ,再将 $L$ 左移到询问的 $l$ ,更新答案,再将 $L$ 移回当前块的末尾. 因为插入一个数最多只会影响 $3$ 个数的信息,所以把它们记录下来,移回时撤销,时间复杂度 $O(n\sqrt n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,res,Ans[MAXN];int BlockSize,tot=0,bel[MAXN],a[MAXN];int lpos[MAXN],rpos[MAXN];struct Query&#123; int l,r,id,block; bool operator &lt; (const Query &amp;rhs) const &#123; return block==rhs.block?r&lt;rhs.r:block&lt;rhs.block; &#125;&#125;q[MAXN];int bf_pre[MAXN],bf_nxt[MAXN];int bf_stk[MAXN],bf_tp;int bf(int i)&#123; bf_tp=0; int ans=0; for(int j=q[i].l;j&lt;=q[i].r;++j) &#123; int x=a[j]; bf_stk[++bf_tp]=x; bf_pre[x]=bf_pre[x-1]+1; bf_nxt[x]=bf_nxt[x+1]+1; int len=bf_pre[x]+bf_nxt[x]-1; ans=max(ans,len); bf_nxt[x-bf_pre[x]+1]=len; bf_pre[x+bf_nxt[x]-1]=len; &#125; Ans[q[i].id]=ans; for(int j=1;j&lt;=bf_tp;++j) bf_pre[bf_stk[j]]=bf_nxt[bf_stk[j]]=0;&#125;int nxt[MAXN],pre[MAXN],tp;struct opt&#123; int x; int p1,n1; // pre[x]:p1-&gt;p2 nxt[x]:n1-&gt;n2 void undo() &#123; pre[x]=p1; nxt[x]=n1; &#125;&#125;;opt stk[MAXN];void solve()&#123; int lstblock=-1,L,R; for(int i=1;i&lt;=m;++i) &#123; if(q[i].block!=lstblock) &#123; L=rpos[q[i].block]; R=L-1; res=0; memset(pre,0,sizeof pre); memset(nxt,0,sizeof nxt); tp=0; lstblock=q[i].block; &#125; if(bel[q[i].l]==bel[q[i].r]) &#123; bf(i); continue; &#125; while(R&lt;q[i].r) &#123; int x=a[++R]; pre[x]=pre[x-1]+1; nxt[x]=nxt[x+1]+1; int len=pre[x]+nxt[x]-1; res=max(res,len); nxt[x-pre[x]+1]=len; pre[x+nxt[x]-1]=len; &#125; int tmp=res; while(L&gt;q[i].l) &#123; int x=a[--L]; pre[x]=pre[x-1]+1; nxt[x]=nxt[x+1]+1; stk[++tp]=(opt)&#123;x,0,0&#125;; int len=pre[x]+nxt[x]-1; stk[++tp]=(opt)&#123;x-pre[x]+1,pre[x-pre[x]+1],nxt[x-pre[x]+1]&#125;; stk[++tp]=(opt)&#123;x+nxt[x]-1,pre[x+nxt[x]-1],nxt[x+nxt[x]-1]&#125;; nxt[x-pre[x]+1]=len; pre[x+nxt[x]-1]=len; res=max(res,len); &#125; Ans[q[i].id]=res; while(tp) &#123; stk[tp].undo(); --tp; &#125; L=rpos[q[i].block]; res=tmp; &#125;&#125;void init_Block()&#123; BlockSize=sqrt(n); for(int i=1;i&lt;=n;++i) bel[i]=(i-1)/BlockSize+1; tot=bel[n]; for(int i=1;i&lt;=n;++i) rpos[bel[i]]=i; for(int i=n;i&gt;=1;--i) lpos[bel[i]]=i;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); init_Block(); for(int i=1;i&lt;=m;++i) &#123; q[i].l=read(); q[i].r=read(); q[i].block=bel[q[i].l]; q[i].id=i; &#125; sort(q+1,q+1+m); solve(); for(int i=1;i&lt;=m;++i) printf("%d\n",Ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>离线</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190815]]></title>
    <url>%2F2019%2F08%2F15%2Ftest20190815%2F</url>
    <content type="text"><![CDATA[发现自己的码力还是太弱,可能需要多做毒瘤题(?) $cubicp$$P=a^3-b^3=(a-b)(a^2+ab+b^2)$ ,因为 $P$ 是质数,所以 $a-b=1$ . 于是 $P=3b^2+3b+1$ ,先预处理所有合法的答案,然后快速回答即可. $dp$考虑朴素的 $dp$ ,设 $f(i,j)$ 表示将前 $i$ 个数分成 $j$ 段的最小花费. 先枚举 $j$ ,可以发现 $i$ 的转移决策是具有单调性的,于是可以优化. 不能用二分决策栈的方法,因为转移额外代价 $cost(k,i)$ 不方便快速在线算. 对求解区间和决策区间分治,这样可以像莫队那样暴力移动端点来算 $cost$ ,时间复杂度 $O(n\log n)$ . $number$可以先二分答案 $mid$ ,于是要考虑 $1\sim mid$ 的全部区间.将它们按照 $x$ 从大到小排序,依次加入. 如果同一种 $x$ 的区间的交集被之前加入的所有区间的并集完全覆盖,显然就不合法,否则一定可以构造出合法的方案. 可以直接用线段树来维护区间覆盖,但会多一个 $\log$ . 优秀的做法是用并查集维护当前每个节点在并集中向右能跳到的最远点,就可以判断合法性了.]]></content>
      <tags>
        <tag>二分</tag>
        <tag>并查集</tag>
        <tag>test</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4345 Korale]]></title>
    <url>%2F2019%2F08%2F15%2Fbzoj-4345-Korale%2F</url>
    <content type="text"><![CDATA[$dfs$ + 堆,求第 $k$ 优解. 首先去求第 $k$ 小的子集权值 $val$ ,先将元素权值从小到大排序. 每个子集可以用一个二元组 $(i,j)$ 表示权值为 $i$ ,最大的元素编号为 $j$ . 将它加入优先队列,一个二元组 $(i,j)$ 可以得到 $(i-a_j+a_{j+1},j+1)$ 与 $(i+a_{j+1},j+1)$ . 前者表示不选 $j$ 了,后者表示保留 $j$ .第 $k$ 次取出二元组时对应的权值就是第 $k$ 小的子集权值. 然后要求第 $k$ 小的具体方案,直接 $dfs$ 爆搜,但要保证权值不超过 $val$ . 每次找后面第一个数,使得加入后权值仍不超过 $val$ ,用线段树来找这个数,第 $k$ 次时集合中的数就是答案. 注意除掉空集的贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,k,a[MAXN],b[MAXN],cnt=0;ll ans[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairpriority_queue&lt;pli&gt; q;void Find_kth()&#123; sort(b+1,b+1+n); q.push(mp(-b[1],1)); for(int t=1;t&lt;=k;++t) &#123; pli tmp=q.top(); ll i=-tmp.first; int j=tmp.second; q.pop(); ans[t]=i; if(t&lt;k &amp;&amp; j&lt;n) &#123; q.push(mp(-i+b[j]-b[j+1],j+1)); q.push(mp(-i-b[j+1],j+1)); &#125; &#125; for(int i=k;i &amp;&amp; ans[i]==ans[k];--i) ++cnt; printf("%lld\n",ans[k]);&#125;struct SegTree&#123; int Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root=min(lson,rson); &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) return (void)(root=a[l]); int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int p,ll v)//位置p之后第一个小于等于v的 &#123; if(p&lt;=l) &#123; if(root&gt;v) return 0; if(l==r) return l; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) &#123; int res=query(o&lt;&lt;1,l,mid,p,v); if(res) return res; &#125; return query(o&lt;&lt;1|1,mid+1,r,p,v); &#125;&#125;T;int stk[MAXN],tp=0;void dfs(int p,ll tmp)&#123; if(!cnt) return; if(!tmp) &#123; --cnt; if(!cnt) for(int i=1;i&lt;=tp;++i) printf("%d" ,stk[i]); return; &#125; for(int i=p+1;i&lt;=n;++i) &#123; i=T.query(1,1,n,i,tmp); if(i) &#123; stk[++tp]=i; dfs(i,tmp-a[i]); --tp; &#125; else break; &#125;&#125;void Construct_kth()&#123; T.BuildTree(1,1,n); dfs(0,ans[k]);&#125;int main()&#123; n=read(),k=read()-1; if(!k) return puts("0")&amp;0; for(int i=1;i&lt;=n;++i) a[i]=b[i]=read(); Find_kth(); Construct_kth(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 515 贪心只能过样例]]></title>
    <url>%2F2019%2F08%2F14%2FLoj-515-%E8%B4%AA%E5%BF%83%E5%8F%AA%E8%83%BD%E8%BF%87%E6%A0%B7%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[$bitset$ 优化 $dp$ . 考虑最朴素的 $dp$ , $f(i,j)$ 表示考虑前 $i$ 个数,能否使得 $S=j$ . 转移时枚举当前这一位选哪一个数,这样直接做的时间复杂度是 $O(n^5)$ . 因为只有 $0/1$ 运算,第二维的最大值为 $10^6$ ,用 $bitset$ 优化,复杂度变成 $O(\frac {n^5} {64})$ ,就可以过了. 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=101;int n;bitset&lt;MAXN*MAXN*MAXN&gt; f,lst;int main()&#123; n=read(); lst[0]=1; for(int i=1;i&lt;=n;++i) &#123; int L=read(),R=read(); f.reset(); for(int x=L;x&lt;=R;++x) f|=lst&lt;&lt;(x*x); lst=f; &#125; cout&lt;&lt;f.count()&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 514 模拟只会猜题意]]></title>
    <url>%2F2019%2F08%2F14%2FLoj-514-%E6%A8%A1%E6%8B%9F%E5%8F%AA%E4%BC%9A%E7%8C%9C%E9%A2%98%E6%84%8F%2F</url>
    <content type="text"><![CDATA[原以为此题必有高论,结果直接 $O(n^2)$ 暴力预处理答案就可以了. 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e4+10;int n,m,ans[MAXN],a[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read()+a[i-1]; ans[i]=-inf; &#125; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) ans[j-i+1]=max(ans[j-i+1],a[j]-a[i-1]); for(int i=n-1;i&gt;=1;--i) ans[i]=max(ans[i+1],ans[i]); for(int i=1;i&lt;=m;++i) printf("%d\n",ans[read()]); return 0;&#125;]]></content>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190814]]></title>
    <url>%2F2019%2F08%2F14%2Ftest20190814%2F</url>
    <content type="text"><![CDATA[$T2$ 被常数卡到暴力分了. $tree$原题.直接树形 $dp$ . $dance$从前往后枚举右端点,依次加入每个点,用单调栈维护后缀最大/最小值,线段树维护答案. $seq$打表或者分析,把递推式子搞出来, $f_i=f_{i-1}+(i-1)\cdot (i-2)$ . 然后用特征方程那一套理论把通项找出来, $f_n=2^{n+1}-n^2-n-2$ ,就可以直接算了.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>树形dp</tag>
        <tag>单调栈</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2049 洞穴勘测]]></title>
    <url>%2F2019%2F08%2F14%2Fbzoj-2049-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[线段树分治 + 并查集. 这本来是个 $LCT$ 的模板题,但离线下来也可以用线段树分治 + 并查集来做. 每条边可以看做在一个时间区间内生效,每个线段树节点维护一个 $vector$ ,存储在该区间内都有效的边. 一条边只会被加入 $O(\log m)$ 个线段树节点,空间复杂度为 $O(m\log m)$ . 最后 $dfs$ 整个线段树,进入一个节点时,就让它的 $vector$ 中的边都生效,退出时撤销这些边. 因为有撤销,所以不能路径压缩,可以用按秩合并的并查集来维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXM=2e5+10;map&lt;pii,int&gt; Eid;struct Edge&#123; int u,v; int l,r; Edge()&#123;r=-1;&#125;&#125; E[MAXM];struct query&#123; int u,v,id;&#125;;int n,m,ans[MAXM],qcnt=0,ecnt=0;vector&lt;query&gt; qry[MAXM];vector&lt;pii&gt; opt[MAXM&lt;&lt;2];int fa[MAXM],siz[MAXM];void init()&#123; for(int i=1; i&lt;=n; ++i) fa[i]=i,siz[i]=1;&#125;int Find(int x)&#123; if(x==fa[x]) return x; return Find(fa[x]);&#125;void Union(int &amp;x,int &amp;y)&#123; if(siz[x]&lt;siz[y]) swap(x,y); siz[x]+=siz[y]; fa[y]=x;&#125;struct SegTree&#123; vector&lt;int&gt; s[MAXM&lt;&lt;2];#define root s[o] void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.push_back(c); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); &#125; void add(int o) &#123; int tot=root.size(); for(int i=0;i&lt;tot;++i) &#123; int x=root[i]; int u=Find(E[x].u),v=Find(E[x].v); if(u==v) continue; Union(u,v); opt[o].push_back(mp(u,v)); &#125; &#125; void del(int o) &#123; int tot=opt[o].size(); for(int i=0;i&lt;tot;++i) &#123; pii t=opt[o][i]; int u=t.first,v=t.second; fa[v]=v; siz[u]-=siz[v]; &#125; &#125; void solve(int o,int p) &#123; int tot=qry[p].size(); for(int i=0;i&lt;tot;++i) &#123; query q=qry[p][i]; int u=Find(q.u),v=Find(q.v); if(u==v) ans[q.id]=1; else ans[q.id]=0; &#125; &#125; void dfs(int o,int l,int r) &#123; add(o); if(l==r) &#123; solve(o,l); del(o); return; &#125; int mid=(l+r)&gt;&gt;1; dfs(o&lt;&lt;1,l,mid); dfs(o&lt;&lt;1|1,mid+1,r); del(o); &#125;&#125; T;int main()&#123; n=read(),m=read(); init(); for(int i=1; i&lt;=m; ++i) &#123; char op[10]; scanf("%s",op); int u=read(),v=read(); if(op[0]=='C') &#123; Eid[mp(u,v)]=Eid[mp(v,u)]=++ecnt; E[ecnt].u=u,E[ecnt].v=v; E[ecnt].l=i; &#125; else if(op[0]=='D') E[Eid[mp(u,v)]].r=i; else qry[i].push_back((query)&#123;u,v,++qcnt&#125;); &#125; for(int i=1; i&lt;=ecnt; ++i) &#123; if(E[i].r==-1) E[i].r=m; T.upd(1,1,m,E[i].l,E[i].r,i); &#125; T.dfs(1,1,m); for(int i=1; i&lt;=qcnt; ++i) puts(ans[i]?"Yes":"No"); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190813]]></title>
    <url>%2F2019%2F08%2F13%2Ftest20190813%2F</url>
    <content type="text"><![CDATA[考了一套简单题. $prime$贪心. 有一个比较明显的贪心策略,即先做若干次除法,再只做加法或只做减法. 做完除法后算答案直接暴力枚举加/减了几步就可以了. 因为 $10^9$ 内的两个相邻质数相差不会超过 $220$ ,所以答案也不会超过 $220$ . 据说质数密度是 $O(\log n)$ 级别的. $path$树状数组. 可以发现这个图就是由若干个不相交的链或者环组成的. 因为只有合并操作,所以可以用并查集来维护每条链和每个环,以及它们的大小. 查询 $(l,r)$ 时,可以用长度不超过 $r$ 的答案减去长度不超过 $l-1$ 的答案,只需要考虑如何计算长度不超过 $k$ 的路径数. 考虑一条大小为 $s$ 的链的贡献.若 $s\le k$ ,贡献为 $\frac {s(s+1)} 2$ ,否则,贡献为 $k\cdot s-\frac {k(k-1)} 2$ . 考虑一个大小为 $s$ 的环的贡献.若 $s\le k$ ,贡献为 $s^2$ ,否则, 贡献为 $s\cdot k$ . 用 $5$ 个树状数组分别维护贡献 (还有一个是链的条数) ,每个链/环的贡献加入它的大小的对应位置. 有个地方没开 $\mbox{long long}$ ,爆成 $95$ 了. 时间复杂度 $O(n\log n)$ . $book$期望 $dp$ . 设 $f(i,j)$ 表示第 $i$ 个人拿到的从新到旧的第 $j$ 本书的期望排名. 转移时枚举每个人拿了哪本书,时间复杂度 $O(n^3)$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>概率/期望</tag>
        <tag>树状数组</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3569 DZY Loves Chinese II]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-3569-DZY-Loves-Chinese-II%2F</url>
    <content type="text"><![CDATA[神仙题. 先做出原图的一棵 $dfs$ 树.对于每条非树边,随机分配一个权值 $x$ ,将它在树上覆盖到的树边的权值全部异或上 $x$ . 每次询问给定了一个边的集合 $S$ ,若存在 $S$ 的一个非空子集,该子集内所有的边权异或和为 $0$ ,则不连通,否则连通. 边权覆盖可以用树上差分,查询可以利用线性基,看给出的边权在 $\mbox{xor}$ 意义下是否线性无关. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=1e5+10,MAXM=1e6+10;int ecnt=0,head[MAXN],nx[MAXM],to[MAXM],id[MAXM];int st[MAXM],ed[MAXM],ontree[MAXM];void addedge(int u,int v,int k)&#123; ++ecnt; id[ecnt]=k; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,tot=0;int dfn[MAXN],idx=0;ull dif[MAXN],val[MAXM];void dfs(int u)&#123; dfn[u]=++idx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dfn[v]) continue; ontree[id[i]]=1; dfs(v); &#125;&#125;void calc(int u,int t)&#123; dfn[u]+=n; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dfn[v]&gt;n) continue; calc(v,i); dif[u]^=dif[v]; &#125; val[id[t]]=dif[u];&#125;void init()&#123; for(int i=1;i&lt;=m;++i) if(!ontree[i]) &#123; ull x=rand()*rand()*rand()*rand(); val[i]=x; int u=st[i],v=ed[i]; dif[u]^=x,dif[v]^=x; &#125; calc(1,0);&#125;struct Base&#123; ull a[64]; int siz; void init() &#123; siz=0; memset(a,0,sizeof a); &#125; void ins(ull x) &#123; for(int i=63;i&gt;=0;--i) if(x&amp;(1ULL&lt;&lt;i)) &#123; if(a[i]) x^=a[i]; else &#123; a[i]=x; ++siz; break; &#125; &#125; &#125;&#125;LB;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); addedge(u,v,i); addedge(v,u,i); st[i]=u,ed[i]=v; &#125; dfs(1); int Q=read(); if(idx!=n) &#123; while(Q--) puts("Disconnected"); return 0; &#125; srand(time(NULL)); init(); while(Q--) &#123; int k=read(); LB.init(); for(int i=1;i&lt;=k;++i) &#123; int c=read()^tot; LB.ins(val[c]); &#125; if(k==LB.siz) ++tot,puts("Connected"); else puts("Disconnected"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>树上差分</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4326 运输计划]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-4326-%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[二分答案 + 树上差分. 首先可以考虑二分答案,变为判定是否存在合法方案使得改造后给出的路径长度都不超过 $mid$ . 预处理每条路径的长度 $len$ ,若 $len\le mid$ ,则不用考虑.否则,被改造的边长度至少为 $mid-len$ . 将每条路径按上述过程处理,可以得出被改造的边长度至少为 $\max (mid-len_i)$ ,并且在所有需要考虑的路径上. 用树上差分给路径上的边打上标记,然后枚举每条边进行验证. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int n,m,x[MAXN],y[MAXN],z[MAXN],len[MAXN];int tofa[MAXN],dis[MAXN],mx=0;int dep[MAXN],Log[MAXN],fa[MAXN][20];int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=Log[dep[x]-dep[y]];i&gt;=0;--i) if(dep[x]-dep[y]&gt;=(1&lt;&lt;i)) x=fa[x][i]; if(x==y) return x; for(int i=Log[dep[x]];i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfs_pre(int u,int F)&#123; fa[u][0]=F; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; dep[v]=dep[u]+1; dis[v]=dis[u]+val[i]; tofa[v]=val[i]; dfs_pre(v,u); &#125;&#125;int dif[MAXN],tot,lim;bool dfs_calc(int u,int F)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==F) continue; if(dfs_calc(v,u)) return true; dif[u]+=dif[v]; &#125; if(u!=1 &amp;&amp; dif[u]==tot &amp;&amp; tofa[u]&gt;=lim) return true; return false;&#125;bool check(int mid)&#123; tot=0,lim=0; for(int i=1;i&lt;=n;++i) dif[i]=0; for(int i=1;i&lt;=m;++i) &#123; if(len[i]&lt;=mid) continue; lim=max(lim,len[i]-mid); ++tot; ++dif[x[i]],++dif[y[i]]; dif[z[i]]-=2; &#125; if(!tot) return true; return dfs_calc(1,0);&#125;int main()&#123; n=read(),m=read(); Log[0]=-1,Log[1]=0; for(int i=2;i&lt;=n;++i) Log[i]=Log[i&gt;&gt;1]+1; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; for(int i=1;i&lt;=m;++i) &#123; x[i]=read(); y[i]=read(); &#125; dfs_pre(1,0); for(int i=1;i&lt;=m;++i) &#123; z[i]=LCA(x[i],y[i]); len[i]=dis[x[i]]+dis[y[i]]-2*dis[z[i]]; mx=max(mx,len[i]); &#125; int L=0,R=mx,ans; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 535 花火]]></title>
    <url>%2F2019%2F08%2F13%2FLoj-535-%E8%8A%B1%E7%81%AB%2F</url>
    <content type="text"><![CDATA[扫描线 + 线段树. 特判序列已经有序的情况,此时不需要进行任何交换. 首先,我们可以首先进行特殊的交换,再进行一般的交换,这样显然不会使答案变劣. 特殊交换之后,还需要的次数就是当前逆序对的数目.所以特殊交换要减少尽可能多的逆序对. 考虑交换两个数 $h_x,h_y,x&lt;y$ ,显然当 $h_x&gt;h_y$ 时,逆序对会减少,否则会增加,于是只考虑 $h_x&gt;h_y$ 的情况. 容易发现交换后减少的逆序对数目就是 $1+2|S|,S=\lbrace k|x&lt;k&lt;y,h_y&lt;h_k&lt;h_x \rbrace$ . 考虑左端点 $x$ 的选择,若 $h_{x_1}&gt;h_{x_2},x_1&lt;x_2$ , $x_2$ 就没用了.于是可以维护出有用的 $x$ . 考虑右端点 $pos_y$ 的选择,若 $h_{y_1}&lt;h_{y_2},y_1&gt;y_2$ , $y_2$ 就没用了.于是可以维护出有用的 $y$ . 考虑一个位置 $k$ 会存在哪些点对 $(x,y)$ 满足 $x&lt;k&lt;y,h_y&lt;h_k&lt;h_x$ .在第一个单调栈中二分找出最小的 $l$ ,使得 $h_l&gt;h_k$ ,在第二个单调栈中二分找出最小的 $r$ ,使得 $h_r&lt;h_x$ . 那么点对 $(x,y)$ 满足 $x&lt;k&lt;y,h_y&lt;h_k&lt;h_x$ ,即 $k$ 对 $(x,y)$ 有贡献的条件是 $x\in [l,k-1],y\in[k+1,r]$ . 这相当于是一个矩形覆盖,问题转化为给了若干个矩形,求一个点最多被覆盖了几次. 扫描线 + 线段树解决,时间复杂度 $O(n\log n)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;int n,h[MAXN],H[MAXN];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;FT;ll ans=0;int vis[MAXN],sx[MAXN],tx=0,sy[MAXN],ty=0;int bsx(int x)&#123; int L=1,R=tx,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(h[sx[mid]]&gt;x) res=mid,R=mid-1; else L=mid+1; &#125; return sx[res];&#125;int bsy(int y)&#123; int L=1,R=ty,res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(h[sy[mid]]&lt;y) res=mid,R=mid-1; else L=mid+1; &#125; return sy[res];&#125;struct node&#123; int x,ly,ry,tp;//1 + -1 - bool operator &lt; (const node &amp;rhs) const &#123; return x==rhs.x?tp&gt;rhs.tp:x&lt;rhs.x; &#125;&#125;p[MAXN&lt;&lt;2];struct SegTree&#123; struct node &#123; int mx,tag; &#125;Tree[MAXN&lt;&lt;4];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void BuildTree(int o,int l,int r) &#123; root.mx=0; root.tag=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void modify(int o,int c) &#123; root.mx+=c; root.tag+=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modify(o&lt;&lt;1,root.tag); modify(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modify(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query() &#123; return Tree[1].mx; &#125;&#125;ST;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) h[i]=H[i]=read(); sort(H+1,H+1+n); for(int i=1;i&lt;=n;++i) &#123; h[i]=lower_bound(H+1,H+1+n,h[i])-H; ans+=FT.sum(n)-FT.sum(h[i]); FT.add(h[i],1); &#125; if(!ans) return puts("0")&amp;0; ++ans; for(int i=1;i&lt;=n;++i) &#123; if(tx&gt;0 &amp;&amp; h[i]&lt;h[sx[tx]]) continue; sx[++tx]=i; vis[i]=1; &#125; for(int i=n;i&gt;=1;--i) &#123; if(ty&gt;0 &amp;&amp; h[i]&gt;h[sy[ty]]) continue; sy[++ty]=i; vis[i]=1; &#125; int cnt=0; for(int i=1;i&lt;=n;++i) &#123; if(vis[i]) continue; int l=bsx(h[i]),r=bsy(h[i]); if(l&lt;i &amp;&amp; i&lt;r) &#123; p[++cnt]=(node)&#123;l,i+1,r,1&#125;; p[++cnt]=(node)&#123;i-1,i+1,r,-1&#125;; &#125; &#125; sort(p+1,p+1+cnt); int s=0; for(int i=1;i&lt;=cnt;++i) &#123; ST.upd(1,1,n,p[i].ly,p[i].ry,p[i].tp); if(p[i].tp&gt;0) s=max(s,ST.query()); &#125; ans-=(1+2LL*s); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五边形数定理学习笔记]]></title>
    <url>%2F2019%2F08%2F13%2F%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[去 大佬的博客 学习了一下相关知识. 整数划分问题将一个正整数 $n$ 拆分成若干正整数之和,求方案数. 令 $f(i,j)$ 表示将 $j$ 拆成 $i$ 个数的方案数,转移有 $f(i,j)=f(i,j-i)+f(i-1,j-1)$ ,边界为 $f(0,0)=1$ . 意义是所有数都 $+1$ 或者新加入一个 $1$ ,时间复杂度 $O(n^2)$ . 几个拓展 要求拆成的正整数两两不同.这样,新加入一个 $1$ 之前的操作必须是每个数都 $+1$ . $f(i,j)=f(i,j-i)+f(i-1,j-i)$ .显然不超过 $\sqrt n$ 个数,时间复杂度 $O(n\sqrt n)$ . 要求拆成的数全部为奇数.方案数等同于拆成两两不同的方案数.可以构造出一一对应的映射( $Ferrers$ 图转置). 要求拆成若干个 $\le k$ 的数.方案数等同于拆成 $\le k$ 个任意大小的正整数. 五边形数定理五边形数 $f_1=1,f_n=f_{n-1}+3n-2$ .对差分求前缀和,得到 $f_n=\frac{n(3n-1)} 2$ . $1,5,12,22,35,51,70,92,117,145,176,210,247,287\dots$ 广义五边形数在公式 $f_n=\frac{n(3n-1)} 2$ 中, $n$ 取 $0,1,-1,2,-2\dots$ $0,1,2,5,7,12,15,22,26,35,40,51,57,70,77,92,100,117,126\dots$ 欧拉函数$$\phi(x)=\prod_{i=1}^{+\infty} (1-x^i)$$ 值得一提的是,上面这个函数就是我们在数论中经常使用的 $\varphi(x)$ 的展开形式. 它仅在 $|x|&lt; 1$ 时收敛,但这里作为形式幂级数,我们不考虑它的敛散性. 五边形数定理$$\begin{aligned}\phi(x)&amp;=1-x-x^2+x^5+x^7-x^{12}-x^{15}\dots \\&amp;=1+\sum_{i=1}^{+\infty}(-1)^i(x^{i(3i-1)/2}+x^{-i(-3i-1)/2})\end{aligned}$$ $x^{i(3i-1)/2}+x^{-i(-3i-1)/2}$ 这个东西的次数分别是相邻的两个广义五边形数. 五边形数定理与整数划分写出整数划分问题的生成函数 $G(x)$ ,显然,$$\begin{aligned}G(x)&amp;=\prod_{i=1}^{+\infty}(1+x^i+x^{2i}+x^{3i}+\dots) \\&amp;=\prod_{i=1}^{+\infty}\frac 1 {1-x^i}\end{aligned}$$发现 $G\times \phi=1$ .把多项式乘法暴力展开,观察系数,可以得到递推式$$G(1)=1,G(n)=G(n-1)+G(n-2)-G(n-5)-G(n-7)+\dots$$因为广义五边形数的级别是 $n^2$ 的,所以直接递推的时间复杂度为 $O(n\sqrt n)$ . 也可以直接在模 $x^{n+1}$ 意义下对 $\phi$ 求逆得到 $G$ ,时间复杂度 $O(n\log n)$.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6261 一个人的高三楼]]></title>
    <url>%2F2019%2F08%2F13%2FLoj-6261-%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E9%AB%98%E4%B8%89%E6%A5%BC%2F</url>
    <content type="text"><![CDATA[生成函数 + $NTT$ . 设这个数列做了 $i$ 次前缀和后的生成函数为 $F_i(x)$ . $F_0(x)$ 是已知的,将下标置为从 $0$ 开始. 考虑如何递推,令 $G(x)=\sum_{i=0}^{n-1}x^i$ ,则$$F_{i+1}(x)\equiv F_i(x)\cdot G(x)\ (\mbox{mod}\ x^n)$$那么就有$$F_k(x)\equiv F_0(x)\cdot G^k(x)\ (\mbox{mod}\ x^n)$$直接用多项式快速幂,时间复杂度 $O(n\log n)$ .但这种做法常数比较大,而且写起来麻烦. 考虑 $G(x)^k$ 的组合意义.有 $k$ 个盒子,每个盒子可以拿出 $0\sim n-1$ 个球, $[x^i]G^k(x)$ 表示拿出了 $i$ 个球的方案数. 盒子是不同的,而球是相同的,相当于把这 $i$ 个球分到 $k$ 个盒子里去.隔板法可知 $[x^i]G^k(x)={i+k-1\choose k-1}$ . 用 $NTT$ 将 $F_0(x)$ 和 $G^k(x)$ 乘起来就是答案了.时间复杂度 $O(n\log n)$ ,是与 $k$ 无关的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll read()&#123; ll out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=1e5+10;int omega[MAXN&lt;&lt;2],inv[MAXN&lt;&lt;2],rev[MAXN&lt;&lt;2],curn=0;void init(int n)&#123; if(curn==n) return; for(int i=0; i&lt;n; ++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((n&gt;&gt;1)*(i&amp;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;int NTT_A[MAXN&lt;&lt;2],NTT_B[MAXN&lt;&lt;2];void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0; i&lt;lenA; ++i) NTT_A[i]=A[i]; for(int i=lenA; i&lt;n; ++i) NTT_A[i]=0; for(int i=0; i&lt;lenB; ++i) NTT_B[i]=B[i]; for(int i=lenB; i&lt;n; ++i) NTT_B[i]=0; DFT(NTT_A,n,false); DFT(NTT_B,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(NTT_A[i],NTT_B[i]); DFT(C,n,true);&#125;int n;ll k;int A[MAXN],B[MAXN],C[MAXN&lt;&lt;2];int main()&#123; n=read(),k=read(); int t=(k-1)%P; for(int i=0; i&lt;n; ++i) A[i]=read(); B[0]=1; for(int i=1; i&lt;n; ++i) &#123; B[i]=mul(B[i-1],add(i,t)); B[i]=mul(B[i],fpow(i,P-2)); &#125; NTT(A,B,C,n,n); for(int i=0; i&lt;n; ++i) printf("%d\n",C[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式的几个板子]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[多项式的几个板子,代码也放在一起了. Luogu P4238 多项式求逆给定一个 $n$ 项的多项式 $A$ ,求多项式 $B$ ,使得 $A\cdot B\equiv 1 (\mbox{mod}\ x^n)$ . 首先还是用 $0$ 将 $n$ 补成 $2$ 的幂次,然后递归求解. 若 $n=1$ ,那么只需要让 $B=A_0^{-1}$ . 若 $n&gt;1$ ,则先求解 $B’$ ,使得 $A\cdot B’\equiv 1(\mbox{mod}\ x^{\frac n 2})$ . 因为 $A\cdot B\equiv 1(\mbox{mod}\ x^n)$ ,所以有 $B-B’\equiv 0(\mbox{mod}\ x^{\frac n 2})$ . 即 $B-B’=C\cdot x^{\frac n 2}$ ,所以 $B^2-2\cdot B\cdot B’+B’^2\equiv 0(\mbox{mod}\ x^n)$ . 两边同乘 $A$ ,得到 $B-2B’+A\cdot B’^2\equiv 0(\mbox{mod}\ x^n)$ . 于是可以得到 $B\equiv 2B’-A\cdot B’^2(\mbox{mod}\ x^n)$ . 由上过程可以看出,多项式 $A$ 有逆元的充要条件是常数项 $A_0$ 有逆元. 时间复杂度为 $\Theta(n\log n)$ . 实现时可以把递归改成迭代,常数会优秀许多. Luogu P4512 多项式除法/多项式取模给定一个 $n$ 次多项式 $A$ ,一个 $m$ 次多项式 $B$ ,满足 $m\le n$ ,求多项式 $D,R$ ,使得,$$A(x)=D(x)B(x)+R(x)$$并且 $\deg (D)\le n-m,\deg (R)&lt;m$ . 尝试先消去余式 $R(x)$ 的影响,考虑多项式的 系数反转 ,即对于一个 $n$ 次多项式 $A$ ,$$A^R(x)=x^n\cdot A(\frac 1 x)$$如 $A(x)=x^3+2x^2+3x+4$ ,则 $A^R(x)=x^3\cdot A(\frac 1 x)=4x^3+3x^2+2x+1$ . 我们要求满足 $A(x)=D(x)B(x)+R(x)$ 的 $D,R$ ,如果将 $x$ 全部用 $\frac 1 x$ 替换,等式仍然成立. 替换后再同时乘上 $x^n$ ,由于 $\deg(D)\le n-m,\deg(R)&lt;m$ ,将 $D,R$ 次数分别看做 $n-m,m-1$ ,不足用 $0$ 补. 于是可以得到,$$A^R(x)=D^R(x)B^R(x)+x^{n-m+1}\cdot R^R(x)$$我们将上面的等式两边都对 $x^{n-m+1}$ 取模, $x^{n-m+1}\cdot R^R(x)$ 就被消去了,于是得到,$$A^R(x)\equiv D^R(x)B^R(x) (\mbox{mod}\ x^{n-m+1})$$对 $B^R(x)$ 用一次多项式求逆,再用一次多项式乘法求得模 $x^{n-m+1}$ 意义下的 $D^R(x)$ . 由于 $\deg (D)\le n-m$ ,反转后 $\deg (D^R)\le n-m$ .所以模意义下求得的 $D^R(x)$ 就是真实的 $D^R(x)$ . 再系数反转求得 $D(x)$ ,回代 $A(x)=D(x)B(x)+R(x)$ 得到 $R(x)$ . 从上述过程可以看出,多项式除法/多项式取模的时间复杂度与多项式求逆相同,为 $\Theta(n\log n)$ . Luogu P4728 多项式 $\ln$首先需要了解多项式的求导和不定积分.对于一个 $n-1$ 次多项式 $A$ , $$A(x)=\sum_{i=0}^{n-1} a_i\cdot x_i\\A’(x)=\sum_{i=0}^{n-2} a_{i+1}\cdot(i+1)\cdot x^i \\\int A(x) \mbox d x=\sum_{i=1}^{n}\frac {a_{i-1}} i \cdot x^i+C$$ 现在给出 $n-1$ 次多项式 $A(x)$ ,要在模 $x^n$ 意义下求 $B(x)$ ,使得 $B(x)\equiv \ln (A(x))\ (\mbox{mod}\ x^n)$ . 两边同时求导,得到 $B’(x)\equiv \frac {A’(x)} {A(x)}\ (\mbox{mod}\ x^n)$ . 多项式求逆得到 $\frac 1 {A(x)}$ ,再算出 $B’(x)$ ,再对 $B’(x)$ 不定积分得到 $B(x)$ . 这里 $B(x)$ 的常数项是 $0$ ,因为 $a_0=1$ ,若将 $\ln$ 函数大力展开,就可以发现 $B$ 的常数项就是 $\ln a_0$ . 时间复杂度 $\Theta(n\log n)$ . 多项式牛顿迭代已知一个函数 $G(x)$ ,在模 $x^n$ 意义下求一个多项式 $F(x)\ \mbox{mod}\ x^n$ ,使得 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ . 仍然将项数用 $0$ 补到 $2$ 的幂次.当 $n=1$ 时,需要单独求解 $G(F(x))\equiv 0(\mbox{mod}\ x)$ . 否则,先求解 $F_0(x)$ ,使得 $G(F_0(x))\equiv 0 (\mbox{mod}\ x^{\frac n 2})$ . 考虑如何拓展到模 $x^n$ 下,把 $G(F(x))$ 在 $F_0(x)$ 处进行泰勒展开, $$G(F(x))=G(F_0(x))+\frac{G’(F_0(x))}{1!}\cdot (F(x)-F_0(x))+\frac{G’’(F_0(x))}{2!}\cdot (F(x)-F_0(x))^2 + \dots$$ 因为 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ ,所以 $G(F(x))\equiv 0(\mbox{mod}\ x^{\frac n 2})$ 也成立. 而 $G(F_0(x))\equiv 0 (\mbox{mod}\ x^{\frac n 2})$ 所以 $F(x)$ 与 $F_0(x)$ 次数低于 $x^{\frac n 2}$ 的部分是相同的. 所以展开式中从第三项 $\frac{G’’(F_0(x))}{2!}\cdot (F(x)-F_0(x))^2$ 起,在模 $x^n$ 意义下都为 $0$ .于是只保留前两项,得到 $$G(F(x))\equiv G(F_0(x))+{G’(F_0(x))}\cdot (F(x)-F_0(x))\ (\mbox{mod}\ x^n)$$ 而 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ ,所以就有 $$F(x)\equiv F_0(x)-\frac {G(F_0(x))} {G’(F_0(x))}\ (\mbox{mod}\ x^n)$$ 需要注意,这里的 $G’(F_0(x))$ 是以 $F_0(x)$ 作为自变量求导,而不是以 $x$ 作为自变量求导. 如,若 $G(x)=\ln x,F_0(x)=x$ ,则 $G’(F_0(x))=\frac 1 {F_0(x)}=\frac 1 x$ ,而不是 $\ln(1)=0$ . 时间复杂度为 $O(n\log n)$ ,由于可以实现类似解方程的操作,所以用途比较广泛. 如实现多项式 $\exp$ ,多项式开根,多项式快速幂等奇奇怪怪的函数. Luogu P4726 多项式 $\exp$给定项数为 $n$ 的多项式 $A(x)$ ,在 $\mbox{mod} \ x^n$ 意义下求多项式 $B(x)$ ,使得 $B(x)\equiv \exp(A(x))\ (\mbox{mod} \ x^n)$ . 取对数,得到 $\ln B\equiv A \ (\mbox{mod} \ x^n)$ ,令 $G(x)=\ln x-A$ ,则问题等价于求解 $F(x)$ ,使得 $G(F(x))\equiv 0(\mbox{mod}\ x^n)$ . 直接套用牛顿迭代的那一套理论,得到$$F\equiv (1-{\ln (F_0)+A})\cdot F_0\ (\mbox{mod}\ x^n)$$递归求解,当 $n=1$ 时,令 $F_0(x)=\exp a_0$ 即可.一般会保证多项式 $A$ 的常数项 $a_0=0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=4e5+10;const int P=998244353,G=3;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int rev[MAXN],omega[MAXN],inv[MAXN];int curn;void init(int n)&#123; for(int i=0;i&lt;n;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(n&gt;&gt;1)); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; omega[l]=fpow(G,(P-1)/l); inv[l]=fpow(omega[l],P-2); &#125; curn=n;&#125;void DFT(int *a,int n,bool invflag)&#123; if(curn!=n) init(n); for(int i=0; i&lt;n; ++i) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int l=2; l&lt;=n; l&lt;&lt;=1) &#123; int m=(l&gt;&gt;1); int gi=omega[l]; if(invflag) gi=inv[l]; for(int *p=a; p!=a+n; p+=l) &#123; int g=1; for(int i=0; i&lt;m; ++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int invn=fpow(n,P-2); for(int i=0; i&lt;n; ++i) a[i]=mul(a[i],invn); &#125;&#125;int a[MAXN],b[MAXN];void NTT(int *A,int *B,int *C,int lenA,int lenB)&#123; int lenC=lenA+lenB-1,n=1; while(n&lt;lenC) n&lt;&lt;=1; for(int i=0;i&lt;lenA;++i) a[i]=A[i]; for(int i=lenA;i&lt;n;++i) a[i]=0; for(int i=0;i&lt;lenB;++i) b[i]=B[i]; for(int i=lenB;i&lt;n;++i) b[i]=0; DFT(a,n,false); DFT(b,n,false); for(int i=0; i&lt;n; ++i) C[i]=mul(a[i],b[i]); DFT(C,n,true);&#125;int tmp[MAXN];void poly_inverse(int *A,int *B,int n)&#123; for(int i=0;i&lt;2*n;++i) B[i]=0; B[0]=fpow(A[0],P-2); int k=0; for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; ++k; NTT(A,B,tmp,i,i); NTT(tmp,B,tmp,i,i); for(int j=0;j&lt;i;++j) B[j]=add(mul(2,B[j]),P-tmp[j]); &#125;&#125;int InvB[MAXN];int ModA[MAXN],ModB[MAXN];void poly_rev(int *A,int n)//n-&gt;最高项次数 &#123; for(int i=0;i&lt;n-i;++i) swap(A[i],A[n-i]);&#125;void poly_division(int *A,int *B,int *D,int *R,int n,int m)&#123; poly_rev(A,n); poly_rev(B,m); for(int i=0;i&lt;n-m+1;++i) ModA[i]=A[i],ModB[i]=B[i]; int N=1; while(N&lt;n-m+1) N&lt;&lt;=1; poly_inverse(ModB,InvB,N); for(int i=n-m+1;i&lt;N;++i) InvB[i]=0; NTT(ModA,InvB,D,n-m+1,n-m+1); poly_rev(D,n-m); poly_rev(A,n); poly_rev(B,m); NTT(B,D,R,m,n-m+1); for(int i=0;i&lt;n;++i) R[i]=add(A[i],P-R[i]);&#125;void poly_diff(int *A,int n)&#123; for(int i=0;i&lt;n-1;++i) A[i]=mul(A[i+1],i+1);&#125;void poly_int(int *A,int n)&#123; for(int i=n;i&gt;=1;--i) A[i]=mul(A[i-1],fpow(i,P-2));&#125;int InvA[MAXN],tmpA[MAXN];void poly_ln(int *A,int *B,int n)&#123; for(int i=0;i&lt;n;++i) tmpA[i]=A[i]; poly_inverse(tmpA,InvA,n); poly_diff(tmpA,n); NTT(tmpA,InvA,B,n,n); poly_int(B,n); B[0]=0; for(int i=0;i&lt;n;++i) tmpA[i]=0;&#125;int lnB[MAXN];void poly_exp(int *A,int *B,int n)&#123; if(n==1) &#123; B[0]=1; return; &#125; poly_exp(A,B,n&gt;&gt;1); for(int i=0;i&lt;n;++i) lnB[i]=0; poly_ln(B,lnB,n); for(int i=0;i&lt;n;++i) lnB[i]=add(A[i],P-lnB[i]); lnB[0]=add(lnB[0],1); NTT(B,lnB,B,n&gt;&gt;1,n); for(int i=n;i&lt;(n+(n&gt;&gt;1));++i) B[i]=0; &#125;int A[MAXN],B[MAXN];int main()&#123; int n=read(); for(int i=0;i&lt;n;++i) A[i]=read(); int N=1; while(N&lt;n) N&lt;&lt;=1; poly_exp(A,B,N); for(int i=0;i&lt;n;++i) printf("%d ",B[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4373 算术天才⑨与等差数列]]></title>
    <url>%2F2019%2F08%2F13%2Fbzoj-4373-%E7%AE%97%E6%9C%AF%E5%A4%A9%E6%89%8D%E2%91%A8%E4%B8%8E%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[线段树 + $hash$ 乱搞. 可以考虑用线段树维护区间的最小值,最大值. 若是等差数列,根据最小/大值,公差可以算出长度,区间元素和,区间元素平方和,区间元素立方和,后两个自然溢出. 在线段树中把这些信息也维护进去,然后查询区间的这些要素,看一下是否符合预期结果即可. 立方和不判似乎也可以过.这东西应该挺难卡的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e5+10;const int P=1e9+7;ull cube(ull x)&#123; return x*x*x;&#125;ull S1(ull x)&#123; return x*(x+1)/2;&#125;ull S2(ull x)&#123; return x*(x+1)*(2*x+1)/6;&#125;ull S3(ull x)&#123; return S1(x)*S1(x);&#125;const ull U=1;int n,m,tot=0,a[MAXN];struct SegTree&#123; struct node &#123; int minv,maxv; ll sum1; ull sum2,sum3; friend node operator + (node lson,node rson) &#123; node root; root.minv=min(lson.minv,rson.minv); root.maxv=max(lson.maxv,rson.maxv); root.sum1=lson.sum1+rson.sum1; root.sum2=lson.sum2+rson.sum2; root.sum3=lson.sum3+rson.sum3; return root; &#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root=lson+rson; &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) &#123; root=(node)&#123;a[l],a[l],a[l],U*a[l]*a[l],cube(a[l])&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int pos,int c) &#123; if(l==r) &#123; root=(node)&#123;c,c,c,U*c*c,cube(c)&#125;; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,l,mid,pos,c); else upd(o&lt;&lt;1|1,mid+1,r,pos,c); pushup(o); &#125; node query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query(o&lt;&lt;1|1,mid+1,r,L,R); return query(o&lt;&lt;1,l,mid,L,R)+query(o&lt;&lt;1|1,mid+1,r,L,R); &#125; bool check(int L,int R,int k) &#123; node tmp=query(1,1,n,L,R); ull len=R-L+1; if((tmp.maxv-tmp.minv)!=(len-1)*k) return false; ll expsum1=len*(tmp.minv+tmp.maxv)/2; if(expsum1!=tmp.sum1) return false; ull b=tmp.minv-k; ull expsum2=len*b*b; expsum2+=k*b*(len+1)*len; expsum2+=k*k*S2(len); if(expsum2!=tmp.sum2) return false; ull expsum3=cube(k)*S3(len); expsum3+=U*3*k*k*b*S2(len); expsum3+=U*3*k*b*b*S1(len); expsum3+=len*cube(b); if(expsum3!=tmp.sum3) return false; return true; &#125;&#125;T;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.BuildTree(1,1,n); while(m--) &#123; int op=read(); if(op==1) &#123; int x=read()^tot,y=read()^tot; T.upd(1,1,n,x,y); &#125; else &#123; int L=read()^tot,R=read()^tot,k=read()^tot; if(T.check(L,R,k)) &#123; puts("Yes"); ++tot; &#125; else puts("No"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 134]]></title>
    <url>%2F2019%2F07%2F20%2FAtcoder-Beginner-Contest-134%2F</url>
    <content type="text"><![CDATA[$F$ 题不错. A Dodecagon签到题. 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int x=read(); cout&lt;&lt;3*x*x&lt;&lt;endl; return 0;&#125; B Golden Apple签到题. 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),D=read(); cout&lt;&lt;(n+2*D)/(2*D+1)&lt;&lt;endl; return 0;&#125; C Exception Handling$ST$ 表或者线段树写一写就好了.或许有不用数据结构的高论? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int a[MAXN];struct Segtree&#123; struct node &#123; int mx; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void bd(int o,int l,int r) &#123; if(l==r) &#123; root.mx=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(o&lt;&lt;1,l,mid); bd(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;R || L&gt;r || l&gt;R) return -1; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mx; int res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) res=max(res,query(o&lt;&lt;1|1,mid+1,r,L,R)); return res; &#125;&#125;T;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); T.bd(1,1,n); for(int i=1;i&lt;=n;++i) printf("%d\n",max(T.query(1,1,n,1,i-1),T.query(1,1,n,i+1,n))); return 0;&#125; D Preparing Boxes倒着确定每个数,显然每个数是唯一确定的. 暴力统计就好了,由调和级数知,时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN];int t[MAXN],m=0;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=n;i&gt;=1;--i) &#123; int x=a[i]; for(int j=i*2;j&lt;=n;j+=i) x^=t[j]; t[i]=x; if(x) ++m; &#125; cout&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=n;++i) if(t[i]) printf("%d ",i); return 0;&#125; E Sequence Decomposing给一个序列,求最少分成几个单调上升子序列. 大概就是导弹拦截那道题.答案就是最长单调不降子序列的长度. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,A[MAXN],a[MAXN];#define lowbit(x) x&amp;(-x)int bit[MAXN];void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=max(bit[x],c);&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s=max(s,bit[x]); return s;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); int m=unique(A+1,A+1+n)-A-1; for(int i=1;i&lt;=n;++i) &#123; int x=lower_bound(A+1,A+1+m,a[i])-A; x=m+1-x; int y=sum(x)+1; add(x,y); &#125; cout&lt;&lt;sum(n)&lt;&lt;endl; return 0;&#125; F Permutation Oddness$dp$ 计数,设 $f(i,j,k,l)$ 表示考虑前 $i$ 个位置, $1,2,\dots i $ 中有 $j$ 个数还没有填,位置 $1,2,\dots,i$ 中有 $k$ 个位置还没有放,已经确定的权值为 $l$ 时的方案数. 后两维可以写在一起,状态数 $O(n^4)$ ,转移 $O(1)$ ,时间复杂度 $O(n^4)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=51;const int P=1e9+7;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void upd(int &amp;x,int y)&#123; x=add(x,y);&#125;int N,K;int f[MAXN][MAXN][MAXN*MAXN];int main()&#123; N=read(),K=read(); f[0][0][0]=1; for(int i=1;i&lt;=N;++i) for(int j=0;j&lt;=i;++j) for(int k=2*j;k&lt;=K;++k) &#123; upd(f[i][j][k],mul(2*j+1,f[i-1][j][k-2*j])); upd(f[i][j][k],mul(j*j+2*j+1,f[i-1][j+1][k-2*j])); if(j) upd(f[i][j][k],f[i-1][j-1][k-2*j]); &#125; cout&lt;&lt;f[N][0][K]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>线段树</tag>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190720]]></title>
    <url>%2F2019%2F07%2F20%2Ftest20190720%2F</url>
    <content type="text"><![CDATA[好题. $A\ Safe\ Bet$$25$ 分做法:枚举镜子摆放的位置,模拟光线,每次用 $set$ 找到下一面镜子,修改方向,最后检验是否从 $(R,C)$ 出来. 满分做法:不额外增加镜子,直接模拟光线,若最后从 $(R,C)$ 出来,答案为 $0$ . 否则,模拟反向光线,从 $(R,C+1)$ 反向射入,可以发现放镜子的可行位置为两条光线的所有交点. 用扫描线 + 线段树求交点数目以及字典序最小的交点即可. 考试情况:只写了 $25$ 分的做法. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=0;i&lt;n;++i)#define pb push_back#define mk make_pair#define X first#define Y second#define tree int t,int l,int r#define left t*2,l,mid#define right t*2+1,mid+1,r#define M int mid=l+r&gt;&gt;1const int N=1000005;typedef pair&lt;int,int&gt; pr;typedef vector&lt;pair&lt;int,pr&gt; &gt; seq;set&lt;pr&gt; a[N],b[N];seq f1,g1,f2,g2;int Case,n,m,R,C,x,y,ll,rr,c[N];long long ans;int get(int x)&#123; int res=0; for (; x; x-=x&amp;-x) res+=c[x]; return res;&#125;void add(int x,int v)&#123; for (; x&lt;=C; x+=x&amp;-x) c[x]+=v;&#125;void ins(int side)&#123; scanf("%d%d",&amp;x,&amp;y),a[x].insert(mk(y,side)),b[y].insert(mk(x,side));&#125;bool track(int x,int y,int d,seq &amp;f,seq &amp;g)&#123; f.clear(),g.clear(); set&lt;pr&gt; :: iterator it; for (;;) &#123; if (d&amp;1) &#123; if (d==1) &#123; it=b[y].upper_bound(mk(x,1)); f.pb(mk(x+1,mk(y,1))); if (it==b[y].end()) return f.pb(mk(R+1,mk(y,-1))),0; f.pb(mk(it-&gt;X,mk(y,-1))),x=it-&gt;X,d=it-&gt;Y?2:0; &#125; else &#123; it=b[y].lower_bound(mk(x,0)); f.pb(mk(x,mk(y,-1))); if (it==b[y].begin()) return f.pb(mk(1,mk(y,1))),0; --it; f.pb(mk(it-&gt;X+1,mk(y,1))),x=it-&gt;X,d=it-&gt;Y?0:2; &#125; &#125; else &#123; if (d==0) &#123; it=a[x].upper_bound(mk(y,1)); if (it==a[x].end()) return g.pb(mk(x,mk(y+1,C))),x==R; g.pb(mk(x,mk(y+1,it-&gt;X-1))),y=it-&gt;X,d=it-&gt;Y?3:1; &#125; else &#123; it=a[x].lower_bound(mk(y,0)); if (it==a[x].begin()) return g.pb(mk(x,mk(1,y-1))),0; --it; g.pb(mk(x,mk(it-&gt;X+1,y-1))),y=it-&gt;X,d=it-&gt;Y?1:3; &#125; &#125; &#125;&#125;void work(seq &amp;f,seq &amp;g)&#123; sort(f.begin(),f.end()),sort(g.begin(),g.end()); int m=f.size(),n=g.size(),j=0; rep(i,n) &#123; while (j&lt;m &amp;&amp; f[j].X&lt;=g[i].X) add(f[j].Y.X,f[j].Y.Y),++j; ll=g[i].Y.X,rr=g[i].Y.Y; int res=get(rr)-get(ll-1); ans+=res; if (g[i].X&lt;x &amp;&amp; res) &#123; x=g[i].X,y=ll; for (int j=20; j&gt;=0; --j) if (y+(1&lt;&lt;j)&lt;=rr &amp;&amp; !(get(y-1+(1&lt;&lt;j))-get(y-1))) y+=1&lt;&lt;j; &#125; &#125; while (j&lt;m) add(f[j].Y.X,f[j].Y.Y),++j;&#125;int main()&#123; freopen("safe.in","r",stdin); freopen("safe.out","w",stdout); while (scanf("%d%d%d%d",&amp;R,&amp;C,&amp;n,&amp;m)!=EOF) &#123; rep(i,R+1) a[i].clear(); rep(j,C+1) b[j].clear(); rep(i,n+m) ins(i&lt;n); printf("Case %d: ",++Case); if (track(1,0,0,f1,g1)) &#123; puts("0"); continue; &#125; track(R,C+1,2,f2,g2); ans=0,x=R+1,work(f1,g2),work(f2,g1); if (ans) printf("%I64d %d %d\n",ans,x,y); else puts("impossible"); &#125; return 0;&#125; $Room\ Service$$25$ 分做法:一堆特判.矩形的情况答案就是对角线长度 $\times 2$ . 我的 $60$ 分做法:其实就是乱搞,出题人是没有设计这一部分的,也没有卡我. 把每条边 $K$ 等分,拆成 $K+1$ 个点,设 $f(i,j,S)$ 表示从出发点到达第 $i$ 条边上的第 $j$ 个点,已经到达过的边集合为 $S$ 时走过的最短长度.大力转移,时间复杂度为 $O(n^2\cdot2^n\cdot K^2)$ .实际上有很多无用状态.参数 $K$ 取 $200$ 就可以了. 满分做法:若需要到的线段为直线,显然只需要将点 $P$ 关于 $n$ 条边都镜面反射一次,得到 $P’$ , $dis(P,P’)$ 即为答案. 但现在是线段,有可能交点在线段外,此时一定是某一个端点处最优.于是只有端点或交点处的状态有用, $flyod$ 预处理两点间最短路后,枚举第一个到的关键点和最后一个到的关键点,更新答案.时间复杂度 $O(n^3)$ . 考试情况:乱搞获得 $60$ 分. $std$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=1;i&lt;=n;++i)const double eps=1e-8;int Case,n;double ans,d[205][205];struct node&#123; double x,y; node() &#123;&#125; node(double _x,double _y):x(_x),y(_y) &#123;&#125; node operator +(const node &amp;A) &#123; return node(x+A.x,y+A.y); &#125; node operator -(const node &amp;A) &#123; return node(x-A.x,y-A.y); &#125; node operator *(const double &amp;A) &#123; return node(x*A,y*A); &#125; double operator *(const node &amp;A) &#123; return x*A.x+y*A.y; &#125; double operator %(const node &amp;A) &#123; return x*A.y-y*A.x; &#125; double norm() &#123; return x*x+y*y; &#125; double len() &#123; return sqrt(norm()); &#125; void read() &#123; scanf("%lf%lf",&amp;x,&amp;y); &#125;&#125; a[205];bool cross(node &amp;A,node &amp;B,node &amp;C,node &amp;D)&#123; return ((C-A)%(B-A))*((D-A)%(B-A))&lt;=0 &amp;&amp; ((C-A)%(B-A))*((D-A)%(B-A))&lt;=0;&#125;void rev(node A,node B,node &amp;C)&#123; node V=B-A; C=(A+V*(((C-A)*V)/V.norm()))*2-C;&#125;double work(node A,int l,node B,int r)&#123; for (int i=l; i&lt;r; ++i) rev(a[i],a[i+1],A); for (int i=r; i&gt;l; --i) &#123; if (!cross(A,B,a[i-1],a[i])) return 1e9; rev(a[i-1],a[i],A),rev(a[i-1],a[i],B); &#125; return (A-B).len();&#125;inline int chg(int x)&#123; return x&gt;n?x-n:x;&#125;inline void Min(double &amp;x,double y)&#123; if (y&lt;x) x=y;&#125;int main()&#123; freopen("room.in","r",stdin); freopen("room.out","w",stdout); while (scanf("%d",&amp;n)!=EOF) &#123; ans=1e9,a[0].read(); rep(i,n) a[i].read(),a[n+i]=a[i]; rep(i,n) rep(j,n-1) d[i][chg(i+j)]=work(a[i],i+1,a[i+j],i+j-1); rep(k,n) rep(i,n) rep(j,n) Min(d[i][j],d[i][k]+d[k][j]); rep(i,n) &#123; ans=min(ans,work(*a,i,*a,i+n)); for (int j=0; j&lt;n; ++j) d[0][chg(i+j)]=work(*a,i,a[i+j],i+j-1), d[chg(i+j)][0]=work(a[i+j],i+j+1,*a,i+n); rep(j,n) rep(k,n) Min(ans,d[0][j]+d[j][k]+d[k][0]); &#125; printf("%.2lf\n",ans); &#125; return 0;&#125; $Rain$满分做法:一个点的水面高度取决于它到边界必须经过的点中的最高海拔. 预处理出边界,从边界上的点出发跑 $Dijkstra$ ,求出每个点的水面高度,然后 $bfs$ 求联通块. 求边界可以先极角排序,从 $x$ 坐标最小的点出发,绕一圈就是边界. 时间复杂度 $O(m\cdot \log m)$ . 考试情况: puts(“0”); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;#define rep(i,n) for (int i=0,_=n;i&lt;_;++i)#define pb push_back#define mk make_pairconst int N=52*52;int Case,n,m,u,v,X,Y,now,o,x[N],y[N],h[N],d[N],id[N],ans[N];bool b[N];priority_queue&lt;pair&lt;int,int&gt; &gt; H;vector&lt;int&gt; e[N];char st[5];int C(char x)&#123; return x&lt;'a'?x-65:x-71;&#125;int get()&#123; scanf("%s",st); int v=C(st[0])*52+C(st[1]); if (id[v]&lt;0) id[v]=now++; return id[v];&#125;bool cmp(const int i,const int j)&#123; return atan2(y[i]-Y,x[i]-X)&lt;atan2(y[j]-Y,x[j]-X);&#125;void dfs(int i)&#123; if (!b[i] || d[i]&lt;=h[i]) return; b[i]=0; rep(k,e[i].size()) dfs(e[i][k]);&#125;int main()&#123; freopen("rain.in","r",stdin); freopen("rain.out","w",stdout); while (scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; rep(i,N) b[i]=1,id[i]=-1,e[i].clear(),d[i]=1&lt;&lt;20; now=0,o=0; rep(i,n) &#123; u=get(),scanf("%d%d%d",x+u,y+u,h+u); if (x[u]&lt;x[o]) o=u; &#125; rep(i,m) u=get(),v=get(),e[u].pb(v),e[v].pb(u); rep(i,n) X=x[i],Y=y[i],sort(e[i].begin(),e[i].end(),cmp); d[o]=h[o],H.push(mk(-d[o],o)); for (int j=o,i=e[o][0];; j=i,i=e[i][u]) &#123; rep(k,e[i].size()) if (e[i][k]==j) &#123; u=k; break; &#125; if (++u==e[i].size()) u=0; d[i]=h[i],H.push(mk(-d[i],i)); if (i==o &amp;&amp; !u) break; &#125; while (!H.empty()) &#123; pair&lt;int,int&gt; t=H.top(); H.pop(); int i=t.second; if (-t.first==d[i]) rep(k,e[i].size()) &#123; int j=e[i][k]; if (max(d[i],h[j])&lt;d[j]) d[j]=max(d[i],h[j]),H.push(mk(-d[j],j)); &#125; &#125; int L=0; rep(i,n) if (b[i] &amp;&amp; d[i]&gt;h[i]) ans[L++]=d[i],dfs(i); if (!L) puts("0"); sort(ans,ans+L); rep(i,L) printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
        <tag>扫描线</tag>
        <tag>test</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4446 小凸玩密室]]></title>
    <url>%2F2019%2F07%2F20%2Fbzoj-4446-%E5%B0%8F%E5%87%B8%E7%8E%A9%E5%AF%86%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[树形 $dp$ . 设 $f(i,j)$ 表示将子树 $i$ 全部点亮,下一次点亮点 $j$ 的最小花费.这样的话,状态数是 $O(n^2)$ 的. 注意到点亮子树 $i$ 后,下一次要么点亮 $i$ 的某个祖先,要么点亮 $i$ 的某个祖先的另外一侧的儿子.树是完全二叉树,所以可以直接用深度表示,树深是 $O(\log n)$ 的,再通过位运算得到节点标号. 设 $f(i,j)$ 表示点亮子树 $i$ 后,下一次点亮 $i$ 的第 $j$ 级祖先的最小花费, $g(i,j)$ 表示点亮子树 $i$ 后,下一次点亮 $i$ 的第 $j$ 级祖先的另一个儿子的最小花费.这样状态数是 $O(n\log n)$ 的. 默认以 $1$ 为根, $dp$ 求出 $f,g$ 的值.然后枚举第一个点亮的点 $x$ ,先点亮子树 $x$ ,跳到 $fa_x$ ,再点亮 $fa_x$ 的另一侧子树,再跳到 $fa_{fa_x}$ ,点亮 $fa_{fa_x}$ 的另一颗子树…需要跳 $O(\log n)$ 次. 时间复杂度 $O(n\log n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int fa(int x)&#123; return x&gt;&gt;1;&#125;int lson(int x)&#123; return x&lt;&lt;1;&#125;int rson(int x)&#123; return x&lt;&lt;1|1;&#125;int Ancestor(int x,int i)&#123; return x&gt;&gt;i;&#125;int Brother(int x,int i)&#123; return (x&gt;&gt;(i-1))^1;&#125;const int MAXN=2e5+10;const int Log=20;const ll inf=1e18;int n,dep[MAXN];ll a[MAXN],dis[MAXN][Log],f[MAXN][Log],g[MAXN][Log];int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) a[i]=read(); dep[1]=1; for(int i=2; i&lt;=n; ++i) &#123; dep[i]=dep[fa(i)]+1; dis[i][1]=read(); for(int j=2; j&lt;=dep[i]; ++j) dis[i][j]=dis[fa(i)][j-1]+dis[i][1]; &#125; for(int i=n; i&gt;=1; --i) &#123; int l=lson(i),r=rson(i); for(int j=1; j&lt;=dep[i]; ++j) &#123; if(r&lt;=n) //lson and rson &#123; f[i][j]=min(a[l]*dis[l][1]+g[l][1]+f[r][j+1],a[r]*dis[r][1]+g[r][1]+f[l][j+1]); g[i][j]=min(a[l]*dis[l][1]+g[l][1]+g[r][j+1],a[r]*dis[r][1]+g[r][1]+g[l][j+1]); &#125; else if(l&lt;=n)// only lson &#123; f[i][j]=a[l]*dis[l][1]+f[l][j+1]; g[i][j]=a[l]*dis[l][1]+g[l][j+1]; &#125; else //leaf &#123; f[i][j]=dis[i][j]*a[Ancestor(i,j)]; g[i][j]=(dis[i][j]+dis[Brother(i,j)][1])*a[Brother(i,j)]; &#125; &#125; &#125; ll ans=inf; for(int i=1; i&lt;=n; ++i) &#123; ll tmp=f[i][1]; for(int x=fa(i),y=i; x; y=x,x=fa(x)) &#123; int z=y^1; if(z&lt;=n) tmp+=dis[z][1]*a[z]+f[z][2]; else tmp+=dis[x][1]*a[fa(x)]; &#125; ans=min(ans,tmp); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4444 国旗计划]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4444-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[$two\ pointer$ + 倍增. 首先破环成链,接一段长度为 $m$ 的在后面.因为区间不覆盖,对于一个区间 $(l,r)$ ,它后面应该接的区间可以贪心确定,就是左端点在 $[l,r]$ 范围内,而右端点最大的区间.这个可以通过 $two\ pointer$ 预处理. 然后用倍增的做法,处理 $f(i,j)$ 表示区间 $i$ 之后的第 $2^j$ 个区间标号. 查询时从 $i$ 开始跳,找到第一个区间使得区间总长 $\ge m$ 即可.时间复杂度 $O(n\cdot \log m)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=4e5+10;struct node&#123; int l,r,id; node(int l=0,int r=0,int id=0):l(l),r(r),id(id) &#123;&#125; bool operator &lt; (const node &amp;rhs) const &#123; return r&lt;rhs.r; &#125;&#125;p[MAXN];int n,m,f[MAXN][20];int ans[MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; int l=read(),r=read(); if(l&gt;r) p[2*i-1]=node(l,r+m,i),p[2*i]=node(l+m,r+2*m,i); else p[2*i-1]=node(l,r,i),p[2*i]=node(l+m,r+m,i); &#125; sort(p+1,p+1+2*n); for(int i=1,j=1;i&lt;=2*n;++i) &#123; while(j&lt;2*n &amp;&amp; p[j+1].l&lt;=p[i].r) ++j; f[i][0]=(i==j)?0:j; &#125; for(int j=1;(1&lt;&lt;j)&lt;=2*n;++j) for(int i=1;i&lt;=2*n;++i) f[i][j]=f[f[i][j-1]][j-1]; for(int i=1;i&lt;=2*n;++i) &#123; if(p[i].l&gt;m) continue; int x=i,tmp=0; for(int j=19;j&gt;=0;--j) if(f[x][j] &amp;&amp; p[f[x][j]].r&lt;p[i].l+m) x=f[x][j],tmp+=(1&lt;&lt;j); x=f[x][0]; ++tmp; ans[p[i].id]=tmp+(int)(p[i].id!=p[x].id); &#125; for(int i=1;i&lt;=n;++i) printf("%d ",ans[i]); puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>two pointer</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4443 小凸玩矩阵]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4443-%E5%B0%8F%E5%87%B8%E7%8E%A9%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[二分答案 + 二分图最大匹配. 二分答案 $mid$ ,权值 $\le mid$ 的边才有用,第 $k$ 大就是第 $n-k+1$ 小,判断一下最大匹配数是否达到 $n-k+1$ ,达到则合法,否则不合法. 时间复杂度 $O(n^3\cdot \log (\max v))$ . 匈牙利算法每次 $dfs$ 前都需要清空 $vis$ 数组. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=256;int a[MAXN][MAXN];vector&lt;int&gt; E[MAXN&lt;&lt;1];int pr[MAXN&lt;&lt;1],vis[MAXN&lt;&lt;1];int n,m,k;bool dfs(int u)&#123; int t=E[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=E[u][i]; if(!vis[v]) &#123; vis[v]=1; if(!pr[v] || dfs(pr[v])) &#123; pr[v]=u; pr[u]=v; return true; &#125; &#125; &#125; return false;&#125;bool check(int mid)&#123; for(int i=1;i&lt;=n+m;++i) E[i].clear(); memset(pr,0,sizeof pr); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(a[i][j]&lt;=mid) &#123; E[i].push_back(j+n); E[j+n].push_back(j); &#125; int ans=0; for(int i=1;i&lt;=n;++i) if(!pr[i]) &#123; memset(vis,0,sizeof vis); ans+=(int)(dfs(i)); &#125; return ans&gt;=(n+1-k);&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) a[i][j]=read(); int L=1,R=inf,ans=inf; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF19E Fairy]]></title>
    <url>%2F2019%2F07%2F19%2FCF19E-Fairy%2F</url>
    <content type="text"><![CDATA[树上差分. 二分图定义是能用黑白两种颜色给图染色,使得没有两个有边相连的节点颜色相同.其实也就是说图中不存在奇环. 那么一张二分图,删去任意一条边后一定仍是二分图.于是我们先做出原图的一棵生成树,再将剩下的边加入. 预处理 $LCA,dep$ ,然后加入非树边 $(u,v)$ .那么树上 $u\to v$ 路径上所有边都被这条非树边”覆盖”了. 若 $dis(u,v)$ 为奇,加入 $(u,v)$ 后会形成偶环,称这样的边为合法的边. 若 $dis(u,v)$ 为偶,则加入 $(u,v)$ 后会形成奇环,称这样的边为不合法的边. 记不合法的边总数为 $tot$ ,若 $tot=0$ ,可以删的边就是所有的边. 若 $tot=1$ ,可以删的边就是唯一的那条不合法边,以及树上被它覆盖,但未被合法边覆盖的边. 若 $tot&gt;1$ ,可以删的边就是树上被所有不合法边覆盖,但未被任意一条合法边覆盖的边. 删去树边时要求未被合法边覆盖,是因为 $(u,v)$ 若被合法边覆盖,删去后 $u$ 可以走奇数步走到 $v$ ,图中仍存在奇环. 判断使用树上差分,被不合法边覆盖 $+1$ ,被合法边覆盖 $-1$ . 图可能有重边,自环,判起来比较麻烦.还可能不连通,需要每个联通块分别做上述步骤. 没有判重边/自环的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,m,vis[MAXN];vector&lt;int&gt; G[MAXN];int color[MAXN];struct Edge&#123; int u,v,id,tp; bool operator &lt; (const Edge &amp;rhs) const &#123; return color[u]&lt;color[rhs.u]; &#125;&#125;E[MAXN];struct DSU&#123; int Fa[MAXN]; void init() &#123; for(int i=1;i&lt;=n;++i) Fa[i]=i; &#125; int Find(int x) &#123; if(x==Fa[x]) return x; return Fa[x]=Find(Fa[x]); &#125; bool Union(int x,int y) &#123; x=Find(x),y=Find(y); if(x==y) return false; Fa[x]=y; return true; &#125;&#125;dsu;void dfs_dye(int u,int col)&#123; color[u]=col; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(color[v]) continue; dfs_dye(v,col); &#125;&#125;typedef pair&lt;int,int&gt; pii;map&lt;pii,int&gt; mp;int fa[MAXN],dep[MAXN],siz[MAXN],mxson[MAXN],top[MAXN];void dfs1(int u,int F)&#123; fa[u]=F; siz[u]=1; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==F) continue; dep[v]=dep[u]+1; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int rt[MAXN],L[MAXN],R[MAXN],delta[MAXN];vector&lt;int&gt; ans;void ins(int k)&#123; ans.push_back(E[k].id);&#125;void dfs_sum(int u)&#123; int t=G[u].size(); for(int i=0;i&lt;t;++i) &#123; int v=G[u][i]; if(v==fa[u]) continue; dfs_sum(v); delta[u]+=delta[v]; &#125;&#125;int main()&#123; n=read(),m=read(); dsu.init(); int cnt=0; for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); ++cnt; E[cnt].u=u,E[cnt].v=v; E[cnt].id=i; G[u].push_back(v); G[v].push_back(u); &#125; m=cnt; int col=0; for(int i=1;i&lt;=n;++i) if(!color[i]) &#123; rt[++col]=i; dfs_dye(i,col); &#125; sort(E+1,E+1+m); for(int i=1;i&lt;=n;++i) G[i].clear(); int curcol=1; L[1]=1; for(int i=1;i&lt;=m;++i) &#123; int u=E[i].u,v=E[i].v; if(color[u]!=curcol) &#123; R[curcol]=i-1; ++curcol; L[curcol]=i; &#125; if(dsu.Union(u,v))//ontree &#123; E[i].tp=1; G[u].push_back(v); G[v].push_back(u); &#125; else E[i].tp=0; &#125; R[curcol]=m; for(int i=1;i&lt;=n;++i) if(!siz[i]) dfs1(i,0); for(int i=1;i&lt;=n;++i) if(!top[i]) dfs2(i,i); for(int c=1;c&lt;=curcol;++c) &#123; int tot=0,tmp; for(int i=L[c];i&lt;=R[c];++i) &#123; if(E[i].tp) continue; int u=E[i].u,v=E[i].v,lca=LCA(u,v); int dis=dep[u]+dep[v]-2*dep[lca],val; if(dis&amp;1) val=-1; else &#123; ++tot; val=1; tmp=i; &#125; delta[u]+=val,delta[v]+=val; delta[lca]-=2*val; &#125; if(!tot) &#123; for(int i=L[c];i&lt;=R[c];++i) ins(i); &#125; else &#123; dfs_sum(rt[c]); if(tot==1) ins(tmp); for(int i=L[c];i&lt;=R[c];++i) &#123; if(!E[i].tp) continue; int u=E[i].u,v=E[i].v; if(fa[u]==v) swap(u,v); if(delta[v]==tot) ins(i); &#125; &#125; &#125; sort(ans.begin(),ans.end()); int t=ans.size(); printf("%d\n",t); for(int i=0;i&lt;t;++i) printf("%d ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4417 超级跳马]]></title>
    <url>%2F2019%2F07%2F19%2Fbzoj-4417-%E8%B6%85%E7%BA%A7%E8%B7%B3%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[矩阵快速幂. 最朴素的 $dp$ 是设 $f(i,j)$ 表示从出发点走到 $(i,j)$ 的方案数.有一个比较精妙的状态设计, 直接令 $f(2,1)=f(2,2)=1,f(i,j)=f(i-2,j)+f(i-1,j-1)+f(i-1,j)+f(i-1,j+1)$ . 后面三项表示从前一列转移过来的贡献,而 $f(i-2,j)$ 表示从第 $i-3,i-5\dots$ 列转移过来的贡献前缀和. 构造一个 $2n\times 2n$ 的矩阵加速转移,时间复杂度 $O(n^3\cdot \log m)$ . 需要特判 $n=1$ 以及 $m=1$ 的情况. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=30011;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=101;int n,m,N;struct Matrix&#123; int v[MAXN][MAXN]; Matrix()&#123;memset(v,0,sizeof v);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=0;k&lt;N;++k) for(int i=0;i&lt;N;++i) for(int j=0;j&lt;N;++j) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;Matrix fpow(Matrix a,int b)&#123; Matrix res; for(int i=0;i&lt;2*n;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; n=read(),m=read(); if(m==1) &#123; if(n==1) puts("1"); else puts("0"); return 0; &#125; Matrix trans,st; if(n==1) &#123; st.v[0][0]=1; st.v[1][0]=1; trans.v[0][1]=1; trans.v[1][1]=trans.v[1][2]=1; trans.v[2][1]=1; N=3; st=fpow(trans,m-1)*st; cout&lt;&lt;st.v[0][0]&lt;&lt;endl; return 0; &#125; st.v[0][0]=st.v[1][0]=1; for(int i=0;i&lt;n;++i) &#123; trans.v[i][i]=1; if(i&gt;0) trans.v[i][i-1]=1; if(i&lt;n-1) trans.v[i][i+1]=1; trans.v[i][i+n]=1; &#125; for(int i=n;i&lt;2*n;++i) trans.v[i][i-n]=1; N=2*n; st=fpow(trans,m-2)*st; cout&lt;&lt;st.v[n-1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4416 阶乘字符串]]></title>
    <url>%2F2019%2F07%2F18%2Fbzoj-4416-%E9%98%B6%E4%B9%98%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 设 $f(S)$ 表示从 $1$ 开始,使得集合 $S$ 中元素所有排列均出现的最小长度. 预处理从位置 $i$ 开始,字母 $j$ 首次出现的位置 $nxt(i,j)$ ,可以状压 $dp$ .转移时枚举排列的最后一个元素的位置, $O(2^n\cdot n+len\cdot n)$ . $n\le 26$ ,似乎过不去?然而字符串长度 $\le 450$ ,最小的合法串是 $O(n^2)$ 级别, $n\ge 22$ 时一定无解. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=451,MAXS=(1&lt;&lt;21)+10;int n,nxt[MAXN][26],f[MAXS];char buf[MAXN];void solve()&#123; n=read(); scanf("%s",buf+1); if(n&gt;=22) &#123; puts("NO"); return; &#125; int m=strlen(buf+1); buf[0]=buf[m+1]='#'; for(int j=0;j&lt;n;++j) nxt[m+1][j]=m+1; for(int i=m;i&gt;=0;--i) for(int j=0;j&lt;n;++j) nxt[i][j]=(buf[i+1]-'a'==j)?i+1:nxt[i+1][j]; memset(f,0,sizeof f); int mx=(1&lt;&lt;n)-1; for(int i=1;i&lt;=mx;++i) &#123; for(int j=0;j&lt;n;++j) if((1&lt;&lt;j)&amp;i) f[i]=max(f[i],nxt[f[i^(1&lt;&lt;j)]][j]); &#125; if(f[mx]&lt;=m) puts("YES"); else puts("NO");&#125;int main()&#123; int T=read(); while(T--) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190717]]></title>
    <url>%2F2019%2F07%2F17%2Ftest20190717%2F</url>
    <content type="text"><![CDATA[$noip$ 套题. 看了下题,感觉可能 $T1$ 比较麻烦,后面两个大概都是 $noip$ 难度. 于是打算把后面两个写了再做 $T1$ .( $flag$ ) $b$这个题上次 $nicodafagood$ 讲过,当时就直接口胡出来了,做法比较套路. 对第 $4$ 个条件 $\gcd_{i=1}^k a_i=1$ 容斥一下,设 $f(i)$ 表示所有数均为 $i$ 的倍数,不考虑第 $4$ 个条件的答案. 那么原问题答案就是 $f(1)-f(2)-f(3)-f(5)+f(6)\dots$ 有奇数个质因子就减去,偶数个质因子就加上,若它的某个质因子次数 $\ge 2$ ,那么它的贡献一定在算那个质因子的 $f$ 的时候被算入,就不用算了. 所以这个系数就是 $\mu$ ,记不考虑第 $4$ 个条件, $a_i$ 取值范围为 $[1,x]$ 时答案为 $F(x)$ ,即 $f(\lfloor \frac n x \rfloor)$. 原问题答案为 $\sum_{i=1}^n F(\lfloor \frac n i\rfloor)\cdot \mu(i)$ . 显然可以整除分块, $\mu$ 的前缀和用杜教筛计算. 计算 $F(x)$ 也是经典问题,位置 $i$ 的元素加上 $i-1$ ,就变成了求单调递增序列个数,而取值范围变成 $[1,x+k-1]$ . 随便取 $k$ 个数,从小到大排序后恰好对应了一种方案.于是 $F(x)={x+k-1\choose k}$ . $x$ 可能很大,但 $k\le 10^3$ ,所以每次求组合数的时候暴力 $O(k)$ 求,大概就能过了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int N=870963;int prime[N+10],cnt=0,ism[N+10],mu[N+10],summu[N+10];void init()&#123; ism[1]=1; mu[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; mu[i]=P-1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; 1LL*prime[j]*i&lt;=N;++j) &#123; int num=prime[j]*i; ism[num]=1; if(i%prime[j]==0) break; mu[num]=add(P,-mu[i]); &#125; &#125; for(int i=1;i&lt;=N;++i) summu[i]=add(summu[i-1],mu[i]);&#125;map&lt;int,int&gt; mp;int sum(int x)&#123; if(x&lt;=N) return summu[x]; if(mp.find(x)!=mp.end()) return mp[x]; int res=1; for(int l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); res=add(res,mul(P-sum(x/l),r-l+1)); &#125; return mp[x]=res;&#125;int n,k,invfack;int F(int x)&#123; int res=invfack; for(int i=x;i&lt;=x+k-1;++i) res=mul(res,i); return res;&#125;void solve()&#123; n=read(),k=read(); invfack=1; for(int i=2;i&lt;=k;++i) invfack=mul(invfack,i); invfack=inv(invfack); int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); int tmp=add(sum(r),P-sum(l-1)); tmp=mul(tmp,F(n/l)); ans=add(ans,tmp); &#125; printf("%d\n",ans);&#125;int main()&#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); init(); int T=read(); while(T--) solve(); return 0;&#125; $c$显然是点分治. 但点的贡献写起来比边的贡献麻烦,因为根节点的贡献只能贡献一次.所以记录时带上根节点的贡献,查询时不带. 分两种情况讨论一下,一种是最大值在当前点到根节点路径上,另一种是在根节点到另外一个点的路径上. 式子列一列,发现就相当于二维平面内有若干点,要统计 $x=x_0$ ,$y\le y_0$ 或 $y&gt;y_0$ 的点的数目. 按 $x$ 为第一关键字, $y$ 为第二关键字排序. 这个东西还要离散化,我的做法写起来特别麻烦,细节特别多. 一直写,一直改,终于改对的时候就没时间了. 于是 $T1$ 爆零. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;int P,n;inline int add(int a,int b)&#123; return (a + b) % P;&#125;const int MAXN=1e5+10;struct SegTree&#123; int idx,Rt; struct node &#123; int ls,rs; int sum; node()&#123;ls=rs=sum=0;&#125; &#125;Tree[MAXN*30];#define root Tree[o] SegTree()&#123;idx=Rt=0;&#125; int query(int o,ll l,ll r,ll L,ll R) &#123; if(!o || L&gt;R || R&lt;=0) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125; void ins(int &amp;o,ll l,ll r,ll pos,int c) &#123; if(pos&gt;r || pos&lt;l) return; if(!o) o=++idx; root.sum+=c; if(l==r) return; ll mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,l,mid,pos,c); else ins(root.rs,mid+1,r,pos,c); &#125;&#125;T1,T2,T3,T4;typedef pair&lt;int,int&gt; pii;#define mp make_pairint head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],ecnt=0;int val[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;ll ans=0;int rt,mi,totsiz,siz[MAXN],vis[MAXN];void Findrt(int u,int fa)&#123; siz[u]=1; int mxsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; Findrt(v,u); siz[u]+=siz[v]; mxsiz=max(mxsiz,siz[v]); &#125; mxsiz=max(mxsiz,totsiz-siz[u]); if(mxsiz&lt;mi) mi=mxsiz,rt=u;&#125;pii stk1[MAXN],stk2[MAXN];int tp1=0,tp2=0;pii q1[MAXN],q2[MAXN];pii q3[MAXN],q4[MAXN];int t=0,t1,t2;inline int id1l(int sum,int mx)&#123; return lower_bound(q1+1,q1+t1+1,mp(sum,mx))-q1;&#125;inline int id1r(int sum,int mx)&#123; return upper_bound(q1+1,q1+t1+1,mp(sum,mx))-q1-1;&#125;inline int id2l(int sum,int mx)&#123; return lower_bound(q2+1,q2+t2+1,mp(sum,mx))-q2;&#125;inline int id2r(int sum,int mx)&#123; return upper_bound(q2+1,q2+t2+1,mp(sum,mx))-q2-1;&#125;int calc1(int sum,int mx)&#123; ll L=id1l(add(P,mx-sum),0); ll R=id1r(add(P,mx-sum),mx); int k=T1.query(1,1,n,L,R); return k; &#125;int calc2(int sum,int mx)&#123; ll L=id2l(sum,mx-1); ll R=id2r(sum,1000000000); int k=T2.query(1,1,n,L,R); return k;&#125;void dfs_pre(int u,int fa,int sum,int mx)&#123; sum=add(sum,val[u]); mx=max(mx,val[u]); q1[++t]=mp(sum,mx); q2[t]=mp(add(P,mx-sum),mx); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; dfs_pre(v,u,sum,mx); &#125;&#125;void dfs(int u,int fa,int SS,int MM,int sum,int mx)&#123; sum=add(sum,val[u]); mx=max(mx,val[u]); SS=add(SS,val[u]); MM=max(MM,val[u]); ans+=calc1(sum,mx); ans+=calc2(sum,mx); stk2[++tp2]=mp(SS,MM); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; dfs(v,u,SS,MM,sum,mx); &#125;&#125;void solve(int u)&#123; t=0; q1[++t]=mp(val[u]%P,val[u]); q2[t]=mp(0,val[u]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; dfs_pre(v,0,val[u]%P,val[u]); &#125; sort(q1+1,q1+1+t); sort(q2+1,q2+1+t); t1=unique(q1+1,q1+1+t)-q1-1; t2=unique(q2+1,q2+1+t)-q2-1; stk1[tp1=1]=mp(val[u]%P,val[u]); T1.ins(T1.Rt,1,n,id1l(val[u]%P,val[u]),1); T2.ins(T2.Rt,1,n,id2l(0,val[u]),1); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; tp2=0; dfs(v,0,val[u],val[u],0,0); for(int i=1;i&lt;=tp2;++i) &#123; T1.ins(T1.Rt,1,n,id1l(stk2[i].first,stk2[i].second),1); T2.ins(T2.Rt,1,n,id2l(add(P,stk2[i].second-stk2[i].first),stk2[i].second),1); stk1[++tp1]=stk2[i]; &#125; &#125; for(int i=1;i&lt;=tp1;++i) &#123; T1.ins(T1.Rt,1,n,id1l(stk1[i].first,stk1[i].second),-1); T2.ins(T2.Rt,1,n,id2l(add(P,stk1[i].second-stk1[i].first),stk1[i].second),-1); &#125;&#125;void Divide(int u)&#123; vis[u]=1; solve(u); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf; totsiz=siz[v]; Findrt(v,0); Divide(rt); &#125;&#125;int main()&#123; freopen("c.in","r",stdin); freopen("c.out","w",stdout); n=read(),P=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; for(int i=1;i&lt;=n;++i) val[i]=read(); mi=inf; totsiz=n; Findrt(1,0); Divide(rt); cout&lt;&lt;ans+n&lt;&lt;endl; return 0;&#125; $a$暴力 + 最优化剪枝 可过.]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>点分治</tag>
        <tag>杜教筛</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4414 数量积]]></title>
    <url>%2F2019%2F07%2F17%2Fbzoj-4414-%E6%95%B0%E9%87%8F%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[结论题. 结论:对于类似斐波那契数列的,满足 $a_i=a_{i-1}+a_{i-2}(i\ge 2),a_1=a_2$ 的数列 $a$ ,有以下等式成立: $$a_1\cdot a_{n+m+1}=a_n\cdot a_m + a_{n+1} \cdot a_{m+1}$$ 等式右边那坨就是我们要求的数量积.即 $v_i\cdot v_j=C\cdot a_{2i+2j+1}$ . 把可以作为数量积的 $O(n)$ 个数全部求出来即可. 证明过程 $sto\ xmk$ . 考虑矩阵乘法. 比较一下最左端的向量和最右端的运算结果即得结论中的等式. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=6e5+10;int n;int res[MAXN],tot=0;int main()&#123; int f1=read(); P=read(),n=read(); int a=0,b=f1%P; for(int i=2;i&lt;=4*n-1;++i) &#123; int c=add(a,b); if((i&amp;1) &amp;&amp; (i&gt;=7)) res[++tot]=mul(c,f1); a=b; b=c; &#125; sort(res+1,res+1+tot); tot=unique(res+1,res+1+tot)-res-1; cout&lt;&lt;tot%P&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 4783 矩阵求逆]]></title>
    <url>%2F2019%2F07%2F17%2FLuogu-4783-%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[矩阵求逆板子. 对一个矩阵,定义它的三种初等行变换: 交换某两行. 将某一行的元素全部 $\times k (k\not= 0)$ . 将某一行的元素的 $k$ 倍加到另一行对应位置上去. 每个初等行变换都对应了一个初等矩阵,即,对矩阵 $A$ 做一次初等行变换,等价于用对应的初等矩阵 $P_0$ 左乘 $A$ ,即 $A=P_0A$ . 若矩阵 $A$ 有逆,一定可以通过高斯消元,做有限次初等行变换得到单位矩阵 $I$ .即, $P_kP_{k-1}\dots P_0 A=I$ .根据矩阵乘法的结合律,把前面所有 $P_i$ 看做一个矩阵 $P$ ,即 $PA=I$ ,根据定义, $P$ 就是我们要求的 $A^{-1}$ . 而 $PI=P$ ,所以我们再维护一个矩阵 $B$ ,初始为 $I$ ,高斯消元时同步与 $A$ 做相同的初等行变换,当 $A$ 变为 $I$ 时, 得到的 $B$ 就是我们要求的 $P$ ,即 $A^{-1}$ . 若在高斯消元时发现 $A$ 无法消成 $I$ ,则说明 $A$ 不可逆. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=400+10;int n,A[MAXN][MAXN],B[MAXN][MAXN];void addrow(int a[],int b[],int t)&#123; for(int i=1;i&lt;=n;++i) a[i]=add(a[i],mul(b[i],t));&#125;bool inverse()&#123; for(int i=1;i&lt;=n;++i) B[i][i]=1; for(int i=1;i&lt;=n;++i) &#123; if(!A[i][i]) &#123; for(int j=i+1;j&lt;=n;++j) if(A[j][i]) &#123; swap(A[i],A[j]); swap(B[i],B[j]); break; &#125; &#125; if(!A[i][i]) return false; int inv=fpow(A[i][i],P-2); for(int j=i+1;j&lt;=n;++j) &#123; int x=A[j][i]; addrow(A[j],A[i],P-mul(x,inv)); addrow(B[j],B[i],P-mul(x,inv)); &#125; &#125; for(int i=n;i&gt;=1;--i) &#123; int inv=fpow(A[i][i],P-2); for(int j=1;j&lt;i;++j) &#123; int x=A[j][i]; addrow(A[j],A[i],P-mul(x,inv)); addrow(B[j],B[i],P-mul(x,inv)); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(!A[i][i]) return false; int inv=fpow(A[i][i],P-2); for(int j=1;j&lt;=n;++j) B[i][j]=mul(B[i][j],inv); &#125; return true;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) A[i][j]=read(); if(inverse()) &#123; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%d ",B[i][j]); puts(""); &#125; &#125; else puts("No Solution"); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190715]]></title>
    <url>%2F2019%2F07%2F15%2Ftest20190715%2F</url>
    <content type="text"><![CDATA[神仙题,又被虐了. $graph$ $60$ 分做法:将所有方程列出来,因为保证有唯一解,所以不用管方程个数,直接高斯消元.时间复杂度 $O(m^3)$ . 满分做法:比较神仙,注意到条件 $2$ 的形式是电学中基尔霍夫方程组,将 $A$ 看做 $\epsilon$ , $B$ 看做 $R$ , $C$ 看做 $I$ . 为每个节点定义一个电压 $\phi(u)$ ,规定 $\phi (1)=0$ , $\phi(u)=\sum_{i=0}^{k-1} I(v_i,v_{i+1})\cdot R(v_i,v_{i+1})-\epsilon (v_i,v_{i+1})$ ,其中 $&lt;v_0=1,v_1,\dots,v_{k-1},v_k=u&gt;$ 是原图中一条路径,这样定义也满足了条件 $3$ . 容易验证无论选择怎样的路径,每个点的电压值都是不变的.利用条件 $1$ 列出 $n-1$ 个方程,高斯消元解出 $2\sim n$ 的电压,再根据 $I(u,v)=\frac {\phi(u)-\phi(v)+\epsilon(u,v)} {R(u,v)}$ 求出电流.时间复杂度 $O(n^3)$ . 考试情况:只写了 $60$ 分的做法. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define rep(i,a,b) for(int i=(a);i&lt;=(b);i++)#define repk(i,a,b) rep(i,a,(b)-1)#define rrep(i,a,b) for(int i=(b);i&gt;=(a);i--)#define rrepk(i,a,b) rrep(i,a,(b)-1)#define fe(e,x) for(edge *e = (x)-&gt;first;e;e = e-&gt;next)#define foreach(tank_type,iterator_name,set_name) \ for(tank_type::iterator iterator_name = (set_name).begin();iterator_name != (set_name).end();iterator_name++)#define comp_def(cmp_name,type) bool cmp_name(type l,type r)#define ifn(x) if(!(x))#define vind(p_point) (p_point-points)#define eind(p_edge) (p_edge-edges)#define eopp(p_edge) (edges+(eind(p_edge)^1))#define mp(x,y) make_pair((x),(y))typedef long long ll;const int inf = 0x3fffffff,upinf = 0x7fffffff,geps = 10;const double eps = 1e-12,dinf = 1e20;ll modnum;struct modll&#123; ll x; modll():x(0)&#123;&#125; modll(ll _x)&#123; _x &lt; 0 ? x = _x % modnum + modnum : (_x &gt;= modnum ? x = _x % modnum : x = _x); &#125; inline static ll pmod(ll _x)&#123; return _x &gt;= modnum ? _x - modnum : _x; &#125; inline static ll plus(ll x,ll y)&#123; return pmod(x + y); &#125; inline static ll minus(ll x,ll y)&#123; return pmod(x + modnum - y); &#125; inline static ll multi(ll x,ll y)&#123; ll s = 0; for(;y;y&gt;&gt;=1)&#123; if(y&amp;1) s = plus(s,x); x = plus(x,x); &#125;return s; &#125; inline static ll inv(ll a)&#123; ll b = modnum,c = a%b,q = a/b,k1 = 1,k2 = 0,k3 = pmod(minus(k1,multi(q,k2))); while(c^1) a = b,b = c,c = a%b,q = a/b,k1 = k2,k2 = k3,k3 = pmod(minus(k1,multi(q,k2))); return k3; &#125; inline static ll llpow(ll b,ll p)&#123; ll s = 1; for(;p;p&gt;&gt;=1)&#123; if(p&amp;1) s = multi(s,b); b = multi(b,b); &#125;return s; &#125;&#125;;bool operator==(modll l,modll r)&#123;return l.x == r.x;&#125;bool operator!=(modll l,modll r)&#123;return l.x != r.x;&#125;modll operator+(modll l,modll r)&#123;return modll(modll::plus(l.x,r.x));&#125;modll operator-(modll l,modll r)&#123;return modll(modll::minus(l.x,r.x));&#125;modll operator*(modll l,modll r)&#123;return modll(modll::multi(l.x,r.x));&#125;modll operator/(modll l,modll r)&#123;return modll(modll::multi(l.x,modll::inv(r.x)));&#125;modll operator^(modll l,ll r)&#123; return r &lt; 0 ? modll(modll::llpow(modll::inv(l.x),-r)) : modll(modll::llpow(l.x,r));&#125;modll operator-(modll l)&#123;return modll(-l.x);&#125;modll operator+=(modll&amp; l,modll r)&#123;return modll(l.x = modll::plus(l.x,r.x));&#125;modll operator-=(modll&amp; l,modll r)&#123;return modll(l.x = modll::minus(l.x,r.x));&#125;modll operator*=(modll&amp; l,modll r)&#123;return modll(l.x = modll::multi(l.x,r.x));&#125;modll operator/=(modll&amp; l,modll r)&#123;return modll(l.x = modll::multi(l.x,modll::inv(r.x)));&#125;modll operator^=(modll&amp; l,ll r)&#123; return modll( l.x = r &lt; 0 ? modll::llpow(modll::inv(l.x),-r) : modll::llpow(l.x,r) );&#125;const int maxn = 100,maxm = 2000;struct equation&#123; modll dat[maxn][maxn + geps]; int n; void clear(int _n)&#123; n = _n; repk(i,0,n) repk(j,0,n+1) dat[i][j].x = 0; &#125; modll&amp; operator()(int i,int j)&#123;return dat[i][j];&#125; void rowswap(int r1,int r2)&#123; repk(j,0,n+1) swap(dat[r1][j],dat[r2][j]); &#125; void elimination(int r1,int r2)&#123;//eliminate r2 from r1 modll g = dat[r2][r1]/dat[r1][r1]; repk(j,0,n+1) dat[r2][j] -= dat[r1][j] * g; &#125; vector&lt;modll&gt; getans()&#123; vector&lt;modll&gt; ans; repk(i,0,n)&#123; if(dat[i][i] == 0)&#123; repk(j,i+1,n) if(dat[i][j] != 0) &#123;rowswap(i,j);break;&#125; if(dat[i][i] == 0) return ans; &#125;repk(j,0,n) if(i != j) elimination(i,j); &#125;repk(i,0,n) ans.push_back(dat[i][n] / dat[i][i]); return ans; &#125;&#125;;struct Graph&#123; equation Eq;pair&lt;int,int&gt; edge[maxm]; modll As[maxm],Bs[maxm]; int V,E; void create(int _V)&#123;Eq.clear(V = _V);E = 0;&#125; void addedge(int u,int v,modll A,modll B)&#123; Eq(v,v) += 1/B; Eq(v,u) -= 1/B; Eq(v,V) -= A/B; Eq(u,v) -= 1/B; Eq(u,u) += 1/B; Eq(u,V) += A/B; As[E] = A,Bs[E] = B; edge[E++] = make_pair(u,v); &#125; vector&lt;ll&gt; solve_graph()&#123; repk(j,0,V+1) Eq(V-1,j) = 0; Eq(V-1,V-1) = 1; vector&lt;modll&gt; Por = Eq.getans(); vector&lt;ll&gt; ans; if(Por.size() == 0) return ans; repk(i,0,E)&#123; int u = edge[i].first,v = edge[i].second; ans.push_back(((Por[v] - Por[u] + As[i]) / Bs[i]).x); &#125;return ans; &#125;&#125;G;int n,m;void Init()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;modnum);G.create(n); int x,y;ll A,B; repk(i,0,m)&#123; scanf("%d%d%lld%lld",&amp;x,&amp;y,&amp;A,&amp;B); G.addedge(x-1,y-1,A,B); &#125;&#125;void solve()&#123; vector&lt;ll&gt; ans = G.solve_graph(); if(ans.size() == 0) printf("-1\n"); else foreach(vector&lt;ll&gt;,it,ans) printf("%lld\n",*it);&#125;int main()&#123; freopen("graph.in","r",stdin); freopen("graph.out","w",stdout); Init(); solve(); return 0;&#125; $grid$ $40$ 分做法:设 $f(s,i,j,d)$ 表示两人各自都走了 $s$ 步,以 $(1,1)$ 作为左下角,第一个人向右走了 $i$ 步,第二个人向右走了 $j$ 步,一共已经经过了 $d$ 个特殊点时的方案数.两人交换算一种方案,限制 $j\le i$ , $O(n^4)$ 大力 $dp$ . 满分做法:先考虑一条路径的方案数,将特殊点按照 $x+y$ 排序,那么一条路径上出现的特殊点的编号递增. 设 $f(i,j)$ 表示走到了第 $i$ 个特殊点,此前经过了 $j$ 个特殊点的方案数, $g(i,j)$ 表示从第 $i$ 个特殊点走到第 $j$ 个特殊点而不经过其他特殊点的方案数.枚举上一个走过的特殊点是 $k$ , $$f(i,j)=\sum_{k=1}^{i-1} f(k,j-1)\cdot g(k,i)$$ 把起点看做 $0$ 号点,终点看做 $C+1$ 号点,方案数为: $$ans=\sum_{i=0}^D f(C+1,i)$$ 考虑如何求 $g(i,j)$ .若不考虑特殊点,从 $(x_0,y_0)$ 走到 $(x_1,y_1)$ 的方案数显然是 $x_1-x_0+y_1-y_0\choose x_1-x_0$ . 记 $h(i,j)$ 表示从特殊点 $i$ 到特殊点 $j$ 的方案数(不考虑限制),枚举不合法路径上的第一个点 $k$ , $$g(i,j)=h(i,j)-\sum_{k=i+1}^{j-1} g(i,k)\cdot h(k,j)$$ 于是我们用 $O(C^3)$ 的时间复杂度解决了一条路径经过特殊点个数不超过 $D$ 的方案数. 到目前为止的部分和 这个题 做法是差不多的. 若要求两条不相交路径的方案数,将两条路径看做 $(1,2)\to (n-1,m)$ 与 $(2,1) \to (n,m-1)$ . 记它们为 $s_1\to t_1,s_2\to t_2$ .容斥一下,用总方案数减去路径相交的方案数. 若两条路径相交于点 $p$ ,可以将它们的后半段交换,得到 $s_1\to p\to t_2$ 与 $s_2\to p \to t_1$ 两条路径. 于是可以断言,所有的 $s_1\to t_2$ 与所有的 $s_2\to t_1$ 一定是一一对应的,且对应的两条路径一定相交. 那么最终答案为 $s_1\to t_1,s_2\to t_2$ 的方案数乘积减去 $s_1\to t_2$ 与 $s_2\to t_1$ 的方案数之和,不需要不相交,直接套用前部分算一条路径的方案数即可. 模数不为质数时,无法直接预处理阶乘逆元,需要分解质因子, $mod=\prod p_i^k$ ,处理每个质因子的时候,位置 $p_i^j$ 特判,其余位置直接求逆元,最后再用 $CRT$ 合并答案. 考试情况:只写了 $40$ 分的部分. $std$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long long#define mkp make_pair#define fir first#define sec secondusing namespace std;const int MaxN = 200010, Log = 10;int fac[MaxN], facpow[MaxN][Log], facinv[MaxN];int factor[Log], ftot;int mod;void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x;&#125;int get_inv(int a) &#123; int x, y; exgcd(a, mod, x, y); return ((x % mod) + mod) % mod;&#125;int power(ll x, int l) &#123; ll ret = 1; for (; l; l &gt;&gt;= 1, x = x * x % mod) if (l &amp; 1) ret = ret * x % mod; return ret;&#125;void init(int n) &#123; ftot = 0; int x = mod; for (int i = 2; i * i &lt;= mod; ++i) if (x % i == 0) &#123; factor[ftot++] = i; while (x % i == 0) x /= i; &#125; if (x != 1) factor[ftot++] = x; fac[0] = facinv[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int x = i; memcpy(facpow[i], facpow[i - 1], sizeof facpow[i]); for (int j = 0; j &lt; ftot; ++j) while (x % factor[j] == 0) &#123; x /= factor[j]; ++facpow[i][j]; &#125; fac[i] = 1ll * fac[i - 1] * x % mod; facinv[i] = get_inv(fac[i]); &#125;&#125;int comb(int n, int m) &#123; int ret = 1ll * fac[n] * facinv[m] % mod * facinv[n - m] % mod; for (int j = 0; j &lt; ftot; ++j) ret = 1ll * ret * power(factor[j], facpow[n][j] - facpow[m][j] - facpow[n - m][j]) % mod; return ret;&#125;const int MaxC = 210;int n, m, c, d;int f[MaxC][MaxC], g[MaxC][MaxC], ways[MaxC][MaxC];bool mark[MaxC][MaxC];int a[2][2][MaxC], ans[MaxC];pair &lt;int, int&gt; car[MaxN];inline bool tless(pair &lt;int, int&gt; a, pair &lt;int, int&gt; b) &#123; return (a.fir &lt;= b.fir) &amp;&amp; (a.sec &lt;= b.sec);&#125;void init_car() &#123; memset(ways, 0, sizeof(ways)); memset(f, 0, sizeof(f)); memset(mark, 0, sizeof(mark)); for (int i = 1; i &lt;= c; ++i) for (int j = i; j &lt;= c; ++j) if (tless(car[i], car[j])) &#123; ways[i][j] = comb(car[j].fir - car[i].fir + car[j].sec - car[i].sec, car[j].fir - car[i].fir); mark[i][j] = 1; &#125; for (int i = 1; i &lt;= c; ++i) for (int j = 1; j &lt;= c; ++j) if (mark[i][j]) &#123; f[i][j] = ways[i][j]; for (int k = i + 1; k &lt; j; ++k) if (mark[i][k] &amp;&amp; mark[k][j] &amp;&amp; f[i][k]) &#123; f[i][j] = (f[i][j] - 1ll * f[i][k] * ways[k][j]) % mod; &#125; &#125;&#125;void calc(int a[], int sx, int sy, int tx, int ty) &#123; fill(a, a + c + 1, 0); car[0] = mkp(sx, sy); car[c + 1] = mkp(tx, ty); if (!tless(car[0], car[c + 1])) return; //init f[0][], f[][c + 1] for (int i = 0; i &lt;= c + 1; ++i) if (tless(car[0], car[i])) &#123; f[0][i] = ways[0][i] = comb(car[i].fir - sx + car[i].sec - sy, car[i].fir - sx); mark[0][i] = 1; for (int j = 1; j &lt; i; ++j) if (mark[0][j] &amp;&amp; mark[j][i] &amp;&amp; f[0][j]) f[0][i] = (f[0][i] - 1ll * f[0][j] * ways[j][i]) % mod; &#125; else &#123; f[0][i] = ways[0][i] = mark[0][i] = 0; &#125; for (int i = c + 1; i &gt;= 0; --i) if (tless(car[i], car[c + 1])) &#123; f[i][c + 1] = ways[i][c + 1] = comb(tx - car[i].fir + ty - car[i].sec, tx - car[i].fir); mark[i][c + 1] = 1; for (int j = i + 1; j &lt;= c; ++j) if (mark[i][j] &amp;&amp; mark[j][c + 1] &amp;&amp; f[i][j]) &#123; f[i][c + 1] = (f[i][c + 1] - 1ll * f[i][j] * ways[j][c + 1]) % mod; &#125; &#125; else &#123; f[i][c + 1] = ways[i][c + 1] = mark[i][c + 1] = 0; &#125; memset(g, 0, sizeof(g)); g[0][0] = 1; for (int i = 1; i &lt;= c + 1; ++i) for (int j = 1; j &lt;= d + 1; ++j) for (int k = 0; k &lt; i; ++k) &#123; g[i][j] = (g[i][j] + 1ll * g[k][j - 1] * f[k][i]) % mod; &#125; for (int i = 0; i &lt;= d + 1; ++i) a[i] = g[c + 1][i + 1];// for (int i = 0; i &lt;= d + 1; ++i) printf("%d ", a[i]); puts(";");&#125;void Main() &#123; scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;c, &amp;d, &amp;mod); init(n + m); for (int i = 1; i &lt;= c; ++i) scanf("%d%d", &amp;car[i].fir, &amp;car[i].sec); sort(car + 1, car + c + 1); init_car(); calc(a[0][0], 1, 2, n - 1, m); calc(a[0][1], 1, 2, n, m - 1); calc(a[1][0], 2, 1, n - 1, m); calc(a[1][1], 2, 1, n, m - 1); int ret = 0; memset(ans, 0, sizeof(ans)); for (int i = 0; i &lt;= d; ++i) &#123; for (int j = 0; j &lt;= i; ++j) ans[i] = (ans[i] + 1ll * a[0][0][j] * a[1][1][i - j] - 1ll * a[0][1][j] * a[1][0][i - j]) % mod; ret += (ans[i] &lt; 0 ? ans[i] += mod : ans[i]); ret &gt;= mod ? ret -= mod : ret; &#125; cout &lt;&lt; ret &lt;&lt; endl;&#125;int main()&#123; freopen("grid.in", "r", stdin); freopen("grid.out", "w", stdout); int T; scanf("%d", &amp;T); while (T--) Main(); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>容斥原理</tag>
        <tag>高斯消元</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190714]]></title>
    <url>%2F2019%2F07%2F15%2Ftest20190714%2F</url>
    <content type="text"><![CDATA[又被虐了. $Fable$ 每做一次冒泡,对于一个数 $a_i$ ,若 $i$ 之前的位置有比它大的数,那么其中一个一定会跳到它的后面. 则它的位置向前移了一位,比它大的数少了一个. 初始时,若前面比它大的数的个数 $\ge k$ ,则说明每次都能往前移,最后的位置就是初始位置 $-k$ .对于剩下的数,它们最后一定会从小到大把剩余的位置补满. 离散化 + 树状数组处理. 考试情况:大部分时间都在想/写/调这个题.最后 $A$ 了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,k;typedef pair&lt;int,int&gt; pii;pii a[MAXN];int ans[MAXN],tot[MAXN],rk[MAXN];int bit[MAXN];#define lowbit(x) x&amp;(-x)void add(int x,int c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c;&#125;int sum(int x)&#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s;&#125;int main()&#123; freopen("fable.in","r",stdin); freopen("fable.out","w",stdout); n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i].second=i,a[i].first=read(); sort(a+1,a+1+n); rk[a[1].second]=1; for(int i=2;i&lt;=n;++i) &#123; if(a[i].first==a[i-1].first) rk[a[i].second]=rk[a[i-1].second]; else rk[a[i].second]=i; &#125; for(int i=1;i&lt;=n;++i) &#123; add(rk[i],1); tot[i]=sum(n)-sum(rk[i]); if(tot[i]&gt;k) ans[i-k]=a[rk[i]].first; &#125; int pos=1; for(int i=1;i&lt;=n;++i) &#123; if(tot[a[i].second]&lt;=k) &#123; while(pos&lt;=n &amp;&amp; ans[pos]) ++pos; ans[pos]=a[i].first; &#125; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125; $Fiend$ 看到 排列,逆序对 ,考虑构造矩阵,观察其行列式. 构造一个矩阵 $A_{i,j}=[L_i\le j\le R_i]$ ,考虑它的行列式定义: $$|A|=\sum_{p\in S_n} sgn(p) \prod_{i=1}^k A_{i,p_i}$$ 对于一种排列 $p$ ,若存在 $L_i\leq p_i\le R_i$ 不成立,则 $A_{i,p_i}=0$ ,对于求和的贡献就是 $0$ . 否则,若逆序对数为偶数,贡献为 $1$ ,逆序对数为奇数,贡献为 $-1$ ,于是只需要判断 $|A|$ 的符号. 直接高斯消元是 $O(n^3)$ 的,可以获得 $70$ 分.由于构造的这个矩阵比较特殊,尝试手动消元. 每一行的 $1$ 都是一段区间,尝试在消元时保持每一行的 $1$ 仍然是一段区间.从小到大枚举 $x$ ,找出所有 $L_i=x$ 的行,找出其中 $R_k$ 最小的那一行 $k$ ,用第 $k$ 行去消其他的 $L_i=x$ 的行. 这些行被消过之后,其中的 $1$ 仍是一段区间,只是左端点变为了 $R_{k+1}$ .维护 $n$ 个集合, $i$ 号集合内存储左端点 $=i$ 的元素,每个元素记录它的行号,右端点. 从小到大枚举 $x$ ,将 $x$ 号集合的元素,除了 $R_k$ ,都放入 $R_{k+1}$ 号集合.用线段树合并实现. 考试情况:构造矩阵的时候不知道怎么就错了,于是感觉不可做,此题爆零. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairstruct node&#123; int val,pos,h; int ls,rs; node(int Val=0,int Pos=0) &#123; ls=rs=h=0; val=Val; pos=Pos; &#125;&#125;Tree[MAXN&lt;&lt;2];int merge(int a,int b)&#123; if(!a || !b) return a+b; if(Tree[a].val&gt;Tree[b].val) swap(a,b); Tree[a].rs=merge(Tree[a].rs,b); if(Tree[Tree[a].ls].h&lt;Tree[Tree[a].rs].h) swap(Tree[a].ls,Tree[a].rs); Tree[a].h=Tree[Tree[a].rs].h+1; return a;&#125;int n,rt[MAXN],id[MAXN],tmp[MAXN];int Calc_Det()&#123; int prod=1; for(int i=1;i&lt;=n;++i) &#123; if(!rt[i]) return 0; node cur=Tree[rt[i]]; rt[i]=merge(Tree[rt[i]].ls,Tree[rt[i]].rs); if(rt[i] &amp;&amp; Tree[rt[i]].val==cur.val) return 0; if(id[cur.pos]!=i) &#123; prod*=-1; int x=tmp[i]; swap(tmp[id[cur.pos]],tmp[i]); swap(id[cur.pos],id[x]); &#125; if(cur.val&lt;n) rt[cur.val+1]=merge(rt[cur.val+1],rt[i]); &#125; return prod;&#125;void solve()&#123; n=read(); for(int i=1;i&lt;=n;++i) rt[i]=0; for(int i=1;i&lt;=n;++i) &#123; int L=read(),R=read(); Tree[i]=node(R,i); id[i]=tmp[i]=i; rt[L]=merge(rt[L],i); &#125; int ans=Calc_Det(); if(ans&lt;0) puts("F"); else if(ans==0) puts("D"); else puts("Y");&#125;int main()&#123; freopen("fiend.in","r",stdin); freopen("fiend.out","w",stdout); int T=read(); while(T--) solve(); return 0;&#125; $Flair$ 分成两部分做,记恰好选 $i$ 道菜的概率为 $A_i$ ,浪费掉的钱为 $B_i$ ,答案为 $\sum_{i=0}^n A_i\cdot B_i$. 答案扩大 $100^n$ 倍,所以 $A_i=p^i\cdot (100-p)^{n-i}\cdot {n\choose i}$ .考虑如何计算 $B_i$ . 若将 $c_i$ 从小到大排序,在模 $c_1$ 意义下对金额跑最短路,显然长度不会超过 $c_1$ ,而每一步的权值不超过 $c_2$ ,所以浪费金额在 $c_1\cdot c_2$ 内, $B_i$ 就会以 $c_1$ 为周期循环. 记 $len=c_1\cdot c_2,per=c_1$ .需要计算出 $A_0,A_1,\dots,A_{len-1}$ 与 $D_j=\sum_{i\ge len,i\ mod\ per=j} A_i$ . 于是答案就为 $\sum_{i=0}^{len-1} A_i\cdot B_i+\sum_{j=0}^{per-1} \lceil \frac {n-len+1-j} {per} \rceil \cdot B_j\cdot D_j$ . $D$ 就是多项式 $(px+1-p)^n$ 长度为 $c_1$ 的循环卷积结果再减去 $&lt;len$ 的部分. 使用 $NTT$ 优化这个卷积.但 $P=10^9+7$ ,所以还要用 $MTT$ .(好毒啊) 考试情况:推出了 $B_i$ 的循环性质,但没有联想到循环卷积,于是只得了 $10$ 分暴力分.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>构造</tag>
        <tag>多项式</tag>
        <tag>树状数组</tag>
        <tag>线段树合并</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4407 于神之怒加强版]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4407-%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 假定 $n\leq m$ ,推式子. 把后面那个 $\sum_{d|x} \mu(\frac x d) \cdot d^k$ 看做关于 $x$ 的函数 $f(x)$ ,它显然是个积性函数,因为可以看成 $\mu(x)$ 与 $x^k$ 的卷积. 线性筛预处理出 $f(x)$ 的前缀和,然后整除分块计算即可. 时间复杂度 $O(n+T\cdot \sqrt n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a+b&gt;=P?a+b-P:a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=5e6+10;int ism[MAXN],prime[MAXN],cnt=0,mu[MAXN],pw[MAXN];int k,sum[MAXN],f[MAXN];void init(int n)&#123; f[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; pw[i]=fpow(i,k); f[i]=add(pw[i],P-1); &#125; for(int j=1;j&lt;=cnt &amp;&amp; 1LL*i*prime[j]&lt;=n;++j) &#123; int x=i*prime[j]; ism[x]=1; pw[x]=mul(pw[i],pw[prime[j]]); if(i%prime[j]==0) &#123; f[x]=mul(f[i],pw[prime[j]]); break; &#125; f[x]=mul(f[i],f[prime[j]]); &#125; &#125; for(int i=1;i&lt;=n;++i) sum[i]=add(sum[i-1],f[i]);&#125;int n,m;int main()&#123; int T=read(); k=read(); init(5000000); while(T--) &#123; n=read(),m=read(); if(n&gt;m) swap(n,m); int ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); int tmp=mul(n/l,m/l); tmp=mul(tmp,add(sum[r],P-sum[l-1])); ans=add(ans,tmp); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4403 序列统计]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[组合计数 + $Lucas$ 定理. 把位置 $i$ 上的数加上它的下标,就变成求单调上升序列的数目了. 即,对于长度为 $i$ 的序列,权值范围变为 $[l+1,r+i]$ .方案数显然为 $r-l+i \choose i$ ,即在权值范围内任选 $i$ 个不同的数,排序后就是一个单调上升序列. 答案为 $\sum_{i=1}^n {r-l+i\choose i}={r-l+1+n\choose n}-1$ . $-1$ 是减去长度为 $0$ 的情况. $P=10^6+3$ ,且是个质数,用 $Lucas$ 定理计算组合数即可.时间复杂度 $O(P+T\cdot \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e6+3;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int fac[P+10],invfac[P+10];void init()&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;P;++i) fac[i]=mul(fac[i-1],i); invfac[P-1]=fpow(fac[P-1],P-2); for(int i=P-2;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int n,int m)&#123; if(n&lt;0 || m&lt;0 || n&gt;m) return 0; if(n&lt;P &amp;&amp; m&lt;P) return mul(fac[m],mul(invfac[n],invfac[m-n])); return mul(C(n/P,m/P),C(n%P,m%P));&#125;int main()&#123; init(); int T=read(); while(T--) &#123; int n=read(),L=read(),R=read(); int m=R-L+1; printf("%d\n",add(C(n,m+n),P-1)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4402 Claris的剑]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4402-Claris%E7%9A%84%E5%89%91%2F</url>
    <content type="text"><![CDATA[组合计数. 求本质不同的序列数目,考虑以最小字典序表示序列,进行计数. 设序列中出现的最大值为 $m$ ,那么序列用最小字典序表示后只有下面两种情况: $1,(2,1,2,1\dots),2,(3,2,3,2\dots),3,\dots m$ . 或者 $1,(2,1,2,1\dots),2,(3,2,3,2\dots),3,\dots m,m-1$ . 若序列长度为 $n$ ,第一种情况可以看做 $\lfloor \frac {n-m} 2 \rfloor$ 个相同的球放入 $m-1$ 个盒子的方案数.盒子可以为空. 第二种情况可以看做$\lfloor \frac {n-m-1} 2 \rfloor$ 个相同的球放入 $m-1$ 个盒子的方案数.盒子可以为空. 枚举 $m$ ,由于长度是 $\le N$ 的,所以相当于那些球也可以不放.预处理阶乘及其逆元后 $O(M)$ 计算即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=2e6+10;int fac[MAXN],invfac[MAXN];int C(int n,int m)&#123; return mul(fac[m],mul(invfac[n],invfac[m-n]));&#125;int calc(int n,int m)&#123; return C(n,m+n-1);&#125;void Init_Fac(int n)&#123; fac[0]=invfac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=fpow(fac[n],P-2); for(int i=n-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int main()&#123; int N=read(),M=read(); Init_Fac((N+M)&gt;&gt;1); int ans=1;//m=1 for(int m=2;m&lt;=N &amp;&amp; m&lt;=M;++m) &#123; ans=add(ans,calc((N-m)&gt;&gt;1,m)); if(N&gt;=m+1) ans=add(ans,calc((N-m-1)&gt;&gt;1,m)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4419 发微博]]></title>
    <url>%2F2019%2F07%2F14%2Fbzoj-4419-%E5%8F%91%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[乱搞. 对每个人 $i$ 维护一个标记 $val_i$ ,表示这个人发过了多少条微博. 如果新连上一个点 $j$ , $ans_j-=val_i$ ,若断开一个点 $j$ , $ans_j+=val_i$ . 最后再将所有边断掉即可. 注意自己发的微博不计入自己的贡献. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,ans[MAXN],val[MAXN];set&lt;int&gt; s[MAXN];set&lt;int&gt;::iterator it;int main()&#123; n=read(),m=read(); while(m--) &#123; char buf[2]; scanf("%s",buf); if(buf[0]=='!') &#123; int x=read(); ++val[x]; &#125; else if(buf[0]=='+') &#123; int x=read(),y=read(); ans[x]-=val[y]; ans[y]-=val[x]; s[x].insert(y); s[y].insert(x); &#125; else &#123; int x=read(),y=read(); ans[x]+=val[y]; ans[y]+=val[x]; s[x].erase(y); s[y].erase(x); &#125; &#125; for(int i=1;i&lt;=n;++i) for(it=s[i].begin();it!=s[i].end();++it) &#123; int j=*it; s[i].erase(j); s[j].erase(i); ans[i]+=val[j]; ans[j]+=val[i]; &#125; printf("%d",ans[1]); for(int i=2;i&lt;=n;++i) printf(" %d",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1191]]></title>
    <url>%2F2019%2F07%2F13%2FCF1191%2F</url>
    <content type="text"><![CDATA[$Div.2$ 怎么出了两个博弈的题啊… A Tokitsukaze and Enhancement 模拟即可. 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int x=read(); x%=4; if(x==0) puts("1 A"); else if(x==1) puts("0 A"); else if(x==2) puts("1 B"); else puts("2 A"); return 0;&#125; B Tokitsukaze and Mahjong 模拟即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;char buf[3][3];int k1(int i)&#123; return buf[i][0];&#125;int k2(int i)&#123; return buf[i][1];&#125;bool equal(int i,int j)&#123; return k1(i)==k1(j) &amp;&amp; k2(i)==k2(j);&#125;bool nx(int i,int j)&#123; return abs(k1(i)-k1(j))&lt;=2 &amp;&amp; k2(i)==k2(j);&#125;int main()&#123; for(int i=1;i&lt;=3;++i) scanf("%s",buf[i]); if(k1(1)==k1(2) &amp;&amp; k1(1)==k1(3) &amp;&amp; k2(1)==k2(2) &amp;&amp; k2(2)==k2(3)) &#123; puts("0"); return 0; &#125; if(k2(1)==k2(2) &amp;&amp; k2(1)==k2(3)) &#123; int a[3]; a[0]=k1(1),a[1]=k1(2),a[2]=k1(3); sort(a,a+3); if(a[1]-a[0]==1 &amp;&amp; a[2]-a[1]==1) &#123; puts("0"); return 0; &#125; &#125; if(equal(1,2) || equal(1,3) || equal(2,3)) puts("1"); else if(nx(1,2) || nx(1,3) || nx(2,3)) puts("1"); else puts("2"); return 0;&#125; C Tokitsukaze and Discard Items 模拟删数的过程,二分找出此次删掉的最后一个数. 每次至少删掉一个数,时间复杂度 $O(m\cdot \log m)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;ll p[MAXN];int x=1,m;int bs(ll lim,int tot)&#123; int L=x,R=m; int ans=x; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(p[mid]-tot&lt;=lim) ans=mid,L=mid+1; else R=mid-1; &#125; return ans;&#125;int main()&#123; ll n=read(); m=read(); ll k=read(); for(int i=1;i&lt;=m;++i) p[i]=read()-1; int tot=0,ans=0; while(tot!=m) &#123; ll pos=(p[x]-tot)/k; ll y=bs(pos*k+k-1,tot); ans++; tot+=y-x+1; x=y+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Tokitsukaze, CSL and Stone Game 感觉思路已经非常接近正解了,但有个情况没判到. 除了先手第一次拿后就必败,最后一定是石子数形成 $0,1,2,\dots n-1$ 的排列. 记初始时石子数为 $x$ 的有 $cnt_x$ 堆,特判一下先手第一次拿后就必败的情况: 若第一次取后未败,则只需判断使局面形成 $0,1,2,\dots n-1$ 的排列需要取的石头的奇偶性. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN],p[MAXN];unordered_map&lt;int,int&gt; cnt;bool check()&#123; if(cnt[0]==n) return true; if(cnt[0]&gt;=2) return true; int k=0; sort(p+1,p+1+n); int m=unique(p+1,p+1+n)-p-1; for(int i=1;i&lt;=m;++i) &#123; int x=p[i]; if(cnt[x]&gt;=3) return true; if(cnt[x]==2 &amp;&amp; cnt[x-1]&gt;=1) return true; if(cnt[x]==2) ++k; &#125; if(k&gt;=2) return true; return false;&#125;int main()&#123; n=read(); int s=0; for(int i=1;i&lt;=n;++i) &#123; p[i]=a[i]=read(); ++cnt[p[i]]; &#125; if(check()) return puts("cslnb")&amp;0; sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) s^=(a[i]-i+1)&amp;1; if(s) puts("sjfnb"); else puts("cslnb"); return 0;&#125; E Tokitsukaze and Duel 给一段 $0/1$ 序列,双方轮流操作,每次操作将一段长度为 $k$ 的区间全部变成一个值,操作后使得整个序列全是 $0$ 或全是 $1$ 的人获胜.可能出现无限操作下去的情况,判为平局. 注意到一个人若第一次操作无法直接取胜,那么他永远也无法取胜,因为对方总是可以通过执行相反的操作. 于是先判断一下先手能否一次操作取胜,再判断一下是否先手第一次无论怎样操作,后手总能一次操作取胜. 若两者都不能取胜,则为平局. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k,a[MAXN],sum[MAXN];int pre[MAXN][2],nxt[MAXN][2];char s[MAXN];bool first_win(int p)&#123; int l=p,r=p+k-1; if(sum[l-1]+sum[n]-sum[r]+k==n) return true; if(sum[l-1]+sum[n]-sum[r]==0) return true; return false;&#125;int find_first(int L,int R,int x)&#123; int s=nxt[L][x]; if(s==0 || s&gt;R) return 0; return s;&#125;int find_last(int L,int R,int x)&#123; int s=pre[R][x]; if(s==0 || s&lt;L) return 0; return s; &#125;bool second_win(int p,int x)&#123; int l=p,r=p+k-1; int L,R; L=find_first(1,l-1,x); if(!L) L=find_first(r+1,n,x); R=find_last(r+1,n,x); if(!R) R=find_last(1,l-1,x); assert(L &amp;&amp; R); return R-L+1&lt;=k;&#125;bool Second_win(int p)&#123; return second_win(p,0) &amp;&amp; second_win(p,1);&#125;int main()&#123; n=read(),k=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i) &#123; a[i]=s[i]-'0'; sum[i]=sum[i-1]+a[i]; &#125; for(int i=1;i&lt;=n;++i) &#123; pre[i][0]=(a[i]==0)?i:pre[i-1][0]; pre[i][1]=(a[i]==1)?i:pre[i-1][1]; &#125; for(int i=n;i&gt;=1;--i) &#123; nxt[i][0]=(a[i]==0)?i:nxt[i+1][0]; nxt[i][1]=(a[i]==1)?i:nxt[i+1][1]; &#125; bool f=true; for(int i=1;i+k-1&lt;=n;++i) &#123; if(first_win(i)) &#123; puts("tokitsukaze"); return 0; &#125; if(f &amp;&amp; !Second_win(i)) f=false; &#125; if(f) puts("quailty"); else puts("once again"); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>codeforces</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4598 模式字符串]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4598-%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[点分治 + $hash$ . 考虑点分治.由于分治时路径起点不确定,无法直接匹配,所以需要 $hash$ 暂时存储状态. 若当前分治中心为 $rt$ ,维护 $pre(i),suf(i)$ 分别表示节点 $i$ 到 $rt$ 的路径, $rt$ 到 $i$ 的路径的 $hash$ 值. 到一个点,先算得它的 $pre$ ,在后面接上 $rt$ 的字符,判断这个串在循环意义下是否与模式串的某个前缀匹配. 可以反着推,假设它能与某个前缀循环匹配,那么根据这个串的长度,可以算出它应该是模式串重复了 $\lfloor len/m \rfloor$ 次,再接上一个长度为 $len\mod m$ 的前缀形成的.判一下 $pre$ 是否与理论上求得的 $hash$ 值相等即可. 若在循环意义下匹配上了长度为 $i$ 的前缀,它的贡献就是当前能与长度 $m-i$ 的后缀循环匹配的 $suf$ 数目. 再算这个点 $suf$ 的贡献,与上面的方法类似.维护一个反串的 $hash$ 会十分方便. 常数大的一批,写法是对的,但时限卡不进去. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e5+10;int n,m;char buf[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;typedef unsigned long long ull;const ull Base=37;ull pw[MAXN],Hash[MAXN],revHash[MAXN];ull val[MAXN],pre[MAXN],suf[MAXN];ull Pattern_Power[MAXN],revPattern_Power[MAXN];ull Add_Char(ull hash,int c)&#123; return hash*Base+c;&#125;void Init_Hash()&#123; Hash[0]=0; for(int i=1;i&lt;=m;++i) Hash[i]=Hash[i-1]*Base+(buf[i]-'A'); revHash[0]=0; for(int i=1;i&lt;=m;++i) revHash[i]=revHash[i-1]*Base+(buf[m-i+1]-'A'); Pattern_Power[0]=0; for(int i=1;i*m&lt;=n;++i) Pattern_Power[i]=Pattern_Power[i-1]*pw[m]+Hash[m]; revPattern_Power[0]=0; for(int i=1;i*m&lt;=n;++i) revPattern_Power[i]=revPattern_Power[i-1]*pw[m]+revHash[m];&#125;int rt,totsize,mi,siz[MAXN],vis[MAXN];ll ans;void Findrt(int u,int fa)&#123; siz[u]=1; int mxsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa || vis[v]) continue; Findrt(v,u); siz[u]+=siz[v]; if(siz[v]&gt;mxsiz) mxsiz=v; &#125; mxsiz=max(mxsiz,totsize-siz[u]); if(mxsiz&lt;mi) mi=mxsiz,rt=u;&#125;int sumpre[MAXN],sumsuf[MAXN];int stk1[MAXN],stk2[MAXN],tp=0;int lstpre[MAXN],lstsuf[MAXN],cnt=0;int Match_pre(ull hash,int len)&#123; int x=len/m,y=len%m; ull exphash=Pattern_Power[x]*pw[y]+Hash[y]; if(exphash==hash) return y; else return m;&#125;int Match_suf(ull hash,int len)&#123; int x=len/m,y=len%m; ull exphash=revPattern_Power[x]*pw[y]+revHash[y]; if(exphash==hash) return y; else return m;&#125;int prelen,suflen;ull preval,sufval;void dfs(int u,int fa,int len,int Rt)&#123; pre[u]=val[u]*pw[len-1]+pre[fa]; suf[u]=val[u]*pw[len-1]+suf[fa]; prelen=Match_pre(pre[u],len); suflen=Match_suf(suf[u],len); if(prelen!=m || suflen!=m) &#123; ++cnt; lstpre[cnt]=prelen; lstsuf[cnt]=suflen; &#125; preval=Add_Char(pre[u],val[Rt]); prelen=Match_pre(preval,len+1); sufval=Add_Char(suf[u],val[Rt]); suflen=Match_suf(sufval,len+1); if(prelen!=m) ans+=sumsuf[(m-prelen)%m]; if(suflen!=m) ans+=sumpre[(m-suflen)%m]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; dfs(v,u,len+1,Rt); &#125;&#125;void solve(int u)&#123; vis[u]=1; if(siz[u]&lt;m) return; for(int i=1;i&lt;=tp;++i) &#123; sumpre[stk1[i]]=0; sumsuf[stk2[i]]=0; &#125; pre[u]=suf[u]=0; ++sumpre[0],++sumsuf[0]; tp=1; stk1[tp]=0; stk2[tp]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; dfs(v,u,1,u); while(cnt) &#123; ++tp; stk1[tp]=lstpre[cnt]; stk2[tp]=lstsuf[cnt]; ++sumpre[lstpre[cnt]]; ++sumsuf[lstsuf[cnt]]; --cnt; &#125; &#125;&#125;void Divide(int u)&#123; solve(u); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf,totsize=siz[v]; Findrt(v,0); Divide(rt); &#125;&#125;void Reset()&#123; memset(head,0,sizeof head); ecnt=0; memset(vis,0,sizeof vis); ans=0;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=100000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; Reset(); n=read(),m=read(); scanf("%s",buf+1); for(int i=1;i&lt;=n;++i) val[i]=buf[i]-'A'; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; scanf("%s",buf+1); Init_Hash(); mi=inf,totsize=n; Findrt(1,0); Divide(rt); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>hash</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4893 聚变反应炉]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4893-%E8%81%9A%E5%8F%98%E5%8F%8D%E5%BA%94%E7%82%89%2F</url>
    <content type="text"><![CDATA[贪心 + 树形背包. 本以为此题必有高论,但发现只有 $n-1$ 条边,是个树.那很显然就是一个树形背包了. 前 $50$ 分 $n$ 比较大,但 $c_i\in \lbrace 0,1 \rbrace$ ,可以贪心.显然先将所有 $c=1$ 的点激发,再激发 $c=0$ 的点最优, 对于后面的 $50$ 分, $n\leq 2000$ ,树形背包解决. 设 $f(u,x)$ 表示将子树 $u$ 内的点全部激发,并且节点 $u$ 初始需要 $x$ 点能量激发. $dfs$ 到节点 $u$ 时,枚举它的所有儿子 $v$ ,递归下去计算出所有 $v$ 的 $f$ 值. 先选一些儿子出来(选 $0$ 个也可),将它们的子树激发,再激发 $u$ ,再激发剩余的子树.那么一个儿子 $v$ 被选,造成的贡献是 $f(v,d_v)$ ,没被选,造成的贡献是 $f(v,\max(d_v-c_u,0))$ , $u$ 的贡献是 $x$ 减去选了的 $c_v$ ,与 $0$ 取 $\max$ . 设 $g(i,j)$ 表示考虑了前 $i$ 个儿子,选了的儿子 $c_v$ 总和是 $j$ 时,前 $i$ 个儿子造成的最小贡献. 对于第 $i$ 个儿子 $v$ ,若选它,有转移 $g(i,j+c_v)\leftarrow g(i-1,j)+f(v,d_v)$ . 若不选它,有转移 $g(i,j)\leftarrow g(i-1,j)+f(v,\max(d_v-c_u,0))$ . 若 $u$ 有 $k$ 个儿子,那么 $f(u,x)=\min \lbrace g(k,j)+\max(x-j,0)\rbrace$ . 注意到 $f$ 的第二维 $x$ 对于确定的 $u$ ,其实只有 $2$ 种取值 $\lbrace d_u,\max(d_u-c_{fa},0)\rbrace$ ,分别用 $0,1$ 代替即可. 时间复杂度 $O(n\cdot \sum c_i)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;const int inf=1e9;const int MAXN=1e5+10,MAXS=1e4+10;int n,c[MAXN],d[MAXN],fa[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];int sumc[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[2019][2],g[2019][MAXS];int calc(int u,int x)&#123; if(!x) return d[u]; if(x==1) return max(0,d[u]-c[fa[u]]);&#125;void solve(int u,int id,int k)&#123; int x=calc(u,id); if(!k) &#123; f[u][id]=x; return; &#125; int i=0; for(int I=head[u];I;I=nx[I]) &#123; int v=to[I]; if(v==fa[u]) continue; ++i; for(int j=0;j&lt;=sumc[u];++j) &#123; if(j+c[v]&lt;=sumc[u]) upd(g[i][j+c[v]],g[i-1][j]+f[v][0]); upd(g[i][j],g[i-1][j]+f[v][1]); &#125; &#125; f[u][id]=inf; for(int j=0;j&lt;=sumc[u];++j) f[u][id]=min(f[u][id],g[k][j]+max(x-j,0)); for(int i=1;i&lt;=k;++i) for(int j=0;j&lt;=sumc[u];++j) g[i][j]=inf;&#125;void dfs(int u,int Fa)&#123; fa[u]=Fa; int k=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; sumc[u]+=c[v]; dfs(v,u); ++k; &#125; solve(u,0,k); solve(u,1,k);&#125;int solve_greedy()&#123; int greedy_ans=0; for(int u=1;u&lt;=n;++u) if(c[u]) &#123; greedy_ans+=max(d[u],0); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; d[v]-=c[u]; &#125; &#125; for(int u=1;u&lt;=n;++u) if(!c[u]) greedy_ans+=max(d[u],0); cout&lt;&lt;greedy_ans&lt;&lt;endl; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) d[i]=read(); for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; if(n&gt;2000) return solve_greedy(); for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=10000;++j) g[i][j]=inf; g[0][0]=0; dfs(1,0); cout&lt;&lt;f[1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>树形dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4592 脑洞治疗仪]]></title>
    <url>%2F2019%2F07%2F12%2Fbzoj-4592-%E8%84%91%E6%B4%9E%E6%B2%BB%E7%96%97%E4%BB%AA%2F</url>
    <content type="text"><![CDATA[线段树. 需要维护一段区间的区间和,最长包含左端点的全 $0$ 区间长度,最长的包含右端点的全 $0$ 区间长度,最长全 $0$ 区间长度,以及支持区间赋值. 用线段树维护.操作 $1,3$ 都比较简单,操作 $2$ ,先查询 $[L_0,R_0]$ 中 $1$ 的数目,再将这段覆盖成 $0$ . 接下来用线段树把 $[L_1,R_1]$ 拆成 $\log$ 个线段树上的区间,遍历一次,找到能填补的最后一个区间. 再在那个区间内二分能填到的最后一个位置.方法类似于找第 $k$ 大.这样就只有一只 $\log$ 了. 时间复杂度 $O(n \cdot \log n)$ . 另外一个做法是使用珂朵莉树,但使用前提是数据随机,或者,区间赋值操作的数目与随机时的数目相近. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m;struct SegTree&#123; struct node &#123; int sum,tag,Len; int lenl,lenr,len; &#125;Tree[MAXN&lt;&lt;2]; friend node operator + (node lson,node rson) &#123; node root; root.Len=lson.Len+rson.Len; root.sum=lson.sum+rson.sum; if(lson.lenl==lson.Len) root.lenl=lson.lenl+rson.lenl; else root.lenl=lson.lenl; if(rson.lenr==rson.Len) root.lenr=rson.lenr+lson.lenr; else root.lenr=rson.lenr; root.len=max(lson.len,rson.len); root.len=max(root.len,lson.lenr+rson.lenl); root.len=max(root.len,root.lenl); root.len=max(root.len,root.lenr); return root; &#125;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; int t=root.tag; root=lson+rson; root.tag=t; &#125; void BuildTree(int o,int l,int r) &#123; root.sum=root.Len=r-l+1; root.tag=-1; root.lenl=root.lenr=root.len=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void Modifiy(int o,int c) &#123; root.tag=c; root.sum=root.Len*c; root.lenl=root.lenr=root.len=c?0:root.Len; &#125; void pushdown(int o) &#123; if(root.tag!=-1) &#123; Modifiy(o&lt;&lt;1,root.tag); Modifiy(o&lt;&lt;1|1,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query_sum(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; pushdown(o); int res=0; if(L&lt;=mid) res+=query_sum(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query_sum(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125; int tmp[50],tot,LL[50],RR[50]; void Split(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; tmp[++tot]=o; LL[tot]=l; RR[tot]=r; return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) Split(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) Split(o&lt;&lt;1|1,mid+1,r,L,R); &#125; int Binary_Search(int o,int l,int r,int x) &#123; int mid=(l+r)&gt;&gt;1; if(l!=r) pushdown(o); if(root.Len-root.sum==x) return r; if(lson.Len-lson.sum&lt;x) return Binary_Search(o&lt;&lt;1|1,mid+1,r,x-lson.Len+lson.sum); else return Binary_Search(o&lt;&lt;1,l,mid,x); &#125; int Search(int L,int R,int brain) &#123; tot=0; Split(1,1,n,L,R); int zero=0,mxrt=-1,x; for(int i=1;i&lt;=tot &amp;&amp; mxrt==-1;++i) &#123; zero+=Tree[tmp[i]].Len-Tree[tmp[i]].sum; if(zero&gt;=brain) &#123; mxrt=i; x=brain-(zero-Tree[tmp[i]].Len+Tree[tmp[i]].sum); &#125; &#125; return Binary_Search(tmp[mxrt],LL[mxrt],RR[mxrt],x); &#125; node query_len(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; pushdown(o); if(R&lt;=mid) return query_len(o&lt;&lt;1,l,mid,L,R); if(L&gt;mid) return query_len(o&lt;&lt;1|1,mid+1,r,L,R); if(L&lt;=mid &amp;&amp; R&gt;mid) return query_len(o&lt;&lt;1,l,mid,L,R)+query_len(o&lt;&lt;1|1,mid+1,r,L,R); &#125; int solve(int L,int R) &#123; node tmp=query_len(1,1,n,L,R); return tmp.len; &#125;&#125;T;int main()&#123; n=read(),m=read(); T.BuildTree(1,1,n); while(m--) &#123; int tp=read(); if(tp==0) &#123; int L=read(),R=read(); T.upd(1,1,n,L,R,0); &#125; else if(tp==1) &#123; int L0=read(),R0=read(); int L1=read(),R1=read(); int tot1=T.query_sum(1,1,n,L0,R0); if(!tot1) continue; T.upd(1,1,n,L0,R0,0); int tot2=T.query_sum(1,1,n,L1,R1); if(tot1+tot2&gt;=R1-L1+1) T.upd(1,1,n,L1,R1,1); else &#123; int pos=T.Search(L1,R1,tot1); T.upd(1,1,n,L1,pos,1); &#125; &#125; else &#123; int L=read(),R=read(); printf("%d\n",T.solve(L,R)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4562 食物链]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4562-%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[记忆化搜索. 题面写得非常烂 .作为一道省选题,没有对 食物链 下任何规范的定义,就让求数目,甚至限制也只说 输入数据符合生物学特点. 讲道理,出题人是要出来谢罪的. 结合样例强行理解,可以给出抽象的题目描述. 给定一张 $DAG$ ,求满足以下条件的路径数目:路径的起点终点不同,且起点的入度为 $0$ ,终点的出度为 $0$ . 记忆化搜索一下,记 $f(i)$ 表示从 $i$ 出发到出度为 $0$ 的点的路径条数.答案为所有入度为 $0$ 的点的 $f$ 之和. 注意特判除掉入度出度均为 $0$ 的点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,indeg[MAXN],outdeg[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; ++outdeg[u]; ++indeg[v];&#125;int f[MAXN];int dp(int u)&#123; if(f[u]!=-1) return f[u]; if(outdeg[u]==0) return f[u]=1; int &amp;res=f[u]; res=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; res+=dp(v); &#125; return res;&#125;int main()&#123; memset(f,-1,sizeof f); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); addedge(u,v); &#125; int ans=0; for(int i=1;i&lt;=n;++i) if(!indeg[i] &amp;&amp; outdeg[i]) ans+=dp(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1189]]></title>
    <url>%2F2019%2F07%2F11%2FCF1189%2F</url>
    <content type="text"><![CDATA[$Div.2$ A Keanu Reeves 显然只需要判断不分割是否可行,若不可行,就把第一个字符分出去,分成两段就好了. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;char s[MAXN];int main()&#123; int n=read(); scanf("%s",s+1); int t[2]=&#123;0,0&#125;; for(int i=1;i&lt;=n;++i) ++t[s[i]-'0']; if(t[0]!=t[1]) &#123; puts("1"); printf("%s\n",s+1); &#125; else &#123; puts("2"); putchar(s[1]); putchar(' '); for(int i=2;i&lt;=n;++i) putchar(s[i]); puts(""); &#125; return 0;&#125; B Number CirCle 假的一批,这个题被罚了 $3$ 次. 构造方法是先将元素排序,先将最大的放在任意一个位置 $x$ ,然后次大的放在 $x+1$ ,第三大放在 $x-1$ ,第四大放在 $x+1\dots$ 然后检验是否合法,若这样放置不合法,则其他所有放置也不可能合法. 为什么?因为题面中的图和样例就是这样做的.大概是因为一个比较大的数,它旁边的数尽量也安排成比较大的数,这样对于双方都最优. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,a[MAXN];int b[MAXN];bool check()&#123; if(b[1]&gt;=b[n]+b[2]) return false; if(b[n]&gt;=b[1]+b[n-1]) return false; for(int i=2;i&lt;n;++i) if(b[i]&gt;=b[i-1]+b[i+1]) return false; return true;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); int x=(n+1)/2; b[x]=a[n]; int tot=n-1; for(int i=1;tot;++i) &#123; b[x+i]=a[tot--]; if(tot) b[x-i]=a[tot--]; &#125; if(check()) &#123; puts("YES"); for(int i=1;i&lt;=n;++i) printf("%d ",b[i]); &#125; else puts("NO"); return 0;&#125; C Candies! 仔细思考一下,不难发现答案就是 $\lfloor \frac {sum(l,r)} {10}\rfloor$ . 因为这个答案就是进位的次数,与运算顺序无关,直接将它们加起来 $/10$ ,得到的就是进位次数. 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int a[MAXN];int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) a[i]=a[i-1]+read(); int q=read(); while(q--) &#123; int l=read(),r=read(); int ans=a[r]-a[l-1]; ans/=10; printf("%d\n",ans); &#125; return 0;&#125; D1 Add on a Tree 容易发现,当且仅当存在两条边,它们只能同时加减同一个数时,就无法得到它们的权值不同的情况. 若存在这样两条边,则一定存在两条这样相邻的边,要让它们满足条件,它们的公共点度数一定为 $2$ ,即不存在其他的边. 于是判一下是否存在度数为 $2$ 的点即可. 代码就是 $D2$ 的一小部分,就不贴了. D2 Add on a Tree: Revolution 好题. 判断合法性和 $D1$ 一样,判是否有度数为 $2$ 的点.若合法,要将每条边的权值都改为要求的权值.特判 $n=2$ . 考虑如何给一条路径 $(u,L_0)$ 上的所有边加上一个权值 $x$ ,其中 $L_0$ 为叶子节点.先选择一个非叶子节点作为根. $u$ 的度数至少为 $3$ ,故一定可以找到另外两个叶子节点 $L_1,L_2$ ,并且这 $3$ 个叶子节点在 $u$ 的 $3$ 个不同子树内. 因为边权都是偶数( $pairwise$ ),所以我们要加的 $x$ 也都选择偶数.于是执行 $(L_0,L_1,\frac x 2),(L_0,L_2,\frac x 2),(L_1,L_2,-\frac x 2)$ 这三个操作,路径 $(u,L_0)$ 上所有边权值就 $+x$ 了. 再来解决原问题,对每条边,维护当前边上的权值与要求的权值还差 $\Delta$ ,然后从根节点开始 $dfs$ ,遍历到 $u$ 时,对它的每个儿子节点 $v$ ,选出子树 $v$ 内任一个叶子节点 $L_0$ ,用上面的操作给路径 $(u,L_0)$ 上的边加上 $\Delta_{u,v}$ 即可. $n\le 1000$ ,可以暴力找/修改,不用写数据结构.时间复杂度 $O(n^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int head[MAXN],ecnt=0,to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];int n,m=0;struct opt&#123; int u,v; ll x; opt(int u=0,int v=0,ll x=0):u(u),v(v),x(x) &#123;&#125;&#125;;queue&lt;opt&gt; Q;void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int deg[MAXN],dfn[MAXN],siz[MAXN],idx=0;int fa[MAXN];ll Delta[MAXN];//Edge(i,fa_i)bool In_SubTree(int v,int x)&#123; return dfn[v]&lt;=dfn[x] &amp;&amp; dfn[x]&lt;=dfn[v]+siz[v]-1;&#125;void Init(int u,int Fa)&#123; dfn[u]=++idx; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; Delta[v]=val[i]; Init(v,u); siz[u]+=siz[v]; &#125;&#125;int rt;void Assign(int u,int v0,int L0,ll x)&#123; int L1=0,L2=0; if(u!=rt) &#123; for(int i=1;i&lt;=n;++i) &#123; if(deg[i]==1 &amp;&amp; !In_SubTree(v0,i)) &#123; if(!L1 &amp;&amp; In_SubTree(u,i)) L1=i; if(!L2 &amp;&amp; !In_SubTree(u,i)) L2=i; if(L1 &amp;&amp; L2) break; &#125; &#125; &#125; else &#123; int v1=0,v2; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==v0 || v==v1) continue; if(!v1) v1=v; else v2=v; &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==1 &amp;&amp; In_SubTree(v1,i)) L1=i; else if(deg[i]==1 &amp;&amp; In_SubTree(v2,i)) L2=i; &#125; m+=3; Q.push(opt(L0,L1,x/2)); Q.push(opt(L0,L2,x/2)); Q.push(opt(L1,L2,-x/2)); while(L0!=u) &#123; Delta[L0]-=x; L0=fa[L0]; &#125;&#125;void dfs(int u)&#123; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u]) continue; int L0=0; for(int j=1;j&lt;=n &amp;&amp; !L0;++j) if(deg[j]==1 &amp;&amp; In_SubTree(v,j)) L0=j; Assign(u,v,L0,Delta[v]); dfs(v); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); ++deg[u],++deg[v]; &#125; if(n==2) &#123; puts("YES"); puts("1"); printf("1 2 %d\n",val[1]); return 0; &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==2) &#123; puts("NO"); return 0; &#125; puts("YES"); rt=0; for(int i=1;i&lt;=n &amp;&amp; !rt;++i) if(deg[i]&gt;1) rt=i; Init(rt,0); dfs(rt); cout&lt;&lt;m&lt;&lt;endl; opt tmp; while(!Q.empty()) &#123; tmp=Q.front(); Q.pop(); printf("%d %d %I64d\n",tmp.u,tmp.v,tmp.x); &#125; return 0;&#125; E Count Pairs 这个题比 $D2$ 简单许多.对于原方程,因为 $a_i\not= a_j$ ,两边乘上 $(a_i-a_j)$ ,可得$$a_i^4 - a_j^4 \equiv k(a_i-a_j)$$ 可以 $O(n) $枚举 $j$ ,计算有多少个 $i$ 满足方程.于是 $a_j$ 此时为常数,整理一下,得到$$a_i^4-k\cdot a_i \equiv a_j^4-k\cdot a_j$$ $k$ 是不变的,所以用一个 $map$ 对于每个 $x\in [0,P)$ 记录 $a_i^4-k\cdot a_i\equiv x$ 的 $i$ 有多少个就好了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int P;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int pw4(int x)&#123; x=mul(x,x); x=mul(x,x); return x;&#125;const int MAXN=3e5+10;unordered_map&lt;int,int&gt; cnt;int n,a[MAXN];int main()&#123; n=read(),P=read(); int k=read(); ll ans=0; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); int x=pw4(a[i]); x=add(x,mul(P-k,a[i])); if(cnt.find(x)!=cnt.end()) ans+=cnt[x]; ++cnt[x]; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; F Array Beauty 元素的顺序是不影响答案的,所以可以先将所有元素从小到大排序.记最大的元素为 $m$ . $Beauty$ 值最大为 $m$ ,记 $Beauty$ 值 $\ge x$ 的子序列有 $p_x$ 个,那么答案为 $\sum_{x=1}^m p_x$ ,因为若一个子序列的 $Beauty$ 值为 $s$ ,它就会在求和中贡献 $s$ 次. 枚举 $x$ 的值,用 $dp$ 求解 $p_x$ .设 $f(i,j)$ 表示以第 $i$ 个数结尾,长度为 $j$ 的,且美丽值 $\ge x$ 的子序列数目. 转移有 $f(i,j)=\sum f(d,j-1),d&lt;i,a_j-a_d\ge x$ .由于 $a$ 已经排过序,所以合法的 $d$ 一定是一段前缀,可以用 $two\ pointer$ 维护,并记录 $f$ 的前缀和.这样, $p_x=\sum f(i,k)$ ,求一个 $p_x$ 的时间复杂度为 $O(n\cdot k)$ . 注意到 $x$ 只需要枚举到 $\lfloor \frac m {k-1}\rfloor$ ,若 $x$ 大于这个值,子序列首尾元素差值就会 $&gt; m$ ,不可能出现. 所以整个问题的时间复杂度为 $O(m \cdot n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;const int MAXN=1e3+10;int n,k;int f[MAXN][MAXN],sum[MAXN][MAXN],a[MAXN];int solve(int x)&#123; for(int i=1;i&lt;=n;++i) f[i][1]=1,sum[i][1]=i; for(int j=2;j&lt;=k;++j) &#123; sum[0][j]=0; int r=1; for(int i=1;i&lt;=n;++i) &#123; while(a[r]&lt;=a[i]-x) ++r; f[i][j]=sum[r-1][j-1]; sum[i][j]=add(sum[i-1][j],f[i][j]); &#125; &#125; return sum[n][k];&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); int m=a[n]; int ans=0; for(int x=1;x&lt;=m/(k-1);++x) ans=add(ans,solve(x)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>数学</tag>
        <tag>codeforces</tag>
        <tag>构造</tag>
        <tag>two pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4561 圆的异或并]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4561-%E5%9C%86%E7%9A%84%E5%BC%82%E6%88%96%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[扫描线 + $set$ . 把圆看做上下两段半圆弧,因为位置关系只有包含和相离,所以无论 $x$ 取什么值,各个圆弧上下相对顺序是不变的.所以可以将它们全都丢进 $set$ 里面,方便接下来查询. 做一个扫描线,左边插入,右边删除.对于每个圆弧,插入的时候询问它的 $upper_bound$ . 若找到的是上圆弧,说明它就是当前圆外面的第一个圆. 若找到的是下圆弧,说明当前圆外面的第一个圆就是那个下圆弧外面的第一个圆. 可能出现找不到的情况,需要特判. 发现自己好像是第一次写扫描线… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;inline double sq(double x)&#123; return x*x;&#125;const int MAXN=2e5+10;int n;double x[MAXN],y[MAXN],r[MAXN],pos;int Sgn[MAXN];struct LR_Arc&#123; int id,sgn; LR_Arc(int id=0,int sgn=0):id(id),sgn(sgn) &#123;&#125; bool operator &lt; (const LR_Arc &amp;rhs) const &#123; return x[id]+sgn*r[id]&lt;x[rhs.id]+rhs.sgn*r[rhs.id]; &#125;&#125;q[MAXN&lt;&lt;1];struct UD_Arc&#123; int id,sgn;//1-up -1-down UD_Arc(int id=0,int sgn=0):id(id),sgn(sgn) &#123;&#125; bool operator &lt; (const UD_Arc &amp;rhs) const &#123; int i=id,j=rhs.id; double y1=y[i]+sgn*(sqrt(sq(r[i])-sq(x[i]-pos))); double y2=y[j]+rhs.sgn*(sqrt(sq(r[j])-sq(x[j]-pos))); return y1==y2?sgn&lt;rhs.sgn:y1&lt;y2; &#125;&#125;;set&lt;UD_Arc&gt; S;set&lt;UD_Arc&gt;::iterator it;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; x[i]=(double)(read()); y[i]=(double)(read()); r[i]=(double)(read()); q[i*2-1]=LR_Arc(i,-1); q[i*2]=LR_Arc(i,1); &#125; sort(q+1,q+1+2*n); for(int i=1;i&lt;=2*n;++i) &#123; pos=x[q[i].id]+q[i].sgn*r[q[i].id]; if(q[i].sgn==-1) &#123; it=S.upper_bound(UD_Arc(q[i].id,1)); if(it!=S.end()) &#123; UD_Arc tmp=*it; if(tmp.sgn==-1) Sgn[q[i].id]=Sgn[tmp.id]; else Sgn[q[i].id]=-Sgn[tmp.id]; &#125; else Sgn[q[i].id]=1; S.insert(UD_Arc(q[i].id,1)); S.insert(UD_Arc(q[i].id,-1)); &#125; else &#123; S.erase(UD_Arc(q[i].id,1)); S.erase(UD_Arc(q[i].id,-1)); &#125; &#125; double ans=0; for(int i=1;i&lt;=n;++i) ans+=sq(r[i])*Sgn[i]; cout&lt;&lt;(ll)(ans)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>扫描线</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4560 字符串覆盖]]></title>
    <url>%2F2019%2F07%2F11%2Fbzoj-4560-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[字符串 $hash$ + 贪心 + $dp$ . 首先可以字符串 $hash$ 预处理出 $N$ 个串各自可以放的位置 (用开头的位置表示) ,以及 $L_{i,j} ,R_{i,j}$ 分别表示从位置 $j$ 往左/右边找,能找到的第一个可以放第 $i$ 个串的位置(不包含 $j$ ). 求最大值,可以贪心.首先枚举这 $N$ 个串放置的 $N!$ 种顺序,依次选择位置.分两种情况,记上个串结束位置为 $p$ ,若与上个串相交,则放在 $L_{i,p}$ 最优,若与上个串不相交,则放在 $R_{i,p}$ 最优.这个决策也可以大力枚举.这一步的时间复杂度 $O(N!\cdot 2^N)$ 求最小值,不相交时贪心放在 $R_{i,p}$ 不一定最优,考虑 $dp$ . 仍然枚举 $N!$ 种放置顺序,设 $f(i,j)$ 表示考虑了前 $j$ 个位置,下一个放置的应该是第 $i$ 个串. 若不放第 $i$ 个串,则转移到 $f(i,j+1)$ . 若放第 $i$ 个串,若它与上一个串不相交,转移到 $f(i+1,j+Len(i))$ .否则放在匹配 $j$ 后能放的第一个位置. 这一步时间复杂度 $O(N!\cdot N\cdot Len(A))$ ,也是总的时间复杂度. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;const ull Base=37;int n,N,len[5];ull Hash[MAXN],pw[MAXN];char A[MAXN],B[5][MAXN];void Init_Hash()&#123; Hash[0]=0; for(int i=1;i&lt;=n;++i) Hash[i]=Hash[i-1]*Base+(ull)(A[i]-'a');&#125;ull Calc_Hash(int l,int r)&#123; return Hash[r]-Hash[l-1]*pw[r-l+1];&#125;int L[5][MAXN],R[5][MAXN],f[5][MAXN];int id[5];int DP(int i,int j)&#123; if(i&gt;N) return 0; j=R[id[i]][j]; if(j==0) return n+1; if(f[i][j]!=-1) return f[i][j]; int &amp;ans=f[i][j]; ans=DP(i,j+1); int k=j+len[id[i]],st=j; ++i; for(;i&lt;=N;++i) &#123; ans=min(ans,DP(i,k)+k-j); int p=R[id[i]][j]; if(p&lt;st || p&gt;=k) return ans; st=p; k=max(k,st+len[id[i]]); &#125; ans=min(ans,k-j); return ans;&#125;int dfs(int i,int j)&#123; if(i&gt;N) return 0; j=R[id[i]][j]; if(!j) return 0; int k=j+len[id[i]],st=j; int ans=0; ++i; for(;i&lt;=N;++i) &#123; ans=max(ans,dfs(i,k)+k-j); int p=L[id[i]][k]; if(p&lt;st || p&gt;=k) return ans; st=p; k=max(k,st+len[id[i]]); &#125; ans=max(ans,k-j); return ans;&#125;int main()&#123; pw[0]=1; for(int i=1;i&lt;=10000;++i) pw[i]=pw[i-1]*Base; int T=read(); while(T--) &#123; scanf("%s",A+1); n=strlen(A+1); N=read(); for(int i=1;i&lt;=N;++i) &#123; scanf("%s",B[i]+1); len[i]=strlen(B[i]+1); &#125; Init_Hash(); memset(L,0,sizeof L); memset(R,0,sizeof R); for(int i=1;i&lt;=N;++i) &#123; ull val=0; for(int j=1;j&lt;=len[i];++j) val=val*Base+(B[i][j]-'a'); for(int j=1;j+len[i]-1&lt;=n;++j) if(Calc_Hash(j,j+len[i]-1)==val) L[i][j]=j; else L[i][j]=L[i][j-1]; for(int j=n+1-len[i];j&gt;=1;--j) if(Calc_Hash(j,j+len[i]-1)==val) R[i][j]=j; else R[i][j]=R[i][j+1]; &#125; for(int i=1;i&lt;=N;++i) id[i]=i; int minans=n+1,maxans=0; do &#123; memset(f,-1,sizeof f); minans=min(minans,DP(1,1)); maxans=max(maxans,dfs(1,1)); &#125;while(next_permutation(id+1,id+1+N)); printf("%d %d\n",minans,maxans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4559 成绩比较]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-4559-%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[组合计数 + 容斥原理 + 拉格朗日插值法. 首先我们确定哪些人被碾压,再确定没有被碾压的人各科分数分别是高于 $B$ 神还是小于等于 $B$ 神.然后就可以将每科分开算所有人各自具体分数的方案数,最后乘在一起. 选出被碾压的人有 $n-1\choose k$ 种方案. 对于课程 $i$ ,有 $r_i-1$ 个人的分比 $B$ 神高,这 $r_i-1$ 个人显然只能在未被碾压的 $n-k-1$ 个人中产生.如果任意分配,可能会出现新的人被碾压.所以用容斥原理计算这部分的贡献,没有人被碾压方案数 $=$ 总方案数 $-$ 保证 $1$ 个人被碾压方案数 $+$ 保证 $2$ 个人被碾压方案数 $\dots$ 记这个答案为 $s$ . 再来计算第 $i$ 科排名恰好为 $r_i$ 的方案数 $p_i$ .枚举这一科 $B$ 神考了 $x$ 分.(有 $r_i=1$ 的情况,所以定义 $0^0=1$ ). $$\begin{aligned}p_i=\sum_{x=1}^{u_i} x^{n-r_i}\cdot (u_i-x)^{r_i-1}\end{aligned}$$ 若暴力算 $p_i$ 可以拿到 $70$ 分.注意到 $p_i$ 是个关于 $u_i$ 的 $n$ 次多项式,而我们只需要求它在某一个位置的值. 拉格朗日插值即可,答案为 ${n-1\choose k}\cdot s \cdot \prod p_i$ . 时间复杂度 $O(n^3\cdot \log n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int n,m,k,C[MAXN][MAXN];int u[MAXN],r[MAXN];void init()&#123; C[0][0]=1; for(int i=1;i&lt;=n;++i) C[i][0]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]);&#125;int Assign_Rank()&#123; int res=1; for(int i=1;i&lt;=m;++i) res=mul(res,C[n-k-1][r[i]-1]); bool flag=true; for(int i=1;i&lt;=n-k-1 &amp;&amp; flag;++i) &#123; int tmp=C[n-k-1][i]; for(int j=1;j&lt;=m;++j) if(n-k-1-i&gt;=r[j]-1) tmp=mul(tmp,C[n-k-1-i][r[j]-1]); else &#123; tmp=0; flag=false; break; &#125; if(i&amp;1) res=add(res,P-tmp); else res=add(res,tmp); &#125; return res;&#125;int Calc_p(int i,int U)&#123; int res=0; for(int x=1;x&lt;=U;++x) res=add(res,mul(fpow(x,n-r[i]),fpow(U-x,r[i]-1))); return res;&#125;int x[MAXN],y[MAXN];int Lagrange(int N,int pos)&#123; int res=0; for(int i=1;i&lt;=N;++i) &#123; int tmp=y[i]; for(int j=1;j&lt;=N;++j) if(i!=j) &#123; tmp=mul(tmp,add(pos,P-x[j])); tmp=mul(tmp,inv(add(x[i],P-x[j]))); &#125; res=add(res,tmp); &#125; return res;&#125;int Assign_Score(int i)&#123; for(int U=2;U&lt;=n+2;++U) x[U-1]=U,y[U-1]=Calc_p(i,U); return Lagrange(n+1,u[i]);&#125;int main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=m;++i) u[i]=read(); for(int i=1;i&lt;=m;++i) r[i]=read(); init(); int ans=C[n-1][k]; ans=mul(ans,Assign_Rank()); for(int i=1;i&lt;=m;++i) ans=mul(ans,Assign_Score(i)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>容斥原理</tag>
        <tag>拉格朗日插值法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4558 方]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-4558-%E6%96%B9%2F</url>
    <content type="text"><![CDATA[容斥原理. 记 $s_i$ 表示顶点恰好有 $i$ 个点是不合法点的正方形数,答案显然是 $s_0-s_1+s_2-s_3+s_4$ . $s_0$ 可以直接算, $s_1$ 可以枚举每个不合法点来算. 算 $s_2,s_3,s_4$ 都只需要枚举每对不合法点,并判断其他两个顶点是否合法,将贡献加入对应的 $s$ . 注意考虑斜着放的正方形. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e8+7;const int inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairset&lt;pii&gt; S;int n,m,k,s[5];int Calc(int l,int r,int h)&#123; int z=min(l+r,h); if(!z) return 0; int res=mul(mul(z,z+3),inv2); if(z&gt;l) res=add(res,P-mul(inv2,mul(z-l,z-l+1))); if(z&gt;r) res=add(res,P-mul(inv2,mul(z-r,z-r+1))); return res;&#125;int calc1(int x,int y)&#123; int t=x,b=n-x,l=y,r=m-y; int res=0; res=add(res,Calc(t,b,l)); res=add(res,Calc(t,b,r)); res=add(res,Calc(l,r,t)); res=add(res,Calc(l,r,b)); res=add(res,P-min(l,t)); res=add(res,P-min(r,t)); res=add(res,P-min(l,b)); res=add(res,P-min(r,b)); return res;&#125;bool check(int x,int y)&#123; return x&gt;=0 &amp;&amp; x&lt;=n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=m;&#125;void count(int ax,int ay,int bx,int by)&#123; if(check(ax,ay) &amp;&amp; check(bx,by)) &#123; int t=S.count(mp(ax,ay))+S.count(mp(bx,by)); ++s[2]; if(t&gt;0) s[3]=add(s[3],1); if(t&gt;1) s[3]=add(s[3],1),s[4]=add(s[4],1); &#125;&#125;int x[MAXN],y[MAXN];void solve()&#123; for(int i=1;i&lt;=n &amp;&amp; i&lt;=m;++i) s[0]=add(s[0],mul(i,mul(n-i+1,m-i+1))); for(int i=1;i&lt;=k;++i) s[1]=add(s[1],calc1(x[i],y[i])); for(int i=1;i&lt;k;++i) for(int j=i+1;j&lt;=k;++j) &#123; int dx=x[i]-x[j]; int dy=y[i]-y[j]; count(x[i]+dy,y[i]-dx,x[j]+dy,y[j]-dx); count(x[i]-dy,y[i]+dx,x[j]-dy,y[j]+dx); if(abs(dx)+abs(dy) &amp; 1) continue; int X=(dx-dy)&gt;&gt;1,Y=(dx+dy)&gt;&gt;1; count(x[i]-X,y[i]-Y,x[j]+X,y[j]+Y); &#125; s[3]/=3; s[4]/=6;&#125;int main()&#123; n=read(),m=read(); k=read(); for(int i=1;i&lt;=k;++i) &#123; x[i]=read(); y[i]=read(); S.insert(mp(x[i],y[i])); &#125; solve(); int ans=0; for(int i=0;i&lt;=4;++i) if(i&amp;1) ans=add(ans,P-s[i]); else ans=add(ans,s[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5104 Fib数列]]></title>
    <url>%2F2019%2F07%2F10%2Fbzoj-5104-Fib%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[二次剩余 + $BSGS$ . 这个题可以暴力水过去.先找出模 $P=10^9+9​$ 意义下的循环节,发现是 $\frac {P-1} 3​$ .于是 $O(\frac {P-1} 3)​$ 暴力判. 考虑正经一点的,比较优秀的做法.记 $\phi=\frac {\sqrt 5+1} 2​$ ,则数列第 $n​$ 项 $F_n=\frac 1 {\sqrt 5} \cdot (\phi^n-(-\frac 1 \phi)^n)​$ . 注意 $5$ 在模 $P$ 意义下可以开根号,记开出来的根为 $k=383008016$ ,答案为 $x$ ,那么要解的方程化为, $$\phi^x-(-\frac 1 \phi)^x=k\cdot n$$ 换元,令 $t=\phi ^x$ ,则方程化为, $$t^2-(-1)^x\cdot=(k\cdot n)t$$ 得到了 $t$ 的一元二次方程,对 $x$ 为奇数/偶数分别求解.若 $\Delta$ 不为二次剩余,则无解. 否则,求根公式解得 $t​$ ,再根据 $t=\phi ^x​$ 用 $BSGS​$ 解出最小 $x​$ . 瓶颈在 $BSGS​$ 上,时间复杂度 $O(\sqrt P)​$ . 暴力 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;int solve(int n)&#123; if(n==1) return 1; int len=333333336; int a=0,b=1,c; for(int i=2;i&lt;=len;++i) &#123; c=add(a,b); if(c==n) return i; a=b; b=c; &#125; return -1;&#125;int main()&#123; int n=read(); cout&lt;&lt;solve(n)&lt;&lt;endl; return 0;&#125; 正经做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9,inv2=(P+1)&gt;&gt;1;const int k=383008016,phi=691504013;const int Len=(P+1)/3;inline int add(int a,int b)&#123; return ((a+b)%P+P)%P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;bool EulerJudge(int x)&#123; return fpow(x,(P-1)&gt;&gt;1)!=(P-1);&#125;int wi;struct Complex&#123; int x,y;//x+yw Complex(int x=0,int y=0):x(x),y(y) &#123;&#125; Complex operator * (const Complex &amp;rhs) const &#123; int tx=mul(mul(y,rhs.y),wi); tx=add(tx,mul(x,rhs.x)); int ty=add(mul(x,rhs.y),mul(y,rhs.x)); return Complex(tx,ty); &#125; friend Complex operator ^ (Complex a,int b) &#123; Complex res=Complex(1,0); while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res; &#125;&#125;;int Cipolla(int n)&#123; if(!EulerJudge(n)) return -1; srand(time(NULL)); int a; while("RLDAKIOI") &#123; a=rand()%P; wi=add(mul(a,a),-n); if(!EulerJudge(wi)) break; &#125; Complex res=Complex(a,1); res=res^((P+1)&gt;&gt;1); res.x=add(res.x,P); return min(res.x,P-res.x);&#125;map&lt;int,int&gt; mp;int BSGS(int a,int b)//a^x=b&#123; mp.clear(); int m=ceil(sqrt(P)); for(int j=0; j&lt;m; ++j) mp[mul(b,fpow(a,j))]=j; for(int i=1; i&lt;=m; ++i) &#123; int j,val=fpow(a,i*m); if(mp.find(val)!=mp.end()) &#123; j=mp[val]; return i*m-j; &#125; &#125; return P;&#125;int n;int solve(int b,int c,int t)&#123; if(t==-1) return P; t=add(t,-b); t=mul(t,inv2); int x=BSGS(phi,t); if(c==1 &amp;&amp; x%2==0) return P; if(c==-1 &amp;&amp; x%2==1) return P; return x;&#125;int calc(int b,int c)&#123; int Delta=add(mul(b,b),mul(-4,c)); int t=Cipolla(Delta); if(t==-1) return P; return min(solve(b,c,t),solve(b,c,add(P,-t)));&#125;int main()&#123; n=read(); int ans=P; int b=mul(P-k,n); ans=min(ans,calc(b,1));//odd ans=min(ans,calc(b,-1));//even if(ans&lt;P) printf("%d\n",ans); else puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>二次剩余</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2305 游戏]]></title>
    <url>%2F2019%2F07%2F10%2FLoj-2305-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$2-SAT$ . 如果没有地图 $x$ ,每张地图只能选两种车,就是个裸的 $2-SAT$ 问题. 现在有地图 $x$ ,但不超过 $8$ 张.所以可以暴力枚举每张地图 $x$ 不能选哪种车,然后 $2-SAT$ 判断. 注意枚举不能选的车时,只用枚举两种,就已经包含了地图 $x$ 选车的所有情况. $2-SAT$ 问题若有解,输出一组合法解的方法,是对于每个状态 $i$ 与它的对立面 $inv(i)$ 比较所在 $scc$ 编号的大小,选择所在 $scc$ 编号小的状态.这样做是和缩点建反图后 $topsort$ 等价的. 时间复杂度 $O(2^d\cdot (n+m))$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,d;char buf[MAXN],s[10];bool flag[MAXN];int idx(int x,int type)&#123; return x*3+type;&#125;int inv(int id)&#123; int x=id/3; int t=id%3; if(flag[idx(x,0)]==false) return idx(x,3-0-t); if(flag[idx(x,1)]==false) return idx(x,3-1-t); if(flag[idx(x,2)]==false) return idx(x,3-2-t);&#125;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct Edge&#123; int x,y; int hx,hy;&#125;E[MAXN];int dfn[MAXN],low[MAXN],scc[MAXN],cnt,tot;int stk[MAXN],tp,in[MAXN];void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; stk[++tp]=u; in[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(!flag[v]) continue; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v; ++tot; do &#123; v=stk[tp--]; in[v]=0; scc[v]=tot; &#125;while(u!=v); &#125;&#125;bool solve(int st)&#123; for(int i=0;i&lt;n;++i) &#123; if(buf[i]=='x') &#123; int t=st&amp;1; flag[idx(i,0)]=true; flag[idx(i,1)]=true; flag[idx(i,t)]=false; st&gt;&gt;=1; &#125; &#125; memset(head,0,sizeof head); ecnt=0; for(int i=1;i&lt;=m;++i) &#123; int x=idx(E[i].x,E[i].hx); int y=idx(E[i].y,E[i].hy); if(x==y) continue; if(!flag[x]) continue; else if(!flag[y]) addedge(x,inv(x)); else &#123; addedge(x,y); addedge(inv(y),inv(x)); &#125; &#125; memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(scc,0,sizeof scc); memset(in,0,sizeof in); tp=0; tot=0; cnt=0; for(int i=0;i&lt;3*n;++i) if(flag[i] &amp;&amp; !dfn[i]) tarjan(i); for(int i=0;i&lt;3*n;++i) if(flag[i] &amp;&amp; scc[i]==scc[inv(i)]) return false; for(int i=0;i&lt;3*n;++i) &#123; if(flag[i] &amp;&amp; scc[i]&lt;scc[inv(i)]) putchar(i%3+'A'); &#125; puts(""); return true;&#125;int main()&#123; n=read(),d=read(); scanf("%s",buf); for(int i=0;i&lt;n;++i) &#123; flag[idx(i,0)]=true; flag[idx(i,1)]=true; flag[idx(i,2)]=true; if(buf[i]!='x') flag[idx(i,buf[i]-'a')]=false; &#125; m=read(); for(int i=1;i&lt;=m;++i) &#123; E[i].x=read()-1; scanf("%s",s); E[i].hx=s[0]-'A'; E[i].y=read()-1; scanf("%s",s); E[i].hy=s[0]-'A'; &#125; bool f=false; for(int i=0;i&lt;(1&lt;&lt;d);++i) if(solve(i)) &#123; f=true; break; &#125; if(!f) puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2302 整数]]></title>
    <url>%2F2019%2F07%2F09%2FLoj-2302-%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[线段树 + 压位. 可以用线段树维护 $x$ 的每个二进制位,一次加/减法可以拆成 $\log$ 次给某一位 $\pm 1$. 假设给第 $p$ 位 $+1$ ,就向高位找到第一个为 $0$ 的位置 $q$ ,将位置 $q$ 改为 $1$ , $p\sim q-1$ 改为 $0$ . 假设给第 $p$ 位 $-1$ ,就向高位找到第一个为 $1$ 的位置 $q$ ,将位置 $q$ 改为 $0$ , $p\sim q-1$ 改为 $1$ . 这样直接做是 $O(n\cdot \log^2n)$ 的,比较慢.因为只维护 $0/1$ 信息,所以一个比较自然的想法是压位. $b\le 30n$ ,为了方便,将 $30$ 位压在一个 $int$ 里面,这样每次操作只用拆成 $2$ 位. 线段树的第 $i$ 个位置维护了二进制位 $(i-1)\times 30\sim i\times 30-1$ 这些位置上的信息.时间复杂度 $O(n\cdot \log n)$. 细节巨多,巨烦.调了两节课. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;const int Base=30;const int s=(1&lt;&lt;30)-1;int n;struct SegTree&#123; struct node &#123; int val,tag; bool mi,mx; node()&#123;val=0;tag=-1;mi=true;mx=false;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mi=lson.mi&amp;rson.mi; root.mx=lson.mx&amp;rson.mx; &#125; void modifiy(int o,int c) &#123; root.tag=c; if(!c) &#123; root.val=0; root.mi=true; root.mx=false; &#125; else &#123; root.val=s; root.mi=false; root.mx=true; &#125; &#125; void pushdown(int o) &#123; if(root.tag!=-1) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int a,int b)//第b个大位第a小位 &#123; if(l==r) return (root.val&gt;&gt;a)&amp;1; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) return query(o&lt;&lt;1,l,mid,a,b); else return query(o&lt;&lt;1|1,mid+1,r,a,b); &#125; void Rejudge(int o) &#123; root.mi=(!root.val); root.mx=(root.val==s); &#125; void upd_fa(int o) &#123; while(o!=1) &#123; pushup(o&gt;&gt;1); o&gt;&gt;=1; &#125; &#125; int Access(int o,int l,int r,int pos) &#123; if(l==r) return o; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) return Access(o&lt;&lt;1,l,mid,pos); else return Access(o&lt;&lt;1|1,mid+1,r,pos); &#125; int First_Non_Mx(int o,int l,int r,int pos) &#123; if(root.mx) return -1; if(l==r) return l; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) &#123; int res=First_Non_Mx(o&lt;&lt;1,l,mid,pos); if(res==-1) return First_Non_Mx(o&lt;&lt;1|1,mid+1,r,pos); else return res; &#125; else return First_Non_Mx(o&lt;&lt;1|1,mid+1,r,pos); &#125; int First_Non_Mi(int o,int l,int r,int pos) &#123; if(root.mi) return -1; if(l==r) return l; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) &#123; int res=First_Non_Mi(o&lt;&lt;1,l,mid,pos); if(res==-1) return First_Non_Mi(o&lt;&lt;1|1,mid+1,r,pos); else return res; &#125; else return First_Non_Mi(o&lt;&lt;1|1,mid+1,r,pos); &#125; void Add(int o,int l,int r,int a,int b)//在第b个大位+a &#123; if(l==r) &#123; root.val+=a; if(root.val&gt;s) &#123; root.val&amp;=s; int p=First_Non_Mx(1,0,n,l+1); int t=Access(1,0,n,p); Tree[t].val++; Rejudge(t); if(Tree[t].val==1 || Tree[t].val==s) upd_fa(t); if(l+1&lt;=p-1) upd(1,0,n,l+1,p-1,0); &#125; Rejudge(o); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) Add(o&lt;&lt;1,l,mid,a,b); else Add(o&lt;&lt;1|1,mid+1,r,a,b); pushup(o); &#125; void Del(int o,int l,int r,int a,int b)//在第b个大位-a &#123; if(l==r) &#123; if(root.val&gt;=a) &#123; root.val-=a; Rejudge(o); return; &#125; root.val=s+1+root.val-a; Rejudge(o); int p=First_Non_Mi(1,0,n,l+1); int t=Access(1,0,n,p); Tree[t].val--; Rejudge(t); if(Tree[t].val==0 || Tree[t].val==s-1) upd_fa(t); if(l+1&lt;=p-1) upd(1,0,n,l+1,p-1,1); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(b&lt;=mid) Del(o&lt;&lt;1,l,mid,a,b); else Del(o&lt;&lt;1|1,mid+1,r,a,b); pushup(o); &#125;&#125;T;int main()&#123; n=read(); read(),read(),read(); for(int i=1;i&lt;=n;++i) &#123; int tp=read(); if(tp==1) &#123; ll a; scanf("%lld",&amp;a); int b=read(); bool flag=(a&gt;0); a=abs(a); a&lt;&lt;=(b%Base); b/=Base; if(flag) &#123; if(a&amp;s) T.Add(1,0,n,a&amp;s,b); if(a&gt;&gt;Base) T.Add(1,0,n,a&gt;&gt;Base,b+1); &#125; else &#123; if(a&amp;s) T.Del(1,0,n,a&amp;s,b); if(a&gt;&gt;Base) T.Del(1,0,n,a&gt;&gt;Base,b+1); &#125; &#125; else &#123; int k=read(); int ans=T.query(1,0,n,k%Base,k/Base); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4161 Shlw loves matrixI]]></title>
    <url>%2F2019%2F07%2F09%2Fbzoj-4161-Shlw-loves-matrixI%2F</url>
    <content type="text"><![CDATA[常系数线性递推. 矩阵快速幂是 $O(k^3\cdot logn)$ 的,不够优秀.观察式子(后续用 $a$ 代替 $h$ ,用 $f$ 代替 $a$ ), $$a_n=\sum_{i=1}^k f_i\cdot a_{n-i}$$ 注意到任意一项 $a_i$ 都可以被 $\lbrace a_0,a_1,\dots,a_{k-1} \rbrace$ 线性表示,考虑已知 $a_n$ 的线性表示,如何求得 $a_{2n}$ 的线性表示.这里需要利用一个性质,若: $$a_n=\sum_{i=0}^{k-1}b_i\cdot a_i$$ 则, $$a_{n+x}=\sum_{i=0}^{k-1}b_i\cdot a_{i+x}$$ 证明应该是显然的,相当于将 $a_x$ 看做这个数列的首项,递推式都是一样的,所以对应系数也是一样的. 于是,连续用 $2$ 次该性质可得, 这样就用 $\lbrace a_0,a_1,a_2,\dots,a_{2k-2} \rbrace$ 线性表示了 $a_{2n}$ .那么只需要求得 $\lbrace a_k,a_{k+1},a_{k+2},\dots,a_{2k-2} \rbrace$ 的线性表示,然后代进去即可. 像快速幂那样做下去,只用做 $logn$ 次.时间复杂度 $O(k^2\cdot logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e3+10;int n,k,tmp[MAXN&lt;&lt;1];void Mul(int *a,int *b,int *f)&#123; memset(tmp,0,k&lt;&lt;3); for(int i=0;i&lt;k;++i) for(int j=0;j&lt;k;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=2*k-2;i&gt;=k;--i) for(int j=0;j&lt;k;++j) tmp[i-j-1]=add(tmp[i-j-1],mul(tmp[i],f[j])); memcpy(a,tmp,k&lt;&lt;2); &#125;int base[MAXN],ans[MAXN];int solve(int *a,int *f,int N)&#123; if(N&lt;k) return a[N]; base[1]=ans[0]=1; while(N) &#123; if(N&amp;1) Mul(ans,base,f); Mul(base,base,f); N&gt;&gt;=1; &#125; int res=0; for(int i=0;i&lt;k;++i) res=add(res,mul(a[i],ans[i])); return res;&#125;int f[MAXN],a[MAXN];int main()&#123; n=read(),k=read(); for(int i=0;i&lt;k;++i) f[i]=add(read(),P); for(int i=0;i&lt;k;++i) a[i]=add(read(),P); cout&lt;&lt;solve(a,f,n)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>常系数线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2304 泳池]]></title>
    <url>%2F2019%2F07%2F09%2FLoj-2304-%E6%B3%B3%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[$dp$ + 常系数线性递推. 面积恰好 $=K$ 的概率不太好求,考虑求出面积 $\le K$ 与面积 $\le K-1$ 的概率,两者相减即为答案. 设 $f(i,j)$ 表示矩形长为 $i$ ,最下面 $j$ 行都安全,而第 $j+1$ 行至少一个位置危险,最大面积不超过 $K$ 的概率. 记 $g(i,j)$ 表示矩形长为 $i$ ,最下面 $j$ 行都安全,最大面积不超过 $K$ 的概率.则 $g(i,j)=\sum_{p\ge j} f(i,p)$ . 边界为 $g(0,j)=f(0,j)=1,g(i,j)=f(i,j)=0\ (i\cdot j&gt;K)$ .我们需要求得 $g(n,0)$ . 枚举第 $j+1$ 行第一个危险的格子在 $r+1$ 列.那么要求前 $r$ 列 $j+1$ 行都安全, $r+2\sim i$ 列前 $j$ 行安全,第 $r+1$ 列前 $j$ 行安全, 第 $r+1$ 列第 $j+1$ 行危险,则转移有, $$f(i,j)=\sum_{r=0}^{i-1} g(r,j+1)\cdot g(i-r-1,j) \cdot q^j\cdot(1-q)$$ $4$ 个限制依次对应了转移方程中的 $4$ 项. 大力 $dp$ ,时间复杂度为 $O(n^2)$ . 考虑如何优化.注意到当 $n&gt;K$ 时,仅有 $f(i,0)$ 与 $g(i,0)$ 这些项不为 $0$ ,而我们要求的是 $g(n,0)$ . 所以只用考虑它们的转移.将 $j=0$ 代入原来的转移方程,可以发现, $$f(i,0)=g(i,0)=\sum_{r=0}^K g(r,1)\cdot g(i-r-1,0)\cdot (1-q)$$ $g(r,1)$ 最多只有前 $K+1$ 项非 $0$ ,这部分可以通过大力 $dp$ 求出.那么 $g(r,1)\cdot (1-q)$ 就可看做常系数. 求 $g(i,0)$ 就是一个常系数线性递推,递推式的长度为 $K$ .使用 $O(K^2\cdot logn)$ 的大力取模做法即可. 总时间复杂度 $O(K^2\cdot logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=1e3+10;int base[MAXN],ans[MAXN],tmp[MAXN&lt;&lt;1];void Mul(int *a,int *b,int *f,int k)&#123; memset(tmp,0,k&lt;&lt;3); for(int i=0;i&lt;k;++i) for(int j=0;j&lt;k;++j) tmp[i+j]=add(tmp[i+j],mul(a[i],b[j])); for(int i=2*k-2;i&gt;=k;--i) for(int j=0;j&lt;k;++j) tmp[i-j-1]=add(tmp[i-j-1],mul(tmp[i],f[j])); memcpy(a,tmp,k&lt;&lt;2);&#125;int solve(int *a,int *f,int n,int k)&#123; memset(base,0,sizeof base); memset(ans,0,sizeof ans); base[1]=ans[0]=1; while(n) &#123; if(n&amp;1) Mul(ans,base,f,k); Mul(base,base,f,k); n&gt;&gt;=1; &#125; int res=0; for(int i=0;i&lt;k;++i) res=add(res,mul(a[i],ans[i])); return res;&#125;int n,q,pw[MAXN];int f[MAXN][MAXN],g[MAXN][MAXN];int a[MAXN],F[MAXN];int Solve(int k)&#123; memset(f,0,sizeof f); memset(g,0,sizeof g); memset(a,0,sizeof a); memset(F,0,sizeof F); for(int j=0;j&lt;=k+1;++j) g[0][j]=f[0][j]=1; for(int i=1;i&lt;=1000;++i) &#123; for(int j=k/i;j&gt;=0;--j) &#123; int L=j?(i-1-k/j):0; L=max(L,0); int R=min(i-1,k/(j+1)); for(int r=L;r&lt;=R;++r) &#123; int t=mul(pw[j],add(1,P-q)); t=mul(t,mul(g[r][j+1],g[i-1-r][j])); f[i][j]=add(f[i][j],t); &#125; g[i][j]=add(g[i][j+1],f[i][j]); &#125; &#125; if(n&lt;=1000) return g[n][0]; for(int i=0;i&lt;=k;++i) a[i]=g[i][0]; for(int r=0;r&lt;=k;++r) F[r]=mul(g[r][1],add(1,P-q)); return solve(a,F,n,k+1);&#125;int main()&#123; n=read(); int k=read(); int x=read(),y=read(); q=mul(x,inv(y)); pw[0]=1; for(int i=1;i&lt;=k;++i) pw[i]=mul(pw[i-1],q); cout&lt;&lt;add(Solve(k),P-Solve(k-1))&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>常系数线性递推</tag>
        <tag>概率/期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Berlekamp-Massey 算法学习笔记]]></title>
    <url>%2F2019%2F07%2F09%2FBerlekamp-Massey-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在李巨的指引下学了一发. 简称 $BM$ 算法,可以以 $O(n^2)$ 的时间复杂度求解一个长度为 $n$ 的数列的最短线性递推式. 对于数列 $\lbrace a_1,a_2,a_3,\dots,a_n \rbrace$ ,称数列 $\lbrace R_1,R_2,R_3,\dots,R_m \rbrace$ 为其线性递推式,当且仅当下式成立: $$\forall m+1\le i\le n,a_i=\sum_{j=1}^m R_j\cdot a_{i-j}$$ 若它是所有合法线性递推式中长度 $m$ 最小的线性递推式,则称它为数列 $\lbrace a_1,a_2,a_3,\dots,a_n \rbrace$ 的最短线性递推式. 若未特殊说明,接下来的递推式,线性递推式均指 最短线性递推式 , $BM$ 算法的主要思路是从前往后依次考虑每个数,修改当前递推式使其合法,并且满足最短. 尝试由 $\lbrace a_1,a_2,a_3,\dots,a_{i-1} \rbrace$ 的递推式 $\lbrace r_1,r_2,r_3,\dots,r_m \rbrace$ 得出 $\lbrace a_1,a_2,a_3,\dots,a_i \rbrace$ 的递推式. 记递推式被更改的次数为 $cnt$ ,第 $i$ 次修改后得到的递推式为 $R_i$ ,规定 $R_0$ 为空.记递推式 $\lbrace r_1,r_2,r_3,\dots,r_m \rbrace$ 为当前递推式,即 $R_{cnt}$ . 记 $delta_i=a_i-\sum_{j=1}^m r_{j}\cdot a_{i-j}$ ,即用当前递推式算得的值与真实值之间的误差.若 $delta_i=0$ ,则不需要对递推式进行修改,直接考虑下一个元素 $a_{i+1}$ . 否则说明 $R_{cnt}$ 在位置 $i$ 出错了,记 $R_{cnt}$ 第一次出错的位置为 $fail_i$ ,则 $fail_{cnt}=i$ .考虑对 $R_{cnt}$ 进行修改,得到 $R_{cnt+1}$ ,并使得它在位置 $i$ 也成立. 若当前 $cnt=0$ ,说明 $a_i$ 是第一个非零元素,直接将 $R_1$ 置为 $\lbrace 0,0,0,\dots0 \rbrace$ ( $i$ 个 $0$ ) 即可. 否则, $cnt&gt;0$ ,说明之前已经修改过递推式,即存在 $R_k$, 记录 $p=fail_k$ ,尝试在 $R_k$ 的基础上修改,在 $a_i$ 的位置上递推出一个 $-delta_{p}$ 每个位置乘上 $\frac {delta_i} {delta_p}$ ,每个位置再加上原来的 $R_{cnt}$ 就得到合法的 $R_{cnt+1}$ . 将 $R_k$ 的元素全部变成它的相反数,再在前面补上一个 $1$ , $-delta_p$ 就到 $p+1$ 位置上来了.再在前面补 $i-p-1$ 个 $0$ , $-delta_p$ 就到位置 $i$ 上来了. 于是得到 $R_{cnt+1}=\frac {delta_i} {delta_p}*\lbrace 0,0,0,\dots,1,-R_{k_1},-R_{k_2},\dots,-R_{k_M} \rbrace + R_{cnt}$ . $0$ 有 $i-p-1$ 个. 为了保证得到的递推式长度最短,我们需要选取恰当的 $k$ .容易看出,得到的 $R_{cnt+1}$ 的长度为 $\max(i-p+M,m)$ , $M$ 为 $R_k$ 的长度, $m$ 为 $R_{cnt}$ 的长度.于是记录 $M-p$ 最短的递推式作为 $R_k$ . 最坏情况需要更新 $n$ 次递推式,时间复杂度 $O(n^2)$ . 用 $BM$ 得到的最短递推式长度最好要明显小于 $n$ 的一半,否则需要再打些表. 为什么?因为若长度为 $\frac n 2$,可以看做 $\frac n 2$ 个变量列出 $\frac n 2$ 个方程,总能找到解. 所以一个随机数列解出的最短递推式长度就是 $n$ 的一半左右,长度在 $\frac n 2$ 左右说明原数列很可能并没有一定的规律,即,大概率对之后的数据不适用. 另,因为计算中涉及 $\frac {delta_i} {delta_p}$ ,所以 $BM$ 在实数域内求解可能有一定的精度误差.若在模质数意义下,则不用考虑. 板子. $vector$ 下标从 $0$ 开始,要注意处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int inf=P+1;inline int add(int a,int b)&#123; return (a+b)%P;&#125;inline int sub(int a,int b)&#123; return (a-b+P)%P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;#define len(A) A.size()typedef vector&lt;int&gt; poly;poly BerlekampMassey(poly a)&#123; poly R_k,R; int n=a.size(); int p=-inf,Delta; int fail,delta; for(int i=0;i&lt;n;++i) &#123; delta=a[i]; for(int j=0;j&lt;len(R);++j) delta=sub(delta,mul(R[j],a[i-(j+1)])); if(!delta) continue; fail=i; if(p==-inf) &#123; R.resize(i+1); p=fail; Delta=delta; continue; &#125; poly r; int tmp=mul(delta,inv(Delta)); for(int j=1;j&lt;=i-p-1;++j) r.push_back(0); r.push_back(tmp); for(int j=0;j&lt;len(R_k);++j) r.push_back(sub(0,mul(tmp,R_k[j]))); if(len(r)&lt;len(R)) r.resize(len(R)); for(int j=0;j&lt;len(R);++j) r[j]=add(r[j],R[j]); if(len(R)+p&lt;len(R_k)+fail) &#123; R_k=R; Delta=delta; p=fail; &#125; R=r; &#125; return R;&#125;int main()&#123; int n=read(); poly a; for(int i=1;i&lt;=n;++i) a.push_back(read()); poly R=BerlekampMassey(a); int m=R.size(); printf("%u\n",m); for(int i=0;i&lt;m;++i) printf("%d ",R[i]); puts(""); for(int i=m;i&lt;n;++i) &#123; int delta=a[i]; for(int j=0;j&lt;m;++j) delta=sub(delta,mul(R[j],a[i-(j+1)])); assert(!delta); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>构造</tag>
        <tag>BM</tag>
        <tag>常系数线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4557 侦察守卫]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4557-%E4%BE%A6%E5%AF%9F%E5%AE%88%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[树形 $dp$ . 设 $f(i,j)$ 表示将子树 $i$ 内除了最上面 $j$ 层,其余关键点都被覆盖的最小代价. $g(i,j)$ 表示子树 $i$ 内所有关键点都已被覆盖,并且还向上覆盖了 $j$ 层的最小代价. 当前处理节点为 $u$ ,其中一个儿子节点为 $v$ ,有转移 $g(u,j)=\min(g(u,j)+f(v,j), f(u,j+1)+g(v,j+1)),f(u,j)=\sum f(v,j-1)$ . 第一个转移表示让子树 $v$ 内的点来覆盖原来需要覆盖的 $j$ 层.第二个转移比较显然. 最后再贪心考虑 $f,g$ 的前缀/后缀和,即 $f(u,j)\leftarrow f(u,j-1),g(u,j)\leftarrow g(u,j+1)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;void upd(int &amp;x,int y)&#123; x=min(x,y);&#125;const int inf=1e9;const int MAXN=5e5+10;int n,m,d,w[MAXN],flag[MAXN];int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[MAXN][22],g[MAXN][22];void dfs(int u,int fa)&#123; if(flag[u]) f[u][0]=g[u][0]=w[u]; for(int i=1;i&lt;=d;++i) g[u][i]=w[u]; g[u][d+1]=f[u][d+1]=inf; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); for(int j=0;j&lt;=d;++j) g[u][j]=min(g[u][j]+f[v][j],f[u][j+1]+g[v][j+1]); for(int j=d-1;j&gt;=0;--j) upd(g[u][j],g[u][j+1]); f[u][0]=g[u][0]; for(int j=1;j&lt;=d;++j) f[u][j]+=f[v][j-1]; for(int j=1;j&lt;=d;++j) upd(f[u][j],f[u][j-1]); &#125;&#125;int main()&#123; n=read(),d=read(); for(int i=1;i&lt;=n;++i) w[i]=read(); m=read(); for(int i=1;i&lt;=m;++i) flag[read()]=1; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); cout&lt;&lt;g[1][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2718 归程]]></title>
    <url>%2F2019%2F07%2F08%2FLoj-2718-%E5%BD%92%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最短路 + 可持久化并查集. 假设有一个新图,只保留当前没有积水的边,那么一个连通块内的点都可以用车直接到达. 询问出发点为 $v$ 时的答案,就是询问新图中 $v$ 所在联通块内的点到 $1$ 号节点的最短距离.可以先用 $Dijkstra$ 预处理出每个点到 $1$ 的距离. 如果不强制在线,可以将询问离线后按水位线从高到低排序,这样在新图中就只有加边的操作,直接用并查集维护联通情况以及联通块的答案. 强制在线的话,就换成可持久化并查集 (用主席树维护 $fa$ ) ,将边从大到小排序依次加入并更新联通块信息.询问时根据高度二分找到对应的版本,然后回答询问即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXN=4e5+10;int lastans,n,m,Q,K,S;struct Edge&#123; int fr,to,val,h; bool operator &lt; (const Edge &amp;rhs) const &#123; return h==rhs.h?val&gt;rhs.val:h&gt;rhs.h; &#125;&#125;E[MAXN&lt;&lt;1];int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;priority_queue&lt;pii&gt; q;int dis[MAXN],vis[MAXN];void Dijkstra()&#123; dis[1]=0; q.push(mp(0,1)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125;&#125;int rt[MAXN&lt;&lt;1];struct PreSegTree&#123; int nodeidx; struct node &#123; int ls,rs; int fa,dep,mn; &#125;Tree[MAXN*30];#define root Tree[o] void init()&#123;nodeidx=0;&#125; void BuildTree(int &amp;o,int l,int r) &#123; o=++nodeidx; if(l==r) &#123; root.fa=l; root.dep=1; root.mn=dis[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(root.ls,l,mid); BuildTree(root.rs,mid+1,r); &#125; void upd_fa(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++nodeidx; root=Tree[pre]; if(l==r) &#123; root.fa=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd_fa(root.ls,Tree[pre].ls,l,mid,pos,c); else upd_fa(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; void upd_dep(int o,int l,int r,int pos) &#123; if(l==r) &#123; ++root.dep; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd_dep(root.ls,l,mid,pos); else upd_dep(root.rs,mid+1,r,pos); &#125; int query_id(int o,int l,int r,int pos) &#123; if(l==r) return o; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_id(root.ls,l,mid,pos); else return query_id(root.rs,mid+1,r,pos); &#125; int query_fa(int o,int x) &#123; int p=query_id(o,1,n,x); if(Tree[p].fa==x) return p; else return query_fa(o,Tree[p].fa); &#125; void recall(int &amp;o,int pre,int l,int r,int pos) &#123; o=++nodeidx; root=Tree[pre]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) recall(root.ls,Tree[pre].ls,l,mid,pos); else recall(root.rs,Tree[pre].rs,mid+1,r,pos); &#125; void merge(int x,int y,int idx) &#123; if(Tree[x].dep&gt;Tree[y].dep) swap(x,y); upd_fa(rt[idx],rt[idx-1],1,n,Tree[x].fa,Tree[y].fa); recall(rt[idx],rt[idx],1,n,Tree[y].fa); int u=query_id(rt[idx],1,n,Tree[y].fa); int v=query_id(rt[idx],1,n,Tree[x].fa); Tree[u].mn=min(Tree[u].mn,Tree[v].mn); if(Tree[x].dep==Tree[y].dep) upd_dep(rt[idx],1,n,Tree[y].fa); &#125;&#125;T;int H[MAXN&lt;&lt;1];void init()&#123; Dijkstra(); sort(E+1,E+1+m); for(int i=1;i&lt;=m;++i) H[i]=E[m+1-i].h; T.BuildTree(rt[0],1,n); for(int i=1;i&lt;=m;++i) &#123; rt[i]=rt[i-1]; int x=E[i].fr,y=E[i].to; x=T.query_fa(rt[i],x); y=T.query_fa(rt[i],y); if(T.Tree[x].fa!=T.Tree[y].fa) T.merge(x,y,i); &#125;&#125;int solve(int v,int p)&#123; int idx=m+1-(upper_bound(H+1,H+1+m,p)-H); int x=T.query_fa(rt[idx],v); return T.Tree[x].mn;&#125;void Reset()&#123; lastans=0; ecnt=0; memset(head,0,sizeof head); memset(dis,0x7f,sizeof dis); memset(vis,0,sizeof vis); T.init(); rt[0]=0;&#125;int main()&#123; freopen("return.in","r",stdin); freopen("return.out","w",stdout); int T=read(); while(T--) &#123; Reset(); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=(E[i].fr=read()); int v=(E[i].to=read()); E[i].val=read(); E[i].h=read(); addedge(u,v,E[i].val); addedge(v,u,E[i].val); &#125; init(); Q=read(),K=read(),S=read(); while(Q--) &#123; int v=(read()+K*lastans-1)%n+1; int p=(read()+K*lastans)%(S+1); lastans=solve(v,p); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>可持久化</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4555 求和]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4555-%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[第二类斯特林数 + $NTT$ . 第二类斯特林数 $S(n,m)$ 表示将 $n$ 个球放入 $m$ 个相同盒子的方案数. 递推式是 $S(n,m)=S(n-1,m-1)+m\cdot S(n-1,m)$ .即讨论第一个球是否单独占一个盒子. 也可利用容斥原理计算, $$S(n,m)=\frac 1 {m!} \sum_{k=0}^m (-1)^k{m\choose k}(m-k)^n$$ 意义是枚举空盒个数为 $k$ ,剩下的球任意放置.因为盒子相同,所以最后要除以 $m!$ . 回到这道题, $j&lt;i$ 时, $S(i,j)=0$ ,所以 $j$ 的枚举范围可以换成 $n$ .将上面的容斥计算式代到要求的式子里面, 仔细观察,发现第二个 $\sum$ 后面那一坨是一个卷积的形式,令 $a_i=\frac {(-1)^i} {i!},b_i=\frac {\sum_{j=0}^n i^j} {i!}$ , $c=a*b$ ,则 $ans=\sum_{j=0}^n 2^j\cdot j!\cdot c_j$ . 预处理 $a,b,2^j,j!$ ( $b_i$ 的分子是等比数列求和 ) ,用 $NTT$ 计算 $c$ . 空间要开够. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353,G=3;const int MAXN=1e5+10;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int rev[MAXN&lt;&lt;2];void NTT_init(int n,int lim)&#123; for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;lim;++j) if((i&gt;&gt;j)&amp;1) rev[i]|=1&lt;&lt;(lim-j-1); &#125;&#125;void DFT(int *a,int n,bool invflag)&#123; for(int i=0;i&lt;n;++i) &#123; if(i&lt;rev[i]) swap(a[i],a[rev[i]]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int gi=fpow(G,(P-1)/l); if(invflag) gi=inv(gi); int m=l&gt;&gt;1; for(int *p=a;p!=a+n;p+=l) &#123; int g=1; for(int i=0;i&lt;m;++i) &#123; int t=mul(g,p[i+m]); p[i+m]=add(p[i],P-t); p[i]=add(p[i],t); g=mul(g,gi); &#125; &#125; &#125; if(invflag) &#123; int Invn=inv(n); for(int i=0;i&lt;n;++i) a[i]=mul(a[i],Invn); &#125;&#125;int n;int a[MAXN&lt;&lt;2],b[MAXN&lt;&lt;2],c[MAXN&lt;&lt;2];int fac[MAXN],invfac[MAXN],pw[MAXN];void init()&#123; pw[0]=1; for(int i=1;i&lt;=n;++i) pw[i]=mul(pw[i-1],2); fac[0]=invfac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=inv(fac[n]); for(int i=n-1;i&gt;=1;--i) invfac[i]=mul(invfac[i+1],i+1); for(int i=0;i&lt;=n;++i) if(i&amp;1) a[i]=add(P,-invfac[i]); else a[i]=invfac[i]; b[0]=1; b[1]=n+1; for(int i=2;i&lt;=n;++i) &#123; b[i]=add(fpow(i,n+1),P-1); b[i]=mul(b[i],inv(i-1)); b[i]=mul(b[i],invfac[i]); &#125;&#125;int main()&#123; n=read(); init(); int N=1,lim=0; while(N&lt;=2*n) N&lt;&lt;=1,++lim; NTT_init(N,lim); DFT(a,N,false); DFT(b,N,false); for(int i=0;i&lt;N;++i) c[i]=mul(a[i],b[i]); DFT(c,N,true); int ans=0; for(int i=0;i&lt;=n;++i) &#123; int tmp=mul(pw[i],fac[i]); ans=add(ans,mul(tmp,c[i])); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4554 游戏]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4554-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[最大流. 比较明显是个网络流,考虑如何建模. 硬石头将每一行分成了若干块,每一块内最多放一个炸弹,每一列也同理.然后对每一行/列的块建出它们的点,每一块能通过的流量都是 $1$ .对于空地 $(x,y)$ ,就从 $(x,y)$ 所在的行块向 $(x,y)$ 所在的列块连流量为 $1$ 的边就好了. 再建出源汇点连上这些块,跑一个最大流即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e3+10,MAXM=3e5+10,N=51;int n,m,Map[N][N],bx[N][N],by[N][N],tx=0,ty=0;const int inf=1e9;char buf[N];struct Edge&#123; int nx,to,flow;&#125;E[MAXM];int head[MAXN],ecnt=-1;void addedge(int u,int v,int flow)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; head[u]=ecnt;&#125;void ins(int u,int v,int flow)&#123; addedge(u,v,flow); addedge(v,u,0);&#125;int trans(char c)&#123; if(c=='*') return 0; if(c=='x') return 1; return 2;&#125;int cur[MAXN],dis[MAXN],flow[MAXN],dep[MAXN];queue&lt;int&gt; q;bool bfs(int S,int T)&#123; for(int i=1;i&lt;=T;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,Flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; Flow+=f; limit-=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return Flow;&#125;int Dinic(int S,int T)&#123; int Maxflow=0; while(bfs(S,T)) Maxflow+=dfs(S,T,inf); return Maxflow;&#125;void solve()&#123; for(int i=1;i&lt;=n;++i) &#123; ++tx; for(int j=1;j&lt;=m;++j) &#123; bx[i][j]=tx; if(Map[i][j]==2) ++tx; &#125; &#125; for(int j=1;j&lt;=m;++j) &#123; ++ty; for(int i=1;i&lt;=n;++i) &#123; by[i][j]=ty; if(Map[i][j]==2) ++ty; &#125; &#125; int S=tx+ty+1,T=tx+ty+2; for(int i=1;i&lt;=tx;++i) ins(S,i,1); for(int i=1;i&lt;=ty;++i) ins(i+tx,T,1); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(!Map[i][j]) ins(bx[i][j],by[i][j]+tx,1); cout&lt;&lt;Dinic(S,T)&lt;&lt;endl;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) Map[i][j]=trans(buf[j]); &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4553 序列]]></title>
    <url>%2F2019%2F07%2F08%2Fbzoj-4553-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[$cdq$ 分治处理三维偏序. 记位置 $i$ 原本的值为 $a_i$ ,可能出现的最大值为 $mx_i$ ,可能出现的最小值为 $mn_i$ .像普通的 $LIS$ 那样,设 $f(i)$ 表示必须以第 $i$ 个数结尾的 $LIS$ 长度. 因为每次只能有一个位置被修改,不难发现完成转移 $f(i)\leftarrow f(j)+1$ 需要同时满足三个条件, $mx_j\leq a_i,a_j\leq mn_i,j&lt;i​$ . 就是一个三维偏序,贡献又是可结合的,于是用 $cdq$ 分治处理即可.时间复杂度 $O(n\cdot log^2n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,a[MAXN],mx[MAXN],mn[MAXN];int f[MAXN];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=max(bit[x],c); &#125; void rst(int x) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=0; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s=max(s,bit[x]); return s; &#125;&#125;T;struct opt&#123; int x,y,pos; bool operator &lt; (const opt &amp;rhs) const &#123; return y==rhs.y?pos&lt;=rhs.pos:y&lt;=rhs.y; &#125;&#125;q[MAXN];void cdq(int L,int R)&#123; if(L==R) return; int mid=(L+R)&gt;&gt;1; cdq(L,mid); int tot=0; for(int i=L;i&lt;=R;++i) &#123; q[++tot].pos=i; if(i&lt;=mid) q[tot].x=mx[i],q[tot].y=a[i]; else q[tot].x=a[i],q[tot].y=mn[i]; &#125; sort(q+1,q+1+tot); for(int i=1;i&lt;=tot;++i) &#123; if(q[i].pos&lt;=mid) T.add(q[i].x,f[q[i].pos]); else f[q[i].pos]=max(f[q[i].pos],T.sum(q[i].x)+1); &#125; for(int i=1;i&lt;=tot;++i) if(q[i].pos&lt;=mid) T.rst(q[i].x); cdq(mid+1,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; mx[i]=mn[i]=a[i]=read(); f[i]=1; &#125; for(int i=1;i&lt;=m;++i) &#123; int pos=read(),x=read(); mx[pos]=max(mx[pos],x); mn[pos]=min(mn[pos],x); &#125; cdq(1,n); cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 133]]></title>
    <url>%2F2019%2F07%2F08%2FAtcoder-Beginner-Contest-133%2F</url>
    <content type="text"><![CDATA[$F$ 没调出来,炸了. C Remainder Minimization 2019 可以直接大力枚举两个余数是多少,再判断它们是否合法,合法就计入贡献. 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;bool judge(int a,int b,int L,int R)&#123; if(R&lt;a || R&lt;b) return false; int L1=(L-a+2018)/2019,R1=(R-a)/2019; int L2=(L-b+2018)/2019,R2=(R-b)/2019; if(L1&gt;R1 || L2&gt;R2) return false; if(a&lt;b) return L1&lt;=R2; else return L1&lt;R2;&#125;int main()&#123; int L=read(),R=read(); int ans=2019; for(int i=0;i&lt;2019;++i) for(int j=0;j&lt;2019;++j) if(judge(i,j,L,R)) ans=min(ans,i*j%2019); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Rain Flows into Dams 设第 $i$ 座山收到的水为 $x_i$ ,可以把题目中所给的条件表示为方程组的形式. 题目保证 $x$ 有唯一的一组合法解,所以直接将这个方程组解出来,得到的就是那组合法解,过程中不必判断. 尝试手动解.首先将所有方程加起来可以得到 $\sum x_i$ .每两个相邻的方程相减可以得到 $x_3-x_1,x_4-x_2,x_5-x_3,x_6-x_4\dots$ 这些值. 求前缀和就可以得到每个奇数位置与 $x_1$ 的差值,每个偶数位置与 $x_2$ 的差值.再根据 $x_n+x_1$ 将 $x_1$ 以及所有奇数位置的 $x$ 解出,用 $\sum x_i$ 减去奇数位置的总和,得到偶数位置的总和,再根据求得的差分解出所有偶数位置 $x$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n;ll sum=0,a[MAXN],t[MAXN],x[MAXN];void pr()&#123; for(int i=1;i&lt;=n;++i) printf("%lld ",x[i]); puts("");&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) sum+=(a[i]=read()); for(int i=3;i&lt;=n;i+=2) &#123; t[i]=a[i-1]-a[i-2]; t[i]+=t[i-2]; &#125; x[1]=a[n]-t[n]; for(int i=1;i&lt;=n;i+=2) sum-=(x[i]=x[1]+2*(t[i])); if(n==3) &#123; x[2]=sum; pr(); return 0; &#125; ll tot=0,cnt=1; for(int i=4;i&lt;n;i+=2) &#123; t[i]=2*(a[i-1]-a[i-2]); t[i]+=t[i-2]; tot+=t[i]; ++cnt; &#125; x[2]=(sum-tot)/(cnt); for(int i=4;i&lt;n;i+=2) x[i]=x[2]+t[i]; pr(); return 0;&#125; E Virus Tree 2 只需满足每个点与它的父亲颜色不同,每个点与它父亲的父亲颜色不同,每个点的所有儿子颜色不同. 设 $f(i)$ 表示当节点 $i$ 的颜色已被确定时,子树 $i$ 内染色的方案数,随便 $dfs$ 一下即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],ecnt=0;void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;const int P=1e9+7;int add(int a,int b)&#123; return (a + b) % P;&#125;int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int fac[MAXN],invfac[MAXN];int n,k,f[MAXN],Deg[MAXN];int fa[MAXN];int A(int N,int M)&#123; if(N&gt;M) return 0; return mul(fac[M],invfac[M-N]);&#125;int dfs(int u,int num,int Fa)&#123; fa[u]=Fa; if(num&lt;=0) return f[u]=0; int deg=(u==1?Deg[u]:Deg[u]-1); if(!deg) return f[u]=1; if(u==1) f[u]=A(deg,k-1); else f[u]=A(deg,k-2); if(!f[u]) return f[u]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; if(u==1) dfs(v,k-1,u); else dfs(v,k-2,u); f[u]=mul(f[u],f[v]); &#125; return f[u];&#125;int main()&#123; n=read(),k=read(); fac[1]=1; for(int i=2;i&lt;=k;++i) fac[i]=mul(fac[i-1],i); invfac[k]=fpow(fac[k],P-2); for(int i=k-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); ++Deg[u],++Deg[v]; &#125; cout&lt;&lt;mul(dfs(1,k,0),k)&lt;&lt;endl; return 0;&#125; F Colorful Tree 不难发现对于每个询问 $(x,y,u,v)$ 只需要找出 $u\to v$ 的路径上颜色为 $x$ 的边的数目 $cnt$ 以及这些边的总长度 $sum$ .答案就是 $dist(u,v)-sum+cnt\cdot y$ . 询问一段区间某种颜色的数目/权值和,用主席树进行维护.时间复杂度 $O(n\cdot log^n)$ . 树上的主席树并不需要像线段树那样维护 $dfs$ 序.直接在第一次 $dfs$ 时每个点复制父亲的信息,再修改即可.询问就是 $rt[u]+rt[v]-rt[LCA]-rt[LCA.fa]$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct Edge&#123; int nx,to;&#125;E[MAXN&lt;&lt;1];int head[MAXN],ecnt=0;int col[MAXN],val[MAXN];void addedge(int u,int v)&#123; ++ecnt; E[ecnt].nx=head[u]; E[ecnt].to=v; head[u]=ecnt;&#125;void ins(int u,int v)&#123; addedge(u,v); addedge(v,u);&#125;int n,m;int dfn[MAXN],idx=0;int dep[MAXN],fa[MAXN],top[MAXN];int siz[MAXN],mxson[MAXN],dist[MAXN];struct PreSegTree&#123; int nodeidx; struct node &#123; int cnt,sum; int ls,rs; &#125;Tree[MAXN*30]; PreSegTree()&#123;nodeidx=0;Tree[0].cnt=Tree[0].sum=0;&#125;#define root Tree[o] void upd(int &amp;o,int pre,int l,int r,int pos,int c) &#123; o=++nodeidx; root=Tree[pre]; if(!pos) return; if(l==r) &#123; root.cnt++; root.sum+=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,Tree[pre].ls,l,mid,pos,c); else upd(root.rs,Tree[pre].rs,mid+1,r,pos,c); &#125; int query_sum(int o,int l,int r,int pos) &#123; if(!o) return root.sum; if(l==r) return root.sum; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_sum(root.ls,l,mid,pos); else return query_sum(root.rs,mid+1,r,pos); &#125; int query_cnt(int o,int l,int r,int pos) &#123; if(!o) return root.cnt; if(l==r) return root.cnt; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query_cnt(root.ls,l,mid,pos); else return query_cnt(root.rs,mid+1,r,pos); &#125;&#125;T;int rt[MAXN];void dfs1(int u,int Fa)&#123; fa[u]=Fa; dep[u]=dep[Fa]+1; siz[u]=1; T.upd(rt[u],rt[Fa],1,n,col[u],val[u]); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(v==Fa) continue; dist[v]=dist[u]+val[v]; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=E[i].nx) &#123; int v=E[i].to; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;void init()&#123; dfs1(1,0); dfs2(1,1);&#125;int getLCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int Solve(int c,int d,int x,int y)&#123; int LCA=getLCA(x,y); int cnt=0,sum=0; cnt+=T.query_cnt(rt[x],1,n,c)+T.query_cnt(rt[y],1,n,c); cnt-=T.query_cnt(rt[LCA],1,n,c)+T.query_cnt(rt[fa[LCA]],1,n,c); sum+=T.query_sum(rt[x],1,n,c)+T.query_sum(rt[y],1,n,c); sum-=T.query_sum(rt[LCA],1,n,c)+T.query_sum(rt[fa[LCA]],1,n,c); int res=dist[x]+dist[y]-dist[LCA]-dist[fa[LCA]]; return res-sum+d*cnt;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); col[n+i]=read(),val[n+i]=read(); ins(u,n+i); ins(v,n+i); &#125; n=2*n-1; init(); while(m--) &#123; int x=read(),y=read(); int u=read(),v=read(); printf("%d\n",Solve(x,y,u,v)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>树形dp</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4551 树]]></title>
    <url>%2F2019%2F07%2F06%2Fbzoj-4551-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[并查集. 大力用树剖 + 树状数组维护是 $O(n\cdot log^3n)$ 的. 考虑先将操作先全部离线下来,每个标记都打上,对于没有被打标记的点,用并查集将它与它的父亲合并. 然后从后往前处理操作,遇到询问就直接回答,遇到修改,其实是给某个点的标记次数 $-1$ ,删除后用并查集合并. 时间复杂度 $O(n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,Q;char buf[2];int head[MAXN],to[MAXN],nx[MAXN],ecnt=0;void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct opt&#123; int tp,x;&#125;q[MAXN];struct dsu&#123; int fa[MAXN]; void init() &#123; for(int i=1;i&lt;=n;++i) fa[i]=i; &#125; int Find(int x) &#123; if(x==fa[x]) return x; return (fa[x]=Find(fa[x])); &#125; void Merge(int u,int v) &#123; u=Find(u),v=Find(v); if(u!=v) fa[u]=v; &#125;&#125;DSU;int flag[MAXN],Fa[MAXN];void dfs(int u,int f)&#123; Fa[u]=f; if(!flag[u]) DSU.Merge(u,f); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v,u); &#125;&#125;int ans[MAXN],tot=0;int main()&#123; n=read(),Q=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); &#125; flag[1]=1; for(int i=1;i&lt;=Q;++i) &#123; scanf("%s",buf); q[i].tp=(buf[0]=='C'); q[i].x=read(); if(q[i].tp) ++flag[q[i].x]; else ++tot; &#125; int pt=tot; DSU.init(); dfs(1,0); for(int i=Q;i&gt;=1;--i) &#123; int tp=q[i].tp,x=q[i].x; if(!tp) &#123; x=DSU.Find(x); ans[pt--]=x; &#125; else &#123; --flag[x]; if(!flag[x]) DSU.Merge(x,Fa[x]); &#125; &#125; for(int i=1;i&lt;=tot;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4552 排序]]></title>
    <url>%2F2019%2F07%2F04%2Fbzoj-4552-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[二分 + 线段树. 开始以为是中间有多次询问,想了两节课.读题发现,只在最后询问一次,那就很友好了. 操作/贡献都只与相对大小有关,经典套路就是二分答案,将数列变为 $0/1$ 数列,就可以直接用线段树维护了. 时间复杂度 $O(m\cdot log^2n)$ . 修改操作注意特判 $L&gt;R$ 的情况. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,q,a[MAXN];struct SegTree&#123; struct node &#123; int sum,tag; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void BuildTree(int o,int l,int r,int k) &#123; root.tag=-1; if(l==r) &#123; if(a[l]&gt;=k) root.sum=1; else root.sum=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid,k); BuildTree(o&lt;&lt;1|1,mid+1,r,k); pushup(o); &#125; void Modifiy(int o,int l,int r,int c) &#123; root.sum=(r-l+1)*c; root.tag=c; &#125; void pushdown(int o,int l,int r) &#123; if(root.tag!=-1) &#123; int mid=(l+r)&gt;&gt;1; Modifiy(o&lt;&lt;1,l,mid,root.tag); Modifiy(o&lt;&lt;1|1,mid+1,r,root.tag); root.tag=-1; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,l,r,c); return; &#125; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;struct opt&#123; int op,L,R;&#125;Q[MAXN];bool check(int k)&#123; T.BuildTree(1,1,n,k); for(int i=1;i&lt;=m;++i) &#123; int L=Q[i].L,R=Q[i].R; int tot1=T.query(1,1,n,L,R); int tot0=R-L+1-tot1; if(Q[i].op==0) &#123; T.upd(1,1,n,L,L+tot0-1,0); T.upd(1,1,n,L+tot0,R,1); &#125; else &#123; T.upd(1,1,n,L,L+tot1-1,1); T.upd(1,1,n,L+tot1,R,0); &#125; &#125; return (bool)(T.query(1,1,n,q,q));&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=m;++i) &#123; Q[i].op=read(); Q[i].L=read(); Q[i].R=read(); &#125; q=read(); int L=1,R=n,ans=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4550 小奇的博弈]]></title>
    <url>%2F2019%2F07%2F02%2Fbzoj-4550-%E5%B0%8F%E5%A5%87%E7%9A%84%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[$Nimk$ 游戏 + $dp$ 计数. 最优策略下,白棋显然都选择右移,黑棋都选择左移.如果把每对棋子的间隔长度看做一堆石子的石子数目,那么此题就是一个 $Nim$ 游戏的变种,每次最多可以选 $d$ 堆石子进行操作.这个东西叫做 $Nimk$ 游戏. $Nimk$ 游戏先手必败条件:对于每个二进制位 $i$ ,所有石子数目的第 $i$ 位之和为 $d+1$ 的倍数. 即, $\forall i,(\sum_j(a_j&gt;&gt;i)\&amp;1)\mod d+1=0​$ . 转成 $Nimk$ 模型,有 $\frac k 2$ 堆石子,石子总数不超过 $n-k$ 个.求必胜方案数可以用总方案数 $n \choose k$ 减去必败方案数. 令 $f(i,j)$ 表示从第 $0$ 位开始算,已经考虑了二进制的前 $i$ 位,用掉了 $j$ 个石子的方案数.转移有: $$f(i+1,j+x\cdot (d+1)\cdot 2^i)+=f(i,j)\cdot {k/2 \choose x\cdot(d+1)}$$ 枚举 $x$ 进行转移,必败方案数就是 $\sum f(inf,j)\cdot {n-j-k/2\choose k/2}$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;inline void upd(int &amp;a,int b)&#123; a=add(a,b);&#125;const int MAXK=101,MAXN=1e4+10;int C[MAXN][MAXK],f[20][MAXN];int main()&#123; int n=read(),k=read(),d=read(); C[0][0]=1; for(int i=1;i&lt;=n;++i) &#123; C[i][0]=1; for(int j=1;j&lt;=i &amp;&amp; j&lt;=k;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125; f[0][0]=1; for(int i=0;i&lt;=16;++i) for(int j=0;j&lt;=n-k;++j) for(ll x=0;x*(d+1)&lt;=k/2 &amp;&amp; x*(d+1)*(1LL&lt;&lt;i)+j&lt;=n-k;++x) upd(f[i+1][x*(d+1)*(1&lt;&lt;i)+j],mul(f[i][j],C[k/2][x*(d+1)])); int ans=0; for(int j=0;j&lt;=n-k;++j) upd(ans,mul(f[16][j],C[n-j-k/2][k/2])); ans=add(-ans,C[n][k]); ans%=P,ans+=P,ans%=P; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4548 小奇的糖果]]></title>
    <url>%2F2019%2F06%2F29%2Fbzoj-4548-%E5%B0%8F%E5%A5%87%E7%9A%84%E7%B3%96%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[树状数组. 题面有些歧义,线段上/下方的点是指横坐标也落在线段范围内的点.不包含所有颜色是指不包含所有 $k$ 种颜色. 要求不包含所有颜色,即至少有一种颜色没有包含.可以枚举这个颜色 $c$ ,计算不包含 $c$ 时的最大收益. 把所有点按照 $y$ 坐标从小到大排序,依次处理.如果对某一个点,以它的 $y$ 坐标为下边界画矩形,贪心画最大的,往两边拓展,直到遇到不能选的颜色为止.这个就是在对应颜色的 $set$ 里面找一下前驱后继. 以它的 $y$ 坐标为上边界同理,将 $y$ 坐标从大到小排序做上面过程即可.画矩形时的收益用树状数组维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct node&#123; int x,y,col; bool operator &lt; (const node &amp;rhs) const &#123; return y&lt;rhs.y; &#125;&#125;a[MAXN];int n,m,ans=0,v[MAXN];struct FenwickTree&#123; int bit[MAXN]; void init()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125;&#125;T;set&lt;int&gt; s[MAXN];set&lt;int&gt;::iterator it;void solve()&#123; T.init(); for(int i=1;i&lt;=m;++i) &#123; s[i].clear(); s[i].insert(0); s[i].insert(n+1); &#125; for(int i=1,j=1;i&lt;=n;i=j) &#123; while(j&lt;=n &amp;&amp; a[j].y==a[i].y) ++j; for(int k=i;k&lt;j;++k) &#123; int tmp=T.sum(*s[a[k].col].lower_bound(a[k].x)-1); tmp-=T.sum(*--s[a[k].col].upper_bound(a[k].x)); ans=max(ans,tmp); &#125; for(int k=i;k&lt;j;++k) &#123; T.add(a[k].x,1); s[a[k].col].insert(a[k].x); &#125; &#125; for(int i=1;i&lt;=m;++i) for(it=s[i].begin();*it!=n+1;) &#123; int j=*it; ++it; ans=max(ans,T.sum(*it-1)-T.sum(j)); &#125;&#125;int main()&#123; int C=read(); while(C--) &#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i].x=read(); a[i].y=read(); a[i].col=read(); v[i]=a[i].x; &#125; sort(a+1,a+1+n); sort(v+1,v+1+n); int cnt=unique(v+1,v+1+n)-v-1; for(int i=1;i&lt;=n;++i) a[i].x=lower_bound(v+1,v+1+cnt,a[i].x)-v; ans=0; solve(); for(int i=1;i*2&lt;=n;++i) swap(a[i],a[n+1-i]); solve(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190629]]></title>
    <url>%2F2019%2F06%2F29%2Ftest20190629%2F</url>
    <content type="text"><![CDATA[$\%\ nicodafagood$ . $quadratic$ 给 $n$ 个二次项系数为 $1$ 的二次函数,分别求 $x=1\sim n$ 时这 $n$ 个函数中的最小值. $n\leq 10^5$ . 因为二次项贡献固定,所以只需要算一次项和常数项的贡献,就相当于 $n$ 条直线在某个位置的最小值. 用凸包或者李超线段树写一下就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n;int A[MAXN],B[MAXN];ll k[MAXN],b[MAXN];const ll inf=1e18;inline ll calc(int seg,int x)&#123; return k[seg]*x+b[seg];&#125;inline int sgn(ll x)&#123; if(!x) return 0; return x&lt;0?-1:1;&#125;ll ans;struct SegTree&#123; int nodecnt; SegTree()&#123;nodecnt=0;&#125; struct node &#123; int ls,rs,id; ll mi; node()&#123;ls=rs=id=0;mi=inf;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void BuildTree(int l,int r) &#123; int o=++nodecnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; root.ls=nodecnt+1; BuildTree(l,mid); root.rs=nodecnt+1; BuildTree(mid+1,r); &#125; void pushup(int o,int l,int r) &#123; if(root.id) root.mi=k[root.id]&lt;0?calc(root.id,r):calc(root.id,l); else root.mi=inf; if(l&lt;r) &#123; root.mi=min(root.mi,lson.mi); root.mi=min(root.mi,rson.mi); &#125; &#125; void upd(int o,int l,int r,int L,int R,int seg) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!root.id) &#123; root.id=seg; pushup(o,l,r); return; &#125; bool f1=calc(root.id,l)&lt;calc(seg,l); bool f2=calc(root.id,r)&lt;calc(seg,r); if(f1==f2 || l==r) &#123; if(!f1) &#123; root.id=seg; pushup(o,l,r); &#125; return; &#125; int mid=(l+r)&gt;&gt;1; bool f3=calc(root.id,mid)&lt;calc(seg,mid); if(f1==f3) &#123; if(f1) upd(root.rs,mid+1,r,L,R,seg); else upd(root.rs,mid+1,r,L,R,root.id),root.id=seg; &#125; else &#123; if(f1) upd(root.ls,l,mid,L,R,root.id),root.id=seg; else upd(root.ls,l,mid,L,R,seg); &#125; &#125; else &#123; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(root.ls,l,mid,L,R,seg); if(R&gt;mid) upd(root.rs,mid+1,r,L,R,seg); &#125; pushup(o,l,r); &#125; void query(int o,int l,int r,int pos) &#123; if(root.id) &#123; if(k[root.id]&lt;0) ans=min(ans,calc(root.id,min(r,pos))); else ans=min(ans,calc(root.id,max(l,pos))); &#125; if(l==r) &#123; ans=min(ans,root.mi); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) query(root.ls,l,mid,pos); else query(root.rs,mid+1,r,pos); &#125;&#125;T;int main()&#123; freopen("quadratic.in","r",stdin); freopen("quadratic.out","w",stdout); n=read(); b[0]=inf; for(int i=1;i&lt;=n;++i) A[i]=read(); T.BuildTree(1,n); for(int i=1;i&lt;=n;++i) &#123; B[i]=read(); k[i]=-2LL*A[i]; b[i]=1LL*A[i]*A[i]+B[i]; T.upd(1,1,n,1,n,i); &#125; for(int i=1;i&lt;=n;++i) &#123; ans=inf; T.query(1,1,n,i); printf("%lld\n",ans+1LL*i*i); &#125; return 0;&#125; $equation$ 给定 $a,b,p,x$ ,求解 $[1,x]$ 中,满足 $n\cdot a^n\equiv b \mod p$ 的 $n$ 的数目. $0\leq a,b&lt;p\leq 10^6.x\leq 10^{12}.$ 保证 $p$ 为质数. 根据费马小定理,指数可以对 $p-1$ 取模.而 $p$ 的范围比较小,于是直接枚举 $n$ 对 $p-1$ 取模的结果 $i$. 即,在 $[0,p-2]$ 内枚举 $i$ ,对应贡献为满足下面两个条件的 $n$ 的数目. $$n\equiv i (mod\ p-1),n\equiv b\cdot a^{-i}(mod\ p)$$ 用 $CRT$ 求解 $p\cdot (p-1)$ 内的 $n$ ,再计算 $[1,x]$ 内对应 $n$ 数目即可. 时间复杂度 $O(p\cdot logp)$ . $datastructure$ 给定一个长度为 $n$ 的正整数数列 $a$ ,要求支持下列操作,共 $m$ 次. 将区间 $[l,r]$ 内的元素加上 $x$ . 将区间 $[l,r]$ 内的元素开平方,向下取整. 询问区间 $[l,r]$ 内的元素平方总和. 询问区间 $[l,r]$ 内的元素总和. $n,m\leq 10^5,1\leq a_i,x\leq 10^9$ . 考虑用线段树维护询问的答案. 有一档部分分是没有操作 $1$ 的,可以直接做,对每个区间记录元素是否都是 $1$ ,开方时讨论即可. 正解做法类似,不过优化的方法不同.开方 $[l,r]$ 时,先询问 $[l,r]$ 内的最大值 $a$ 与最小值 $b$ . 开方时都向下取整,若 $\sqrt {a}=\sqrt {b}$ ,就将这个区间全部修改为 $\sqrt a$ .若 $a-\sqrt a=b-\sqrt b$ ,就给这个区间全部减去 $a-\sqrt a$ ,因为这个差是关于元素大小不下降的. 若两种情况都不满足,就暴力修改区间内所有元素. 因为一次区间加最多会使得 $logn$ 个结点的 $a-b$ 变化,而变化后我们最多暴力开 $6$ 次方它就变成 $1$ 了,所以操作 $1,2$ 复杂度均摊下来,一次为 $O(logn)$ .于是总时间复杂度 $O(nlogn)$ . $unsigned\ long\ long$ 输出指令是 $\%llu$ .考试写成 $\%u$ 了. $70\to 15$ .]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>李超线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1186]]></title>
    <url>%2F2019%2F06%2F29%2FCF1186%2F</url>
    <content type="text"><![CDATA[$Div.2$ 冲上来就 $pp$ 了前 $4$ 个题,感觉终于可以上个分,然后就 $Unrated$ 了. A Vus the Cossack and a Contest 签到题. 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),m=read(),k=read(); if(n&lt;=m &amp;&amp; n&lt;=k) puts("Yes"); else puts("No"); return 0;&#125; B Vus the Cossack and a Game 题已经被爆破了. 有一个 $n\times m$ 的网格,要在里面放上若干 $1\times 2$ 的骨牌,要求任意两个八连通的格子不能被同时占据,求最多放置的骨牌数目. $n,m\leq 10^9$ . 暂时还不知道有没有可行的做法. C Vus the Cossack and Strings 其实可以直接算 $1$ 的个数是否相同,若相同,则不同的位置一定是偶数个. 因为两个 $1$ 如果对齐放,没有贡献,如果错开放,贡献是 $2$ ,也相当于没有贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int n,m,a[MAXN],b[MAXN];char buf[MAXN];int k[MAXN];void init()&#123; scanf("%s",buf+1); n=strlen(buf+1); for(int i=1;i&lt;=n;++i) a[i]=buf[i]-'0'; scanf("%s",buf+1); m=strlen(buf+1); for(int i=1;i&lt;=m;++i) b[i]=buf[i]-'0';&#125;int query(int l,int r)&#123; return k[r]^k[l-1];&#125;int main()&#123; init(); for(int i=2;i&lt;=n;++i) if(a[i]!=a[i-1]) k[i]^=1; for(int i=1;i&lt;=n;++i) k[i]^=k[i-1]; int ans=0,s=0; for(int i=1;i&lt;=m;++i) if(a[i]!=b[i]) s^=1; if(s==0) ++ans; for(int i=2;i+m-1&lt;=n;++i) &#123; s^=query(i,i+m-1); if(s==0) ++ans; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Vus the Cossack and Numbers 考虑如果将所有数都向下取整,得到的和为 $-sum$ ,那么显然需要将 $sum$ 个数改成向上取整. 只要不是整数都能改,所以改掉 $sum$ 个就可以了. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const double eps=1e-8;int n;double a[MAXN],upv[MAXN],downv[MAXN],delta[MAXN];bool flag[MAXN];void pr()&#123; for(int i=1;i&lt;=n;++i) printf("%d\n",flag[i]?(int)ceil(a[i]):(int)floor(a[i]));&#125;int main()&#123; n=read(); double sum=0; for(int i=1;i&lt;=n;++i) &#123; scanf("%lf",&amp;a[i]); upv[i]=ceil(a[i])-a[i]; downv[i]=floor(a[i])-a[i]; delta[i]=upv[i]-downv[i]; sum-=downv[i]; &#125; for(int i=1;i&lt;=n &amp;&amp; fabs(sum)&gt;eps;++i) if(fabs(delta[i])&gt;eps) flag[i]=true,sum-=1.0; pr(); return 0;&#125; E Vus the Cossack and a Field 可以直接算二维前缀和再相减.记 $f(x,y)$ 表示以 $(1,1)$ 为左上角, $(x,y)$ 为右下角的子矩形的权值和. 那么答案就是 $f(x_2,y_2)-f(x_2,y_1-1)-f(x_1-1,y_2)+f(x_1-1,y_1-1)$ . 先预处理出 $x\leq n,y\leq m$ 内的 $f(x,y)$ ,就是二维前缀和. 然后计算所有的 $f(x,y)$ ,就可以将它分割成整的块的不整的块,不整的块用预处理的前缀和算就好了. F Vus the Cossack and a Graph 待更. 有个贪心的假做法,不知道为什么很多人都用这个水过去了.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4547 小奇的集合]]></title>
    <url>%2F2019%2F06%2F27%2Fbzoj-4547-%E5%B0%8F%E5%A5%87%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[贪心 + 矩阵快速幂. 显然可以贪心,每次取最大的两个数加起来.答案为初始所有元素之和加上每次操作加入的数. 记初始时最大数为 $a$ ,次大数为 $b$ ,因为题目保证答案非负,所以 $a,b$ 不可能都为负. 若 $a,b$ 都非负,那么加入的数就是一个类斐波那契数列,用矩阵快速幂加速计算就可以了. 若 $a&gt;0$ , $b&lt;0$ ,那么就先算出最少要加几次能使得有两个非负数.只要 $k$ 不为 $0$ ,又保证最终答案为非负,那么一定能在 $k$ 次之内得到两个非负数. 这部分贡献可以直接算出,然后再对剩余次数计算类斐波那契数列部分的贡献即可. 记得答案 $+$ 模数后再输出. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=0x7fffffff;const int P=1e7+7;const int inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct Matrix&#123; int A[3][3]; Matrix()&#123;memset(A,0,sizeof A);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=0;k&lt;3;++k) for(int i=0;i&lt;3;++i) for(int j=0;j&lt;3;++j) res.A[i][j]=add(res.A[i][j],mul(A[i][k],rhs.A[k][j])); return res; &#125;&#125;;Matrix fpow(Matrix a,int b)&#123; Matrix res; for(int i=0;i&lt;3;++i) res.A[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;int calc(int a,int b,int k)&#123; assert(k&gt;=0); Matrix trans,st; trans.A[0][0]=trans.A[0][1]=1; trans.A[1][0]=1; trans.A[2][0]=trans.A[2][1]=trans.A[2][2]=1; st.A[0][0]=a; st.A[1][0]=b; st=fpow(trans,k)*st; return st.A[2][0];&#125;int main()&#123; int n=read(),k=read(),ans=0; int a=-inf,b=-inf; while(n--) &#123; int x=read(); ans=add(ans,x); if(x&gt;a) b=a,a=x; else if(x&gt;b) b=x; &#125; if(a&gt;=0 &amp;&amp; b&gt;=0) ans=add(ans,calc(a,b,k)); else &#123; int tmp=(-b+a-1)/a; ans=add(ans,mul(tmp,b)); ans=add(ans,mul(a,mul(inv2,mul(tmp+1,tmp)))); k-=tmp; b=tmp*a+b; if(b&gt;a) swap(a,b); ans=add(ans,calc(a,b,k)); &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1041 圆上的整点]]></title>
    <url>%2F2019%2F06%2F26%2Fbzoj-1041-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[有技巧的大力枚举. 求 $x^2+y^2=r^2$ 的整数解组数,只需要求出 $x,y&gt;0$ 的组数,再 $\times 4,+4$ 即为答案. 方程变形得到 $y^2=(r+x)(r-x)$ ,记 $d=gcd(r+x,r-x)$ ,则 $y^2=d^2\cdot \frac {r+x} d \cdot \frac {r-x} d$ . 记 $u^2=\frac {r+x} d,v^2=\frac {r-x} d,u&gt;v&gt;0$ .则 $2r=d(u^2+v^2),2x=d(u^2-v^2),y=uvd$ . 因为 $d$ 是 $2r$ 的约数,所以大力枚举 $d$ ,再大力枚举 $u$ ,计算出 $v$ 后再验证 $u&gt;v$ 及 $gcd(u,v)=1$ 是否成立即可. 时间复杂度 $O(r^{3\over 4} \cdot \log r)​$ .实际上跑不满,因为枚举 $d​$ 是 $O(r^{1\over 2})​$ 的,而只有 $d​$ 为 $2r​$ 约数时才枚举 $u​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll gcd(ll a,ll b)&#123; if(!b) return a; return gcd(b,a%b);&#125;int check(ll r,ll d,ll u)&#123; ll v2=2*r/d-u*u; ll v=sqrt(v2); if(v*v!=v2) return 0; if(u&lt;=v) return 0; ll x=d*(u*u-v*v); if(x&amp;1) return 0; x/=2; if(gcd(u,v)!=1) return 0; return 1;&#125;int main()&#123; ll r=read(); ll ans=0; for(ll d=1;d*d&lt;=2*r;++d) &#123; if(2*r%d==0) &#123; for(ll u=1;u*u&lt;2*r/d;++u) ans+=check(r,d,u); ll D=2*r/d; if(D!=d) &#123; for(ll u=1;u*u&lt;2*r/D;++u) ans+=check(r,D,u); &#125; &#125; &#125; ans*=4; ans+=4; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4538 网络]]></title>
    <url>%2F2019%2F06%2F25%2Fbzoj-4538-%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[整体二分 + 树状数组. 如果断掉一个点,将经过它的链给撤去,就会比较麻烦.换一个思路,二分答案 $mid$ ,如果所有权值 $\geq mid$ 的链都经过了它,那么真实答案就 $\leq mid$ ,否则 $\geq mid$ . 于是只加入权值 $\geq mid$ 的链,判断该点被覆盖的次数.链的覆盖有一个比较经典的套路,若一条链首尾是 $u,v$ ,就将 $u,v$ 处的权值 $+1$ ,将 $u,v$ 的 $lca$ 以及 $lca$ 的父亲节点的权值 $-1$ ,查询一个点 $x$ 被覆盖的次数,就是查询子树 $x$ 内所有点的权值和.这个可以用一个树状数组来实现. 这些操作是满足整体二分的要求的,所以再套一个整体二分一起处理.时间复杂度 $O(nlog^2n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,m,ans[MAXN],qcnt=0;struct Node&#123; int type,id; int a,b,v,t,x;&#125;q[MAXN&lt;&lt;2],ql[MAXN],qr[MAXN];struct FenwickTree&#123;#define lowbit(x) x&amp;(-x) int bit[MAXN]; void add(int x,int c) &#123; if(!x) return; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)-sum(l-1); &#125;&#125;T;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int fa[MAXN],mxson[MAXN],siz[MAXN];int dep[MAXN],dfnidx=0,dfn[MAXN],top[MAXN];void dfs1(int u,int Fa)&#123; dep[u]=dep[Fa]+1; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++dfnidx; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa[u] &amp;&amp; v!=mxson[u]) dfs2(v,v); &#125;&#125;int LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int val[MAXN],totv=0;int pcnt=0,pos[MAXN];void upd(int a,int b,int k)&#123; int lca=LCA(a,b); T.add(dfn[a],k); T.add(dfn[b],k); T.add(dfn[lca],-k); T.add(dfn[fa[lca]],-k);&#125;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type==2) ans[q[i].id]=val[l]; return; &#125; int mid=val[(l+r)&gt;&gt;1],cntl=0,cntr=0; int tot=0; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type==0) &#123; if(q[i].v&gt;mid) &#123; upd(q[i].a,q[i].b,1); ++tot; qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else if(q[i].type==1) &#123; if(q[i].v&gt;mid) &#123; upd(q[i].a,q[i].b,-1); --tot; qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else &#123; int x=q[i].x; int tmp=T.query(dfn[x],dfn[x]+siz[x]-1); if(tmp&gt;=tot) ql[++cntl]=q[i]; else qr[++cntr]=q[i]; &#125; &#125; for(int i=L;i&lt;=R;++i) if(q[i].type==0 &amp;&amp; q[i].v&gt;mid) upd(q[i].a,q[i].b,-1); else if(q[i].type==1 &amp;&amp; q[i].v&gt;mid) upd(q[i].a,q[i].b,1); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+i+cntl-1]=qr[i]; int Mid=(l+r)&gt;&gt;1; solve(l,Mid,L,L+cntl-1); solve(Mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs1(1,0); dfs2(1,1); for(int i=1;i&lt;=m;++i) &#123; q[i].type=read(); if(q[i].type==0) &#123; q[i].a=read(); q[i].b=read(); q[i].v=read(); val[++totv]=q[i].v; &#125; else if(q[i].type==1) &#123; int t=read(); q[i]=q[t]; q[i].type=1; &#125; else &#123; q[i].x=read(); q[i].id=++qcnt; &#125; &#125; val[++totv]=-1; sort(val+1,val+1+totv); totv=unique(val+1,val+1+totv)-val-1; solve(1,totv,1,m); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>整体二分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3110 K大数查询]]></title>
    <url>%2F2019%2F06%2F23%2Fbzoj-3110-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[整体二分. 整体二分. 因为修改操作对二分答案的贡献是给一段区间 $+1$ ,所以用线段树来维护即可. 一次分治结束后并不能直接重置线段树,因为这样每次操作就和整个序列长度线性相关了. 将修改操作 $+1$ 的部分都 $-1$ 撤回即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,ans[MAXN],qcnt=0;struct Node&#123; int a,b; ll c; int type,id;&#125;q[MAXN&lt;&lt;2],ql[MAXN],qr[MAXN];struct Segtree&#123; struct node &#123; ll sum,tag; node()&#123;sum=0;tag=0;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void modifiy(int o,int c,int l,int r) &#123; root.sum+=1LL*c*(r-l+1); root.tag+=c; &#125; void pushdown(int o,int l,int r) &#123; if(root.tag) &#123; int mid=(l+r)&gt;&gt;1; modifiy(o&lt;&lt;1,root.tag,l,mid); modifiy(o&lt;&lt;1|1,root.tag,mid+1,r); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(l&gt;R || L&gt;r) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c,l,r); return; &#125; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(l&gt;R || L&gt;r) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; pushdown(o,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type==2) ans[q[i].id]=l; return; &#125; int cntl=0,cntr=0; int mid=(l+r)&gt;&gt;1; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type==1) &#123; if(q[i].c&gt;mid) &#123; T.upd(1,1,n,q[i].a,q[i].b,1); qr[++cntr]=q[i]; &#125; else ql[++cntl]=q[i]; &#125; else &#123; ll tmp=T.query(1,1,n,q[i].a,q[i].b); if(tmp&gt;=q[i].c) qr[++cntr]=q[i]; else if(tmp&lt;q[i].c) &#123; q[i].c-=tmp; ql[++cntl]=q[i]; &#125; &#125; &#125; for(int i=L;i&lt;=R;++i) if(q[i].type==1 &amp;&amp; q[i].c&gt;mid) T.upd(1,1,n,q[i].a,q[i].b,-1); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+i+cntl-1]=qr[i]; solve(l,mid,L,L+cntl-1); solve(mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; q[i].type=read(); q[i].a=read(); q[i].b=read(); q[i].c=read(); if(q[i].type==2) q[i].id=++qcnt; &#125; solve(-n,n,1,m); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1901 Dynamic Rankings]]></title>
    <url>%2F2019%2F06%2F21%2Fbzoj-1901-Dynamic-Rankings%2F</url>
    <content type="text"><![CDATA[整体二分. $solve(l,r,L,R)$ 表示当前处理编号在 $L\sim R$ 内的询问与修改操作,询问的答案在 $l\sim r$ 内. 每次处理时,若当前 $l=r$ ,就回答 $L\sim R$ 内的询问. 否则,二分答案 $mid$ ,对于编号在 $L\sim R$ 内的修改操作,按照修改的权值分成 $\le mid,&gt;mid$ 两边,若 $\le mid$ ,就在树状数组里将它对应的位置 $+1$ . 对于编号在 $L\sim R$ 内的询问操作,按照在树状数组中询问区间的权值和 $sum\le k,&gt;k$ 分成两边,若 $&lt;k$ ,就将 $k$ 减去这个 $sum$ . 然后将分出的修改与询问操作分到左右两边,递归解决即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=1e5+10;int n,m,a[MAXN];int ans[MAXN];struct node&#123; int x,y,k,id,type; node()&#123;x=y=k=id=type=0;&#125; node(int x,int y,int k,int id,int type):x(x),y(y),k(k),id(id),type(type) &#123;&#125;&#125;q[MAXN*3],ql[MAXN*3],qr[MAXN*3];struct FenwickTree&#123; int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c; &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x]; return s; &#125; int query(int l,int r) &#123; return sum(r)-sum(l-1); &#125;&#125;T;int cnt=0,qcnt=0;void solve(int l,int r,int L,int R)&#123; if(l&gt;r || L&gt;R) return; if(l==r) &#123; for(int i=L;i&lt;=R;++i) if(q[i].type) ans[q[i].id]=l; return; &#125; int mid=(l+r)&gt;&gt;1,cntl=0,cntr=0; for(int i=L;i&lt;=R;++i) &#123; if(q[i].type) &#123; int sum=T.query(q[i].x,q[i].y); if(sum&gt;=q[i].k) ql[++cntl]=q[i]; else &#123; q[i].k-=sum; qr[++cntr]=q[i]; &#125; &#125; else &#123; if(q[i].x&lt;=mid) &#123; T.add(q[i].id,q[i].y); ql[++cntl]=q[i]; &#125; else qr[++cntr]=q[i]; &#125; &#125; for(int i=1;i&lt;=cntl;++i) if(!ql[i].type) T.add(ql[i].id,-ql[i].y); for(int i=1;i&lt;=cntl;++i) q[L+i-1]=ql[i]; for(int i=1;i&lt;=cntr;++i) q[L+cntl+i-1]=qr[i]; solve(l,mid,L,L+cntl-1); solve(mid+1,r,L+cntl,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); q[++cnt]=node(a[i],1,0,i,0); &#125; for(int i=1;i&lt;=m;++i) &#123; char buf[2]; scanf("%s",buf); if(buf[0]=='Q') &#123; int x=read(),y=read(),k=read(); q[++cnt]=node(x,y,k,++qcnt,1); &#125; else &#123; int x=read(),y=read(); q[++cnt]=node(a[x],-1,0,x,0); a[x]=y; q[++cnt]=node(a[x],1,0,x,0); &#125; &#125; solve(-inf,inf,1,cnt); for(int i=1;i&lt;=qcnt;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>离线</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4540 序列]]></title>
    <url>%2F2019%2F06%2F20%2Fbzoj-4540-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[线段树. 这道题显然有一个莫队的做法,但它是带根号的,不够优秀.考虑用一个 $O(nlogn)$ 的做法解决它. 考虑将询问离线下来,从 $1$ 到 $n$ 依次加入元素,当前已经加入了第 $p$ 个元素,对每个位置维护 $val_i,sum_i$ ,分别表示区间 $[i,p]$ 的最小值,以及 $val_i$ 所有历史版本值之和.若 $i&gt;p$ ,则当前 $val_i=0$ . 加入第 $p$ 个元素后,立即回答所有 $r=p$ 的询问,答案显然是 $\sum_{i=l}^r sum_i$ . 于是我们只需要用一颗线段树来维护 $val,sum$ 这两个值(的区间和)即可. 考虑加入第 $p$ 个元素后如何修改 $val,sum$ .可以通过单调栈求出最小的 $i$ ,使得 $[i,p]$ 内最小值都为 $a_p$ .需要将 $[i,p]$ 这个区间内的 $val$ 都修改成 $a_p$ ,并让区间 $[1,p]$ 内的 $sum$ 加上对应位置新的 $val$. 时间复杂度 $O(nlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,Q,A[MAXN];ll ans[MAXN];struct Query&#123; int l,id; Query(int l=0,int id=0):l(l),id(id) &#123;&#125;&#125;;vector&lt;Query&gt; V[MAXN];int stk[MAXN],tp=0;struct tag&#123; ll a,b,c,d; void init()&#123;a=1;b=c=d=0;&#125; tag(int a,int b,int c,int d):a(a),b(b),c(c),d(d) &#123;&#125; tag()&#123;init();&#125; bool valid() &#123; if(a==1 &amp;&amp; !b &amp;&amp; !c &amp;&amp; !d) return false; return true; &#125; tag operator + (const tag &amp;rhs) const &#123; tag Newtag; Newtag.a=rhs.a*a; Newtag.b=rhs.a*b+rhs.b; Newtag.c=rhs.c*a+c; Newtag.d=rhs.c*b+d+rhs.d; return Newtag; &#125;&#125;;struct SegTree&#123; struct node &#123; ll val,sum,len; tag t; bool TagValid() &#123; return t.valid(); &#125; &#125; Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void BuildTree(int o,int l,int r) &#123; root.val=root.sum=0; root.len=r-l+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void pushup(int o) &#123; root.val=lson.val+rson.val; root.sum=lson.sum+rson.sum; &#125; void Modifiy(int o,tag Newtag) &#123; root.sum+=Newtag.c*root.val+Newtag.d*root.len; root.val=Newtag.a*root.val+Newtag.b*root.len; root.t=root.t+Newtag; &#125; void pushdown(int o) &#123; if(root.TagValid()) &#123; Modifiy(o&lt;&lt;1,root.t); Modifiy(o&lt;&lt;1|1,root.t); (root.t).init(); &#125; &#125; void upd(int o,int l,int r,int L,int R,tag Newtag) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; Modifiy(o,Newtag); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,Newtag); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,Newtag); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; pushdown(o); int mid=(l+r)&gt;&gt;1; ll res=0; if(L&lt;=mid) res+=query(o&lt;&lt;1,l,mid,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,mid+1,r,L,R); return res; &#125;&#125;T;int main()&#123; n=read(),Q=read(); for(int i=1; i&lt;=n; ++i) A[i]=read(); for(int i=1; i&lt;=Q; ++i) &#123; int l=read(),r=read(); V[r].push_back(Query(l,i)); &#125; T.BuildTree(1,1,n); for(int p=1; p&lt;=n; ++p) &#123; while(tp &amp;&amp; A[p]&lt;A[stk[tp]]) --tp; int i=stk[tp]+1; stk[++tp]=p; tag Newtag=tag(0,A[p],0,0); T.upd(1,1,n,i,p,Newtag); Newtag=tag(1,0,1,0); T.upd(1,1,n,1,p,Newtag); int siz=V[p].size(); for(int j=0; j&lt;siz; ++j) ans[V[p][j].id]=T.query(1,1,n,V[p][j].l,p); &#125; for(int i=1; i&lt;=Q; ++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4537 最小公倍数]]></title>
    <url>%2F2019%2F06%2F19%2Fbzoj-4537-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[分块 + 并查集. 如果对于每个询问 $(u,v,a,b)$ ,我们都只加入 $a,b$ 均小于等于该询问的 $a,b$ 的边,那么答案为 $Yes$ 就等价于 $u,v$ 在同一个联通块中,并且这个连通块中有一条边的 $a$ 等于该询问的 $a$ ,有一条边的 $b$ 等于该询问的 $b$ . 若只有 $a$ 这一维的限制,可以将所有边,询问按 $a$ 排序后依次处理,用并查集维护. 但现在有 $a,b$ 两维的限制,而 $m$ 不是很大,考虑分块. 将所有边与询问按照 $a$ 的大小分成 $\sqrt m$ 块,按顺序处理每一块.处理第 $i$ 块的时候,将第 $1\sim i-1$ 块内的边和第 $i$ 块内的询问都拿出来,按照 $b$ 从小到大排序后依次处理,并用并查集维护连通性和联通块内最大的 $a,b$ . 第 $i$ 块内的边也可能产生贡献,因为它们的数量不超过 $\sqrt m$ ,所以每次遇到询问时,将这些边当中合法的加入,这个询问结束后再撤销就好了. 因为要实现可撤销的并查集,所以要按秩合并,不能路径压缩.时间复杂度 $O(m\sqrt m\cdot logm)$ . 注意 $a,b$ 可能为 $0$ ,所以初始化最大值要为 $-1$ .因为这个调了一节课. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;struct node&#123; int u,v,a,b,id; int type;&#125;eq[MAXN],tmp[MAXN];bool cmp1(node A,node B)&#123; return A.a&lt;B.a || (A.a==B.a &amp;&amp; A.type&lt;B.type);&#125;bool cmp2(node A,node B)&#123; return A.b&lt;B.b || (A.b==B.b &amp;&amp; A.type&lt;B.type);&#125;int ans[MAXN];int n,m,q,BlockSize,BlockNum;int L[MAXN],R[MAXN],lpos[MAXN],rpos[MAXN];struct Disjoint_Set_Union&#123; int fa[MAXN],siz[MAXN],maxa[MAXN],maxb[MAXN]; int OperationNum; struct Operation &#123; int x,NewFa,sizx,Orgmaxa,Orgmaxb; &#125;opt[MAXN]; void SaveOperation(int x,int NewFa,int sizx,int Orgmaxa,int Orgmaxb) &#123; int k=++OperationNum; opt[k].x=x; opt[k].NewFa=NewFa; opt[k].sizx=sizx; opt[k].Orgmaxa=Orgmaxa; opt[k].Orgmaxb=Orgmaxb; &#125; void Undo() &#123; while(OperationNum) &#123; int k=OperationNum--; int x=opt[k].x,NewFa=opt[k].NewFa; int sizx=opt[k].sizx; int Orgmaxa=opt[k].Orgmaxa; int Orgmaxb=opt[k].Orgmaxb; if(x!=NewFa) siz[NewFa]-=sizx; fa[x]=x; maxa[NewFa]=Orgmaxa; maxb[NewFa]=Orgmaxb; &#125; &#125; void init() &#123; OperationNum=0; for(int i=1;i&lt;=n;++i) &#123; fa[i]=i; siz[i]=1; maxa[i]=maxb[i]=-1; &#125; &#125; int Find(int x) &#123; if(fa[x]==x) return x; return Find(fa[x]); &#125; void addedge(int u,int v,int a,int b,bool flag) &#123; u=Find(u),v=Find(v); if(u!=v) &#123; if(siz[v]&gt;siz[u]) swap(u,v); if(flag) SaveOperation(v,u,siz[v],maxa[u],maxb[u]); siz[u]+=siz[v]; fa[v]=u; maxa[u]=max(maxa[u],a); maxa[u]=max(maxa[u],maxa[v]); maxb[u]=max(maxb[u],b); maxb[u]=max(maxb[u],maxb[v]); &#125; else &#123; if(flag) SaveOperation(u,u,siz[u],maxa[u],maxb[u]); maxa[u]=max(maxa[u],a); maxb[u]=max(maxb[u],b); &#125; &#125; bool check(int u,int v,int a,int b) &#123; u=Find(u),v=Find(v); if(u!=v) return false; if(maxa[u]!=a || maxb[u]!=b) return false; return true; &#125;&#125;DSU;void solve(int CurBlock)&#123; DSU.init(); int tot=0; for(int i=1;i&lt;L[CurBlock];++i) if(eq[i].type==1) tmp[++tot]=eq[i]; for(int i=L[CurBlock];i&lt;=R[CurBlock];++i) if(eq[i].type==2) tmp[++tot]=eq[i]; sort(tmp+1,tmp+1+tot,cmp2); for(int i=1;i&lt;=tot;++i) &#123; if(tmp[i].type==1) DSU.addedge(tmp[i].u,tmp[i].v,tmp[i].a,tmp[i].b,false); else &#123; if(tmp[i].id==44) &#123; int qq=1; &#125; for(int j=L[CurBlock];j&lt;=R[CurBlock];++j) if(eq[j].type==1 &amp;&amp; eq[j].a&lt;=tmp[i].a &amp;&amp; eq[j].b&lt;=tmp[i].b) DSU.addedge(eq[j].u,eq[j].v,eq[j].a,eq[j].b,true); ans[tmp[i].id]=DSU.check(tmp[i].u,tmp[i].v,tmp[i].a,tmp[i].b); DSU.Undo(); &#125; &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; eq[i].u=read(); eq[i].v=read(); eq[i].a=read(); eq[i].b=read(); eq[i].type=1; &#125; q=read(); for(int i=1;i&lt;=q;++i) &#123; eq[i+m].u=read(); eq[i+m].v=read(); eq[i+m].a=read(); eq[i+m].b=read(); eq[i+m].id=i; eq[i+m].type=2; &#125; sort(eq+1,eq+m+q+1,cmp1); BlockSize=sqrt(m+q); BlockNum=(m+q+BlockSize-1)/BlockSize; for(int i=1;i&lt;=BlockNum;++i) &#123; L[i]=R[i-1]+1; R[i]=L[i]+BlockSize-1; &#125; R[BlockNum]=m+q; for(int i=1;i&lt;=BlockNum;++i) solve(i); for(int i=1;i&lt;=q;++i) puts(ans[i]?"Yes":"No"); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>离线</tag>
        <tag>分块</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4518 征途]]></title>
    <url>%2F2019%2F06%2F18%2Fbzoj-4518-%E5%BE%81%E9%80%94%2F</url>
    <content type="text"><![CDATA[斜率优化 $dp$ . 推一下式子,记第 $i$ 天走的长度为 $t_i$ , $s=\sum t_i$ ,则 $S^2 \cdot m^2=(m\cdot \sum t_i^2)-s^2$ . 由于 $m,s$ 为定值,所以只需要最小化平方和 $\sum t_i^2$ . 设 $f(i,j)$ 表示走了 $i$ 天,恰好走了 $j$ 段路时的最小平方和, $sum_i$ 表示前 $i$ 段路的长度和. 暴力转移有 $f(i,j)=\min \lbrace f(i-1,k)+(sum_j-sum_k)^2,0\leq k&lt;j \rbrace$ ,可以看出暴力转移是 $O(n^3)$ 的. 若固定 $i$ ,可以看出 $j$ 这一维是满足斜率优化的,因为同时与 $j,k$ 有关的项是 $-2sum_j\cdot sum_k$ ,而 $sum_k$ 单调. 于是就可以进行斜率优化了.若用 $k_1$ 转移比 $k_2$ 更优 ( $k_1&gt;k_2$ ) ,由转移方程可得到: $$slope(k_1,k_2)={f(i-1,k_1)+sum_{k_1}^2-f(i-1,k_2)-sum_{k_2}^2 \over sum_{k_1}-sum_{k_2}} &lt; 2sum_j$$ 而斜率 $2sum_j$ 也是单调的,所以并不需要二分,直接暴力跳指针,用单调队列维护下凸壳即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e3+10;int n,m,sum[MAXN],s;ll f[MAXN][MAXN];double sqr(double x)&#123; return x*x;&#125;double slope(int i,int k1,int k2)&#123; return (f[i-1][k1]+sqr(sum[k1])-f[i-1][k2]-sqr(sum[k2]))/(1.0*sum[k1]-1.0*sum[k2]);&#125;int q[MAXN],head,tail;// [head,tail]int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+read(); memset(f,63,sizeof f); f[0][0]=0; for(int i=1;i&lt;=m;++i) &#123; head=tail=0; for(int j=1;j&lt;=n;++j) &#123; while(head&lt;tail &amp;&amp; slope(i,q[head+1],q[head])&lt;2*sum[j]) ++head; int k=q[head]; f[i][j]=f[i-1][k]+1LL*(sum[j]-sum[k])*(sum[j]-sum[k]); while(head&lt;tail &amp;&amp; slope(i,q[tail],q[tail-1])&gt;slope(i,q[tail],j)) --tail; q[++tail]=j; &#125; &#125; cout&lt;&lt;f[m][n]*m-1LL*sum[n]*sum[n]&lt;&lt;endl; return 0;&#125; 更了一个用 $WQS$ 二分的做法. 这道题用 $WQS$ 二分,也称凸优化,可以做到 $O(n\log s_n)$ 的时间复杂度. 定义 $g(i)$ 表示必须走 $i$ 段时的最小 $\sum t_j^2$ .那么我们就是要求 $g(m)$ 的值. 普通的斜率优化其实就是在枚举选了多少段. 二分一个权值 $mid$ ,表示每选一段带来的额外花费,此时得到新的函数 $f(x)=g(x)+mid\cdot x$ . 因为 $g(x)$ 是具有凸性的,所以 $g’(x)$ 是单调的,而 $f’(x)=g’(x)+mid$ ,相当于在左右移动 $g’(x)$ 的零点. 而 $f’(x)$ 的零点就是让 $f(x)$ 取得最小值的点,一次斜率 $dp$ 可以 $O(n)$ 求出,也同时求出了 $f(x)$ 的最小值. 通过二分不断调整 $mid$ ,直到 $f’(x)$ 的零点为 $m$ ,就得到了 $f(m)$ ,再根据 $g(m)=f(m)-mid\cdot m$ 得出答案. 因为实际问题中,这些函数只在整数处才有定义,所以二分权值时也只用在整数中二分. 时间复杂度 $O(n\log s_n)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int read()&#123; int out=0,sgn=1; char jp=getchar(); while(jp!='-' &amp;&amp; (jp&lt;'0' || jp&gt;'9')) jp=getchar(); if(jp=='-') sgn=-1,jp=getchar(); while(jp&gt;='0' &amp;&amp; jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*sgn;&#125;const int MAXN=3e3+10;ll sqr(ll x)&#123; return x*x;&#125;int n,m;ll f[MAXN],g[MAXN],s[MAXN];double slope(int k1,int k2)&#123; return (double)(f[k1]+sqr(s[k1])-f[k2]-sqr(s[k2]))/(double)(s[k1]-s[k2]);&#125;int q[MAXN],head,tail;bool check(ll mid)&#123; q[head=tail=0]=0; for(int i=1;i&lt;=n;++i) &#123; while(head&lt;tail &amp;&amp; slope(q[head+1],q[head])&lt;2*s[i]) ++head; int k=q[head]; f[i]=f[k]+sqr(s[i]-s[k])+mid; g[i]=g[k]+1; while(head&lt;tail &amp;&amp; slope(q[tail-1],q[tail])&gt;slope(q[tail],i)) --tail; q[++tail]=i; &#125; return g[n]&lt;=m;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) s[i]=s[i-1]+read(); ll L=0,R=s[n]*s[n]/m; ll res; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(check(mid)) &#123; res=m*(f[n]-mid*m)-sqr(s[n]); R=mid-1; &#125; else L=mid+1; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4516 生成魔咒]]></title>
    <url>%2F2019%2F06%2F18%2Fbzoj-4516-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%2F</url>
    <content type="text"><![CDATA[$SAM$ . 每次在末尾加入一个字符,再询问当前串本质不同的子串数目. 用 $SAM$ 维护,答案就是所有非根结点的 $maxlen-minlen+1$ 之和,即 $maxlen(u)-maxlen(fa_u)$ 之和. 由于字符集比较大,所以用 $map$ 存边,确定/更换父亲结点时更新答案即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct SuffixAutomaton&#123; map&lt;int,int&gt; ch[MAXN]; int idx,lst; int len[MAXN],fa[MAXN]; ll ans; SuffixAutomaton()&#123;idx=lst=1;ans=0;memset(fa,0,sizeof fa);&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1,ans+=len[np]; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) &#123; fa[np]=q; ans+=len[np]-len[q]; &#125; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; ans+=len[np]-len[nq]; ch[nq]=ch[q]; while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; printf("%lld\n",ans); &#125;&#125;SAM;int main()&#123; int n=read(); for(int i=1;i&lt;=n;++i) SAM.Extend(read()); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1181]]></title>
    <url>%2F2019%2F06%2F18%2FCF1181%2F</url>
    <content type="text"><![CDATA[$Div.2$ 鸽了生物晚自习过来打. A Chunga-Changa 签到题.分类讨论一下就好了. 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll x,y,z;int main()&#123; x=read(),y=read(),z=read(); if((x+y)/z==x/z+y/z) cout&lt;&lt;(x+y)/z&lt;&lt;' '&lt;&lt;0&lt;&lt;endl; else &#123; ll s=x/z+y/z; x%=z,y%=z; if((x+y)/z) cout&lt;&lt;s+1&lt;&lt;' '&lt;&lt;min(z-x,z-y)&lt;&lt;endl; else cout&lt;&lt;s&lt;&lt;0&lt;&lt;endl; &#125; return 0;&#125; B Split a Number 显然应该贪心从最中间的位置切开. 有 $0$ 的话,就从中间往两边分别找第一个合法的位置就好了. 高精度用 $python$ 就很棒. 12345678910111213n = input()s = raw_input()fig = []for i in xrange(1, n): if s[i] != '0': fig.append((max(i, n - i), i))fig.sort()k = fig[0][0]ans = int(s)for i in xrange(min(10, len(fig))): j = fig[i][1] ans = min(ans, int(s[:j]) + int(s[j:]))print ans C Flag 记录 $D(i,j)$ 表示从 $(i,j)$ 往下走,并且满足颜色一直相同能走到的最远位置, $k(i,j)$ 表示从 $(i,j)$ 往右走,并且满足颜色一直相同能走的最远格数. 然后大力枚举 $(i,j)$ ,统计以 $(i,j)$ 为左上角的 $Flag$ 数目即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e3+10;int n,m;int col[MAXN][MAXN];char buf[MAXN];int D[MAXN][MAXN];int k[MAXN][MAXN];const int inf=1e9;struct seg&#123; int val[MAXN&lt;&lt;2];#define root val[o]#define lson val[o&lt;&lt;1]#define rson val[o&lt;&lt;1|1] void bd(int y,int o,int l,int r) &#123; if(l==r) &#123; root=k[l][y]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(y,o&lt;&lt;1,l,mid); bd(y,o&lt;&lt;1|1,mid+1,r); root=min(lson,rson); &#125; int query(int o,int l,int r,int L,int R) &#123; assert(root); if(L&lt;=l &amp;&amp; r&lt;=R) return root; int mid=(l+r)&gt;&gt;1; int s=inf; if(L&lt;=mid) s=min(s,query(o&lt;&lt;1,l,mid,L,R)); if(R&gt;mid) s=min(s,query(o&lt;&lt;1|1,mid+1,r,L,R)); assert(s&gt;=1 &amp;&amp; s&lt;=m); return s; &#125;&#125;T[MAXN];ll calc(int x,int y)&#123; int p1=x; int p2=D[p1][y]+1; if(p2&gt;n) return 0; int p3=D[p2][y]+1; if(p3&gt;n) return 0; int len=p2-p1; if(p3!=p2+len) return 0; if(p3+len-1&gt;n) return 0; if(D[p3][y]&lt;p3+len-1) return 0; return T[y].query(1,1,n,p1,p3+len-1);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; scanf("%s",buf+1); for(int j=1;j&lt;=m;++j) col[i][j]=buf[j]-'a'+1; &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=m;j&gt;=1;--j) if(col[i][j]!=col[i][j+1]) k[i][j]=1; else k[i][j]=k[i][j+1]+1; &#125; for(int j=1;j&lt;=m;++j) &#123; for(int i=n;i&gt;=1;--i) if(col[i][j]!=col[i+1][j]) D[i][j]=i; else D[i][j]=D[i+1][j]; &#125; for(int j=1;j&lt;=m;++j) T[j].bd(j,1,1,n); ll ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) ans+=calc(i,j); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Irrigation 容易发现当所有的城市次数都相等后举办地点一定会出现循环 $1,2,3,\dots,m$ . 记初始 $n$ 轮举办后,举办次数最多的一个城市举办了 $t$ 场,那么根据规则,再举办 $t\cdot m-n$ 场后,即从第 $t\cdot m+1$ 场开始举办城市就会开始出现循环 $1,2,3,\dots,m$ . 可以将询问离线下来,按照时间从前往后顺序进行回答. 一层一层填满下面这个图,边填边回答询问 ( $two\ pointer$ ),用 $treap$ 维护当前可能会被填到的元素就好了. 最后还剩下的询问的答案一定是出现在 $1,2,3,\dots,m$ 的循环中,答案容易得出. E A Story of One Country 尝试倒着做,每次水平或竖直地将一个子矩形切成两个,并且切的时候不能切断任意一个 $castle$ 区域. 如果经过若干次切割后,能使得每个子矩形内都包含了 恰好一个 $castle$ 区域,那么原图就是合法的. 注意到对于同一个子矩形,如果把它内部的 $castle$ 区域用这个 $castle$ 区域的一个非空子集代替,不会使结果变劣,即,若原子矩形是合法的,那么替换后的子矩形仍然是合法的. 又因为题目对切割次数没有限制,所以我们只要能找到一条切割线(水平或竖直)使得切割后得到的两个子矩形内部都含有 $castle$ 区域,且自身不穿过 $castle$ 区域,就称它是合法的,沿着它切开,不会影响最终的答案. 于是我们可以递归解决这个问题,对于当前的子矩形每次找到一条切割线,切割后递归处理得到的两个子矩形.若当前矩形不是恰好包含一个 $castle$ 区域,又找不到合法的切割线,则说明当前子矩形不合法,原图也不合法. 如果每次随意去找一条合法切割线执行上述操作,最坏情况是每次切割后,一个子矩形内只有 $1$ 个 $castle$ 区域,而另一个子矩形内含有剩下所有的 $castle$ 区域,此时的时间复杂度是 $O(n^2logn)$ ,只能通过简单版的数据. 用线段树来维护 $castle$ 区域,每次找出合适的切割使得得到的两个子矩形含有的 $castle$ 区域数目差尽可能小,此时时间复杂度为 $O(nlog^2n)$ ,可以通过所有数据.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>平衡树</tag>
        <tag>线段树</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diverta 2019 Programming Contest 2]]></title>
    <url>%2F2019%2F06%2F17%2Fdiverta-2019-Programming-Contest-2%2F</url>
    <content type="text"><![CDATA[来的时候发现只有一个小时了.然而还是 头铁 开题,怒掉一波 $rating$ . 比赛链接. 官方题解. A Ball Distribution 签到题. 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int main()&#123; int n=read(),k=read(); if(k&gt;1) cout&lt;&lt;n-k; else cout&lt;&lt;0; return 0;&#125; B Picking Up 显然只需要枚举两个点,将它们的坐标差作为 $(p,q)$ 进行计算,其他的 $(p,q)$ 没有用. 然后用并查集或者记忆化搜索随便搞搞就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;int n;pii p[51];int ans=51;int f[51],A,B;map&lt;pii,int&gt; id;int dfs(int x)&#123; if(f[x]!=-1) return f[x]; int&amp; res=f[x]; res=0; if(id.find(make_pair(p[x].first-A,p[x].second-B))!=id.end()) &#123; int y=id[make_pair(p[x].first-A,p[x].second-B)]; if(f[y]!=-1) return 0; else &#123; res=0; return dfs(y); &#125; &#125; return res=1;&#125;void solve(int a,int b)&#123; if(a==-3 &amp;&amp; b==-2) &#123; int d=1; &#125; A=a,B=b; int res=0; memset(f,-1,sizeof f); for(int i=1;i&lt;=n;++i) if(f[i]==-1) res+=dfs(i); ans=min(ans,res);&#125;int main()&#123; n=read(); if(n==1) &#123; puts("1"); return 0; &#125; for(int i=1;i&lt;=n;++i) &#123; p[i].first=read(); p[i].second=read(); id[p[i]]=i; &#125; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) if(i!=j) solve(p[i].first-p[j].first,p[i].second-p[j].second); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; C Successive Subtraction 构造 + 贪心. 首先可以将 $0$ 全部减掉,于是只剩下正/负数. 特判只有正数与只有负数的情况,只有正数就让最小的那个数贡献为负,只有负数就让最大的那个数贡献为负. 否则,正负数都有的情况,答案一定是 $\sum |a_i|$ . 证明的话,考虑只有一个正数的情况,用它去减其他所有数即得 $\sum |a_i|$ .只有一个负数的情况,留下一个正数后,让那个负数减其他所有数,再让留下的正数减它,答案也是 $\sum |a_i|$ . 否则,正负数都至少有 $2$ 个.每次取出两个正数 $x,y$ ,一个负数 $z$ ,连续操作两次,先得到 $z-y$ ,再得到 $x-(z-y)=x+y-z$ . 这样操作后正负数都减少了 $1$ 个,并且每个数的贡献还是 $|a_i|$ ,一直操作,直到正数只有一个或负数只有一个时,执行对应情况的操作即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define int llinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN];int res=0;void solve1()//-&#123; cout&lt;&lt;res+2*a[n]&lt;&lt;endl; int x=a[n]; for(int i=n-1;i&gt;=1;--i) &#123; printf("%lld %lld\n",x,a[i]); x-=a[i]; &#125;&#125;void solve2()//+&#123; cout&lt;&lt;res-2*a[1]&lt;&lt;endl; int x=a[1]; for(int i=2;i&lt;n;++i) &#123; printf("%lld %lld\n",x,a[i]); x-=a[i]; &#125; printf("%lld %lld\n",a[n],x);&#125;int stk1[MAXN],stk2[MAXN];int tp1=0,tp2=0;void solve3()//+,-&#123; cout&lt;&lt;res&lt;&lt;endl; int zr=0; for(int i=1;i&lt;=n;++i) &#123; if(a[i]&gt;0) stk1[++tp1]=a[i]; else if(a[i]&lt;0) stk2[++tp2]=a[i]; else ++zr; &#125; assert(zr!=n); while(zr--) printf("%lld 0\n",stk1[tp1]); assert(tp1 &amp;&amp; tp2); while(tp1!=1 &amp;&amp; tp2!=1) &#123; int x=stk1[tp1]; --tp1; int y=stk1[tp1]; --tp1; int z=stk2[tp2]; --tp2; printf("%lld %lld\n",z,y); printf("%lld %lld\n",x,z-y); stk1[++tp1]=x+y-z; &#125; if(tp1==1) &#123; int x=stk1[tp1]; while(tp2) &#123; printf("%lld %lld\n",x,stk2[tp2]); x-=stk2[tp2--]; &#125; &#125; else &#123; int x=stk2[tp2]; for(int i=1;i&lt;tp1;++i) &#123; printf("%lld %lld\n",x,stk1[i]); x-=stk1[i]; &#125; printf("%lld %lld\n",stk1[tp1],x); &#125;&#125;signed main()&#123; n=read(); bool f1=false,f2=false; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); res+=abs(a[i]); if(a[i]&gt;0) f1=true; if(a[i]&lt;0) f2=true; &#125; sort(a+1,a+1+n); if(!f1) solve1(); else if(!f2) solve2(); else solve3(); return 0;&#125; D Squirrel Merchant 贪心 + 背包. 显然到 $B$ 时可以先把先前在 $A$ 买的东西全部卖掉后再进行操作,不会使结果变劣. 于是就成了 $A$ 买 + $B$ 卖 与 $B$ 买 + $A$ 卖 两个过程.尝试最大化每一步的收益即可. 如 $A$ 买 + $B$ 卖 这个过程,就可以用 $g_A$ 的容量换取 $g_B-g_A$ 的收益.另外的两种同理. 做两次背包即可.时间复杂度 $O(N\cdot \max(g,s,b))$ . 注意开 $long\ long$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int w[4],c[4],V;const int MAXN=5001*5001;int f[MAXN];int solve_package()&#123; memset(f,0,sizeof f); int res=0; for(int j=1;j&lt;=3;++j) &#123; if(c[j]&lt;=0) continue; for(int i=w[j];i&lt;=V;++i) &#123; f[i]=max(f[i],f[i-w[j]]+c[j]); res=max(res,f[i]); &#125; &#125; return res;&#125;int pr[2][4];int main()&#123; V=read(); for(int i=0;i&lt;2;++i) for(int j=1;j&lt;=3;++j) pr[i][j]=read(); for(int i=1;i&lt;=3;++i) &#123; c[i]=pr[1][i]-pr[0][i]; w[i]=pr[0][i]; &#125; V+=solve_package(); for(int i=1;i&lt;=3;++i) &#123; c[i]=pr[0][i]-pr[1][i]; w[i]=pr[1][i]; &#125; V+=solve_package(); cout&lt;&lt;V&lt;&lt;endl; return 0;&#125; E Balanced Piles $dp$ . 先只考虑 $D=1$ 的情况.设 $f(i,j)$ 表示当前最大值为 $i$ ,最大值有 $j$ 个时,操作到最终状态的方案数. 预先给每块砖钦定一个两两不同的优先度,若可以操作多块砖,则优先操作优先度高的砖. 那么若 $i\not=H$ ,可以转移到 $f(i+1,1)$ ,若 $j\not=N$ ,可以转移到 $f(i,j+1)$ .新加入的那块砖插入到原来的 $j$ 块砖中,有 $j+1$ 种方案.所以 $f(i,j)=f(i+1,1)+(j+1)\cdot f(i,j+1)$ ( $i=H$ 或 $j=N$ 除外). 边界是 $f(H,N)=1$ ,答案是 $f(0,N)$ .钦定优先度会使方案数 $\times N!$ ,但我们转移时规定了顺序,即方案数是序列的方案数,所以又要 $/ N!$ ,两者就抵消掉了. 123456789101112131415161718192021int f[MAXN][MAXN];int dfs(int i,int j)&#123; if(f[i][j]!=-1) return f[i][j]; int&amp; res=f[i][j]; res=0; if(i!=H) res=add(res,dfs(i+1,1)); if(j!=N) res=add(res,mul(j+1,dfs(i,j+1))); return res;&#125;int main()&#123; N=read(),H=read(),D=read(); memset(f,-1,sizeof f); f[H][N]=1; cout&lt;&lt;dfs(0,N)&lt;&lt;endl; return 0;&#125; 观察转移形式 $f(i,j)=f(i+1,1)+(j+1)\cdot f(i,j+1)$ ,可发现答案 $f(0,N)$ 就对应了下面这个 $DAG$ 从 $(0,N)$ 到 $(H,N)$ 的路径条数. 边上的数字代表有几条重边 ,图中 $N=4,H=5$ . 经过 奥妙重重 的运算,答案 $f(0,N)=(\sum_{i=1}^N i!)^{H-1}\cdot N!$ . 再来考虑一般的 $D\geq 1$ 的情况. 考虑一个数列 $0=h_0&lt;h_1&lt;\dots &lt;h_K=H$ ,满足 $\forall 0\leq i&lt;K,h_{i+1}-h_i\leq D$ .那么现在要求每次操作的高度 $h$ 能依次构成上面形式的数列,答案就是 $(\sum_{i=1}^N i!)^{K-1}\cdot N!$ . 沿用 $D=1$ 时构造 $DAG$ 的思路,答案对应了下面的 $DAG$ 从 $0$ 到 $N$ 的路径数目. $weight$ 其实就是说重边的数目.图片均来自官方题解. 维护 $f(i)$ 表示 $0\to i$ 的路径条数,并维护 $f$ 的前缀和,即可在 $O(n)$ 内解决此题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int MAXN=1e6+10;int fac[MAXN];inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int N,H,D,sf=0;int f[MAXN],sum[MAXN];int main()&#123; N=read(),H=read(),D=read(); fac[0]=1; for(int i=1;i&lt;=N;++i) &#123; fac[i]=mul(fac[i-1],i); sf=add(sf,fac[i]); &#125; f[0]=1,sum[0]=1; for(int i=1;i&lt;=H;++i) &#123; if(i-D-1&gt;=0) f[i]=add(sum[i-1],P-sum[i-D-1]); else f[i]=sum[i-1]; f[i]=mul(f[i],sf); sum[i]=add(sum[i-1],f[i]); &#125; cout&lt;&lt;mul(mul(f[H],fac[N]),inv(sf))&lt;&lt;endl; return 0;&#125; F Diverta City 构造. 考虑数学归纳法,对于 $N=2$ 的情况,显然可以直接连一条长度 $1$ 的边完成构造. 否则,对于 $N\geq 3$ ,先构造一个 $N-1$ 个点的完全图满足要求,再加入第 $N$ 个点,则只需要考虑从第 $N$ 个点向前 $N-1$ 个点连边的长度. 令 $M$ 为先前构造出的 $N-1$ 个点的图中最长的哈密顿路径长度,令 $a=\lbrace 1,2,4,7,12,20,29,38,52\rbrace$ ,则第 $N$ 个点与第 $i$ 个点相连的边长度为 $(M+1)\cdot a_i$ 即可满足新得到的 $N$ 个点的图也符合要求. 为啥呢?因为任意一条新图的哈密顿路径中,只有 $1$ 条新加入的边( $N$ 为路径起点/终点) , 或 $2$ 条新加入的边( $N$ 不为路径起点/终点),而其余的边一定是 $N-1$ 个点的图中一条哈密顿路径的一部分. 所以新图中的每一条哈密顿路径长度都可以被表示为 $x+(M+1)\cdot a_i$ 或 $x+(M+1)\cdot(a_i+a_j)$ . 其中 $0\leq x\leq M$ .而我们构造的数列 $a$ 是满足所有 $a_i,a_i+a_j$ 都是互异的,所以新图的每条哈密顿路径长度也是互异的,于是得到的新图也满足条件. 当 $N=10$ 时,可以验证此时最长的边为 $96755758040&lt;10^{11}$ 满足限制.每次加点后暴力枚举 $i!/2$ 条哈密顿路径,计算 $M$ .时间复杂度 $O((N+1)!)$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=11;const int a[]=&#123;0,1,2,4,7,12,20,29,38,52&#125;;int n,p[MAXN];ll w[MAXN][MAXN],M;void GetM(int x)&#123; M=0; for(int i=1;i&lt;=x;++i) p[i]=i; do &#123; ll res=0; for(int i=1;i&lt;x;++i) res+=w[p[i]][p[i+1]]; M=max(M,res); &#125;while(next_permutation(p+1,p+1+x));&#125;void solve(int x)&#123; for(int i=1;i&lt;x;++i) w[i][x]=w[x][i]=(M+1)*a[i];&#125;int main()&#123; n=read(); w[1][2]=w[2][1]=1; M=1; for(int i=3;i&lt;=n;++i) &#123; solve(i); GetM(i); &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) printf("%lld ",w[i][j]); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>dp计数</tag>
        <tag>并查集</tag>
        <tag>DAG</tag>
        <tag>构造</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4515 游戏]]></title>
    <url>%2F2019%2F06%2F14%2Fbzoj-4515-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[树链剖分 + 李超线段树. 显然可以先来一个树剖,就成了区间上的问题.每次修改 $(s,t)$ 就拆成 $(s,lca),(lca,t)$ 两段来做. 于是修改操作都是给一条区间加一条线段的形式,询问是问一个区间内点值的最小值. 用李超线段树维护优势线段与区间的答案即可. 时间复杂度 $O(nlog^3n)$ ,但常数比较小,所以能过. 强行上树系列. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const ll inf=123456789123456789;const int MAXN=1e5+10;int ecnt=0,head[MAXN];int to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll dist[MAXN];int mxson[MAXN],siz[MAXN],fa[MAXN],dep[MAXN];int idx=0,dfn[MAXN],rnk[MAXN],top[MAXN],distofa[MAXN];void dfs1(int u,int Fa)&#123; siz[u]=1; fa[u]=Fa; dep[u]=dep[Fa]+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; distofa[v]=val[i]; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp,ll CurDist)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; dist[idx]=CurDist; if(mxson[u]) dfs2(mxson[u],tp,CurDist+distofa[mxson[u]]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v,CurDist+distofa[v]); &#125;&#125;int Query_LCA(int x,int y)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;ll tmp,k[MAXN*50],b[MAXN*50];ll calc(int seg,int x)&#123; return k[seg]*dist[x]+b[seg];&#125;int n,m,cnt=0;ll ans;struct SegTree&#123; int nodecnt; SegTree()&#123;nodecnt=0;&#125; struct node &#123; int ls,rs,id; ll mi; node()&#123;ls=rs=id=0;mi=inf;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void BuildTree(int l,int r) &#123; int o=++nodecnt; if(l==r) return; int mid=(l+r)&gt;&gt;1; root.ls=nodecnt+1; BuildTree(l,mid); root.rs=nodecnt+1; BuildTree(mid+1,r); &#125; void pushup(int o,int l,int r) &#123; if(root.id) root.mi=k[root.id]&lt;0?calc(root.id,r):calc(root.id,l); else root.mi=inf; if(l&lt;r) &#123; root.mi=min(root.mi,lson.mi); root.mi=min(root.mi,rson.mi); &#125; &#125; void upd(int o,int l,int r,int L,int R,int seg) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; if(!root.id) &#123; root.id=seg; pushup(o,l,r); return; &#125; bool f1=calc(root.id,l)&lt;calc(seg,l); bool f2=calc(root.id,r)&lt;calc(seg,r); if(f1==f2 || l==r) &#123; if(!f1) &#123; root.id=seg; pushup(o,l,r); &#125; return; &#125; int mid=(l+r)&gt;&gt;1; bool f3=calc(root.id,mid)&lt;calc(seg,mid); if(f1==f3) &#123; if(f1) upd(root.rs,mid+1,r,L,R,seg); else upd(root.rs,mid+1,r,L,R,root.id),root.id=seg; &#125; else &#123; if(f1) upd(root.ls,l,mid,L,R,root.id),root.id=seg; else upd(root.ls,l,mid,L,R,seg); &#125; &#125; else &#123; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(root.ls,l,mid,L,R,seg); if(R&gt;mid) upd(root.rs,mid+1,r,L,R,seg); &#125; pushup(o,l,r); &#125; void query(int o,int l,int r,int L,int R) &#123; if(root.id) &#123; if(k[root.id]&lt;0) ans=min(ans,calc(root.id,min(r,R))); else ans=min(ans,calc(root.id,max(l,L))); &#125; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; ans=min(ans,root.mi); return; &#125; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) query(root.ls,l,mid,L,R); if(R&gt;mid) query(root.rs,mid+1,r,L,R); &#125;&#125;T;void Modifiy1(int x,int lca,int A,int B)&#123; tmp=B; while(top[x]!=top[lca]) &#123; k[++cnt]=-A; b[cnt]=tmp+1LL*A*dist[dfn[x]]; int L=dfn[top[x]],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp+=1LL*(dist[R]-dist[L]+distofa[top[x]])*A; x=fa[top[x]]; &#125; k[++cnt]=-A; b[cnt]=tmp+1LL*A*dist[dfn[x]]; int L=dfn[lca],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp+=1LL*(dist[R]-dist[L])*A;&#125;void Modifiy2(int x,int lca,int A,int B)&#123; tmp+=1LL*(dist[dfn[x]]-dist[dfn[lca]])*A; while(top[x]!=top[lca]) &#123; k[++cnt]=A; b[cnt]=tmp-1LL*A*dist[dfn[x]]; int L=dfn[top[x]],R=dfn[x]; T.upd(1,1,n,L,R,cnt); tmp-=1LL*(dist[R]-dist[L]+distofa[top[x]])*A; x=fa[top[x]]; &#125; if(x!=lca) &#123; k[++cnt]=A; b[cnt]=tmp-1LL*A*dist[dfn[x]]; int L=dfn[lca]+1,R=dfn[x]; T.upd(1,1,n,L,R,cnt); &#125;&#125;void Query(int x,int lca)&#123; while(top[x]!=top[lca]) &#123; int L=dfn[top[x]],R=dfn[x]; T.query(1,1,n,L,R); x=fa[top[x]]; &#125; int L=dfn[lca],R=dfn[x]; T.query(1,1,n,L,R);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs1(1,0); dfs2(1,1,0); T.BuildTree(1,n); while(m--) &#123; int tp=read(); int x=read(),y=read(); int lca=Query_LCA(x,y); if(tp==1) &#123; int A=read(),B=read(); Modifiy1(x,lca,A,B); Modifiy2(y,lca,A,B); &#125; else &#123; ans=inf; Query(x,lca); Query(y,lca); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树链剖分</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4514 数字配对]]></title>
    <url>%2F2019%2F06%2F12%2Fbzoj-4514-%E6%95%B0%E5%AD%97%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[费用流. 将每个数字 $a_i$ 拆成入点 $p_i$ 和出点 $q_i$,对于 $S\to p_i,q_i\to T$ 连费用为 $0$ ,容量为 $b_i$ 的边. 若 $a_i,a_j$ 之间可以配对,就对于 $p_i\to q_j,p_j\to q_i$ 连费用为 $-c_i\cdot c_j$ ,容量为 $inf$ 的边. 跑 $mcmf$ ,每次 $spfa$ 完之后判一下是否会使得费用 $&gt;0$ ,若会,就加上限制下的最大流量,然后退出即可. 这样做每对的贡献都被算了 $2$ 次,所以最后答案要 $/2$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;int head[MAXN],ecnt=-1,pcnt=0;struct Edge&#123; int to,nx; ll flow,val;&#125;E[MAXN];void addedge(int u,int v,ll flow,ll val)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; E[ecnt].val=val; head[u]=ecnt;&#125;void ins(int u,int v,ll flow,ll val)&#123; addedge(u,v,flow,val); addedge(v,u,0,-val);&#125;int n,a[MAXN],b[MAXN],c[MAXN];int p[MAXN],q[MAXN];bool is_prime(int x)&#123; if(x==1) return false; for(int i=2;i*i&lt;=x;++i) if(x%i==0) return false; return true;&#125;int vis[MAXN],pre[MAXN],lst[MAXN];ll dis[MAXN],flow[MAXN];bool spfa(int S,int T)&#123; for(int i=1;i&lt;=pcnt;++i) dis[i]=inf,flow[i]=inf,vis[i]=0; pre[T]=-1; queue&lt;int&gt; q; dis[S]=0; vis[S]=1; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dis[v]-dis[u]&gt;E[i].val) &#123; dis[v]=dis[u]+E[i].val; pre[v]=u; lst[v]=i; flow[v]=min(flow[u],E[i].flow); if(!vis[v]) &#123; q.push(v); vis[v]=1; &#125; &#125; &#125; &#125; return pre[T]!=-1;&#125;ll mcmf(int S,int T)&#123; ll maxflow=0,mincost=0; while(spfa(S,T)) &#123; if(mincost+flow[T]*dis[T]&gt;0) &#123; ll tmp=-mincost; maxflow+=tmp/dis[T]; return maxflow; &#125; maxflow+=flow[T]; mincost+=flow[T]*dis[T]; int now=T; while(now!=S) &#123; E[lst[now]].flow-=flow[T]; E[lst[now]^1].flow+=flow[T]; now=pre[now]; &#125; &#125; return maxflow;&#125;int main()&#123; memset(head,-1,sizeof head); int S=++pcnt,T=++pcnt; n=read(); for(int i=1;i&lt;=n;++i) p[i]=++pcnt,q[i]=++pcnt; for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) &#123; b[i]=read(); ins(S,p[i],b[i],0); ins(q[i],T,b[i],0); &#125; for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;i;++j) &#123; int x=max(a[i],a[j]),y=min(a[i],a[j]); if(x%y==0 &amp;&amp; is_prime(x/y)) &#123; ins(p[i],q[j],inf,-1LL*c[i]*c[j]); ins(p[j],q[i],inf,-1LL*c[i]*c[j]); &#125; &#125; int ans=mcmf(S,T); cout&lt;&lt;ans/2&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4584 赛艇]]></title>
    <url>%2F2019%2F06%2F12%2Fbzoj-4584-%E8%B5%9B%E8%89%87%2F</url>
    <content type="text"><![CDATA[$dp$ + 组合数学. 如果值域很小,那么可以直接设 $f(i,j)$ 表示考虑了前 $i$ 个人,第 $i$ 个人选 $j$ 的方案数. 于是考虑离散化.将这些区间离散化为 $O(n)$ 个区间,区间按 $l$ 从小到大排序,且互不相交. 设 $f(i,j)$ 表示考虑了前 $i$ 个人,第 $i$ 个人参了赛,且选择的数在第 $j$ 个区间内的方案数. 那么 $1\sim i-1$ 这些人选择的数有在区间 $j$ 内的,也有不在区间 $j$ 内的.若有 $m$ 个在区间 $j$ 内的,区间 $j$ 的长度为 $L$ ,那么方案数为 ${L+m-1\choose m}$ ,因为 $i$ 必须选.而不在区间 $j$ 内的部分就是个前缀和. 于是大力枚举从 $k$ 转移来,前 $p$ 个人都没选在区间 $j$ 内,用前缀和优化一下转移就好了. 时间复杂度 $O(n^3)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=500+10;int n,a[MAXN],b[MAXN],num[MAXN&lt;&lt;1],tot,g[MAXN],C[MAXN],inv[MAXN];void pre_inv()&#123; inv[1]=1; for(int i=2;i&lt;=n;++i) inv[i]=1LL*(P-P/i)*inv[P%i]%P;&#125;int main()&#123; n=read(); pre_inv(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); b[i]=read(); num[++tot]=a[i]; num[++tot]=b[i]+1; &#125; sort(num+1,num+1+tot); tot=unique(num+1,num+1+tot)-num-1; for(int i=1;i&lt;=n;++i) &#123; a[i]=lower_bound(num+1,num+1+tot,a[i])-num; b[i]=lower_bound(num+1,num+1+tot,b[i]+1)-num; &#125; C[0]=1; g[0]=1; for(int j=1;j&lt;tot;++j) &#123; int len=num[j+1]-num[j]; for(int i=1;i&lt;=n;++i) C[i]=mul(mul(C[i-1],len+i-1),inv[i]); for(int i=n;i&gt;=1;--i) &#123; if(a[i]&gt;j || b[i]&lt;j+1) continue; int f=0,m=1,c=len; for(int p=i-1;p&gt;=0;--p) &#123; f=add(f,mul(c,g[p])); if(a[p]&lt;=j &amp;&amp; j+1&lt;=b[p]) c=C[++m]; &#125; g[i]=add(g[i],f); &#125; &#125; int ans=0; for(int i=1;i&lt;=n;++i) ans=add(ans,g[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4596 黑暗前的幻想乡]]></title>
    <url>%2F2019%2F06%2F11%2Fbzoj-4596-%E9%BB%91%E6%9A%97%E5%89%8D%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[矩阵树定理 + 容斥原理. 如果把所有出现的边都加上,直接算生成树个数,可能会包括了有某些公司没有用边的情况. 于是减去 $1$ 个公司不修路,其他公司随便修的方案数.再加上 $2$ 个公司不修路的方案数… 二进制大力枚举每个公司的边考不考虑,用矩阵树定理算方案数,乘上容斥系数即可. 时间复杂度 $O(2^n\cdot n^3)$ . 二进制表示状态的题,下标从 $0$ 开始会方便一些. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;inline int count(int x)&#123; int s=0; while(x) s+=x&amp;1,x&gt;&gt;=1; return s;&#125;const int MAXN=20;typedef pair&lt;int,int&gt; pii;#define mp make_pairint n,ans=0;vector&lt;pii&gt; E[MAXN];int A[MAXN][MAXN];int sgn;void SwapRow(int x,int y,int k)&#123; for(int i=k;i&lt;n;++i) swap(A[x][i],A[y][i]);&#125;void GCD(int x,int y)&#123; if(!A[y][x]) return; int t=A[x][x]/A[y][x]; for(int i=x;i&lt;n;++i) A[x][i]=add(A[x][i],P-mul(t,A[y][i])); SwapRow(x,y,x); sgn*=-1; GCD(x,y);&#125;void Gauss(int x)&#123; if(x==n-1) return; if(!A[x][x]) &#123; for(int i=x+1;i&lt;n;++i) if(A[i][x]) &#123; SwapRow(x,i,x); sgn*=-1; break; &#125; &#125; if(!A[x][x]) return; for(int i=x+1;i&lt;n;++i) if(A[i][x]) GCD(x,i); Gauss(x+1);&#125;int det()&#123; int res=1; sgn=1; Gauss(1); for(int i=1;i&lt;n;++i) res=mul(res,A[i][i]); return add(P,sgn*res);&#125;int main()&#123; n=read(); for(int i=0;i&lt;n-1;++i) &#123; int m=read(); for(int j=1;j&lt;=m;++j) &#123; int u=read(),v=read(); E[i].push_back(mp(u-1,v-1)); &#125; &#125; int mx=1&lt;&lt;(n-1); for(int st=0;st&lt;mx;++st) &#123; memset(A,0,sizeof A); int tot=count(st); for(int i=0;i&lt;n-1;++i) &#123; if((st&gt;&gt;i)&amp;1) continue; int siz=E[i].size(); for(int j=0;j&lt;siz;++j) &#123; int u=E[i][j].first; int v=E[i][j].second; ++A[u][u],++A[v][v]; A[u][v]=add(A[u][v],P-1); A[v][u]=add(A[v][u],P-1); &#125; &#125; if(tot&amp;1) ans=add(ans,P-det()); else ans=add(ans,det()); &#125; cout&lt;&lt;add(ans%P,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>矩阵树定理</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190611]]></title>
    <url>%2F2019%2F06%2F11%2Ftest20190611%2F</url>
    <content type="text"><![CDATA[$noip$ 模拟题? $exam$ 贪心. 显然是每 $k$ 题安排错一次能使得分最小.若能通过安排使得没有 $k$ 个连续正确,那么答案就是 $m$ . 否则,一定会出现连续对 $k$ 次,我们尽量把它们安排在前面,错的题安排在后面.这样后面贡献就是做对的题目数,前面的贡献是连续做对 $x$ 道题目得分.这个得分单独算一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int n,m,k;int calc(int x)&#123; int t=x/k; int tmp=fpow(2,t+1); tmp=add(tmp,P-2-t); tmp=mul(tmp,k); return add(tmp,x);&#125;int main()//use dp to check&#123; freopen("exam.in","r",stdin); freopen("exam.out","w",stdout); n=read(),m=read(),k=read(); m=n-m; int tot=n/k; int ans=0; if(tot&lt;=m) &#123; ans=n-m; cout&lt;&lt;ans&lt;&lt;endl; &#125; else &#123; int x=n-m*k; ans=calc(x); ans=add(ans,mul(m,k-1)); cout&lt;&lt;add(ans%P,P)&lt;&lt;endl; &#125; return 0;&#125; $genes$ 线段树. 其实只有 $n$ 种情况,每次将第一个元素放到最后,并检验当前是否合法,做 $n$ 次即可. 用线段树来维护每个元素当前对应的前缀和就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int MAXN=1e6+10;int n,a[MAXN],sum[MAXN],tot;struct Segtree&#123; int val[MAXN&lt;&lt;2]; int tag[MAXN&lt;&lt;2];#define root val[o]#define lson val[o&lt;&lt;1]#define rson val[o&lt;&lt;1|1] void pushup(int o) &#123; root=min(lson,rson); &#125; void modifiy(int o,int c) &#123; root+=c; tag[o]+=c; &#125; void pushdown(int o) &#123; if(tag[o]) &#123; modifiy(o&lt;&lt;1,tag[o]); modifiy(o&lt;&lt;1|1,tag[o]); tag[o]=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; tag[o]=0; if(l==r) &#123; root=sum[l]; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r,int pos) &#123; if(l==r) return root; int mid=(l+r)&gt;&gt;1; pushdown(o); if(pos&lt;=mid) return query(o&lt;&lt;1,l,mid,pos); else return query(o&lt;&lt;1|1,mid+1,r,pos); &#125; int check() &#123; return val[1]&gt;=0; &#125;&#125;T;int main()//use bf to check&#123; freopen("genes.in","r",stdin); freopen("genes.out","w",stdout); n=read(); for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); sum[i]=sum[i-1]+a[i]; &#125; tot=sum[n]; T.BuildTree(1,1,n); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int tmp=T.query(1,1,n,i); T.upd(1,1,n,i,i,tot-tmp); if(i&gt;1) T.upd(1,1,n,1,i-1,-tmp); if(i&lt;n) T.upd(1,1,n,i+1,n,-tmp); ans+=T.check(); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; $paths$ $dp$ . 其实就是要求两条不相交路径总长最小值.设 $f(i,j)$ 表示当前一条路径的最后一个点是 $i$ ,另一条路径的最后一个点是 $j$ 时的最短长度. 每次用 $f(i,j)$ 去更新 $f(i,1+\max(i,j)),f(1+\max(i,j),j)$ 就可以保证每个点恰好被选一次了. 特殊点和起点终点特判一下就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=1e3+10;const double inf=1e18;int n,x[MAXN],y[MAXN],b1,b2;double dis[MAXN][MAXN],f[MAXN][MAXN];double calcModulus(int i,int j)&#123; return sqrt(1.0*(x[i]-x[j])*(x[i]-x[j])+1.0*(y[i]-y[j])*(y[i]-y[j]));&#125;int main()&#123; freopen("paths.in","r",stdin); freopen("paths.out","w",stdout); n=read(),b1=read()+1,b2=read()+1; for(int i=1; i&lt;=n; ++i) &#123; x[i]=read(); y[i]=read(); for(int j=1; j&lt;i; ++j) dis[i][j]=dis[j][i]=calcModulus(i,j); &#125; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) f[i][j]=inf; f[1][1]=0; for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) &#123; if(i==n &amp;&amp; j==n) break; int k=max(i,j)+1; if(k&gt;n) --k; if(k!=b2) f[k][j]=min(f[k][j],f[i][j]+dis[i][k]); if(k!=b1) f[i][k]=min(f[i][k],f[i][j]+dis[j][k]); &#125; printf("%.2f\n",f[n][n]); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4590 自动刷题机]]></title>
    <url>%2F2019%2F06%2F10%2Fbzoj-4590-%E8%87%AA%E5%8A%A8%E5%88%B7%E9%A2%98%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[二分答案. 不难发现 $n$ 增大,切题数不会增多, $n$ 减小,切题数不会减少. 于是分别二分 $n$ 的最小值与最大值,检验直接模拟操作就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,k,x[MAXN];bool checkmin(ll mid)&#123; int tot=0; ll len=0; for(int i=1;i&lt;=n;++i) &#123; len+=x[i]; len=max(len,0LL); if(len&gt;=mid) len=0,++tot; &#125; if(len&gt;=mid) len=0,++tot; return tot&lt;=k;&#125;ll solvemin()&#123; ll L=1,R=1e18; ll ans=-1; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(checkmin(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; return ans;&#125;bool checkmax(ll mid)&#123; int tot=0; ll len=0; for(int i=1;i&lt;=n;++i) &#123; len+=x[i]; len=max(len,0LL); if(len&gt;=mid) len=0,++tot; &#125; if(len&gt;=mid) len=0,++tot; return tot&gt;=k;&#125;ll solvemax()&#123; ll L=1,R=1e18; ll ans=-1; while(L&lt;=R) &#123; ll mid=(L+R)&gt;&gt;1; if(checkmax(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; return ans;&#125;int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;++i) x[i]=read(); ll a=solvemin(),b=solvemax(); if(a&gt;b || a&lt;0 || b&lt;0) puts("-1"); else cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1173]]></title>
    <url>%2F2019%2F06%2F08%2FCF1173%2F</url>
    <content type="text"><![CDATA[$Div.2$ 官方题解 A Nauuo and Votes 签到题. B Nauuo and Chess 构造题. 可以将所有数沿着第一列与最后一行放成一个 $L$ 形.容易验证一定是合法的. 这样构造, $m=\lfloor \frac n 2 \rfloor+1$ .而考虑首尾两个位置,有$$|r_1-r_n|+|c_1-c_n|\geq n-1$$ 而 $|r_1-r_n|\leq m-1,|c_1-c_n|\leq m-1$ ,所以 $2m-2\geq n-1$ , $m$ 为整数,可得到 $m\geq \lfloor \frac n 2 \rfloor+1$ . 所以这样构造一定是一个最优解. C Nauuo and Cards 策略是如果能不打 $0$ 直接完成,就直接完成,否则先打若干 $0$ ,然后再也不打 $0$ . 考虑如果已经打了若干 $0$ ,开始一直打数字牌,那么此时 $1$ 必定在手中, $2$ 必定在手中或在牌堆的第 $1$ 个位置(打了 $1$ 就会被摸到手中), $3$ 必定在手中或在第 $2$ 个位置,以此类推. 如果有一些牌的位置不合要求,那么我们需要先打空白牌来将他们加入到手中或是放到正确的位置. 在手中可以看做位置 $0$ ,记 $p_i$ 为 $i$ 的初始位置,那么答案就是 $n+\max\limits_{i=1}^n (p_i-i+1)$ . $n$ 是因为要连续打出 $1\sim n$ 这些牌,后面的部分是将 $p_i$ 调整到 $i-1$ 所需打出的 $0$ 的数目. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,a[MAXN],b[MAXN],p[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) p[b[i]=read()]=i; if(p[1]) &#123; int x; for(x=2;p[x]==p[1]+x-1;++x); if(p[x-1]==n) &#123; int y; for(y=x;y&lt;=n &amp;&amp; p[y]&lt;=y-x;++y); if(y&gt;n) &#123; cout&lt;&lt;n-x+1&lt;&lt;endl; return 0; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;++i) ans=max(ans,p[i]-i+1); cout&lt;&lt;ans+n&lt;&lt;endl; return 0;&#125; D Nauuo and Circle $dp$ 计数. 考虑 $dp$ ,设 $f_u$ 表示子树 $u$ 的方案数,先钦定根节点为 $1$ ,最后答案就是 $n\cdot f_1$ . 画子树时,先要给所有儿子,若不为根,还有自己排序,转移有 $f_u=(|son_u|+[u==1])!\cdot \prod\limits_{v \in son_u}f_v$ . 把 $dp$ 的式子展开,可以发现答案就是 $n\cdot \prod\limits _{i=1}^n deg_i$ , $deg$ 表示度数. 待续…]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>codeforces</tag>
        <tag>dp计数</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4805 欧拉函数求和]]></title>
    <url>%2F2019%2F06%2F08%2Fbzoj-4805-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[练习了min_25筛.跑得挺快的. 注意将所有数都当成质数时, $f(x)=x-1$ ,但它并不是个完全积性函数. 所以要拆成 $f(x)=1,g(x)=x$ 两个函数分别预处理,然后相减. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int cnt=0,prime[MAXN],ism[MAXN];ll sumphi[MAXN];void init_prime(int n)&#123; ism[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=n;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125; for(int i=1;i&lt;=cnt;++i) sumphi[i]=sumphi[i-1]+prime[i]-1;&#125;ll calcsum(int x)&#123; return 1LL*(2+x)*(x-1)/2;&#125;int tot=0,w[MAXN],id1[MAXN],id2[MAXN];ll f[MAXN],g[MAXN];int N,sqN;ll S(int n,int j)&#123; if(n&lt;=1 || prime[j]&gt;n) return 0; int id=n; if(id&lt;=sqN) id=id1[id]; else id=id2[N/id]; ll res=g[id]-sumphi[j-1]; for(int k=j;k&lt;=cnt &amp;&amp; 1LL*prime[k]*prime[k]&lt;=n;++k) &#123; ll pw1=prime[k],pw2=prime[k]*prime[k]; for(int e=1;pw2&lt;=n;++e) &#123; ll tmp=pw1/prime[k]*(prime[k]-1); tmp*=S(n/pw1,k+1); tmp+=pw2/prime[k]*(prime[k]-1); res+=tmp; pw1*=prime[k],pw2*=prime[k]; &#125; &#125; return res;&#125;int main()&#123; N=read(); sqN=(sqrt(N)); init_prime(sqN); for(int l=1,r;l&lt;=N;l=r+1) &#123; r=N/(N/l); w[++tot]=N/l; if(N/l&lt;=sqN) id1[N/l]=tot; else id2[N/(N/l)]=tot; &#125; for(int i=1;i&lt;=tot;++i) f[i]=w[i]-1,g[i]=calcsum(w[i]); for(int j=1;j&lt;=cnt;++j) for(int i=1;i&lt;=tot &amp;&amp; prime[j]*prime[j]&lt;=w[i];++i) &#123; int k=w[i]/prime[j]; if(k&lt;=sqN) k=id1[k]; else k=id2[N/k]; g[i]-=1LL*(prime[j])*(g[k]-sumphi[j-1]-j+1); f[i]-=f[k]-j+1; &#125; for(int i=1;i&lt;=tot;++i) g[i]-=f[i]; ll ans=S(N,1)+1; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[min_25筛学习笔记]]></title>
    <url>%2F2019%2F06%2F05%2Fmin-25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一篇比较详细的学习笔记. 由于渲染有点小问题,所以就直接传 $PDF$ 了.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4667 小y的密码]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4667-%E5%B0%8Fy%E7%9A%84%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[排列/组合计数. 限制是否满足只与 $0\sim 9$ 这些数字各自出现了多少次有关.所以可以 $dfs$ 大力枚举这些数字各自的出现次数. 若限制满足,再计算用这些数字能组合出多少 $\leq n$ 的数. 若这些数个数不足 $n$ 的位数,那么就是带重复元素的排列数.注意减掉有前导 $0$ 的情况. 若个数达到了 $n$ 的位数,就枚举从哪一位开始可以不用考虑限制(就相当于数位 $dp$ 里面那个 $limit$ ). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int n,k,limit;int t,pw[11];int a[11],tot[11],fig[11],m=0;int fac[11];ll ans=0;bool check()&#123; if(!m || !a[m]) return false; int mid=a[(m+1)&gt;&gt;1]; ll sum=0; for(int i=1;i&lt;=m &amp;&amp; sum&lt;=limit;++i) &#123; ll tmp=1; for(int j=1;j&lt;=k;++j) tmp*=a[i]-mid; sum+=tmp; &#125; return sum&lt;=limit;&#125;int calc(int x)&#123; int res=fac[x]; for(int i=0;i&lt;=9;++i) res/=fac[tot[i]]; return res;&#125;void solve()&#123; memset(tot,0,sizeof tot); for(int i=1;i&lt;=m;++i) ++tot[a[i]]; if(m&lt;t) &#123; ans+=calc(m); if(tot[0]) &#123; --tot[0]; ans-=calc(m-1); &#125; &#125; else &#123; bool flag=true; int tmp=t; for(int i=t;i&gt;=1;--i) &#123; for(int j=(i==t);j&lt;fig[i];++j) if(tot[j]) &#123; --tot[j]; --tmp; ans+=calc(tmp); ++tot[j]; ++tmp; &#125; if(!tot[fig[i]]) &#123; flag=false; break; &#125; --tot[fig[i]]; --tmp; &#125; ans+=(int)flag; &#125;&#125;void dfs(int x)&#123; if(check()) solve(); if(m==t) return; for(int i=x;i&lt;=9;++i) &#123; ++m; a[m]=i; dfs(i); --m; &#125;&#125;int main()&#123; fac[0]=1; for(int i=1;i&lt;=9;++i) fac[i]=fac[i-1]*i; n=read(),k=read(),limit=read(); while(n) fig[++t]=n%10,n/=10; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4606 DNA]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4606-DNA%2F</url>
    <content type="text"><![CDATA[$dp$ 计数. 求第 $R$ 大,可以想到把某一类的方案数全部算出来,用 $R$ 去减,就和用平衡树求第 $k$ 大,用 $k$ 减 $siz$ 的操作类似. 题面都明示了? 设 $f(i,j,k)$ 表示第 $i$ 个字符填 $j$ ,至少需要分成 $k$ 个不下降段的方案数.倒着 $dp$ 即可. 最后就从前往后匹配,一边匹配一边减就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e4+10;int n,m,a[MAXN],id[400];char s[MAXN],invid[5]=&#123;'A','C','G','T'&#125;;ll f[MAXN][5][11],R;int main()&#123; for(int i=0;i&lt;4;++i) id[invid[i]]=i; id['N']=4; n=read(),m=read(); R=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i) a[i]=id[s[i]]; if(a[n]==4) for(int i=0;i&lt;4;++i) f[n][i][1]=1; else f[n][a[n]][1]=1; for(int i=n-1;i&gt;=1;--i) &#123; if(a[i]==4) &#123; for(int j=0;j&lt;4;++j) for(int k=1;k&lt;=m;++k) for(int l=0;l&lt;4;++l) f[i][j][k]+=f[i+1][l][k-(j&gt;l)]; &#125; else &#123; for(int k=1;k&lt;=m;++k) for(int l=0;l&lt;4;++l) f[i][a[i]][k]+=f[i+1][l][k-(a[i]&gt;l)]; &#125; &#125; for(int i=1;i&lt;=n;++i) for(int j=0;j&lt;4;++j) for(int k=1;k&lt;=m;++k) f[i][j][k]+=f[i][j][k-1]; a[0]=0; for(int i=1;i&lt;=n;++i) &#123; if(a[i]==4) &#123; for(int j=0;j&lt;4;++j) &#123; ll tmp=(j&lt;a[i-1])?f[i][j][m-1]:f[i][j][m]; if(R&gt;tmp) R-=tmp; else &#123; a[i]=j; break; &#125; &#125; &#125; if(a[i]&lt;a[i-1]) --m; printf("%c",invid[a[i]]); &#125; puts(""); return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4600 硬币游戏]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4600-%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[博弈论. 操作一枚硬币,它只能影响到 $c$ 与自己相同的硬币.于是 $SG$ 函数就只需要 $a,b$ 两个状态. 而 $a,b$ 是指数,非常小,所以状态数目也很少,直接暴力计算 $SG$ 函数即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=25;int SG[MAXN][MAXN][MAXN];void init_SG(int maxq)&#123; vector&lt;int&gt; s; int tmp=0; for(int a=0;a&lt;=20;++a) for(int b=0;b&lt;=20;++b) &#123; s.clear(); for(int p=1;p&lt;=20;++p,tmp=0) for(int q=1;q&lt;=maxq &amp;&amp; p*q&lt;=a;++q) &#123; tmp^=SG[maxq][a-p*q][b]; s.push_back(tmp); &#125; for(int p=1;p&lt;=20;++p,tmp=0) for(int q=1;q&lt;=maxq &amp;&amp; p*q&lt;=b;++q) &#123; tmp^=SG[maxq][a][b-p*q]; s.push_back(tmp); &#125; sort(s.begin(),s.end()); int siz=s.size(); if(!siz || s[0]) &#123; SG[maxq][a][b]=0; continue; &#125; for(int i=1;i&lt;siz;++i) &#123; if(s[i]-s[i-1]&gt;=2) &#123; SG[maxq][a][b]=s[i-1]+1; break; &#125; &#125; if(!SG[maxq][a][b]) SG[maxq][a][b]=s[siz-1]+1; &#125;&#125;int n,maxq;int main()&#123; for(int i=1;i&lt;=20;++i) init_SG(i); int T=read(); while(T--) &#123; n=read(),maxq=read(); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int dir=read(); if(dir) continue; int x=i,a=0,b=0; while(x%2==0) ++a,x/=2; while(x%3==0) ++b,x/=3; ans^=SG[maxq][a][b]; &#125; if(ans) puts("win"); else puts("lose"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4602 齿轮]]></title>
    <url>%2F2019%2F06%2F04%2Fbzoj-4602-%E9%BD%BF%E8%BD%AE%2F</url>
    <content type="text"><![CDATA[图的 $dfs$ 遍历. 方向和速度显然可以分开判. 方向就是判二分图.而对于速度,走过一条边,相对速度可以看做乘了一个比值. 因为 $x,y\leq 100$ ,所以可以直接分解质因数,像染色那样做就可以了. 时间复杂度 $O(25m)$ . 另外一种更优雅的方法是直接在模大质数意义下做乘除法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;int ism[101],cnt=0,prime[101];void init_prime()&#123; ism[1]=1; for(int i=2;i&lt;=100;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=100;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int ecnt,head[MAXN];struct edge&#123; int to,nx; int dir; int x,y;&#125;E[MAXN&lt;&lt;1];void addedge(int u,int v,int x,int y)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].dir=(x*y&lt;0)?-1:1; E[ecnt].x=abs(x); E[ecnt].y=abs(y); head[u]=ecnt;&#125;int n,m;int dir[MAXN],factor[MAXN][26];void init()&#123; ecnt=0; memset(head,0,sizeof head); memset(dir,0,sizeof dir); memset(factor,0,sizeof factor);&#125;int transfac[26];void add(int x,int c)&#123; for(int i=1;i&lt;=cnt &amp;&amp; prime[i]&lt;=x;++i) while(x%prime[i]==0) &#123; x/=prime[i]; transfac[i]+=c; &#125;&#125;bool dfs(int u)&#123; bool flag=true; for(int i=head[u];i &amp;&amp; flag;i=E[i].nx) &#123; int v=E[i].to; memset(transfac,0,sizeof transfac); add(E[i].y,1); add(E[i].x,-1); if(dir[v]) &#123; if(dir[u]*E[i].dir!=dir[v]) return false; for(int i=1;i&lt;=25;++i) if(factor[u][i]+transfac[i]!=factor[v][i]) return false; &#125; else &#123; dir[v]=dir[u]*E[i].dir; for(int i=1;i&lt;=25;++i) factor[v][i]=factor[u][i]+transfac[i]; flag&amp;=dfs(v); &#125; &#125; return flag;&#125;int main()&#123; init_prime(); int T=read(); for(int casenum=1;casenum&lt;=T;++casenum) &#123; init(); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),x=read(),y=read(); addedge(u,v,x,y); addedge(v,u,y,x); &#125; bool flag=true; for(int i=1;i&lt;=n &amp;&amp; flag;++i) if(!dir[i]) &#123; dir[i]=1; flag&amp;=dfs(i); &#125; if(flag) printf("Case #%d: Yes\n",casenum); else printf("Case #%d: No\n",casenum); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4627 回转寿司]]></title>
    <url>%2F2019%2F06%2F03%2Fbzoj-4627-%E5%9B%9E%E8%BD%AC%E5%AF%BF%E5%8F%B8%2F</url>
    <content type="text"><![CDATA[线段树. 区间和可以转化为前缀和之差.记前缀和为 $sum$ ,从前往后加入数,加入到第 $i$ 个数的时候,就要算 $L\leq sum_i-sum_j\leq R,0\leq j&lt;i$ 的 $j$ 的数目. 不等式变一下,就是求 $sum_i-R\leq sum_j\leq sum_i-L$ 的数目.用权值线段树来维护,动态开点即可. 注意权值可能是负的,所以根节点的 $l,r$ 分别为 $-inf,inf$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e10;int n,L,R;struct Segtree&#123; int idx; struct node &#123; int cnt; int ls,rs; node()&#123;cnt=ls=rs=0;&#125; &#125;Tree[MAXN*50]; Segtree()&#123;idx=0;&#125;#define root Tree[o] void upd(int &amp;o,ll l,ll r,ll pos) &#123; if(!o) o=++idx; ++root.cnt; if(l==r) return; ll mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(root.ls,l,mid,pos); else upd(root.rs,mid+1,r,pos); &#125; int query(int o,ll l,ll r,ll L,ll R) &#123; if(L&gt;R || R&lt;l || l&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.cnt; int res=0; ll mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125;&#125;T;int rt=0;ll ans=0,sum=0;int main()&#123; n=read(); L=read(),R=read(); T.upd(rt,-inf,inf,0); for(int i=1;i&lt;=n;++i) &#123; sum+=read(); ans+=T.query(rt,-inf,inf,sum-R,sum-L); T.upd(rt,-inf,inf,sum); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4662 snow]]></title>
    <url>%2F2019%2F06%2F02%2Fbzoj-4662-snow%2F</url>
    <content type="text"><![CDATA[线段树. 考虑将 $L$ 离散化后,用线段树来维护每个清理工当前的工作长度. 若一个人将区间 $[L,R]$ 清扫后,被影响的人 $i$ 应该满足 $L&lt;L_i\leq R$ 或 $R_i\geq L&gt;L_i$ ,编号是一个区间. 显然不能直接修改,因为对它们的影响是不一样的.但对于所有影响到的 $L_i$ 相同的 $i$ 或所有 $R_i$ 相同的 $i$ 的影响是一样的,而这些人的编号也是一个区间. 于是可以用一个 $set$ 存储所有的三元组 $(l,r,pos)$ 表示编号在区间 $l,r$ 内的人,均满足 $L_i=pos$ .再用一个 $set$ 存储 $R_i=pos$ 的所有三元组. 修改时暴力取出所有的三元组,在线段树上修改后将它们合并成一个三元组放回去.而合并只会使区间变大,操作总次数是 $O(n)$ 的,所以时间复杂度是对的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;const int inf=1e9;int n,t,L[MAXN],R[MAXN];struct Segtree&#123; struct node &#123; int tag,val; node()&#123;tag=val=0;&#125; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.val=min(lson.val,rson.val); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.tag=min(root.tag,inf); root.val+=c; root.val=min(root.val,inf); &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; if(l==r) &#123; root.val=R[l]-L[l]+1; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void upd(int o,int l,int r,int L,int R,int c)//[L,R]+=c &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125; int query(int o,int l,int r) &#123; if(l==r) return l; pushdown(o); int mid=(l+r)&gt;&gt;1; if(lson.val&lt;=rson.val) return query(o&lt;&lt;1,l,mid); else return query(o&lt;&lt;1|1,mid+1,r); &#125;&#125;Seg;struct Fenwicktree&#123; int bit[MAXN]; Fenwicktree()&#123;memset(bit,0,sizeof bit);&#125;#define lowbit(x) x&amp;(-x) void add(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]+=c,bit[x]=min(bit[x],inf); &#125; int query(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s+=bit[x],s=min(s,inf); return s; &#125; void upd(int L,int R,int c) &#123; add(L,c); add(R+1,-c); &#125;&#125;Fenwick;struct interval&#123; int l,r,pos; interval(int l=0,int r=0,int pos=0):l(l),r(r),pos(pos) &#123;&#125; bool operator &lt; (const interval &amp;rhs) const &#123; return pos&lt;rhs.pos; &#125;&#125;;set&lt;interval&gt; SL,SR;set&lt;interval&gt;::iterator it,tt;int main()&#123; t=read(),n=read(); for(int i=1;i&lt;=n;++i) &#123; L[i]=read(); R[i]=read(); &#125; for(int i=1;i&lt;=n;++i) &#123; Fenwick.add(i,L[i]-L[i-1]); SL.insert(interval(i,i,L[i])); SR.insert(interval(i,i,R[i])); &#125; Seg.BuildTree(1,1,n); SL.insert(interval(0,0,0)); SL.insert(interval(0,0,t+1)); SR.insert(interval(0,0,0)); SR.insert(interval(0,0,t+1)); for(int i=1;i&lt;=n;++i) &#123; int x=Seg.query(1,1,n); printf("%d\n",x); int l=Fenwick.query(x); int r=l+Seg.Tree[1].val-1; if(l!=r) &#123; int lx=n+1,rx=1; interval tmp=interval(0,0,l); it=SL.lower_bound(tmp); while((*it).pos&lt;=r) &#123; rx=max(rx,(*it).r); lx=min(lx,(*it).l); Fenwick.upd((*it).l,(*it).r,r-(*it).pos); Seg.upd(1,1,n,(*it).l,(*it).r,(*it).pos-r); tt=it; ++it; SL.erase(tt); &#125; SL.insert(interval(lx,rx,r)); lx=n+1,rx=1; tmp=interval(0,0,r); it=SR.lower_bound(tmp); while((*it).pos&gt;l) &#123; rx=max(rx,(*it).r); lx=min(lx,(*it).l); Seg.upd(1,1,n,(*it).l,(*it).r,l-(*it).pos); tt=it; --it; SR.erase(tt); &#125; SR.insert(interval(lx,rx,l)); &#125; Seg.upd(1,1,n,x,x,inf); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4663 hack]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4663-hack%2F</url>
    <content type="text"><![CDATA[最小割. 如果没有只能经过 $1$ 条被 $hack$ 边的限制,就是个裸的最小割. 解决的方法就是反向边的权值建成 $inf$ .感性理解一下,看下面这个图(图来自出题人): 在没有建 $inf$ 边前,割掉图中两条红色标记边是最优方案.而加上 $inf$ 后,就会出现 $st\to b\to a\to ed$ 这条路径.还需要割掉其他的边. 这样一来,不同时割掉两条红色标记边(即在一条路径上的边)就不会变得更劣. 还要注意将 $st$ 原来到不了的点预处理出来,将它们打上标记删去.否则可能出现如下情况(图来自出题人): 本来 $st$ 到不了 $a$ ,但加了 $inf$ 边后就连通了,会导致割掉额外的边. 这大概是几个月前考试做的?犹记李巨随手切了此题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e2+10,MAXM=1e4+10;const ll inf=1e18;int ecnt=-1,head[MAXN];struct Edge&#123; int to,nx; ll flow;&#125;E[MAXM];void addedge(int u,int v,ll flow)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=flow; head[u]=ecnt;&#125;int n,m;bool reachable[MAXN];void init()&#123; queue&lt;int&gt; q; reachable[1]=true; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(reachable[v] || E[i].flow&gt;=inf) continue; reachable[v]=true; q.push(v); &#125; &#125;&#125;int dep[MAXN],cur[MAXN];bool bfs(int S,int T)&#123; for(int i=1;i&lt;=n;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; queue&lt;int&gt; q; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(!reachable[v] || E[i].flow&lt;=0 || dep[v]!=-1) continue; dep[v]=dep[u]+1; q.push(v); &#125; &#125; return dep[T]!=-1;&#125;ll dfs(int u,int T,ll limit)&#123; if(u==T || !limit) return limit; ll f,flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(!reachable[v]) continue; if(E[i].flow&gt;0 &amp;&amp; dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; flow+=f; limit-=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return flow;&#125;ll Dinic(int S,int T)&#123; ll maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return maxflow;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read()+1; int v=read()+1; int w=read(); addedge(u,v,w); addedge(v,u,inf); &#125; init(); ll ans=Dinic(1,n); if(ans&lt;0 || ans&gt;=inf) puts("-1"); else cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4681 旅行]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4681-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[最短路. 这类点,边数目比较少,却有一些奇奇怪怪的条件的最短路,大多都是拆点.然而实现时并不需要真的拆点,只需要在做最短路的时候给 $dis$ 多加几维即可. 考虑暴力做法,应该是 $dfs$ 找出每一条路径,贪心地将不在路径上最短的边与在路径上最长的边交换,最多 $k$ 次. 然而路径条数可以被随便搞到指数级. 沿用贪心的思想,最后最优路径中的边一定会包含全部前 $L$ 小的边,可以将边排序,枚举 $L$ ,结合最短路解决. 设 $f(u,j,k)$ 表示从 $1$ 到 $u$ ,路径上有 $j$ 条前 $L$ 小的边,交换了 $k$ 次时的最短路.转移时分当前边不在前 $L$ 小与当前边在前 $L$ 小,用 $Dijkstra$ 转移即可. 注意正反加了两条边,实际排名需 $/2$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=151;int ans=0x7fffffff;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;struct Edge&#123; int u,v,len; bool operator &lt; (const Edge &amp;rhs) const &#123; return len&lt;rhs.len; &#125;&#125;E[MAXN];struct node&#123; int u,j,k,dis; bool operator &lt; (const node &amp;rhs) const &#123; return dis&gt;rhs.dis; &#125; node(int u=0,int j=0,int k=0,int dis=0):u(u),j(j),k(k),dis(dis) &#123;&#125;&#125;;int N,M,K;int dis[MAXN][MAXN][MAXN],vis[MAXN][MAXN][MAXN];priority_queue&lt;node&gt; q;void Dijkstra(int L)&#123; memset(vis,0,sizeof vis); memset(dis,63,sizeof dis); node p=node(1,0,0,0); dis[1][0][0]=0; q.push(p); while(!q.empty()) &#123; p=q.top(); q.pop(); int u=p.u,j=p.j,k=p.k; if(vis[u][j][k]) continue; vis[u][j][k]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(i&lt;=L*2) &#123; if(j&lt;L &amp;&amp; dis[v][j+1][k]-dis[u][j][k]&gt;E[j+1].len) &#123; dis[v][j+1][k]=dis[u][j][k]+E[j+1].len; p=node(v,j+1,k,dis[v][j+1][k]); q.push(p); &#125; &#125; else &#123; if(j&lt;L &amp;&amp; k&lt;K &amp;&amp; dis[v][j+1][k+1]-dis[u][j][k]&gt;E[j+1].len) &#123; dis[v][j+1][k+1]=dis[u][j][k]+E[j+1].len; p=node(v,j+1,k+1,dis[v][j+1][k+1]); q.push(p); &#125; if(dis[v][j][k]-dis[u][j][k]&gt;E[(i+1)&gt;&gt;1].len) &#123; dis[v][j][k]=dis[u][j][k]+E[(i+1)&gt;&gt;1].len; p=node(v,j,k,dis[v][j][k]); q.push(p); &#125; &#125; &#125; &#125; for(int i=0;i&lt;=K;++i) ans=min(ans,dis[N][L][i]);&#125;int main()&#123; N=read(),M=read(),K=read(); for(int i=1;i&lt;=M;++i) &#123; E[i].u=read(); E[i].v=read(); E[i].len=read(); &#125; sort(E+1,E+1+M); for(int i=1;i&lt;=M;++i) &#123; addedge(E[i].u,E[i].v); addedge(E[i].v,E[i].u); &#125; for(int i=0;i&lt;=M;++i) Dijkstra(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4669 抢夺]]></title>
    <url>%2F2019%2F05%2F30%2Fbzoj-4669-%E6%8A%A2%E5%A4%BA%2F</url>
    <content type="text"><![CDATA[二分答案 + 费用流. 答案显然可以二分,只需要如何验证一个答案 $mid$ 是否合法. 考虑第一波同时出发的人,他们会选择最优的路径,而后来的人选择的路径必定与他们相同. 于是可以通过增广计算出在 $mid$ 天内到达的人数.而退流操作对应的贡献也是正确的,所以不需要另外考虑. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10;const int inf=1e9;int ecnt=-1,head[MAXN];struct edge&#123; int nx,to,flow,dis;&#125;E[MAXN];void addedge(int u,int v,int flow,int dis)&#123; ++ecnt; E[ecnt].nx=head[u]; E[ecnt].to=v; E[ecnt].flow=flow; E[ecnt].dis=dis; head[u]=ecnt;&#125;void ins(int u,int v,int flow,int dis)&#123; addedge(u,v,flow,dis); addedge(v,u,0,-dis);&#125;int n,m,k;int dis[MAXN],flow[MAXN],pre[MAXN],lst[MAXN],vis[MAXN];queue&lt;int&gt; q;bool spfa(int S,int T)&#123; while(!q.empty()) q.pop(); for(int i=1;i&lt;=n;++i) &#123; vis[i]=0; flow[i]=inf; dis[i]=inf; &#125; pre[T]=-1; vis[S]=1; dis[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(E[i].flow&gt;0 &amp;&amp; dis[v]&gt;dis[u]+E[i].dis) &#123; dis[v]=dis[u]+E[i].dis; flow[v]=min(flow[u],E[i].flow); pre[v]=u; lst[v]=i; if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return pre[T]!=-1;&#125;int Dist[MAXN],Flow[MAXN],tot=0;int mcmf(int S,int T)&#123; while(spfa(S,T)) &#123; int now=T; while(now!=S) &#123; E[lst[now]].flow-=flow[T]; E[lst[now]^1].flow+=flow[T]; now=pre[now]; &#125; ++tot; Dist[tot]=dis[T]; Flow[tot]=flow[T]; &#125;&#125;void init()&#123; memset(head,-1,sizeof head); ecnt=-1; tot=0;&#125;bool check(int mid)&#123; ll tmp=k; for(int i=1;i&lt;=tot &amp;&amp; tmp&gt;0;++i) tmp-=1LL*(mid-Dist[i]+1)*Flow[i]; return tmp&lt;=0;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k)) &#123; init(); for(int i=1;i&lt;=m;++i) &#123; int u=read()+1,v=read()+1,c=read(); ins(u,v,c,1); &#125; mcmf(1,n); int ans=-1,L=0,R=n+k+1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,R=mid-1; else L=mid+1; &#125; if(ans==-1) puts("No solution"); else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4621 Tc605]]></title>
    <url>%2F2019%2F05%2F29%2Fbzoj-4621-Tc605%2F</url>
    <content type="text"><![CDATA[$dp$ . 一个数字只可以往左右拓展,把周围的数变成和它一样的数.所以最终状态一定是一些数字段拼起来的,而且数字之间相对的前后顺序不会改变. 对最终状态进行 $dp$ .设 $f(i,j)$ 表示考虑了前 $i$ 个位置,操作了 $j$ 次的情况总数.一个数字段最多操作一次,处理出每个数字左右延伸的范围,枚举拓展的右端点进行转移即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=512;int n,m,a[MAXN],f[MAXN][MAXN];int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); f[0][0]=1; for(int i=1;i&lt;=n;++i) &#123; int l=i; while(l&gt;1 &amp;&amp; a[l-1]&lt;a[i]) --l; int r=i; while(r&lt;n &amp;&amp; a[r+1]&lt;a[i]) ++r; f[i][m]=add(f[i][m],f[i-1][m]); for(int j=m;j&gt;=1;--j) &#123; int tmp=f[l-1][j-1]; for(int k=l;k&lt;=r;++k) &#123; f[k][j]=add(f[k][j],tmp); tmp=add(tmp,f[k][j-1]); &#125; f[i][j-1]=add(f[i][j-1],f[i-1][j-1]); f[i][j]=add(f[i][j],-f[i-1][j-1]); &#125; &#125; int ans=0; for(int i=0;i&lt;=m;++i) ans=add(ans,f[n][i]); cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4658 rescue]]></title>
    <url>%2F2019%2F05%2F29%2Fbzoj-4658-rescue%2F</url>
    <content type="text"><![CDATA[$dp$ + 线段树. 显然只有关键点有用.设 $f(i)$ 表示到了第 $i$ 个关键点时的最小损失.把起点看做第 $0$ 个关键点,转移有: $$f(i)=\min_{j=0}^{i-1}\lbrace f(j)+ \lceil \frac {T_i-T_j} D \rceil\cdot A\rbrace - b_i$$ 这样大力转移是 $O(n^2)$ 的.注意到 $D$ 是固定的,考虑把 $T$ 写成 $T=C\cdot D+E,0\leq E&lt;D$ . 那么原式就可以变成 $$f(i)=\min_{j=0}^{i-1}\lbrace f(j)+ A\cdot (C_i-C_j)+[E_i&gt;E_j]\cdot A\rbrace - b_i$$ 以 $E$ 为下标建一颗动态开点的线段树,在 $E_j&lt; E_i,E_j\geq E_i$ 两部分分别查询 $f_j-A\cdot C_j$ 的最小值即可. 注意把 $Tree[0].val$ 初始化为 $inf$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;const ll inf=1e18;struct Segtree&#123; int idx; Segtree()&#123;idx=0;Tree[0].ls=Tree[0].rs=0;Tree[0].val=inf;&#125; struct node &#123; int ls,rs; ll val; &#125;Tree[MAXN*30];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs] void pushup(int o) &#123; root.val=min(lson.val,rson.val); &#125; void ins(int &amp;o,int l,int r,int pos,ll c) &#123; if(!o) &#123; o=++idx; root.val=inf; root.ls=root.rs=0; &#125; if(l==r) &#123; root.val=min(root.val,c); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(root.ls,l,mid,pos,c); else ins(root.rs,mid+1,r,pos,c); pushup(o); &#125; ll query(int o,int l,int r,int L,int R) &#123; if(!o || L&gt;R) return inf; if(L&lt;=l &amp;&amp; r&lt;=R) return root.val; ll res=inf; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=min(res,query(root.ls,l,mid,L,R)); if(R&gt;mid) res=min(res,query(root.rs,mid+1,r,L,R)); return res; &#125;&#125;T;int n,rt=0;int A,B[MAXN],C[MAXN],D,E[MAXN],K,M;ll f[MAXN];void update_info(int x)&#123; T.ins(rt,0,D-1,E[x],f[x]-1LL*A*C[x]);&#125;int main()&#123; K=read(),M=read(),D=read(),A=read(); n=read(); C[0]=K/D,E[0]=K%D,B[0]=0; ++n; C[n]=M/D,E[n]=M%D,B[n]=0; f[0]=0; update_info(0); for(int i=1;i&lt;n;++i) &#123; int T=read(); C[i]=T/D; E[i]=T%D; B[i]=read(); &#125; for(int i=1;i&lt;=n;++i) &#123; f[i]=1LL*C[i]*A-B[i]; ll tmp=T.query(rt,0,D-1,0,E[i]-1)+A; tmp=min(tmp,T.query(rt,0,D-1,E[i],D-1)); f[i]+=tmp; update_info(i); &#125; cout&lt;&lt;(-f[n])&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4659 lcm]]></title>
    <url>%2F2019%2F05%2F28%2Fbzoj-4659-lcm%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 转化一下条件,数对 $(a,b)$ 符合要求等价于 $\mu(gcd(a,b))\not=0​$ . 为了方便,记 $m=\min(A,B)$ , 集合 $S=\lbrace x|\mu(x)\not=0\rbrace$ ,$sum(x)=\frac {x(x+1)} 2$ . 则答案 $ans$ 为: 到这一步,直接用两个整除分块算,时间复杂度 $O(T\cdot n^{\frac 3 4})$. 然而发现极限数据要跑 $10s+$ . 再变一步,将枚举 $x,d$ 变为先枚举 $D=xd$ ,再枚举 $x$. $$ans=\sum_{D=1}^{m}D \sum_{x|D} \mu(x)^2\mu(\frac D x)\frac D x \sum_{a=1}^{A/D}\sum_{b=1}^{B/D} ab$$ 设三个函数 $f,g,h$ : 函数 $g,h$ 显然都是积性函数.而 $f=g*h$ ,也为积性函数.于是可以线性筛预处理 $f$ ,然后对 $D$ 整除分块. 时间复杂度优化到 $O(T\cdot \sqrt n)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1&lt;&lt;30;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;const int MAXN=4e6+10;int prime[MAXN],cnt=0,ism[MAXN],mu[MAXN];int f[MAXN],sumfx[MAXN];void init(int N)&#123; ism[1]=1,mu[1]=1; sumfx[1]=1; f[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; mu[i]=-1; f[i]=-i+1; &#125; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=N;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]) &#123; mu[i*prime[j]]=-mu[i]; f[i*prime[j]]=mul(f[i],f[prime[j]]); &#125; else &#123; mu[i*prime[j]]=0; if((1LL*i)%(1LL*prime[j]*prime[j])==0) f[i*prime[j]]=0; else f[i*prime[j]]=mul(f[i/prime[j]],-prime[j]); break; &#125; &#125; sumfx[i]=add(sumfx[i-1],mul(i,f[i])); &#125;&#125;int sum(int x)&#123; return (1LL*x*(x+1)/2)%P;&#125;int main()&#123; init(4000000); int T=read(); while(T--) &#123; int ans=0; int A=read(),B=read(); int m=min(A,B); for(int LD=1,RD;LD&lt;=m;LD=RD+1) &#123; RD=min(A/(A/LD),B/(B/LD)); ans=add(ans,mul(sumfx[RD]-sumfx[LD-1],mul(sum(A/LD),sum(B/LD)))); &#125; printf("%d\n",add(ans,P)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4657 tower]]></title>
    <url>%2F2019%2F05%2F28%2Fbzoj-4657-tower%2F</url>
    <content type="text"><![CDATA[最小割. 想到网络流应该不难,但关键是怎样建模. 因为只有横向炮塔与竖向炮塔可能发生冲突,所以可以先套路地把一个点拆成一个横点和一个竖点,横点向对应竖点之间连一条边权为 $inf$ 的边.然后从源点 $S$ 向每个竖向攻击的炮塔的竖点连边权为 $inf$ 的边,从每个横向攻击的炮塔的横点向汇点 $T$ 连一条边权为 $inf$ 的边. 考虑每个炮塔,选择一个点进行攻击,这个点显然是从炮塔出发到最大贡献所在点这条路径 $p$ 上的某个点. 那么对于一个竖向攻击的炮塔,沿着路径 $p$ ,从炮塔到最大贡献点,相邻两点的竖点连上边. 对于一个横向攻击的炮塔,沿着路径 $p$ ,从最大贡献点到炮塔,相邻两点的横点连上边. 开始时钦定每个炮塔都打各自最大贡献点,收益为 $\sum max_i$ ,但这样会有路径相交,在图中表现为 $S$ 与 $T$ 连通.若一个炮塔改为打点 $u$ ,就把对应的路径 $p$ 上以 $u$ 为一端,另一端远离炮塔的点的边割掉就行了.减少的收益是 $max_i-val_u$ .可以发现,最后 $S$ 与 $T$ 不连通就与炮弹路径不相交是等价的. 于是在路径 $p$ 上连边时,将边权设置为 $max_i-val_u$ ,用 $\sum max_i$ 减去最小割即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=2e5+10;int ecnt=-1,head[MAXN],cur[MAXN],tot=0;struct edge&#123; int nx,to,flow;&#125;E[MAXN];void addedge(int u,int v,int w)&#123; ++ecnt; E[ecnt].to=v; E[ecnt].nx=head[u]; E[ecnt].flow=w; head[u]=ecnt;&#125;void ins(int u,int v,int w)&#123; addedge(u,v,w); addedge(v,u,0);&#125;int dep[MAXN];bool bfs(int S,int T)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); for(int i=1;i&lt;=tot;++i) cur[i]=head[i]; memset(dep,-1,sizeof dep); dep[S]=0; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i!=-1;i=E[i].nx) &#123; int v=E[i].to; if(dep[v]==-1 &amp;&amp; E[i].flow) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T]!=-1;&#125;int dfs(int u,int T,int limit)&#123; if(u==T || !limit) return limit; int f,flow=0; for(int i=cur[u];i!=-1;i=E[i].nx) &#123; cur[u]=i; int v=E[i].to; if(dep[v]==dep[u]+1 &amp;&amp; (f=dfs(v,T,min(limit,E[i].flow)))) &#123; limit-=f; flow+=f; E[i].flow-=f; E[i^1].flow+=f; if(!limit) break; &#125; &#125; return flow;&#125;int Dinic(int S,int T)&#123; int maxflow=0; while(bfs(S,T)) maxflow+=dfs(S,T,inf); return maxflow;&#125;int n,m;int node_id[51][51][2];//0:up/down 1:left/rightint org_graph[51][51];int S,T,ans=0;void build_graph(int x,int y,int tp)&#123; org_graph[x][y]=0; if(tp==1 || tp==2) &#123; ins(S,node_id[x][y][0],inf); int mx=0,maxpos=-1; if(tp==1) &#123; for(int i=x-1;i&gt;=1;--i) if(org_graph[i][y]&gt;mx) mx=org_graph[i][y],maxpos=i; if(maxpos==-1) return; for(int i=x-1;i&gt;=maxpos;--i) ins(node_id[i+1][y][0],node_id[i][y][0],mx-org_graph[i+1][y]); &#125; else &#123; for(int i=x+1;i&lt;=n;++i) if(org_graph[i][y]&gt;mx) mx=org_graph[i][y],maxpos=i; if(maxpos==-1) return; for(int i=x+1;i&lt;=maxpos;++i) ins(node_id[i-1][y][0],node_id[i][y][0],mx-org_graph[i-1][y]); &#125; ans+=mx; &#125; else &#123; ins(node_id[x][y][1],T,inf); int mx=0,maxpos=-1; if(tp==3) &#123; for(int j=y-1;j&gt;=1;--j) if(org_graph[x][j]&gt;mx) mx=org_graph[x][j],maxpos=j; if(maxpos==-1) return; for(int j=y-1;j&gt;=maxpos;--j) ins(node_id[x][j][1],node_id[x][j+1][1],mx-org_graph[x][j+1]); &#125; else &#123; for(int j=y+1;j&lt;=m;++j) if(org_graph[x][j]&gt;mx) mx=org_graph[x][j],maxpos=j; if(maxpos==-1) return; for(int j=y+1;j&lt;=maxpos;++j) ins(node_id[x][j][1],node_id[x][j-1][1],mx-org_graph[x][j-1]); &#125; ans+=mx; &#125;&#125;int main()&#123; memset(head,-1,sizeof head); n=read(),m=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; org_graph[i][j]=read(); node_id[i][j][0]=++tot; node_id[i][j][1]=++tot; ins(tot-1,tot,inf); &#125; S=++tot,T=++tot; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(org_graph[i][j]&lt;0) build_graph(i,j,-org_graph[i][j]); ans-=Dinic(S,T); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6053 简单的函数]]></title>
    <url>%2F2019%2F05%2F28%2FLoj-6053-%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[min_25 筛 . 除了 $2$ 之外的质数 $p$ 都是奇数, $f(p)=p-1$ ,而 $f(2)=3$ . 把 $f(p)$ 都当成 $f(p)=p-1$ ,用 min_25 筛法来做.有 $2$ 就特判一下, $+2$ 就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int P=1e9+7;const int inv2=(P+1)&gt;&gt;1;inline int add(ll a,ll b)&#123; a%=P; b%=P; return (a + b) % P;&#125;inline int mul(ll a,ll b)&#123; a%=P; b%=P; return 1LL * a * b % P;&#125;ll n,sqr,w[MAXN];int cnt=0,ism[MAXN],sump[MAXN],m;ll prime[MAXN];ll id1[MAXN],id2[MAXN];void init(int N)&#123; ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) &#123; prime[++cnt]=i; sump[cnt]=add(sump[cnt-1],i); &#125; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=N;++j) &#123; ism[prime[j]*i]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int h[MAXN],g[MAXN],ans;int S(ll x,int y)&#123; if(x&lt;=1 || prime[y]&gt;x) return 0; int k=(x&lt;=sqr)?id1[x]:id2[n/x]; int res=add(g[k]-sump[y-1],y-h[k]-1); if(y==1) res+=2; for(int i=y;i&lt;=cnt &amp;&amp; 1LL*prime[i]*prime[i]&lt;=x;++i) &#123; ll pow1=prime[i],pow2=1LL*prime[i]*prime[i]; for(int e=1;pow2&lt;=x;++e,pow1=pow2,pow2*=prime[i]) &#123; int tmp=mul(S(x/pow1,i+1),prime[i]^e); tmp=add(tmp,prime[i]^(e+1)); res=add(res,tmp); &#125; &#125; return res;&#125;int main()&#123; n=read(); sqr=sqrt(n); init(sqr); for(ll l=1,r;l&lt;=n;l=r+1) &#123; ll &amp;i=l,&amp;j=r; r=n/(n/l); w[++m]=n/l; h[m]=add(w[m]%P,-1); g[m]=mul(w[m],w[m]+1); g[m]=mul(g[m],inv2); g[m]=add(g[m],-1); if(w[m]&lt;=sqr) id1[n/l]=m; else id2[r]=m; &#125; for(int j=1;j&lt;=cnt;++j) for(int i=1;i&lt;=m &amp;&amp; prime[j]*prime[j]&lt;=w[i];++i) &#123; int k=(w[i]/prime[j]&lt;=sqr)?id1[w[i]/prime[j]]:id2[n/(w[i]/prime[j])]; g[i]=add(g[i],-mul(prime[j],add(g[k],-sump[j-1]))); h[i]=add(h[i],j-h[k]-1); &#125; ans=add(S(n,1),1); cout&lt;&lt;(ans+P)%P&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4665 小w的喜糖]]></title>
    <url>%2F2019%2F05%2F27%2Fbzoj-4665-%E5%B0%8Fw%E7%9A%84%E5%96%9C%E7%B3%96%2F</url>
    <content type="text"><![CDATA[容斥 + $dp$ . 要求有重复元素的错排方案数. 设 $f(i,j)$ 表示考虑前 $i$ 种糖,钦定 $j$ 个人拿到原来的糖,其他 $(n-j)$ 个人乱拿的方案数. $cnt_x$ 表示第 $x$ 种糖的数目. 枚举第 $i$ 种糖被 $k$ 个原来的人拿到,有 $f(i,j)=\sum_{k\leq j,k\leq cnt_i} f(i-1,j-k)\times {cnt_i \choose k}\times [(cnt_i-k)!]^{-1}$ . 最终答案为 $ans=\sum_{i=0}^n (-1)^i \times f(n,i) \times (n-i)!$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+9;inline int add(int a,int b)&#123; return (a + b) % P; &#125; inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=2019;int n,cnt[MAXN],fac[MAXN],invfac[MAXN];int ans=0,f[MAXN][MAXN];void init()&#123; fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); invfac[n]=inv(fac[n]); for(int i=n-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int M,int N)// M \choose N&#123; if(M&lt;0 || N&lt;0 || M&lt;N) return 0; return mul(fac[M],mul(invfac[M-N],invfac[N]));&#125;int main()&#123; n=read(); init(); for(int i=1;i&lt;=n;++i) &#123; int x=read(); ++cnt[x]; &#125; f[0][0]=1; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum+=cnt[i]; for(int j=0;j&lt;=sum;++j) for(int k=0;k&lt;=cnt[i] &amp;&amp; k&lt;=j;++k) &#123; int tmp=mul(f[i-1][j-k],C(cnt[i],k)); tmp=mul(tmp,invfac[cnt[i]-k]); f[i][j]=add(f[i][j],tmp); &#125; &#125; for(int i=0;i&lt;=n;++i) &#123; int tmp=(i&amp;1)?(-1):(1); tmp=mul(tmp,f[n][i]); tmp=mul(tmp,fac[n-i]); ans=add(ans,tmp); &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>dp计数</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190526]]></title>
    <url>%2F2019%2F05%2F26%2Ftest20190526%2F</url>
    <content type="text"><![CDATA[感觉 $T3$ 很假. $tweak$ 题面有误.题意是每次可以选一条边,权值修改为任意非负整数,问至少改多少条可以使 $1\to n$ 的最短路 $\leq c$ . 显然可以贪心,每次修改时都改成 $0$ .设 $f(i,j)$ 表示 $1\to i$ ,改了 $j$ 条边时的最短路.用 $spfa$ 转移即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;const int MAXN=1e3+10;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],val[MAXN];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int n,m,c;int f[MAXN][MAXN],tot=0;int vis[MAXN];queue&lt;int&gt; q;void spfa()&#123; memset(f,63,sizeof f); int inf=f[0][0]; f[1][0]=0; vis[1]=1; q.push(1); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; bool flag=false; for(int j=0;j&lt;=m;++j) &#123; if(f[u][j]&gt;=inf) break; if(f[u][j]&lt;=f[v][j+1]) &#123; f[v][j+1]=f[u][j]; &#125; if(f[u][j]+val[i]&lt;=f[v][j]) &#123; f[v][j]=f[u][j]+val[i]; if(!j) flag=true; &#125; &#125; if(flag &amp;&amp; !vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125;&#125;int main()&#123; freopen("tweak.in","r",stdin); freopen("tweak.out","w",stdout); n=read(),m=read(),c=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); &#125; spfa(); for(int i=0;i&lt;=m;++i) if(f[n][i]&lt;=c) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; return 0;&#125; $coins$ 把每个硬币看做多项式 $(x^{a_i}+1)$ ,如果每个硬币都可以用,方案数就是 $\prod (x^{a_i}+1)$ 这个多项式中系数非零的 $x^k(k&gt;0)$ 的个数. 限定某个硬币 $i$ 不能用,只需要在多项式 $\prod (x^{a_i}+1)$ 中把 $(x^{a_i}+1)$ 除去,然后统计答案. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') k=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();&#125; return k*x;&#125;int n,a[101];const int MAXN=3e5+10;ll poly[MAXN],tmp[MAXN];ll stk[MAXN],sk[MAXN];int deg=0,tp=0;int query(int p)&#123; tp=0; int Deg=deg,res=0; while(Deg) &#123; ll s=poly[Deg]; if(!s) &#123; --Deg; continue; &#125; if(!tmp[Deg-p] &amp;&amp; Deg-p) ++res; tmp[Deg-p]+=s; stk[++tp]=Deg-p; poly[Deg-p]-=s; sk[tp]=s; --Deg; &#125; for(int i=1;i&lt;=tp;++i) &#123; tmp[stk[i]]=0; poly[stk[i]]+=sk[i]; &#125; return res;&#125;int main()&#123; freopen("coin.in","r",stdin); freopen("coin.out","w",stdout); n=read(); poly[0]=1; for(int i=1;i&lt;=n;++i) &#123; a[i]=read(); for(int j=deg;j&gt;=0;--j) poly[a[i]+j]+=poly[j]; deg+=a[i]; &#125; for(int i=1;i&lt;=n;++i) printf("%d\n",query(a[i])); return 0;&#125; $cakes$ $std:$ 维护一个堆,存储每种大小的元素数目.每次取出顶部三个,做最多的三元组,把剩余的放回去. 并不知道我的贪心哪里出了问题.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>最短路</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4653 区间]]></title>
    <url>%2F2019%2F05%2F26%2Fbzoj-4653-%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[线段树. 可以先将区间按照大小从小到大排序,并将端点离散化. 枚举以第 $i$ 个区间为最短区间时的答案,从 $i$ 开始往后面添加区间,直到有个点被覆盖 $m$ 次. 更新答案后,下次枚举不需要重新加入,只需要把第 $i$ 个区间删除即可. 用线段树支持区间覆盖与撤销,并维护被覆盖次数的最大值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10,inf=2e9;int n,m,ans=inf;int A[MAXN&lt;&lt;1],cnt=0;struct interval&#123; int l,r,len; bool operator &lt; (const interval &amp;rhs) const &#123; return len &lt; rhs.len; &#125;&#125;I[MAXN];int rk(int x)&#123; return lower_bound(A+1,A+1+cnt,x)-A;&#125;struct Segtree&#123; struct node &#123; int tag,mx; node()&#123;tag=mx=0;&#125; &#125;Tree[MAXN&lt;&lt;3];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] int query() &#123; return Tree[1].mx; &#125; void pushup(int o) &#123; root.mx=max(lson.mx,rson.mx); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.mx+=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void upd(int o,int l,int r,int L,int R,int c) &#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) upd(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) upd(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125;&#125;T;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; A[++cnt]=I[i].l=read(); A[++cnt]=I[i].r=read(); I[i].len=I[i].r-I[i].l; &#125; sort(I+1,I+1+n); sort(A+1,A+1+cnt); cnt=unique(A+1,A+1+cnt)-(A+1); for(int i=1;i&lt;=n;++i) &#123; I[i].l=rk(I[i].l); I[i].r=rk(I[i].r); &#125; int head=1,tail=0; while(head&lt;=n) &#123; while(T.query()&lt;m &amp;&amp; tail&lt;n) &#123; ++tail; T.upd(1,1,cnt,I[tail].l,I[tail].r,1); &#125; if(T.query()==m) ans=min(ans,I[tail].len-I[head].len); T.upd(1,1,cnt,I[head].l,I[head].r,-1); ++head; &#125; cout&lt;&lt;(ans==inf?-1:ans)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4767 两双手]]></title>
    <url>%2F2019%2F05%2F26%2Fbzoj-4767-%E4%B8%A4%E5%8F%8C%E6%89%8B%2F</url>
    <content type="text"><![CDATA[容斥 +$dp$ . 把两种移动方式看做两个向量 $\vec a,\vec b$ .因为题目保证它们不共线,所以每个点都可以被写成 $x\cdot \vec a+y\cdot \vec b$ . 那么以解出来的 $(x,y)$ 代替原来的坐标,问题就变成了每次可以向右或向上走一步,求方案数. 如果没有障碍,答案显然是 $C_{x+y}^x$ .但现在有障碍.直接递推显然不行,因为新坐标可以达到 $2\times 500^2$ . 考虑容斥.将障碍点,目标点视为关键点,做坐标转换(如果不是整数就直接舍去),然后排序.原点为第 $0$ 个关键点. 设 $f(i)$ 表示从原点到达第 $i$ 个关键点而不经过其他关键点的方案数. $g(i,j)$ 表示从第 $i$ 个关键点到第 $j$ 个关键点的所有方案数.转移有 $f(i)=g(0,i)-\sum_{j=1}^{i-1} g(j,i)\cdot f(j)$ .而 $g$ 不需要考虑障碍,显然就是组合数. 时间复杂度 $O(n^2)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;const int P=1e9+7;const int inf=1e9;inline int add(int a,int b)&#123; return (a + b &gt;= P) ? (a + b - P) : (a + b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;typedef pair&lt;int,int&gt; pii;const pii badp=make_pair(inf,inf);int n,k=0,ax,ay,bx,by;int ex=inf,ey=inf;pii p[MAXN];pii trans(int M,int N)&#123; int x,y; int up=ay*M-ax*N,down=bx*ay-by*ax; if(up%down || up/down&lt;0) return badp; y=up/down; up=M*by-N*bx,down=ax*by-ay*bx; if(up%down || up/down&lt;0) return badp; x=up/down; if(x&gt;ex || y&gt;ey) return badp; return make_pair(x,y);&#125;int fac[MAXN],invfac[MAXN];void init()&#123; int N=MAXN-10; fac[0]=1; for(int i=1;i&lt;=N;++i) fac[i]=mul(fac[i-1],i); invfac[N]=fpow(fac[N],P-2); for(int i=N-1;i&gt;=0;--i) invfac[i]=mul(invfac[i+1],i+1);&#125;int C(int N,int M)&#123; return mul(fac[M],mul(invfac[N],invfac[M-N]));&#125;int g(int i,int j)&#123; int x=p[j].first-p[i].first,y=p[j].second-p[i].second; if(x&lt;0 || y&lt;0) return 0; return C(x,x+y);&#125;int f[MAXN];int main()&#123; init(); int Ex=read(),Ey=read(); n=read(),ax=read(),ay=read(),bx=read(),by=read(); p[++k]=trans(Ex,Ey); if(p[k]==badp) &#123; puts("0"); return 0; &#125; ex=p[k].first,ey=p[k].second; for(int i=1;i&lt;=n;++i) &#123; int x=read(),y=read(); pii tmp=trans(x,y); x=tmp.first,y=tmp.second; if(ex&lt;x || ey&lt;y) continue; assert(tmp!=badp); p[++k]=tmp; &#125; p[0]=make_pair(0,0); ++k; sort(p,p+k); f[0]=1; for(int i=1;i&lt;k;++i) &#123; f[i]=g(0,i); for(int j=1;j&lt;i;++j) f[i]=add(f[i],P-mul(g(j,i),f[j])); &#125; cout&lt;&lt;f[k-1]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder Beginner Contest 127]]></title>
    <url>%2F2019%2F05%2F25%2FAtcoder-Beginner-Contest-127%2F</url>
    <content type="text"><![CDATA[被 $E$ 给卡住了.数据范围读错还行. 前 $3$ 道题目主要考察读入和输出. D Integer Cards 贪心 + 二分. 显然可以随意安排操作的顺序.于是可以给操作按照 $c$ 从大到小排序,那么前面的操作就不会影响后面的操作. 于是每次操作的时候贪心选小的替换,替换后直接将那部分删去就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m,a[MAXN];ll t[MAXN],sum[MAXN];struct opt&#123; int b,c; bool operator &lt; (const opt &amp;rhs) const &#123; return c&gt;rhs.c; &#125;&#125;q[MAXN];ll ans=0;int head,tail;int bs(int x)&#123; int L=head,R=tail,res=-1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(a[mid]&lt;x) L=mid+1,res=mid; else R=mid-1; &#125; return res;&#125;int main()&#123; n=read(); m=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+1+n); for(int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=m;++i) &#123; q[i].b=read(); q[i].c=read(); &#125; sort(q+1,q+1+m); head=1,tail=n; for(int i=1;i&lt;=m;++i) &#123; int pos=bs(q[i].c); if(pos==-1) continue; int tmp=min(q[i].b,pos-head+1); ans+=1LL*tmp*q[i].c; head=head+tmp; &#125; while(head&lt;=tail) &#123; ans+=a[head]; ++head; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Cell Distance $N\times M\leq 2\times 10^5$ ,我看成 $N,M\leq 2\times 10^5$ 了… 考虑一对点 $p,q$ ,它们显然会在 $C^{K-2}_{NM}$ 个方案中被计入贡献. 于是只需要枚举每个点,计算它到其他点的距离和,再乘上 $C_{NM}^{K-2}$ ,最后还要除以 $2$ . F Absolute Minima 平衡树 + 线段树. 那个 $b$ 显然没什么用,可以单独算. 问题就变成可以在数轴上插入点,每次询问到这些点距离和最小的位置与这个距离和. 若现在有 $k$ 个点,第一问,显然应该取中位数.这个可以用一颗平衡树维护答案. 第二问,把绝对值拆开,只需要询问当前比 $x$ 小的数总和,当前比 $x$ 大的数总和.用了离散化 + 权值线段树.感觉应该有更简单的方法? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;struct FhqTreap&#123;#define rt treap[o]#define ls treap[treap[o].lson]#define rs treap[treap[o].rson] int x,y,z,ans; int idx; FhqTreap() &#123; x=y=z=0; idx=0; &#125; struct node &#123; int lson,rson,key,weight,size; &#125; treap[MAXN]; inline int newnode(int key) &#123; ++idx; treap[idx].size=1; treap[idx].weight=rand(); treap[idx].key=key; return idx; &#125; inline void pushup(int o) &#123; rt.size=ls.size+rs.size+1; &#125; void split(int&amp; x,int&amp; y,int key,int o)//小于等于key的分在x中 &#123; if(!o) x=y=0; else &#123; if(rt.key&lt;=key) &#123; x=o; split(rt.rson,y,key,rt.rson); &#125; else &#123; y=o; split(x,rt.lson,key,rt.lson); &#125; pushup(o); &#125; &#125; int merge(int x,int y)//合并,保证x的权值小于y的权值. key_x&lt;key_y &#123; if(x==0||y==0) return x+y; if(treap[x].weight&lt;treap[y].weight) &#123; treap[x].rson=merge(treap[x].rson,y); pushup(x); return x; &#125; else &#123; treap[y].lson=merge(x,treap[y].lson); pushup(y); return y; &#125; &#125; inline int Rank(int&amp;root,int key)//get the node (which key equals to the key)'s rank. &#123; split(x,y,key-1,root); ans=treap[x].size+1; root=merge(x,y); return ans; &#125; inline int kth(int o,int rank)// find the id of the node which rank is the rank in the tree which root is o. &#123; while(1) &#123; if(ls.size&gt;=rank) o=rt.lson;//the answer must be in o's lson,search in it. else if(ls.size+1==rank) return treap[o].key;//o is the rank'th. else &#123; rank-=ls.size+1; o=rt.rson;//cannot find in o and o's lson,search in o's rson. &#125; &#125; &#125; inline void Insert(int&amp;root,int key)// insert a node which key is the key in whole the tree. &#123; split(x,y,key,root); root=merge(merge(x,newnode(key)),y); &#125;&#125; T;ll bsum=0;int Q,k=0,Rt=0;struct query&#123; int op,a,b;&#125;q[MAXN];int A[MAXN],cnt=0;struct Segtree&#123; struct node &#123; ll sum,tot; int l,r; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=lson.sum+rson.sum; &#125; void BuildTree(int o,int l,int r) &#123; root.l=l,root.r=r; root.sum=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void upd(int o,int pos,int c) &#123; int l=root.l,r=root.r; if(l==r) &#123; root.sum+=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) upd(o&lt;&lt;1,pos,c); else upd(o&lt;&lt;1|1,pos,c); pushup(o); &#125; ll query(int o,int L,int R) &#123; if(L&gt;R) return 0; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; ll res=0; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res+=query(o&lt;&lt;1,L,R); if(R&gt;mid) res+=query(o&lt;&lt;1|1,L,R); return res; &#125;&#125;Seg;int rnk(int x)&#123; return lower_bound(A+1,A+1+cnt,x)-A;&#125;int main()&#123; Q=read(); for(int i=1;i&lt;=Q;++i) &#123; q[i].op=read(); if(q[i].op==1) &#123; A[++cnt]=q[i].a=read(); q[i].b=read(); &#125; &#125; sort(A+1,A+1+cnt); cnt=unique(A+1,A+1+cnt)-(A+1); Seg.BuildTree(1,1,cnt); for(int i=1;i&lt;=Q;++i) &#123; if(q[i].op==1) &#123; int a=q[i].a,b=q[i].b; ++k; bsum+=b; Seg.upd(1,rnk(a),a); T.Insert(Rt,a); &#125; else &#123; int rk=(k+1)&gt;&gt;1; int x=T.kth(Rt,rk); rk=T.Rank(Rt,x); int pos=rnk(x); ll res=1LL*(rk-1)*x-Seg.query(1,1,pos-1)-1LL*(k-rk+1)*x+Seg.query(1,pos,cnt); printf("%d %lld\n",x,res+bsum); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Atcoder</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>平衡树</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4670 佛罗里达]]></title>
    <url>%2F2019%2F05%2F24%2Fbzoj-4670-%E4%BD%9B%E7%BD%97%E9%87%8C%E8%BE%BE%2F</url>
    <content type="text"><![CDATA[随机乱搞. 随机做很多次,每次 $random\ shuffle$ 出一个加点的序列,然后按照这个序列加点. 每次贪心判,加在哪个集合里面能使答案增加的量更小,就加在哪个里面. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int T=800;const int inf=0x7fffffff;const int MAXN=256;int n,val[MAXN][MAXN],p[MAXN];int A[MAXN],sizA,B[MAXN],sizB,mxA,mxB;ll ans;int main()&#123; srand(time(NULL)); while(~scanf("%d",&amp;n)) &#123; ans=inf; memset(val,0,sizeof val); for(int i=1;i&lt;n;++i) for(int j=i+1;j&lt;=n;++j) val[i][j]=val[j][i]=read(); for(int i=1;i&lt;=n;++i) p[i]=i; for(int t=1;t&lt;=T;++t) &#123; ll res=0; random_shuffle(p+1,p+1+n); sizA=sizB=0; mxA=mxB=0; for(int i=1;i&lt;=n;++i) &#123; int valA=0,valB=0; for(int j=1;j&lt;=sizA;++j) valA=max(valA,val[p[i]][A[j]]); for(int j=1;j&lt;=sizB;++j) valB=max(valB,val[p[i]][B[j]]); if(valA&lt;=mxA &amp;&amp; valB&lt;=mxB) &#123; int k=rand()&amp;1; if(k) A[++sizA]=p[i]; else B[++sizB]=p[i]; continue; &#125; if(valA-mxA&lt;=valB-mxB) &#123; if(valA-mxA&gt;0) &#123; res+=valA-mxA; mxA=valA; &#125; A[++sizA]=p[i]; &#125; else &#123; if(valB-mxB&gt;0) &#123; res+=valB-mxB; mxB=valB; &#125; B[++sizB]=p[i]; &#125; if(res&gt;=ans) break; &#125; ans=min(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>近似算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4675 点对游戏]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-4675-%E7%82%B9%E5%AF%B9%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[点分治. 表面上看是个期望的题,然而跟期望没多大关系. 每个人的答案显然是 能选的点对数目/总点对数目*幸运点对的总数目 . 只需要求幸运点对的总数目.由于 $m$ 很小,所以直接点分治就可以了.时间复杂度 $O(nmlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=5e4+10;int n,m,luckynum[11];ll sum=0;int ecnt=0,head[MAXN],nx[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int totsiz,siz[MAXN],mi,rt,vis[MAXN];void getroot(int u,int fa)&#123; siz[u]=1; int sonsiz=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; getroot(v,u); siz[u]+=siz[v]; sonsiz=max(sonsiz,siz[v]); &#125; sonsiz=max(sonsiz,totsiz-siz[u]); if(sonsiz&lt;mi) mi=sonsiz,rt=u;&#125;int dis[MAXN],bucket[MAXN],stk1[MAXN],tp1=0,stk2[MAXN],tp2=0;void getdis(int u,int fa)&#123; stk2[++tp2]=u; dis[u]=dis[fa]+1; for(int i=1;i&lt;=m;++i) if(luckynum[i]&gt;=dis[u]) sum+=bucket[luckynum[i]-dis[u]]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v] || v==fa) continue; getdis(v,u); &#125;&#125;void solve(int u)&#123; while(tp1) bucket[dis[stk1[tp1--]]]=0; dis[u]=0;//先清空,再设dis[u]=0,否则可能清空错误 bucket[0]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; tp2=0; getdis(v,u); while(tp2) &#123; stk1[++tp1]=stk2[tp2]; ++bucket[dis[stk2[tp2]]]; --tp2; &#125; &#125;&#125;void divide(int u)&#123; solve(u); vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(vis[v]) continue; mi=inf,totsiz=siz[v]; getroot(v,0); divide(rt); &#125;&#125;void getsum()&#123; mi=inf,totsiz=n; getroot(1,0); divide(rt);&#125;double calc(ll pairs)&#123; return (double(pairs)) * (double(sum)) / (double(1LL * n * (n-1) )) ;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;++i) luckynum[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; getsum(); int p=(n+2)/3; printf("%.2f\n",calc(1LL*p*(p-1))); p=(n+1)/3; printf("%.2f\n",calc(1LL*p*(p-1))); p=n/3; printf("%.2f\n",calc(1LL*p*(p-1))); return 0;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4698 Sandy的卡片]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-4698-Sandy%E7%9A%84%E5%8D%A1%E7%89%87%2F</url>
    <content type="text"><![CDATA[$SAM$ . 相同的定义比较奇怪,其实只需要差分一下就可以了,问题就是求这些串的最长公共子串.用 $SAM$ 解决. 答案就是求出的公共子串 $+1$ ?但有可能没有位置补,比如 $s_1=”23”,s_2=”23”$ ,答案应该是 $2$ 而不是 $3$ . 解决办法也很简单,在每个串后面加一个独特的且不在字符集中的标识符就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=1500,MAXN=2e3+10;int buf[MAXN];int L,n,T=0;struct SuffixAutoMation&#123; int idx,lst; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN],siz[MAXN]; int A[MAXN],t[MAXN]; int mxl[MAXN],res[MAXN]; SuffixAutoMation() &#123; idx=lst=1; &#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; res[np]=len[np]=len[p]+1; siz[np]=1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; res[nq]=len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1; i&lt;=idx; ++i) ++t[len[i]]; for(int i=1; i&lt;=idx; ++i) t[i]+=t[i-1]; for(int i=1; i&lt;=idx; ++i) A[t[len[i]]--]=i; &#125; void solve() &#123; L=read(); for(int i=1; i&lt;=L; ++i) buf[i]=read()-2; buf[L+1]=T+200,buf[L+2]=0; ++L; for(int i=1; i&lt;=L; ++i) buf[i]=buf[i+1]-buf[i]+1200; memset(mxl,0,sizeof mxl); int p=1,tmp=0; for(int i=1; i&lt;=L; ++i) &#123; int c=buf[i]; while(p &amp;&amp; ch[p][c]==0) p=fa[p]; if(p==0) p=1,tmp=0; else &#123; tmp=min(tmp,len[p])+1; p=ch[p][c]; &#125; mxl[p]=max(mxl[p],tmp); &#125; for(int i=idx; i&gt;=1; --i) &#123; int u=A[i]; mxl[fa[u]]=max(mxl[fa[u]],mxl[u]); &#125; for(int i=1; i&lt;=idx; ++i) res[i]=min(res[i],mxl[i]); &#125; void pr() &#123; int ans=0; for(int i=1; i&lt;=idx; ++i) ans=max(ans,res[i]); cout&lt;&lt;ans+1&lt;&lt;endl; &#125;&#125; SAM;int main()&#123; n=read(); L=read(); for(int i=1; i&lt;=L; ++i) buf[i]=read()-2; ++T; buf[L+1]=T+200,buf[L+2]=0; ++L; for(int i=1; i&lt;=L; ++i) &#123; buf[i]=buf[i+1]-buf[i]+1200; SAM.Extend(buf[i]); &#125; SAM.topsort(); for(int i=1; i&lt;n; ++i) &#123; ++T; SAM.solve(); &#125; SAM.pr(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4668 冷战]]></title>
    <url>%2F2019%2F05%2F22%2Fbzoj-4668-%E5%86%B7%E6%88%98%2F</url>
    <content type="text"><![CDATA[并查集按秩合并. 除了维护连通性,还需要维护每个点与它父亲的边被连上的时间. 用路径压缩会破坏树内部的结构,使用按秩合并就可以了.这样合并,树高不超过 $logn$ ,询问时,直接暴力跳到 $LCA$ ,路径上边被连上的最晚时间即为答案. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10;int n,m,lastans=0;int fa[MAXN],siz[MAXN],t[MAXN],dep[MAXN],tid=0;int Find(int x)&#123; if(x==fa[x]) return x; int fx=Find(fa[x]); dep[x]=dep[fa[x]]+1; return fx;&#125;void merge(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(siz[x]&lt;siz[y]) swap(x,y); siz[x]+=siz[y]; fa[y]=x; t[y]=tid;&#125;int query(int x,int y)&#123; int fx=Find(x),fy=Find(y); if(fx!=fy) return 0; int res=0; while(x!=y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); res=max(res,t[x]); x=fa[x]; &#125; return res;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;++i) siz[i]=1,fa[i]=i; for(int i=1;i&lt;=m;++i) &#123; int tp=read(); if(!tp) &#123; int u=read()^lastans,v=read()^lastans; ++tid; merge(u,v); &#125; else &#123; int u=read()^lastans,v=read()^lastans; lastans=query(u,v); printf("%d\n",lastans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4700 适者]]></title>
    <url>%2F2019%2F05%2F22%2Fbzoj-4700-%E9%80%82%E8%80%85%2F</url>
    <content type="text"><![CDATA[李超线段树. 如果没有秒杀,就是个简单的贪心.算出第 $i$ 个敌人需要攻击的次数 $T_i$ ,考虑在攻击顺序中,交换两个相邻敌人带来的影响. 容易发现按照 $\frac {T_i} {A_i}$ 从小到大排序就可以了. 现在可以秒杀两个敌人,先按照 $\frac {T_i} {A_i}$ 从小到大排个序.但肯定不能贪心秒杀前两个.因为原来是考虑了击杀时间,而秒杀没有击杀时间.可以随意举出反例. 考虑秒杀 $i,j(i&lt;j)$ 时,答案会减少的值.记 $preT,sufA$ 分别表示 $T$ 的前缀和, $A$ 的后缀和.贡献就有 $i,j,[i+1,j-1],[j+1,n]$ 这四段. 发现如果固定 $i$ ,那么就是要求 $-A_j\cdot T_i+b_j$ 的最大值,其中 $b_j$ 是可以预处理的,是仅和 $j$ 有关的一个量. 那么就是求 $x=T_i$ 这条直线与 $j&gt;i$ 的这些直线 $(-A_j,b_j)$ 交点纵坐标最大值.枚举 $i$ 时从大到小,就只需要维护加入直线和询问这两个操作.用李超线段树维护一下就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n,ATK;ll k[MAXN],b[MAXN],ans=0,delta=0;ll calc(int seg,int pos)&#123; return 1LL * k[seg] * pos + b[seg];&#125;bool is_cover(int a,int b,int pos)&#123; return calc(a,pos)&gt;=calc(b,pos);&#125;struct Segtree&#123; int v[MAXN&lt;&lt;2]; void ins(int o,int l,int r,int c) &#123; if(l==r) &#123; if(is_cover(c,v[o],l)) v[o]=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(k[c]&gt;k[v[o]]) &#123; if(is_cover(c,v[o],mid)) ins(o&lt;&lt;1,l,mid,c),v[o]=c; else ins(o&lt;&lt;1|1,mid+1,r,c); &#125; else &#123; if(is_cover(c,v[o],mid)) ins(o&lt;&lt;1|1,mid+1,r,c),v[o]=c; else ins(o&lt;&lt;1,l,mid,c); &#125; &#125; ll query(int o,int l,int r,int pos) &#123; ll res=calc(v[o],pos); if(l==r) return res; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) res=max(res,query(o&lt;&lt;1,l,mid,pos)); else res=max(res,query(o&lt;&lt;1|1,mid+1,r,pos)); return res; &#125;&#125;T;struct enemy&#123; int a,t; bool operator &lt; (const enemy &amp;rhs) const &#123; return a*rhs.t&gt;rhs.a*t; &#125;&#125;p[MAXN];ll preT[MAXN],sufA[MAXN];int main()&#123; n=read(),ATK=read(); for(int i=1;i&lt;=n;++i) &#123; p[i].a=read(); int D=read(); p[i].t=(D+ATK-1)/ATK; &#125; sort(p+1,p+1+n); for(int i=1;i&lt;=n;++i) preT[i]=preT[i-1]+p[i].t; for(int i=n;i&gt;=1;--i) sufA[i]=sufA[i+1]+p[i].a; for(int i=1;i&lt;=n;++i) &#123; k[i]=-p[i].a; b[i]=sufA[i]*p[i].t+preT[i-1]*p[i].a-p[i].a; ans+=p[i].t*sufA[i]-p[i].a; &#125; T.ins(1,1,n,n); for(int i=n-1;i&gt;=1;--i) &#123; delta=max(delta,T.query(1,1,n,p[i].t)+b[i]); T.ins(1,1,n,i); &#125; ans-=delta; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3073 Journeys]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-3073-Journeys%2F</url>
    <content type="text"><![CDATA[线段树优化连边. 边是双向的.开两颗线段树, $A$ 里面节点表示一条有向边的起点,儿子向父亲连边, $B$ 里面节点表示一条有向边的终点,父亲向儿子连边, $B$ 向 $A$ 中对应的节点连边. 区间连边时,新建一个节点,将区间在线段树上拆成 $log$ 个区间进行连边就好了. 最后跑一次 $Dijkstra$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e5+10,MAXM=2220000;int n,m,S;int ecnt=0,head[MAXM],to[MAXM],nx[MAXM],val[MAXM];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;struct node&#123; int ls,rs;&#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]int pos[MAXN],tot=0;void bd1(int &amp;o,int l,int r)&#123; o=++tot; if(l==r) &#123; pos[l]=o; return; &#125; int mid=(l+r)&gt;&gt;1; bd1(root.ls,l,mid); bd1(root.rs,mid+1,r); addedge(root.ls,o,0); addedge(root.rs,o,0);&#125;void bd2(int &amp;o,int l,int r)&#123; o=++tot; if(l==r) &#123; addedge(o,pos[l],0); return; &#125; int mid=(l+r)&gt;&gt;1; bd2(root.ls,l,mid); bd2(root.rs,mid+1,r); addedge(o,root.ls,0); addedge(o,root.rs,0);&#125;void upd1(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; addedge(o,tot,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd1(root.ls,l,mid,L,R); if(R&gt;mid) upd1(root.rs,mid+1,r,L,R);&#125;void upd2(int o,int l,int r,int L,int R)&#123; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; addedge(tot,o,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) upd2(root.ls,l,mid,L,R); if(R&gt;mid) upd2(root.rs,mid+1,r,L,R);&#125;int rt1=0,rt2=0;int vis[MAXM],dis[MAXM];typedef pair&lt;int,int&gt; pii;#define mp make_pairpriority_queue&lt;pii&gt; q;void Dijkstra()&#123; memset(dis,0x7f,sizeof dis); dis[pos[S]]=0; q.push(mp(0,pos[S])); while(!q.empty()) &#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[v]-dis[u]&gt;val[i]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),S=read(); bd1(rt1,1,n); bd2(rt2,1,n); while(m--) &#123; int x1=read(),y1=read(),x2=read(),y2=read(); ++tot;upd1(rt1,1,n,x1,y1);upd2(rt2,1,n,x2,y2); ++tot;upd1(rt1,1,n,x2,y2);upd2(rt2,1,n,x1,y1); &#125; Dijkstra(); for(int i=1;i&lt;=n;++i) printf("%d\n",dis[pos[i]]&gt;&gt;1); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>线段树连边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4762 最小集合]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-4762-%E6%9C%80%E5%B0%8F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[状压 $dp$ . 如果把所有元素 $xor\ 1023$ ,那么就等价于集合内元素 $or$ 和为 $1023$ ,去掉任意一个后 $or$ 和不为 $1023$ . 设 $f(i,j,k)$ 表示考虑了前 $i$ 个数,前面已经选择的数 $or$ 和为 $j$ ,期望后面选出的数 $or$ 和包含 $k$ 时的方案数. 若第 $i+1$ 个数为 $x$ ,不选它,则有 $f(i+1,j,k)+=f(i,j,k)$ . 如果选了它,假设能转移到 $f(i+1,j|x,k’)$ ,那么 $k’$ 需要满足: $k’|x=k$ . $k’|j|x\not= k’|j$ .这是为了保证去掉 $x$ 后就不合法了. 如果只考虑满足第一个条件的,就有 $f(i+1,j|x,k\ xor\ (k\&amp;x) )+=f(i,j,k)$ .因为 $x,k$ 都为 $1$ 的位置上可以随便选. 还要减去满足第一个条件,但不满足第二个条件的部分. $f(i+1,j|x,(k\ xor\ (k\&amp;x))|(x\ xor (x\&amp; j)) )-=f(i,j,k)$ . 后面括号表示 $x$ 对 $j$ 产生的贡献,即将原来的 $0$ 变为了 $1$ .如果 $k’$ 的这些位上也是 $1$ ,就不满足第二个条件了. 初始有 $f(0,0,0)=1$ ,答案为 $f(n,1023,0)$ .这样做是 $O(n\cdot 4^{10})$ 的. 注意到若 $f(i,j,k)\not = 0$ ,则一定有 $k$ 是 $j$ 的子集.于是枚举 $k$ 时只用枚举 $j$ 的子集.时间复杂度 $O(n\cdot 3^{10})$ . 滚掉第一维,优化空间. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b); &#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int N=1023;int n,a[N+10],f[2][N+10][N+10];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) a[i]=read()^N; int id=0; f[0][0][0]=1; for(int i=1;i&lt;=n;++i) &#123; int x=a[i]; memset(f[id^1],0,sizeof f[id^1]); for(int j=0;j&lt;=N;++j) &#123; for(int k=j;;k=(k-1)&amp;j) &#123; if(f[id][j][k]) &#123; f[id^1][j][k]=add(f[id^1][j][k],f[id][j][k]); f[id^1][j|x][k^(k&amp;x)]=add(f[id^1][j|x][k^(k&amp;x)],f[id][j][k]); f[id^1][j|x][(k^(k&amp;x))|(x^(x&amp;j))]=add(f[id^1][j|x][(k^(k&amp;x))|(x^(x&amp;j))],P-f[id][j][k]); &#125; if(!k) break; &#125; &#125; id^=1; &#125; cout&lt;&lt;f[id][N][0]&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4754 独特的树叶]]></title>
    <url>%2F2019%2F05%2F21%2Fbzoj-4754-%E7%8B%AC%E7%89%B9%E7%9A%84%E6%A0%91%E5%8F%B6%2F</url>
    <content type="text"><![CDATA[树 $hash$ . 要判断树的同构,自然要用到 $hash$ .但 $hash$ 的方法很多,我们要选取一种 优美 的方式.比如说字符串中,进制 $hash$ 就很优美,它可以 $O(1)$ 计算一个子串的 $hash$ 值. 在树中,一般是将一个点的 $hash$ 值设为所有儿子 $hash$ 值从小到大排序组成的串的进制 $hash$ 值,再乘上这个点的子树大小.若为叶子节点,则 $hash$ 值为 $1$ . 上面是对有根树的操作.然而这道题是无根树.找重心转成有根树十分麻烦(因为多了一个点),考虑换根,求出以每个点作为根节点的 $hash$ 值. 设 $f(i),g(i),h(i)$ 分别表示以 $1$ 为根时节点 $i$ 的 $hash$ 值,以 $fa_i$ 为根并去掉子树 $i$ 后 $fa_i$ 的 $hash$ 值,以 $i$ 为根时节点 $i$ 的 $hash$ 值. 对 $A,B$ 两棵树都做一次 $hash$ ,将 $A$ 中每个节点的 $h(i)$ 放入 $set$ 中,然后从小到大枚举 $B$ 树中度数为 $1$ 的点 $x$ .如果它连在 $y$ 上,由于我们 优美 的 $hash$ 定义,删去它后以 $y$ 为根, $y$ 的 $hash$ 值应该是 $\frac {h(x)} {n+1}$ .在 $set$ 中查询是否出现即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairconst int MAXN=1e5+10;const int P=998244353;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b); &#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int Pow[MAXN],Base=37,val[MAXN];int pre[MAXN],suf[MAXN];pii vp[MAXN];set&lt;int&gt; s;struct Tree&#123; int n; int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1]; int f[MAXN],g[MAXN],h[MAXN],siz[MAXN]; int deg[MAXN]; void addedge(int u,int v) &#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt; &#125; void init() &#123; ecnt=0; for(int i=1;i&lt;=n;++i) head[i]=f[i]=g[i]=h[i]=deg[i]=0; for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); ++deg[u],++deg[v]; &#125; &#125; void dfs1(int u,int fa) &#123; siz[u]=1; int tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs1(v,u); siz[u]+=siz[v]; &#125; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa) val[++tot]=f[v]; &#125; sort(val+1,val+1+tot); int tmp=1; for(int i=1;i&lt;=tot;++i) &#123; f[u]=add(f[u],mul(tmp,val[i])); tmp=mul(tmp,Base); &#125; f[u]=mul(f[u],siz[u]); if(!tot) f[u]=1; &#125; void dfs2(int u,int fa) &#123; int tot=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; vp[++tot]=mp(f[v],v); &#125; if(fa) vp[++tot]=mp(g[u],-1); sort(vp+1,vp+1+tot); pre[0]=suf[tot+1]=0; for(int i=1;i&lt;tot;++i) pre[i]=add(pre[i-1],mul(Pow[i-1],vp[i].first)); for(int i=tot;i&gt;1;--i) suf[i]=add(suf[i+1],mul(Pow[i-2],vp[i].first)); for(int i=1;i&lt;=tot;++i) &#123; if(vp[i].second==-1) continue; g[vp[i].second]=mul(n-siz[vp[i].second],pre[i-1]+suf[i+1]); &#125; if(!fa &amp;&amp; tot==1) g[vp[1].second]=1; int tmp=1; for(int i=1;i&lt;=tot;++i) &#123; h[u]=add(h[u],mul(vp[i].first,tmp)); tmp=mul(tmp,Base); &#125; h[u]=mul(h[u],n); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=fa) dfs2(v,u); &#125; &#125; void solve(int id) &#123; dfs1(1,0); dfs2(1,0); if(!id) &#123; for(int i=1;i&lt;=n;++i) s.insert(h[i]); &#125; else &#123; int inv=fpow(n,P-2); for(int i=1;i&lt;=n;++i) &#123; if(deg[i]!=1) continue; int tmp=mul(h[i],inv); if(s.find(tmp)!=s.end()) &#123; cout&lt;&lt;i&lt;&lt;endl; return; &#125; &#125; &#125; &#125;&#125;A,B;int main()&#123; int n=read(); Pow[0]=1; for(int i=1;i&lt;=n+1;++i) Pow[i]=mul(Pow[i-1],Base); A.n=n,B.n=n+1; A.init(); B.init(); A.solve(0); B.solve(1); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190519]]></title>
    <url>%2F2019%2F05%2F20%2Ftest20190519%2F</url>
    <content type="text"><![CDATA[$T3$ 题意理解错了.直接爆炸. $sequence$ 考虑一段区间 $[l,r]$ 合法,则显然 $\forall\ l\leq i\leq r,b_i\geq \max_{j=l}^i a_j$ . 这个东西对于 $l,r$ 两边来说都是具有单调性的, $two\ pointer$ 扫一遍即可. 用线段树做 $RMQ$ 为 $O(nlogn)$ ,用 $ST$ 表则为 $O(n)$ . $circulate$ 考虑枚举循环节循环次数,对于每个确定的循环次数,二分出循环节数字的最大值. 为了计算不重不漏,容斥一下,该循环次数的质因子个数为奇数,则加上,否则减去. $2\times 10^{18}$ 有 $19$ 个数字…考试没加 $19$ 的情况,丢了 $20$ 分. $cannon$ 题意搞错了,没注意到一座山被轰了几次后高度减低,可以换其他的炮轰… $80pts$ 很简单.设 $f(i)$ 表示轰平一座高度为 $i$ 的山最少需要轰几次,然后从低到高判断能否轰即可. 转移就有 $\forall x\leq 0,f(x)=0.f(i)=1+f(i-max_D)$ , $max_D$ 表示 $A_j\geq i$ 中最大的 $D_j$ . $100pts$ 的做法就是在上面改一下.因为 $D\leq 300$ ,所以上面的 $f$ 数组有用的只有 $M\cdot D$ 个.用 $map$ 做即可.]]></content>
      <tags>
        <tag>二分</tag>
        <tag>STL</tag>
        <tag>two pointer</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4755 扭动的回文串]]></title>
    <url>%2F2019%2F05%2F20%2Fbzoj-4755-%E6%89%AD%E5%8A%A8%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[二分 + $Hash​$ . 先补充上多余字符,将回文串全部弄成奇回文串.然后二分 + $Hash$ 预处理出每个位置的最大回文半径. 对于第三种情况,可以枚举回文中心,显然往两边拓展时,过了最大回文半径时就换到另一个串是最优的.于是可以二分在另一个串中的长度, $Hash$ 判断合法性.拼接位置的处理比较麻烦,可以调用补字符前的原串 $Hash$ 值. 时间复杂度 $O(nlogn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef unsigned long long ull;const int MAXN=2e5+10;const ull Base=137;ull Pow[MAXN],Hash[4][MAXN],revHash[4][MAXN];int n,ans=1;char s[2][MAXN],buf[2][MAXN];int cnt;ull calc(int k,int l,int r)&#123; return Hash[k][r]-Pow[r-l+1]*Hash[k][l-1];&#125;ull revcalc(int k,int l,int r)&#123; return revHash[k][l]-Pow[r-l+1]*revHash[k][r+1];&#125;bool check(int k,int pos,int len)&#123; ull Left=calc(k,pos-len,pos-1); ull Right=revcalc(k,pos+1,pos+len); return Left==Right;&#125;int r[2][MAXN];int solve(int L,int R)&#123; int l=1,r=min(L,n-R+1),res=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(calc(2,L-mid+1,L)==revcalc(3,R,R+mid-1)) res=mid,l=mid+1; else r=mid-1; &#125; return res;&#125;int main()&#123; n=read(); scanf("%s%s",s[0]+1,s[1]+1); for(int k=0;k&lt;2;++k) &#123; for(int i=1;i&lt;=n;++i) Hash[k+2][i]=Hash[k+2][i-1]*Base+s[k][i]; for(int i=n;i&gt;=1;--i) revHash[k+2][i]=revHash[k+2][i+1]*Base+s[k][i]; &#125; n=cnt; Pow[0]=1; for(int i=1;i&lt;=n;++i) Pow[i]=Pow[i-1]*Base; for(int k=0;k&lt;2;++k) &#123; for(int i=1;i&lt;=n;++i) Hash[k][i]=Hash[k][i-1]*Base+(buf[k][i]); for(int i=n;i&gt;=1;--i) revHash[k][i]=revHash[k][i+1]*Base+(buf[k][i]); &#125; for(int k=0;k&lt;2;++k) &#123; for(int pos=1;pos&lt;=n;++pos) &#123; int L=1,R=(n-1)&gt;&gt;1; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(k,pos,mid)) r[k][pos]=mid,L=mid+1; else R=mid-1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; int L=(i-r[0][i]+1)&gt;&gt;1,R=(i+r[0][i])&gt;&gt;1; ans=max(ans,r[0][i]+solve(L-1,R)*2); &#125; for(int i=1;i&lt;=n;++i) &#123; int L=(i-r[1][i]+1)&gt;&gt;1,R=(i+r[1][i])&gt;&gt;1; ans=max(ans,r[1][i]+solve(L,R+1)*2); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4771 七彩树]]></title>
    <url>%2F2019%2F05%2F19%2Fbzoj-4771-%E4%B8%83%E5%BD%A9%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主席树. 询问的点要求在子树 $x$ 内,并且 $dep\leq dep_x+d$ ,这样就有 $dfn,dep$ 上的两维限制,所以可以用主席树把符合条件的点抠出来. 只需要考虑怎么计算不同颜色的种数.对于一种颜色,可以在每个点的位置让权值 $+1$ ,而在 $LCA$ 处让权值 $-1$ .只需要处理 $dfs$ 序相邻的两个点的 $LCA$ (因为最深)就可以保证询问子树时贡献不会被重复计算了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;struct PreSegtree&#123; int idx; void init()&#123;idx=0;Tree[0].siz=Tree[0].ls=Tree[0].rs=0;&#125; struct node &#123; int ls,rs,siz; &#125;Tree[MAXN*50];#define root Tree[o] void insert(int &amp;o,int lst,int l,int r,int pos,int c) &#123; o=++idx; root=Tree[lst]; root.siz+=c; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(root.ls,Tree[lst].ls,l,mid,pos,c); else insert(root.rs,Tree[lst].rs,mid+1,r,pos,c); &#125; int query(int o,int l,int r,int L,int R) &#123; if(L&gt;r || l&gt;R || !o) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.siz; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res; &#125;&#125;T;int rt[MAXN];int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m;int dfnidx=0,dfn[MAXN],rnk[MAXN],siz[MAXN],dep[MAXN];int fa[MAXN][20],Log[MAXN];int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=Log[dep[x]-dep[y]];i&gt;=0;--i) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=Log[dep[x]];i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfs(int u)&#123; dfn[u]=++dfnidx; rnk[dfnidx]=u; siz[u]=1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dep[v]=dep[u]+1; dfs(v); siz[u]+=siz[v]; &#125;&#125;set&lt;int&gt; S[MAXN];set&lt;int&gt;::iterator it;void init()&#123; ecnt=0; dfnidx=0; T.init(); memset(head,0,sizeof head); memset(rt,0,sizeof rt); memset(fa,0,sizeof fa); dep[1]=1;&#125;int pd[MAXN],v[MAXN];bool cmp(int x,int y)&#123; return dep[x]&lt;dep[y];&#125;void solve()&#123; int lastans=0; n=read(),m=read(); for(int i=1;i&lt;=n;++i) &#123; v[i]=read(); S[i].clear(); pd[i]=i; &#125; for(int i=2;i&lt;=n;++i) &#123; fa[i][0]=read(); addedge(fa[i][0],i); &#125; dfs(1); for(int j=1;j&lt;=Log[n];++j) for(int i=1;i&lt;=n;++i) fa[i][j]=fa[fa[i][j-1]][j-1]; sort(pd+1,pd+1+n,cmp); for(int i=1;i&lt;=n;++i) &#123; int j=pd[i]; int a=0,b=0; it=S[v[j]].lower_bound(dfn[j]); T.insert(rt[dep[j]],rt[dep[pd[i-1]]],1,n,dfn[j],1); if(it!=S[v[j]].end()) &#123; b=rnk[*it]; T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(b,j)],-1); &#125; if(it!=S[v[j]].begin()) &#123; --it; a=rnk[*it]; T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(a,j)],-1); &#125; if(a &amp;&amp; b) T.insert(rt[dep[j]],rt[dep[j]],1,n,dfn[LCA(a,b)],1); S[v[j]].insert(dfn[j]); &#125; while(m--) &#123; int x=read()^lastans; int d=read()^lastans; lastans=T.query(rt[min(dep[x]+d,dep[pd[n]])],1,n,dfn[x],dfn[x]+siz[x]-1); lastans-=T.query(rt[dep[x]-1],1,n,dfn[x],dfn[x]+siz[x]-1); printf("%d\n",lastans); &#125;&#125;int main()&#123; Log[1]=0; for(int i=2;i&lt;MAXN;++i) Log[i]=Log[i&gt;&gt;1]+1; int Testcases=read(); while(Testcases--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4773 负环]]></title>
    <url>%2F2019%2F05%2F19%2Fbzoj-4773-%E8%B4%9F%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[$floyd$ + 倍增. 写保卫王国那道题的时候学习了 Min-plus matrix multiplication ,即将矩阵乘法中的乘法换成加法,加法换成取 $\min$ .这东西还有其他的用法.若一个图的邻接矩阵的 $k$ 次方为 $A$ (在这样运算下), 则 $A_{i,j}$ 表示图中从 $i$ 到 $j$ ,经过 $k$ 条边的最短路长度. 为啥?因为这样运算其实就是 $floyd$ 的转移,只不过恰好也满足了结合律. 要找最短的负环,可以设 $f[k]$ 为原邻接矩阵的 $2^k$ 次方,倍增解决即可,环的大小即为边的数目. 时间复杂度 $O(n^3logn)$ . 注意要将邻接矩阵中自己到自己的距离设为 $0$ ,这样答案才满足单调性. 也可以直接二分答案,时间复杂度为 $O(n^3log^2n)$ ,但对于 $n\leq 300$ 来说差异不大. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int inf=1e9;const int MAXN=300+10;int n,m;struct Matrix&#123; int A[MAXN][MAXN]; Matrix()&#123;memset(A,63,sizeof A);&#125; Matrix operator * (const Matrix &amp;rhs) const &#123; Matrix res; for(int k=1;k&lt;=n;++k) for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) res.A[i][j]=min(res.A[i][j],A[i][k]+rhs.A[k][j]); return res; &#125;&#125;f[10],cur,nx;int Log[MAXN];int main()&#123; Log[1]=0; for(int i=2;i&lt;MAXN;++i) Log[i]=Log[i&gt;&gt;1]+1; n=read(),m=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); f[0].A[u][v]=w; &#125; for(int i=1;i&lt;=n;++i) cur.A[i][i]=f[0].A[i][i]=0; int mx=Log[n]; for(int i=1;i&lt;=mx;++i) f[i]=f[i-1]*f[i-1]; int ans=0; for(int i=mx;i&gt;=0;--i) &#123; bool flag=false; nx=f[i]*cur; for(int j=1;j&lt;=n &amp;&amp; !flag;++j) if(nx.A[j][j]&lt;0) flag=true; if(!flag) ans+=1&lt;&lt;i,cur=nx; &#125; printf("%d",ans+1&gt;n?0:ans+1); return 0;&#125;]]></content>
      <tags>
        <tag>floyd</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4774 修路]]></title>
    <url>%2F2019%2F05%2F17%2Fbzoj-4774-%E4%BF%AE%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[斯坦纳树 + 状压 . 开始感觉直接做一颗最小生成树出来,把没用的边割掉就好了.然而随手画几个图发现是错的. 然后学习了一波 最小斯坦纳树 .这东西可以看做是最小生成树的一般情况.生成树是求一个选边方案,将所有的点加入联通块中.斯坦纳树是把指定点集中的点加入联通块中,也可以加入不在点集中的点来辅助. 求解最小斯坦纳树是 $NP$ 的,没有多项式算法,用状压做.设 $f[S][i]$ 为指定点的连通状态为 $S$ ,最小斯坦纳树的根节点为 $i$ 时的最小权值.转移有两种.第一种是将当前集合拆成两个不相交的子集, $f[S][i]\leftarrow f[S_1][i]+f[S_2][i],S_1,S_2\subset S,S_1 \&amp; S_2=0$ .另一种是换根, $f[S][i]\leftarrow f[S][j]+val_{i,j}$ ,后者表示连接 $i,j$ 的边权.这东西有后效性,用 $Spfa$ 转移. 而这道题是指定点对间连通,可以看做最小斯坦纳森林.设 $g[S]$ 表示连通了点集 $S$ 的最小斯坦纳森林的权值. 转移有 $g[S]\leftarrow g[S_1]+g[S_2],S_1,S_2\subset S,S_1 \&amp; S_2=0​$ .即将 $S​$ 拆成两个不相交子集. $S_1,S_2​$ 都需要满足每对对应点要么都不在其中,要么都在其中. 最后答案就是 $g[S_0]$ , $S_0$ 表示将那 $2d$ 个点都连通的状态. 小心爆 $int$ . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e4+10,MAXS=1&lt;&lt;8;int inf;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;int f[MAXS][MAXN],g[MAXS];int n,m,D;queue&lt;int&gt; q;int vis[MAXN];void SPFA(int S)&#123; while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(f[S][v]-f[S][u]&gt;val[i]) &#123; f[S][v]=f[S][u]+val[i]; if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125;&#125;bool check(int S)&#123; return (S&amp;((1&lt;&lt;D)-1))==(S&gt;&gt;D);&#125;int main()&#123; n=read(),m=read(),D=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; memset(f,63,sizeof f); memset(g,63,sizeof g); inf=f[0][0]; for(int i=1;i&lt;=D;++i) f[1&lt;&lt;(i-1)][i]=f[1&lt;&lt;(D+i-1)][n-i+1]=0; int mx=1&lt;&lt;(2*D); for(int S=0;S&lt;mx;++S) &#123; for(int i=1;i&lt;=n;++i) &#123; for(int S1=(S-1)&amp;S;S1;S1=(S1-1)&amp;S) f[S][i]=min(f[S][i],f[S1][i]+f[S^S1][i]); if(f[S][i]&lt;inf) &#123; q.push(i); vis[i]=1; &#125; &#125; SPFA(S); for(int i=1;i&lt;=n;++i) g[S]=min(g[S],f[S][i]); &#125; for(int S=0;S&lt;mx;++S) for(int S1=(S-1)&amp;S;S1;S1=(S1-1)&amp;S) if(check(S1) &amp;&amp; check(S^S1)) g[S]=min(g[S],g[S1]+g[S^S1]); if(g[mx-1]&gt;=inf) puts("-1"); else cout&lt;&lt;g[mx-1]; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
        <tag>斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4735 你的生命已如风中残烛]]></title>
    <url>%2F2019%2F05%2F16%2Fbzoj-4735-%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%B7%B2%E5%A6%82%E9%A3%8E%E4%B8%AD%E6%AE%8B%E7%83%9B%2F</url>
    <content type="text"><![CDATA[一道短小精悍(指代码)的数学题. 把每个位置上的数都 $-1$ ,于是要求就变为每个位置的前缀和都是非负数. 如果在最后再加入一个 $-1$ ,那么就只有最后一个位置前缀和为 $-1$ ,其他位置都是非负数. 这样就可证明,对于一个序列的所有循环同构,有且仅有一种序列是合法的. 因为只有把多出来的 $-1$ 放在最后才合法.因为总和为 $-1$ ,若最后一个位置不是 $-1$ ,那么前面一个位置的前缀和一定为负. 而这个 $-1$ 可以是原有的与新加的共 $m-n+1$ 个 $-1$ 中的任意一个,所以应除去. $$ans=\frac {m!} {m-n+1}$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int n=read(),m=0; for(int i=1;i&lt;=n;++i) m+=read(); int ans=1; for(int i=2;i&lt;=m;++i) ans=mul(ans,i); ans=mul(ans,fpow(m-n+1,P-2)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4860 树的难题]]></title>
    <url>%2F2019%2F05%2F16%2Fbzoj-4860-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[点分治 + 线段树合并. 英语月考的时候一直在想这个题… 有路径长度的限制,可以考虑点分治.然后发现在合并两条路径时有两种情况. 靠近当前分治中心的那两条边如果颜色不同,就直接将两条路径权值加起来.否则还要减去那条边的颜色权值. 分治时把子树按照与当前分支中心连接的边的颜色排序,扫一遍,维护两颗线段树,分别表示连到分治中心的边与当前颜色不同的最大权值与相同的最大权值. 处理完一种颜色的时候把两颗线段树合并起来就好了.时间复杂度 $O(nlog^2n)$ . bzoj 不支持 C++11​ 是真的毒瘤… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pairtypedef pair&lt;int,int&gt; pii;const ll inf=1e18;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,limL,limR,roota,rootb,cnt;struct node&#123; int ls,rs; ll mxv;&#125;Tree[MAXN*30];#define root Tree[o]int newnode()&#123; int o=++cnt; root.ls=root.rs=0; root.mxv=-inf; return o;&#125;void pushup(int o)&#123; root.mxv=max(Tree[root.ls].mxv,Tree[root.rs].mxv);&#125;int merge(int a,int b)&#123; if(!a || !b) return a+b; Tree[a].mxv=max(Tree[a].mxv,Tree[b].mxv); Tree[a].ls=merge(Tree[a].ls,Tree[b].ls); Tree[a].rs=merge(Tree[a].rs,Tree[b].rs); return a;&#125;void insert(int &amp;o,int l,int r,int pos,ll c)&#123; if(!o) o=newnode(); if(l==r) &#123; root.mxv=max(root.mxv,c); return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(root.ls,l,mid,pos,c); else insert(root.rs,mid+1,r,pos,c); pushup(o);&#125;ll query(int o,int l,int r,int L,int R)&#123; if(!o) return -inf; if(L&lt;=l &amp;&amp; r&lt;=R) return root.mxv; ll res=-inf; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) res=max(res,query(root.ls,l,mid,L,R)); if(R&gt;mid) res=max(res,query(root.rs,mid+1,r,L,R)); return res;&#125;vector&lt;pii&gt; edge[MAXN];ll ans=-inf,mi;int rt=0,totsize,vis[MAXN],siz[MAXN];int val[MAXN];void Findrt(int u)&#123; siz[u]=1; vis[u]=1; int sonsize=0; int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second; if(vis[v]) continue; Findrt(v); siz[u]+=siz[v]; sonsize=max(sonsize,siz[v]); &#125; sonsize=max(sonsize,totsize-siz[u]); if(sonsize&lt;mi) rt=u,mi=sonsize; vis[u]=0;&#125;void getsize(int u)&#123; ++totsize; vis[u]=1; int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second; if(!vis[v]) getsize(v); &#125; vis[u]=0;&#125;ll mx[MAXN];void dfs(int u,ll c,int len,int curcol)&#123; if(len&gt;limR) return; vis[u]=1; mx[len]=max(mx[len],c); int SIZ=edge[u].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii i=edge[u][id]; int v=i.second,r=i.first; ll newc=c; if(r!=curcol) newc+=val[r]; if(!vis[v]) dfs(v,newc,len+1,r); &#125; vis[u]=0;&#125;void solve(int u)&#123; totsize=cnt=roota=rootb=0; mi=inf; getsize(u); Findrt(u); int Rt=rt; getsize(Rt); vis[Rt]=1; int precol=0; int SIZ=edge[Rt].size(); for(int id=0;id&lt;SIZ;++id) &#123; pii e=edge[Rt][id]; int v=e.second,r=e.first; if(vis[v]) continue; for(int k=0;k&lt;=siz[v];++k) mx[k]=-inf; if(rootb &amp;&amp; r!=precol) &#123; roota=merge(roota,rootb); rootb=0; &#125; dfs(v,val[r],1,r); for(int i=1;i&lt;=siz[v] &amp;&amp; i&lt;limR &amp;&amp; mx[i]!=mx[0];++i) &#123; ll tmp=max(ans,i&gt;=limL &amp;&amp; i&lt;=limR? mx[i]:-inf); tmp=max(tmp,query(roota,1,limR,max(1,limL-i),limR-i)+mx[i]); tmp=max(tmp,query(rootb,1,limR,max(1,limL-i),limR-i)-val[r]+mx[i]); ans=max(ans,tmp); &#125; for(int i=1;i&lt;=siz[v] &amp;&amp; i&lt;limR &amp;&amp; mx[i]!=mx[0];++i) &#123; insert(rootb,1,limR,i,mx[i]); &#125; precol=r; &#125; for(int id=0;id&lt;SIZ;++id) &#123; pii e=edge[Rt][id]; int v=e.second; if(!vis[v]) solve(v); &#125;&#125;int main()&#123; Tree[0].mxv=-inf; n=read(),m=read(),limL=read(),limR=read(); for(int i=1;i&lt;=m;++i) val[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),c=read(); edge[u].push_back(mp(c,v)); edge[v].push_back(mp(c,u)); &#125; for(int i=1;i&lt;=n;++i) sort(edge[i].begin(),edge[i].end()); solve(1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树合并</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4916 神犇与蒟蒻]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4916-%E7%A5%9E%E7%8A%87%E4%B8%8E%E8%92%9F%E8%92%BB%2F</url>
    <content type="text"><![CDATA[杜教筛小水题. 根据 $\mu$ 的定义,第一个式子显然为 $1$ . 根据 $\varphi$ 的定义,第二个式子显然为 $\sum_{i=1}^N i\cdot \varphi(i)$ ,直接杜教筛即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P; &#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv2,inv6;inline int sumh(int x)&#123; int s=mul(x,x+1); s=mul(s,2*x+1); s=mul(s,inv6); return s;&#125;inline int sumg(int l,int r)&#123; return mul(mul(l+r,r-l+1),inv2);&#125;const int N=32000,MAXN=N+10;int phi[MAXN],cnt=0,prime[MAXN],ism[MAXN],sum[MAXN];void init()&#123; phi[1]=1,ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=N;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=mul(phi[i],prime[j]); break; &#125; phi[i*prime[j]]=mul(phi[i],prime[j]-1); &#125; &#125; for(int i=1;i&lt;=N;++i) sum[i]=add(sum[i-1],mul(i,phi[i]));&#125;map&lt;int,int&gt; mp;int calc(int n)&#123; if(n&lt;=N) return sum[n]; if(mp.find(n)!=mp.end()) return mp[n]; int res=sumh(n); for(int l=2,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); res=add(res,P-mul(sumg(l,r),calc(n/l))); &#125; return mp[n]=res;&#125;int main()&#123; inv2=fpow(2,P-2); inv6=fpow(6,P-2); init(); int n=read(); printf("%d\n%d\n",1,calc(n)); return 0;&#125;]]></content>
      <tags>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4926 皮皮妖的递推]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4926-%E7%9A%AE%E7%9A%AE%E5%A6%96%E7%9A%84%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[构造. 发现这个迭代过程与斐波那契数列有相似之处,构造 $g(i)=g(i-1)+g(i-m),g(0)=1$ . 把 $n$ 拆成 $k$ 个 $g_i$ 的和, $n=\sum_{i=1}^k g(a_i)$ ,则 $f_n=\sum_{i=1}^k g(a_i-1)$ . 证明:将 $f$ 定义式变形得到 $f(n)+f^m(n-1)=n$ .而 $n=\sum_{i=1}^k g(a_i),f_n=\sum_{i=1}^k g(a_i-1)$ . $f^2(n)=\sum_{i=1}^k g(a_i-2)$ ,依次计算,可得 $f^m(n)=\sum_{i=1}^k g(a_i-m)$ . 而现在需要的是 $f^m(n-1)$ ,而 $n$ 只比 $n-1$ 多了个 $1$ ,把 $g(0)$ 设为 $1$ 即可. 那么就有 $\sum_{i=1}^k g(a_i-1)+\sum_{i=1}^k g(a_i-m)=\sum_{i=1}^k g(a_i)$ .于是 $g(i)=g(i-1)+g(i-m),g(0)=1$ . 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e6+10;ll g[MAXN];int main()&#123; ll n=read(),m=read(); for(int i=0;i&lt;=m;++i) g[i]=1; int mx=m+1; for(;;++mx) &#123; g[mx]=g[mx-1]+g[mx-m]; if(g[mx]&gt;n) break; &#125; --mx; ll ans=0; for(int i=mx;i&gt;=1 &amp;&amp; n;--i) if(n&gt;=g[i]) n-=g[i],ans+=g[i-1]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4962 简单的字符串]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4962-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$Manacher$ . 不知道性质的话应该挺难做的… 先枚举子串中心,往两侧拓展,将走到的位置的字符交替写下来,记作 $S$ . 比如字符串是 $abcdacce$ ,以 $d$ 右侧的那个位置为中心,则 $S=daccbcae$ (此处先写左边). 若中心的两侧长度为 $L$ 的两个子串循环同构,则 $S$ 中对应的长度为 $2L$ 的前缀能被 $1$ 或 $2$ 个偶回文串拼接成. 证明:如果左右两个子串完全相同,那么这个长度为 $2L$ 的前缀自身就是一个偶回文串.否则,若左右两个子串不同,但循环同构,那么设右边的串为 $s_1,s_2,\dots s_L$ ,左边的串为 $s_i,s_{i+1},\dots,s_L,s_1,s_2\dots,s_{i-1}$ . 那么这个长度为 $2L$ 的前缀就应该是 $(s_{i-1},s_1,s_{i-2},s_2,\dots,s_1,s_{i-1})+(s_L,s_i,s_{L-1},s_{i+1},\dots,s_i,s_L)$ . 显然加号两边的串都是偶回文串. 还有一个性质,若 $S=u+v$ , $u$ 和 $v$ 都是偶回文串,那么要么 $u$ 是 $S$ 的最长偶回文前缀,要么 $v$ 是 $S$ 的最长偶回文后缀.Claris的证明 于是用 $Manacher$ 跑出每个位置的最长回文半径 $rmax$ ,对于每个前缀判断一下拆成 最长偶回文前缀 + 偶回文串 与拆成 偶回文串 + 最长偶回文后缀 是否有一个合法即可. 时间复杂度 $O(n^2)$ . 若用 $Hash$ 代替 $Manacher$ 则为 $O(n^2 logn)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=5e3+10;int ch[MAXN],s[MAXN];int n,rmax[MAXN],pre[MAXN];int solve(int p)&#123; int len=0; for(int i=p,j=p+1;i&gt;=1 &amp;&amp; j&lt;=n;--i,++j) s[++len]=ch[i],s[++len]=ch[j]; fill(pre+1,pre+2+len,0); int r=0,pos=1; for(int i=1;i&lt;=len;++i) &#123; int mx=min(max(r-i,0),rmax[2*pos-i]); while(i+mx+1&lt;=n &amp;&amp; i-mx&gt;0 &amp;&amp; s[i+mx+1]==s[i-mx]) ++mx; rmax[i]=mx; if(i+mx&gt;=r) r=i+mx,pos=i; pre[i+rmax[i]]=max(pre[i+rmax[i]],rmax[i]); &#125; for(int i=len;i&gt;=1;--i) pre[i]=max(pre[i],pre[i+1]-1); for(int i=len;i&gt;=1;i-=2) pre[i]&lt;&lt;=1; int mx=0,res=0; for(int i=2;i&lt;=len;i+=2) &#123; if(rmax[i/2]==i/2) mx=i; if(rmax[(i+mx)/2]&gt;=(i-mx)/2 || rmax[(i-pre[i])/2]&gt;=(i-pre[i])/2) ++res; &#125; return res;&#125;int main()&#123; int ans=0; n=read(); for(int i=1;i&lt;=n;++i) ch[i]=read(); for(int i=1;i&lt;n;++i) ans+=solve(i); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4985 评分]]></title>
    <url>%2F2019%2F05%2F14%2Fbzoj-4985-%E8%AF%84%E5%88%86%2F</url>
    <content type="text"><![CDATA[二分答案 + $dp$ . 这种只有比较大小的操作的题,套路大多是二分答案 $x$ ,将大于等于 $x$ 的视作 $1$ ,其余视作 $0$ ,再考虑判断. 此题二分答案后,可以设 $f(i)$ 表示要将位置 $i$ 上的数确定为 $1$ ,至少需要在前面填几个 $1$ (已确定的位置不算). 那么初始时,若 $i$ 的值未确定,则 $f(i)=1$ ,若 $\geq x$ ,则为 $0$ ,若 $&lt;x$ ,则为 $inf$ . 转移时用队列,将前三个取出来,将最小的两个值加起来放在最后.因为要让最后一个为 $1$ ,则这三个中至少有两个 $1$ . 只剩下一个数时,判断它是否不超过可以随便填的 $1$ 的数目即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;const int inf=1e9;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m;int d[MAXN];int fd[MAXN];queue&lt;int&gt; q;bool check(int x)&#123; while(!q.empty()) q.pop(); int fcnt=0; for(int i=1;i&lt;=n-m;++i) if(fd[i]&gt;=x) ++fcnt; for(int i=1;i&lt;=n;++i) &#123; if(d[i]==0) q.push(1); else if(d[i]&gt;=x) q.push(0); else q.push(inf); &#125; while(1) &#123; int a=q.front(); q.pop(); if(q.empty()) return a&lt;=fcnt; int b=q.front(); q.pop(); int c=q.front(); q.pop(); q.push(min(inf,min(a+b,min(a+c,b+c)))); &#125;&#125;int main()&#123; n=read(),m=read(); int L=1,R=0; for(int i=1;i&lt;=m;++i) &#123; int x=read(),pos=read(); d[pos]=x; R=max(R,x); &#125; for(int i=1;i&lt;=n-m;++i) &#123; fd[i]=read(); R=max(R,fd[i]); &#125; int ans=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid)) ans=mid,L=mid+1; else R=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4998 星球联盟]]></title>
    <url>%2F2019%2F05%2F13%2Fbzoj-4998-%E6%98%9F%E7%90%83%E8%81%94%E7%9B%9F%2F</url>
    <content type="text"><![CDATA[离线,并查集维护点双. 一个比较直接的做法是将点双缩点,然后用 $LCT$ 维护缩点后的树. 其实也可以直接用并查集做.因为只有加边的操作,所以可以离线处理出最后图的一颗生成树. 然后加边时,若为树边,答案显然是 $No$ .否则用并查集将那两个点合并起来,同时维护 $siz$ 就好了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,m,q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;2],nx[MAXN&lt;&lt;2];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int f[MAXN],siz[MAXN];int Find(int x)&#123; return x==f[x]?x:(f[x]=Find(f[x]));&#125;int U[MAXN&lt;&lt;1],V[MAXN&lt;&lt;1];int fa[MAXN],dep[MAXN];void dfs(int u,int Fa)&#123; fa[u]=Fa; dep[u]=dep[Fa]+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v!=Fa) dfs(v,u); &#125;&#125;int treeedge[MAXN&lt;&lt;1];void merge(int x,int y)&#123; x=Find(x),y=Find(y); while(x!=y) &#123; if(dep[x]&lt;dep[y]) swap(x,y); int fx=Find(fa[x]); f[x]=fx; siz[fx]+=siz[x]; x=fx; &#125;&#125;int main()&#123; n=read(),m=read(),q=read(); for(int i=1;i&lt;=n;++i) f[i]=i; for(int i=1;i&lt;=m+q;++i) &#123; int u=read(),v=read(); U[i]=u,V[i]=v; int x=Find(u),y=Find(v); if(x!=y) &#123; f[x]=y; addedge(u,v); addedge(v,u); treeedge[i]=1; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!fa[i]) dfs(i,i); for(int i=1;i&lt;=n;++i) f[i]=i,siz[i]=1; for(int i=1;i&lt;=m;++i) if(!treeedge[i]) merge(U[i],V[i]); for(int i=m+1;i&lt;=m+q;++i) &#123; if(treeedge[i]) puts("No"); else &#123; merge(U[i],V[i]); printf("%d\n",siz[Find(U[i])]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190512]]></title>
    <url>%2F2019%2F05%2F12%2Ftest20190512%2F</url>
    <content type="text"><![CDATA[普及组套题.可能就 $AK$ 了. 前两题很 $sb$ ,没啥可说的. 考后发现 $T3$ 是个普及组模拟赛的题?还是入门 $OJ$ 上的… Link 考试做法:考虑枚举答案为 $t$ ,那么前 $t$ 天不割的总长是确定的,为 $\sum h_i+t\cdot grow_i$ .需要最大化 $t$ 次割草割去的长度总和. 一株草显然可以只割一次,割多次和只割最后一次是等价的.那么枚举范围就可以设为 $1\sim n$ . 而同一天也不能割两株草.所以 $n$ 株草, $t$ 天就形成了一个 $n\times t$ 的矩阵,每个点有权值,现在每一行每一列最多选 $1$ 个,要求共选 $t​$ 个的最大收益,就成了经典模型. 用一个大数 $inf$ 减去原权值作为权值,就是最小费用最大流,最后算一下就可以了.由于 $n\leq 50​$ ,肯定能过. 大家的做法:枚举答案 $t$ ,将草按 $grow$ 排序,先割 $grow$ 小的,再割大的,总共割 $t$ 次. 然后设 $f(i,j)$ 表示前 $i$ 株草割了 $j$ 株能获得的最大收益就好了. 贪心部分的正确性可以用经典套路证明,尝试交换两株草被割的次序,答案不会变得更优. 顿时感觉自己好 $sb​$ 啊.如果这题把数据出大点今天可能就凉了…]]></content>
      <tags>
        <tag>背包</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5479 tree]]></title>
    <url>%2F2019%2F05%2F12%2Fbzoj-5479-tree%2F</url>
    <content type="text"><![CDATA[欧拉序 + 贪心 + 二分. $LCA$ 问题首先可以处理出欧拉序,将树上问题转化成序列问题. 于是就变成了给出一些 $A$ 类点,一些 $B$ 类点,选两个不同类的点作为区间,求区间内 $dep$ 的最小值的最大值. 看上去可以直接二分,然而没什么用,因为区间数目是 $|A|\cdot |B|$ 的. 考虑贪心.对于一个 $B$ 类点,如果我们钦定它作为左端点,那么那个作为右端点的 $A$ 类点应该越靠左越好.如果钦定它为右端点,那么那个 $A$ 类点应该越靠左越好. 于是对每个 $B$ 类点二分出左/右最近的 $A$ 类点,将这两个区间的 $dep$ 最小值加入贡献. 预处理 $ST$ 表,时间复杂度 $O(\sum |B| \cdot log|A|)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10;int n,m;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int dep[MAXN],dfn[MAXN],idx;int a[MAXN&lt;&lt;1];void dfs(int u,int fa)&#123; dep[u]=dep[fa]+1; dfn[u]=++idx; a[idx]=dep[u]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); a[++idx]=dep[u]; &#125;&#125;const int LogN=20;int st[MAXN&lt;&lt;1][LogN];int Log[MAXN&lt;&lt;1];void init_ST()&#123; for(int i=1;i&lt;=2*n-1;++i) st[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=2*n-1;++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=2*n-1;++i) st[i][j]=min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);&#125;int query(int l,int r)&#123; int k=Log[r-l+1]; return min(st[l][k],st[r-(1&lt;&lt;k)+1][k]);&#125;void reset()&#123; ecnt=0; idx=0; for(int i=1;i&lt;=n;++i) head[i]=0;&#125;int dfnset[MAXN&lt;&lt;1],A;int pre(int x)&#123; return dfnset[upper_bound(dfnset,dfnset+A,x)-dfnset-1];&#125;int suf(int x)&#123; return dfnset[lower_bound(dfnset,dfnset+A,x)-dfnset];&#125;int main()&#123; Log[1]=0; for(int i=2;i&lt;=200000;++i) Log[i]=Log[i&gt;&gt;1]+1; int T=read(); while(T--) &#123; n=read(),m=read(); reset(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; dfs(1,0); init_ST(); while(m--) &#123; int ans=0; A=read(); for(int i=1;i&lt;=A;++i) dfnset[i]=dfn[read()]; sort(dfnset+1,dfnset+1+A); dfnset[0]=0,dfnset[A+1]=2*n; A+=2; int B=read(); for(int i=1;i&lt;=B;++i) &#123; int x=dfn[read()]; int lx=pre(x),rx=suf(x); if(lx) ans=max(ans,query(lx,x)); if(rx!=2*n) ans=max(ans,query(x,rx)); &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5478 gcd]]></title>
    <url>%2F2019%2F05%2F11%2Fbzoj-5478-gcd%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演. 题面有误, $a$ 应该是 $1\sim n$ 的一个排列.因为这个卡了好久… 用 $\varphi$ 反演就很好做. $O(n)$ 大力枚举 $d$ ,因为 $a$ 是个排列,所以可以大力枚举集合中的每个数的约数,对 $1\sim n$ 中每个数记录一下有 $f(i)$ 个数是它的倍数,那么后面那坨就是 $\sum f(i)^2$ 了. 集合大小总和是个调和级数,总时间复杂度应该是 $O(nlog^3n)$ .(其实我不会证) 直接 $memset$ 会 $T$ ,可能需要一点卡常的奇技淫巧. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;const int MAXN=1e5+10;inline int add(int a,int b)&#123; return (a+b&gt;=P)?(a+b-P):(a+b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int n,a[MAXN];int phi[MAXN],ism[MAXN],cnt=0,prime[MAXN];vector&lt;int&gt; factor[MAXN];void init()&#123; for(int i=1;i&lt;=n;++i) for(int j=i;j&lt;=n;j+=i) factor[j].push_back(i); ism[1]=1,phi[1]=1; for(int i=2;i&lt;=n;++i) &#123; if(!ism[i]) prime[++cnt]=i,phi[i]=i-1; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=n;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) &#123; phi[i*prime[j]]=mul(phi[i],prime[j]); break; &#125; phi[i*prime[j]]=mul(phi[i],prime[j]-1); &#125; &#125;&#125;int f[MAXN],vis[MAXN];int main()&#123; n=read(); init(); for(int i=1;i&lt;=n;++i) a[i]=read(); int ans=0; for(int i=1;i&lt;=n;++i) &#123; int res=0; for(int j=i;j&lt;=n;j+=i) &#123; int p=a[j]; int siz=factor[p].size(); for(int k=0;k&lt;siz;++k) &#123; int q=factor[p][k]; if(vis[q]!=i) &#123; f[q]=1; vis[q]=i; &#125; else ++f[q]; res=add(res,mul(2*f[q]-1,phi[q])); &#125; &#125; res=mul(res,phi[i]); ans=add(ans,res); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5477 星际穿越]]></title>
    <url>%2F2019%2F05%2F10%2Fbzoj-5477-%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A%2F</url>
    <content type="text"><![CDATA[$dfs$ 序 + 树状数组. 由于路径的权是点权,可以考虑每个点被多少条路径经过,乘上它的点权即为贡献. 假设当前询问是在子树 $p$ 内,考虑一个点 $i$ ,在子树 $i$ 内与不在子树 $i$ 内的点形成了 $siz[i]\cdot (siz[p]-siz[i]+1)$ 条路径,都经过了点 $i$ . 还有一部分路径是将 $i$ 作为 $LCA$ 经过.显然每两个在 $i$ 的不同儿子形成的子树内的点都会经过 $i$ .这部分路径数目可以在 $dfs$ 时利用前缀和算出,记作 $k[i]$ . 由于修改只会单点修改点权,不改变树的形态,把那个 $siz[p]$ 拆出去算,预处理出每个点的剩下的系数. 直接利用 $dfs$ 序,树状数组维护答案. 记 $w[i]=k[i]+siz[i]\cdot (1-siz[u])​$ . 那么每次询问的答案就是子树 $p​$ 内的 $siz[p]\cdot (\sum siz[i]\cdot val[i])+(\sum w[i]\cdot val[i])​$ . 开两个树状数组分别维护前缀 $\sum siz\cdot val$ 与 $\sum siz\cdot w$ 就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;const int P=1e9+7;int n,m;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct FenwickTree&#123; #define lowbit(x) x&amp;(-x) int bit[MAXN]; FenwickTree()&#123;memset(bit,0,sizeof bit);&#125; void upd(int x,int c) &#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]=add(bit[x],c); &#125; int sum(int x) &#123; int s=0; for(;x;x-=lowbit(x)) s=add(s,bit[x]); return s; &#125; int query(int l,int r) &#123; return add(sum(r),P-sum(l-1)); &#125;&#125;;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN];void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int siz[MAXN],dfn[MAXN],idx=0;int k[MAXN],w[MAXN];void dfs(int u,int fa)&#123; dfn[u]=++idx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u); k[u]=add(k[u],mul(siz[v],siz[u])); siz[u]+=siz[v]; &#125; siz[u]++;&#125;FenwickTree T1;//siz*valFenwickTree T2;//w*valvoid init()&#123; for(int i=1;i&lt;=n;++i) &#123; T1.upd(dfn[i],mul(siz[i],val[i])); w[i]=add(k[i],mul(siz[i],P+1-siz[i])); T2.upd(dfn[i],mul(w[i],val[i])); &#125;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;++i) &#123; val[i]=1; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; val[n]=1; dfs(1,0); init(); while(m--) &#123; int op=read(); if(op==1) &#123; int p=read(),x=read(); T1.upd(dfn[p],mul(siz[p],x)); T2.upd(dfn[p],mul(w[p],x)); &#125; else &#123; int p=read(); int ans=T2.query(dfn[p],dfn[p]+siz[p]-1); ans=add(ans,mul(siz[p],T1.query(dfn[p],dfn[p]+siz[p]-1))); printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5476 位运算]]></title>
    <url>%2F2019%2F05%2F09%2Fbzoj-5476-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[树状数组. 如果直接离散化 + 莫队,时间复杂度 $O(m\sqrt n)$ ,无法通过. 如果在计算异或和时,一个数在区间内出现了 $k$ 次,使最后一次不计入贡献,那么就只算了 $k-1$ 次. 这样得到的答案就是出现偶数次的数的异或和. 将询问离线,并按照 $r$ 排序,于是可以从前往后一个个加入数.加入一个数 $a_i$ 后,就处理所有 $r=i$ 的询问. 每次加入数 $x$ 时,在它的上一次出现的位置(若有)加入贡献即可.用树状数组维护前缀异或和. $bzoj$ 上数据有点毒.还需要开 $long\ long$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;ll a[MAXN],A[MAXN];int n,m,tot;ll res[MAXN];struct qry&#123; int l,r; int id; bool operator &lt; (const qry &amp;rhs) const &#123; return r==rhs.r?l&lt;rhs.l:r&lt;rhs.r; &#125;&#125;q[MAXN];#define lowbit(x) x&amp;(-x)ll bit[MAXN];void add(int x,ll c)&#123; for(;x&lt;=n;x+=lowbit(x)) bit[x]^=c;&#125;ll sum(int x)&#123; ll s=0; for(;x&gt;0;x-=lowbit(x)) s^=bit[x]; return s;&#125;ll query(int l,int r)&#123; return sum(r)^sum(l-1);&#125;int lstpos[MAXN];int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) A[i]=a[i]=read(); sort(A+1,A+1+n); tot=unique(A+1,A+1+n)-A-1; m=read(); for(int i=1;i&lt;=m;++i) &#123; q[i].l=read(),q[i].r=read(); q[i].id=i; &#125; sort(q+1,q+1+m); for(int i=1,j=1;i&lt;=n;++i) &#123; int x=lower_bound(A+1,A+1+tot,a[i])-A; if(lstpos[x]) add(lstpos[x],A[x]); lstpos[x]=i; for(;j&lt;=m &amp;&amp; q[j].r==i;++j) res[q[j].id]=query(q[j].l,q[j].r); &#125; for(int i=1;i&lt;=m;++i) printf("%lld\n",res[i]); return 0;&#125;]]></content>
      <tags>
        <tag>位运算</tag>
        <tag>离线</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 5496 字符串问题]]></title>
    <url>%2F2019%2F05%2F09%2Fbzoj-5496-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$SAM$ 优化连边 + $DAG$ 上 $dp$ . 首先可以搞一个 $n_a+n_b$ 个节点的图.如果一个 $A$ 串支配了一个 $B$ 串,就从这个 $A$ 串对应的点向 $B$ 串对应的点连一条有向边.如果一个 $B$ 串是一个 $A$ 串的前缀,就从这个 $B$ 串对应的点向 $A$ 串对应的点连一条有向边. 然后判环,如果没有环就在 $DAG$ 上 $dp$ 找最长路径.节点数目为 $O(n_a+n_b)$ ,可以接受. 但是暴力连边的时间复杂度高达 $O(n_an_b)$ ,于是获得 $40$ 分好成绩. 考虑利用 $SAM$ 的 $parent$ 树自带的树形结构来优化连边. 第一类边,对于一个 $A$ 串,我们可以在 $SAM$ 上倍增找到它对应的节点,然后对于每个它支配的 $B$ 串也用倍增找到节点,从 $A$ 串节点向 $B$ 串节点连一条有向边. 第二类边,要求 $B$ 串是 $A$ 串前缀.我们如果把主串反过来,就变成了 $B$ 串是 $A$ 串的后缀.在 $parent$ 树上显然表现为 $B$ 对应的节点是 $A$ 对应的节点的祖先.那么建 $parent$ 树时就从父亲到儿子连有向边,边自动就连好了. 这样连边的时间复杂度为 $O(|S|log|S|)$ ,节点数目为 $O(|S|)$ ,均可以接受. 但还存在一个问题. $parent$ 树上一个节点对应的子串不止一个.可能出现两个 $A$ 串都被定位到一个节点上.于是每次 $A$ 串定位到一个位置时就新建一个节点栽上去.新建 $n_a​$ 个节点,不会爆炸. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;const int Siz=26,MAXN=1e6+10;int lst,idx,tmp;int n,m,K;int siz[MAXN],pos[MAXN];int ch[MAXN][Siz],fa[MAXN];int len[MAXN];void Extend(int c,int id)&#123; int p=lst,np=++idx; lst=np; pos[id]=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int L;int Lg[MAXN];int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],eval[MAXN],indeg[MAXN];ll dp[MAXN];int val[MAXN],dep[MAXN],g[MAXN];vector&lt;pii&gt; d[MAXN];vector&lt;int&gt; v[MAXN];set&lt;pii&gt; s;int l[MAXN],r[MAXN],p[MAXN];int A[MAXN],t[MAXN];void topsort()&#123; for(int i=1;i&lt;=idx;++i) t[len[i]]++; for(int i=1;i&lt;=L;++i) t[i]+=t[i-1]; for(int i=idx;i&gt;=1;--i) A[t[len[i]]--]=i; for(int i=1;i&lt;=idx;++i) &#123; int u=A[i]; dep[u]=dep[fa[u]]+1; v[fa[u]].push_back(u); &#125; for(int i=1;i&lt;=L;++i) t[i]=0;&#125;inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; ++indeg[v]; eval[ecnt]=w; head[u]=ecnt;&#125;const int Logn=20;int f[MAXN][Logn];int jump(int u,int l)&#123; for(int i=Lg[dep[u]];i&gt;=0;--i) if(len[f[u][i]]&gt;=l) u=f[u][i]; pii t=make_pair(u,l); if(s.find(t)==s.end()) &#123; g[u]++; s.insert(t); &#125; return u;&#125;void dfs(int u,int Fa)&#123; if(Fa) addedge(Fa,u,0); int h=0; sort(d[u].begin(),d[u].end()); if(d[u].size()) &#123; p[d[u][0].second]=u; for(int i=1;i&lt;d[u].size();++i) &#123; if(d[u][i].first!=d[u][i-1].first) &#123; h=i; break; &#125; p[d[u][i].second]=u; &#125; &#125; int pre=u; while(g[u]&gt;1) &#123; ++idx; --g[u]; p[d[u][h].second]=idx; for(int i=h+1;i&lt;d[u].size();++i) &#123; if(d[u][i].first!=d[u][i-1].first) &#123; h=i; break; &#125; p[d[u][i].second]=idx; &#125; addedge(pre,idx,0); pre=idx; &#125; for(int i=0;i&lt;v[u].size();++i) dfs(v[u][i],pre);&#125;char buf[MAXN];void init()&#123; s.clear(); ecnt=0; for(int i=1;i&lt;=idx;++i) &#123; dep[i]=0; head[i]=0; indeg[i]=0; dp[i]=0; val[i]=0; &#125; for(int i=1;i&lt;=tmp;++i) &#123; v[i].clear(); d[i].clear(); memset(ch[i],0,sizeof ch[i]); fa[i]=0; g[i]=0; &#125; lst=idx=1;&#125;int q[MAXN];void solve()&#123; scanf("%s",buf+1); L=strlen(buf+1); for(int i=L;i&gt;=1;--i) Extend(buf[i]-'a',i); topsort(); for(int i=2;i&lt;=idx;++i) f[i][0]=fa[i]; for(int j=1;j&lt;=Lg[L];++j) for(int i=2;i&lt;=idx;++i) f[i][j]=f[f[i][j-1]][j-1]; n=read(); for(int i=1;i&lt;=n;++i) &#123; l[i]=read(); r[i]=read(); p[i]=jump(pos[l[i]],r[i]-l[i]+1); &#125; m=read(); for(int i=n+1;i&lt;=n+m;++i) &#123; l[i]=read(); r[i]=read(); p[i]=jump(pos[l[i]],r[i]-l[i]+1); &#125; for(int i=1;i&lt;=n+m;++i) d[p[i]].push_back(make_pair(r[i]-l[i]+1,i)); tmp=idx; dfs(1,0); for(int i=1;i&lt;=n;++i) val[p[i]]=r[i]-l[i]+1; K=read(); for(int i=1;i&lt;=K;++i) &#123; int x=read(),y=read(); addedge(p[x],p[y+n],r[x]-l[x]+1); &#125; int tot=0; ll ans=0; q[++tot]=1; for(int i=1;i&lt;=tot;++i) &#123; int U=q[i]; ans=max(ans,dp[U]+val[U]); for(int j=head[U];j;j=nx[j]) &#123; int V=to[j]; indeg[V]--; dp[V]=max(dp[V],dp[U]+eval[j]); if(!indeg[V]) q[++tot]=V; &#125; &#125; if(tot&lt;idx) puts("-1"); else printf("%lld\n",ans);&#125;int main()&#123; for(int i=2;i&lt;MAXN;++i) Lg[i]=Lg[i&gt;&gt;1]+1; int T=read(); while(T--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DAG</tag>
        <tag>SAM</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 5358 快速查询]]></title>
    <url>%2F2019%2F05%2F08%2FLuogu-5358-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[乱搞 $STL$ + 线性筛乘法逆元. 乱搞 $STL$ + 线性筛乘法逆元. 因为只有 $10^5$ 种操作,所以被单独赋值的位置最多也就 $10^5$ 个,这些可以开 $map$ 记录,其他位置可以整体维护. 维护 $mul,add,sum,v$ 四个标记, $mul,add$ 表示 $map$ 中存储的值为 $x$ ,实际上是 $mul\cdot x+add$ . $sum$ 表示当前所有元素的和. $v$ 表示不在 $map​$ 中的数统一的值. 初始 $mul=1,add=sum=v=0.​$ 几种操作仔细推一下就好了: 操作 $1$ :先用操作 $5$ 查询 $a_i$ ,算出新的 $sum$ ,再将 $map$ 中位置 $i$ 改为 $(val-add)\cdot mul^{-1}$ . 操作 $2$ : $sum+=val\cdot n,add+=val,v+=val.$ 操作 $3$ : 若 $val\not = 0,sum\times =val,mul\times =val,add\times =val,v\times =val.$ 若 $val=0$ ,执行操作 $4$ ,将所有值都赋为 $0$,否则会使 $mul=0$ ,要用到 $mul^{-1}​$ 时就炸了 . 操作 $4$ : 将 $map$ 清空, $sum=val\cdot n,mul=1,add=0,v=val$ . 操作 $5$ : 若 $a_i$ 在 $map$ 中有权值 $x$ ,那么就是 $mul\cdot x+add$ ,否则为 $v$ . 操作 $6$ : 当前的 $sum​$ . $O(P)$ 预处理乘法逆元,并使用 $unordered$_$map$ ,时间复杂度即为 $O(tq)$ .123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e7+19;int inv[P+10];void init()&#123; inv[1]=1; for(int i=2;i&lt;P;++i) &#123; inv[i]=1LL*(P-P/i)*inv[P%i]%P;// assert(1LL*inv[i]*i%P==1); &#125;&#125;inline int Add(int a,int b)&#123; return (a+b)%P;&#125;inline int Mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e5+10;unordered_map&lt;int,int&gt; mp;int n,q,t;int opt[MAXN],qx[MAXN],qy[MAXN];int add=0,mul=1,sum=0,v=0;int ans=0;int query(int x)&#123; if(mp.find(x)!=mp.end()) &#123; int key=mp[x]; return Add(add,Mul(key,mul)); &#125; else return v;&#125;void operate(int id)&#123; int val,op=opt[id],i; if(op==1) &#123; i=qx[id]; val=qy[id]; int org=query(i); sum=Add(sum,val-org); mul=Add(mul,P); int curv=Mul(inv[mul],Add(val,-add)); mp[i]=curv; return; &#125; if(op==2) &#123; val=qx[id]; sum=Add(sum,Mul(val,n)); add=Add(add,val); v=Add(v,val); return; &#125; bool trans=false; if(op==3) &#123; val=qx[id]; if(val) &#123; sum=Mul(sum,val); mul=Mul(mul,val); add=Mul(add,val); v=Mul(v,val); return; &#125; else op=4,trans=true; &#125; if(op==4) &#123; val=trans?0:qx[id]; mp.clear(); sum=Mul(val,n); mul=1,add=0; v=val; return; &#125; if(op==5) &#123; i=qx[id]; ans=Add(ans,query(i)); return; &#125; if(op==6) &#123; ans=Add(ans,sum); return; &#125;&#125;int main()&#123; init(); n=read(),q=read(); for(int i=1;i&lt;=q;++i) &#123; opt[i]=read(); if(opt[i]!=6) qx[i]=read(); if(opt[i]==1) qy[i]=read(); &#125; t=read(); while(t--) &#123; int a=read(),b=read(); for(int j=1;j&lt;=q;++j) operate((a+1LL*j*b)%q+1); &#125; printf("%d\n",(ans%P+P)%P); return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1149]]></title>
    <url>%2F2019%2F05%2F07%2FCF1149%2F</url>
    <content type="text"><![CDATA[$Div.1$ CF1149A Prefix Sum Primes 构造 + 贪心. 可以先线性筛预处理一个质数表.于是就变成了用一定数量的 $1,2​$ 来填每个位置差分的值. 从前往后填,如果当前能放 $2​$ 的话肯定不会劣于放两个 $1​$ .于是能放 $2​$ 就放,否则放 $1​$ ,直到放完为止. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e6+10;int prime[MAXN],cnt=0,ism[MAXN];void init(int N)&#123; ism[1]=1; for(int i=2;i&lt;=N;++i) &#123; if(!ism[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=N;++j) &#123; ism[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;int bgs[3];void solve()&#123; for(int i=1;i&lt;=cnt;++i) &#123; int dif=prime[i]-prime[i-1]; int us2=min(bgs[2],dif/2); for(int j=1;j&lt;=us2;++j) printf("2 "); bgs[2]-=us2; dif-=2*us2; int us1=min(bgs[1],dif); for(int j=1;j&lt;=us1;++j) printf("1 "); bgs[1]-=us1; if(bgs[1]+bgs[2]==0) return; &#125;&#125;int main()&#123; init(1000000); int n=read(); for(int i=1;i&lt;=n;++i) bgs[read()]++; solve(); return 0;&#125; CF1149B Three Religions 贪心 + $dp$ . 首先可以发现如果三个串匹配到了一定位置,最后在原串中用的字符位置肯定越靠前越好. 于是可以设 $f(i,j,k)$ 表示三个串分别匹配了 $i,j,k$ 的长度时,最后用的字符在原串中的位置. 可以预处理 $nx(i,j)$ 表示原串中第 $i$ 个字符往后跳,跳到的第一个字符为 $j$ 的位置.跳不到设为 $n+1$ .那么就可以借助 $nx$ 来完成 $f$ 的转移. 那么计算完成后,只需要判断 $f(len_1,len_2,len_3)\leq n$ 是否成立.成立则为 $YES$ ,否则为 $NO$ . 并不能 $O(q\cdot 250^3)$ 暴力 $dp$ .注意每次加一个字符时(假定加在第一个串上),前面的 $dp$ 值不会被影响,只需计算 $f(len_1+1,j,k)$ 这 $250^2$ 个状态.每次删字符时直接让 $len$ 减 $1$ 就可以了.下次会覆盖掉多余的值. 时间复杂度 $O(q\cdot 250^2)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e5+10,L=251;const int Siz=26;char buf[MAXN];int n,Q,nx[MAXN][Siz];int minpos[Siz];int f[L][L][L];int len[4];int s[4][L];int main()&#123; n=read(); Q=read(); scanf("%s\n",buf+1); for(int i=0;i&lt;Siz;++i) minpos[i]=n+1; buf[0]='a'; for(int i=n+1;i&gt;=0;--i) &#123; memcpy(nx[i],minpos,sizeof minpos); minpos[buf[i]-'a']=i; &#125; f[0][0][0]=0; while(Q--) &#123; char tp[2],newchar[2]; int id; scanf("%s%d",tp,&amp;id); if(tp[0]=='+') &#123; scanf("%s",&amp;newchar); s[id][++len[id]]=newchar[0]-'a'; if(id==1) &#123; for(int i=len[1];i&lt;=len[1];++i) for(int j=0;j&lt;=len[2];++j) for(int k=0;k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; else if(id==2) &#123; for(int i=0;i&lt;=len[1];++i) for(int j=len[2];j&lt;=len[2];++j) for(int k=0;k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; else &#123; for(int i=0;i&lt;=len[1];++i) for(int j=0;j&lt;=len[2];++j) for(int k=len[3];k&lt;=len[3];++k) &#123; int res=n+1; if(i) res=min(res,nx[f[i-1][j][k]][s[1][i]]); if(j) res=min(res,nx[f[i][j-1][k]][s[2][j]]); if(k) res=min(res,nx[f[i][j][k-1]][s[3][k]]); f[i][j][k]=res; &#125; &#125; &#125; else --len[id]; puts(f[len[1]][len[2]][len[3]]&lt;=n?"YES":"NO"); &#125; return 0;&#125; CF1149C Tree Generator™ 给的括号序列就是一个欧拉序(进出都记录). 容易处理出每个点的 $dep​$ ,遇见 $(​$ 就 $+1​$ ,否则 $-1​$ . 考虑两个点的距离为 $dep_u+dep_v-2dep_{lca}​$ ,在欧拉序中.和用 $RMQ​$ 做 $LCA​$ 一样,两个点的 $lca​$ 一定位于这两个点的中间,且深度最小. 那么找直径就转化为找三个位置 $u\leq lca\leq v$ ,使得 $dep_u+dep_v-2dep_{lca}$ 最大. 每次修改交换两个括号,中间那一段 $dep$ 都会 $+2/-2$ .于是用线段树维护每个位置的 $dep$ , $dep_l-2dep_i$ , $dep_r-2dep_i$ 的 $max$ 即可. 注意合并节点,标记的细节. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;int n,Q;int dep[MAXN];struct SegTree&#123; struct node &#123; int res;//dep[l]+dep[r]-2dep[i] int tag; int mxdep,negdep;//dep[i],-2dep[i] int ldep,rdep;//dep[l]-2dep[i],dep[r]-2dep[i] &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.mxdep=max(lson.mxdep,rson.mxdep); root.negdep=max(lson.negdep,rson.negdep); root.ldep=max(lson.ldep,rson.ldep); root.ldep=max(root.ldep,lson.mxdep+rson.negdep); root.rdep=max(lson.rdep,rson.rdep); root.rdep=max(root.rdep,lson.negdep+rson.mxdep); root.res=max(lson.res,rson.res); root.res=max(root.res,lson.mxdep+rson.rdep); root.res=max(root.res,lson.ldep+rson.mxdep); &#125; void BuildTree(int o,int l,int r) &#123; root.tag=0; if(l==r) &#123; root.mxdep=dep[l]; root.negdep=-2*dep[l]; root.rdep=root.ldep=-dep[l]; root.res=0; return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; void modifiy(int o,int c) &#123; root.tag+=c; root.mxdep+=c; root.negdep-=2*c; root.ldep-=c; root.rdep-=c; &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void update(int o,int l,int r,int L,int R,int c) &#123; if(L&gt;r || l&gt;R || L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; pushdown(o); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,mid+1,r,L,R,c); pushup(o); &#125;&#125;T;#define pr printf("%d\n",T.Tree[1].res);char buf[MAXN];int main()&#123; n=read(),Q=read(); scanf("%s",buf+1); for(int i=1;i&lt;=2*n-2;++i) &#123; dep[i]=dep[i-1]; if(buf[i]=='(') ++dep[i]; else --dep[i]; &#125; T.BuildTree(1,1,2*n-2); pr; while(Q--) &#123; int L=read(),R=read(); if(L&gt;R) swap(L,R); if(buf[L]=='(') T.update(1,1,2*n-2,L,R-1,-2); else T.update(1,1,2*n-2,L,R-1,2); pr; swap(buf[L],buf[R]); &#125; return 0;&#125; CF1149D Abandoning Roads 最小生成树 + 状压 $dp$. 用 $kruskal$ 做最小生成树的时候,会先考虑权值为 $a$ 的边,那么可以先预处理出由 $a$ 边连接出的联通块. 从 $1$ 到 $p$ 跑最短路,每条 $b$ 边会连接两个联通块,将联通块状压,就可以记录哪些联通块已经走过了. 注意到对一个点数 $\leq 3$ 的联通块,不可能进入它后再走出去,因为这样的长度至少为 $2b$ ,而它内部长度最长才 $2a$ .所以可以不记这些联通块.状态数目在 $O(2^{n/4}m)$ 级别,就可以直接做了. CF1149E Election Promises 博弈论. 结论: $SG_u=mex(SG_v),sum(x)=\oplus_{SG_i=x}h_i$ , $\oplus$ 表示异或和.先手能胜,当且仅当 $\exists x ,sum(x)\not=0​$ . 如果所有的 $sum$ 都为 $0$ ,那么先手随意操作一次,都会使得有 $sum$ 变为非 $0$ .然后后手再操作一次,所有 $sum$ 又可以被修改为 $0$ :找到最大的 $x$ , $sum(x)&gt;0$ 进行修改.]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>codeforces</tag>
        <tag>构造</tag>
        <tag>博弈论</tag>
        <tag>状压dp</tag>
        <tag>dfs序</tag>
        <tag>自动机dp</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2286 消耗战]]></title>
    <url>%2F2019%2F05%2F06%2Fbzoj-2286-%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[虚树 + 树形 $dp$ . 考虑最暴力的树形 $dp$.设 $f_u$ 表示使得子树 $u$ 中所有关键点都与 $1$ 断开的最小代价. 那么对于 $u$ 的所有儿子 $v$ ,如果 $v$ 是关键点,代价为 $val(u,v)$ ,否则为 $min(val(u,v),f_v)$ . $f_u$ 就是所有儿子的代价之和,最终答案即为 $f_1$ . 这样暴力 $dp$ 是 $O(nm)$ 的,无法通过.但注意到关键点数目总和 $\sum k\leq 5\times 10^5$ ,所以可以使用 虚树 进行处理. 虚树 就是新建出的一颗树,只保留原树中所有关键节点与它们所有的 $LCA$ ,而原图中其它的链被简化成边或点. 这样一颗 虚树 的节点数目不会超过 $2k-1$.因为 $k$ 个关键节点所有不同的 $LCA$ 最多 $k-1$ 个. 构造时,先在原树中预处理 $dfs$ 序,子树大小 $siz$ ,并预处理倍增数组,以快速查找 $LCA$ 以及一条链上最小边. 然后将所有关键点加入一个数组中,按照 $dfs$ 序排序,再将相邻两个点的 $LCA$ 也放入数组中,再放入 $1$ . 再按照 $dfs$ 序排序,去重,就得到了我们在虚树上的 $dfs$ 遍历顺序.按照这个顺序进行 $dfs$ ,判断下个点是继续$dfs$ 还是回溯回来,只需用预处理的 $dfs$ 序和 $siz$ 判断下个点是否在当前的子树中. 在虚树上 $dfs$ 的同时像原来一样进行树形 $dp$ .不过虚树中两个点的边在原图中实际是一条链.在虚树中直接割断两个点的花费是连接这两个点的链上所有边的最小边权.用预处理的倍增数组进行查询即可. 时间复杂度 $O(\sum klogk)$ . 开始写的时候预处理倍增数组居然没有按拓扑序,而是直接按照节点编号顺序处理.这样居然还能有 $90pts$ .出计数不好吗,非要出最优化让人水过去. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=250010;int ecnt,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],val[MAXN&lt;&lt;1];inline void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; val[ecnt]=w; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int n,m,k;int tid=0,marked[MAXN];int fa[MAXN][20],minc[MAXN][20];void init()&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=19;++j) &#123; fa[i][j]=fa[fa[i][j-1]][j-1]; minc[i][j]=min(minc[i][j-1],minc[fa[i][j-1]][j-1]); &#125;&#125;int dfsidx=0,dfn[MAXN],siz[MAXN],dep[MAXN];void dfs(int u,int f)&#123; siz[u]=1; dep[u]=dep[f]+1; dfn[u]=++dfsidx; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==f) continue; fa[v][0]=u; minc[v][0]=val[i]; dfs(v,u); siz[u]+=siz[v]; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;--i) if(dep[x]-(1&lt;&lt;i)&gt;=dep[y]) x=fa[x][i]; if(x==y) return x; for(int i=19;i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int minval(int x,int lca)&#123; int res=1e9; for(int i=19;i&gt;=0;--i) if(dep[x]-(1&lt;&lt;i)&gt;=dep[lca]) &#123; res=min(res,minc[x][i]); x=fa[x][i]; &#125; return res;&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;int q[MAXN&lt;&lt;1],tot;int id;ll f[MAXN];void dfs_vtree()&#123; int u=q[id]; f[u]=1e18; ll res=0; while(1) &#123; if(id==tot) break; if(dfn[q[id+1]]&lt;=dfn[u]+siz[u]-1) &#123; int v=q[++id]; if(marked[v]==tid) &#123; dfs_vtree(); f[v]=minval(v,u); &#125; else &#123; dfs_vtree(); f[v]=min(f[v],1LL*minval(v,u)); &#125; res+=f[v]; &#125; else break; &#125; if(res) f[u]=min(f[u],res);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); addedge(v,u,w); &#125; dfs(1,0); init(); m=read(); while(m--) &#123; tot=0; k=read(); ++tid; for(int i=1;i&lt;=k;++i) &#123; int x=read(); marked[x]=tid; q[++tot]=x; &#125; sort(q+1,q+1+tot,cmp); for(int i=1;i&lt;k;++i) q[++tot]=LCA(q[i],q[i+1]); q[++tot]=1; sort(q+1,q+1+tot,cmp); tot=unique(q+1,q+1+tot)-q-1; id=1; dfs_vtree(); printf("%lld\n",f[1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 4556 字符串]]></title>
    <url>%2F2019%2F05%2F04%2Fbzoj-4556-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 倍增 + 线段树合并. 这里有两个小性质需要注意. 答案是可二分的.这个应该比较显然. 两个子串的最长公共后缀就是它们在 $SAM$ 上状态节点 $LCA$ 的 $maxlen$ .想象两个串都从前往后缩短,当两者缩到同一个串,即公共后缀时,节点也跳到了它们的 $LCA$ .长度即为 $maxlen$ . 于是把整个串翻转,询问前缀相关问题就变成了询问后缀相关问题.询问时,可以二分答案 $x$ ,转化为判定问题. 从 $d$ 对应的位置用倍增往上跳,找到 $maxlen\geq x$ 的 $dep$ 最小的祖先(其 $right$ 集合最大,为最优),判断它的 $right$ 集合中是否出现了 $[a+x-1,b]$ 中的某个位置. 如果出现了,那么从这个位置往前的 $x$ 个字符就是要找的子串,否则就找不到. 可以看出 $c$ 的作用就是限制了二分答案 $x$ 的范围,显然不能超过 $d-c+1$ 与 $b-a+1​$ . 一个点的 $right$ 集合是它所有儿子节点 $right$ 集合的并集.所以可以用线段树合并来维护. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e5+10;int lst=1,idx=1;int n,m;int siz[MAXN],pos[MAXN],leafright[MAXN];int ch[MAXN][Siz],fa[MAXN];int len[MAXN];void Extend(int c,int id)&#123; int p=lst,np=++idx; lst=np; pos[id]=np; leafright[np]=id; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int tot=0;struct node&#123; int sum,ls,rs;&#125;Tree[MAXN*30];#define root Tree[o]#define lson Tree[root.ls]#define rson Tree[root.rs]void update(int &amp;o,int l,int r,int pos)&#123; o=++tot; ++root.sum; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(root.ls,l,mid,pos); else update(root.rs,mid+1,r,pos);&#125;void pushup(int o)&#123; root.sum=lson.sum+rson.sum;&#125;int merge(int x,int y)&#123; if(!x || !y) return x+y; int o=++tot; root.ls=merge(Tree[x].ls,Tree[y].ls); root.rs=merge(Tree[x].rs,Tree[y].rs); pushup(o); return o;&#125;int query(int o,int l,int r,int L,int R)&#123; if(L&gt;r || l&gt;R) return 0; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; int mid=(l+r)&gt;&gt;1; int res=0; if(L&lt;=mid) res+=query(root.ls,l,mid,L,R); if(R&gt;mid) res+=query(root.rs,mid+1,r,L,R); return res;&#125;int f[MAXN][18];int rt[MAXN];void mergeright(int u)&#123; f[u][0]=fa[u]; for(int i=1;i&lt;=17;++i) f[u][i]=f[f[u][i-1]][i-1]; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; mergeright(v); rt[u]=merge(rt[u],rt[v]); &#125;&#125;bool check(int x,int L,int R,int u)&#123; if(!x) return true; if(L&gt;R) return false; for(int i=17;i&gt;=0;--i) if(len[f[u][i]]&gt;=x) u=f[u][i]; return query(rt[u],1,n,L,R)&gt;0;&#125;char buf[MAXN];int main()&#123; n=read(),m=read(); scanf("%s",buf+1); for(int i=1;i&lt;(n+1-i);++i) swap(buf[i],buf[n+1-i]); for(int i=1;i&lt;=n;++i) Extend(buf[i]-'a',i); for(int i=1;i&lt;=idx;++i) addedge(fa[i],i); for(int i=1;i&lt;=idx;++i) if(leafright[i]) update(rt[i],1,n,leafright[i]); mergeright(1); while(m--) &#123; int a=read(),b=read(),c=read(),d=read(); swap(a,b),swap(c,d); a=n+1-a,b=n+1-b,c=n+1-c,d=n+1-d; int L=0,R=min(d-c+1,b-a+1); int res=0; while(L&lt;=R) &#123; int mid=(L+R)&gt;&gt;1; if(check(mid,a+mid-1,b,pos[d])) res=max(res,mid),L=mid+1; else R=mid-1; &#125; printf("%d\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>倍增</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2555 substring]]></title>
    <url>%2F2019%2F05%2F04%2Fbzoj-2555-substring%2F</url>
    <content type="text"><![CDATA[$SAM+LCT$ . 如果没有修改,就直接建出 $SAM$ ,询问时从根出发走到对应状态,该状态的 $siz$ 即为答案. 现在要支持修改,沿用上面思路,只不过要动态维护 $parent$ 树的形态,需要加边,删边. 套一个 $LCT$ 进行维护就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e6+10;int lst=1,idx=1;int siz[MAXN],tag[MAXN];int stk[MAXN],tp=0;struct Link_Cut_Tree&#123; struct node &#123; int ch[2],fa; node()&#123;ch[0]=ch[1]=fa=0;&#125; &#125;Tree[MAXN];#define root Tree[x] bool isroot(int x) &#123; return Tree[root.fa].ch[0]!=x &amp;&amp; Tree[root.fa].ch[1]!=x; &#125; void modifiy(int x,int c) &#123; if(x) &#123; siz[x]+=c; tag[x]+=c; &#125; &#125; void pushdown(int x) &#123; if(tag[x]) &#123; modifiy(root.ch[0],tag[x]); modifiy(root.ch[1],tag[x]); tag[x]=0; &#125; &#125; void rotate(int x) &#123; int y=Tree[x].fa; int z=Tree[y].fa; if(!isroot(y)) Tree[z].ch[Tree[z].ch[1]==y]=x; Tree[x].fa=z; int k=(x==Tree[y].ch[1]); Tree[y].ch[k]=Tree[x].ch[k^1]; Tree[Tree[x].ch[k^1]].fa=y; Tree[x].ch[k^1]=y; Tree[y].fa=x; &#125; void splay(int x) &#123; stk[++tp]=x; for(int pos=x;!isroot(pos);pos=Tree[pos].fa) stk[++tp]=Tree[pos].fa; while(tp) pushdown(stk[tp--]); while(!isroot(x)) &#123; int y=Tree[x].fa; int z=Tree[y].fa; if(!isroot(y)) (Tree[z].ch[0]==y)^(Tree[y].ch[0]==x)?rotate(x):rotate(y); rotate(x); &#125; &#125; void Access(int x) &#123; for(int y=0;x;y=x,x=Tree[x].fa) &#123; splay(x); Tree[x].ch[1]=y; &#125; &#125; void link(int x,int y) &#123; Tree[x].fa=y; Access(y); splay(y); modifiy(y,siz[x]); &#125; void cut(int x) &#123; Access(x); splay(x); modifiy(Tree[x].ch[0],-siz[x]); Tree[x].ch[0]=Tree[Tree[x].ch[0]].fa=0; &#125;&#125;LCT;struct SuffixAutoMation&#123; int ch[MAXN][Siz],fa[MAXN]; int len[MAXN]; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) &#123; fa[np]=1; LCT.link(np,1); &#125; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) &#123; fa[np]=q; LCT.link(np,q); &#125; else &#123; int nq=++idx; len[nq]=len[p]+1; LCT.link(nq,fa[q]); LCT.cut(q); LCT.link(q,nq); LCT.link(np,nq); fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125;&#125;SAM;int L;char buf[MAXN];void getinfo(int mask)&#123; scanf("%s",buf); L=strlen(buf); for(int i=0; i&lt;L; ++i) &#123; mask=(mask*131+i) % L; swap(buf[i],buf[mask]); &#125;&#125;int mask=0;int main()&#123; int Q=read(); scanf("%s",buf); L=strlen(buf); for(int i=0;i&lt;L;++i) SAM.Extend(buf[i]-'A'); while(Q--) &#123; scanf("%s",buf); if(buf[0]=='A') //Add &#123; getinfo(mask); for(int i=0;i&lt;L;++i) SAM.Extend(buf[i]-'A'); &#125; else //Query &#123; getinfo(mask); int p=1; for(int i=0;i&lt;L;++i) &#123; p=SAM.ch[p][buf[i]-'A']; &#125; if(!p) puts("0"); else &#123; LCT.splay(p); printf("%d\n",siz[p]); mask^=siz[p]; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190504]]></title>
    <url>%2F2019%2F05%2F04%2Ftest20190504%2F</url>
    <content type="text"><![CDATA[据说 是 $noip$ 难度. 题面 $find$ 比较简单.按照 $x$ 坐标排序后,就是以 $y$ 坐标为关键字做一个 $LIS​$ . $O(nlogn)​$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=x*10+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=1e6+10;int n=0,my,y[MAXN],Y[MAXN];pair&lt;int,int&gt; p[MAXN];int bit[MAXN];#define lowbit(x) x&amp;(-x)inline void add(int x,int c)&#123; for(; x&lt;=my; x+=lowbit(x)) bit[x]=max(bit[x],c);&#125;inline int sum(int x)&#123; int s=0; for(; x; x-=lowbit(x)) s=max(s,bit[x]); return s;&#125;int main()&#123; freopen("find.in","r",stdin); freopen("find.out","w",stdout); int N=read(); for(int i=1; i&lt;=N; ++i) &#123; int a=read(),b=read(); if(a&lt;0 || b&lt;0) continue; ++n; p[n].first=a; Y[n]=y[n]=b; &#125; sort(Y+1,Y+1+n); my=unique(Y+1,Y+1+n)-Y-1; for(int i=1; i&lt;=n; ++i) p[i].second=lower_bound(Y+1,Y+1+my,y[i])-Y; sort(p+1,p+1+n); int ans=0; for(int i=1; i&lt;=n; ++i) &#123; int ky=p[i].second; int mx=sum(ky); ans=max(ans,mx+1); add(ky,mx+1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; $walk$ 是个套路题. 标算套路:因为询问给出的 $v$ 最大是 $10^{18}$ ,所以走不为 $1$ 的边,最多走 $60$ 次就会变成 $0$ . 于是只需要用并查集把边权为 $1$ 连接的两个点并在一起,然后跳的时候暴力跳,跳成 $0$ 或者到终点就退出. 这样最多跳 $60$ 次,而且大多数时候跳不满,所以可以过. 我的做法相当假.注意到这个操作是可合并的,直接树剖 + 线段树维护区间边权乘积. 但是区间乘积可能会爆掉 $long\ long$ . 于是每次 $pushup$ 的时候都让乘积与 $0$ 取 $max$ .这样一段爆掉的区间乘积(大概率)是 $0$ .跳的时候遇到了就直接输出 $0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll x=0,k=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123; if(ch=='-') k=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=x*10+ch-'0'; ch=getchar(); &#125; return k*x;&#125;const int MAXN=2e5+10;int n,Q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1],fa[MAXN];int dep[MAXN];inline void addedge(int u,int v,ll w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;ll wp[MAXN];int dfn[MAXN],dfnidx=0,rnk[MAXN],siz[MAXN],mxson[MAXN],top[MAXN];void dfs1(int u,int f)&#123; fa[u]=f; siz[u]=1; dep[u]=dep[f]+1; for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v==f) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++dfnidx; rnk[dfnidx]=u; top[u]=tp; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u]; i; i=nx[i]) &#123; int v=to[i]; if(v!=mxson[u] &amp;&amp; v!=fa[u]) dfs2(v,v); &#125;&#125;ll prod[MAXN&lt;&lt;2];#define root prod[o]#define lson prod[o&lt;&lt;1]#define rson prod[o&lt;&lt;1|1]void pushup(int o)&#123; root=lson*rson; root=max(root,0LL);&#125;void bd(int o,int l,int r)&#123; if(l==r) &#123; root=wp[rnk[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; bd(o&lt;&lt;1,l,mid); bd(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void update(int o,int l,int r,int pos,ll c)&#123; if(l==r) &#123; root=c; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(o&lt;&lt;1,l,mid,pos,c); else update(o&lt;&lt;1|1,mid+1,r,pos,c); pushup(o);&#125;ll query(int o,int l,int r,int L,int R)&#123; ll res=1; if(l&gt;R || L&gt;r) return 1; if(L&lt;=l &amp;&amp; r&lt;=R) return max(0LL,root); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) &#123; res*=query(o&lt;&lt;1,l,mid,L,R); res=max(res,0LL); &#125; if(R&gt;mid) &#123; res*=query(o&lt;&lt;1|1,mid+1,r,L,R); res=max(res,0LL); &#125; return res;&#125;void solve()&#123; int idx=n; for(int i=1; i&lt;n; ++i) &#123; int u=read(),v=read(); ll w=read(); ++idx; addedge(u,idx,0); addedge(idx,u,0); addedge(idx,v,0); addedge(v,idx,0); wp[idx]=w; &#125; for(int i=1; i&lt;=n; ++i) wp[i]=1; dfs1(1,0); dfs2(1,1); bd(1,1,idx); while(Q--) &#123; int tp=read(); if(tp==1) &#123; int x=read(),y=read(); ll v=read(); while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ll p=query(1,1,idx,dfn[top[x]],dfn[x]); if(p&lt;=0) &#123; puts("0"); continue; &#125; v/=p; x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); ll p=query(1,1,idx,dfn[y],dfn[x]); if(p&lt;=0) &#123; puts("0"); continue; &#125; v/=p; printf("%lld\n",v); &#125; else &#123; int p=read(); ll c=read(); update(1,1,idx,dfn[p+n],c); &#125; &#125;&#125;int main()&#123; freopen("walk.in","r",stdin); freopen("walk.out","w",stdout); n=read(); Q=read(); solve(); return 0;&#125; $sunset$ 想出了正确做法,但今天是按照 $5$ 个小时的节奏在打的,实际是 $3.5h$ ,只剩了 $20min$ ,就没写了. 显然每个联通块可以分开做.对于一个联通块,做一颗 $dfs​$ 树,因为是无向图,所以除了树边之外就只有返祖边. 返祖边会形成一个环,如果这个环的大小为偶(通过 $dep​$ 之差判断),显然没有作用.若为奇,就把环上的边都打上标记. 询问时,若 $dep_x,dep_y$ 奇偶性不同,直接走树边长度就是奇数.否则如果两者路径上有被标记的边,走一个奇环再出来,长度也是奇数. 如果两种情况都不满足,就无法找到长度为奇数的路径.]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>tarjan</tag>
        <tag>树链剖分</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3926 诸神眷顾的幻想乡]]></title>
    <url>%2F2019%2F05%2F03%2Fbzoj-3926-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[广义 $SAM$ . 广义 $SAM$ ,就是在 $Trie$ 树上建 $SAM$ .注意到树上的每个串都可以看成以某个叶子节点为根的 $Trie$ 树上的一条路径. 而叶子节点数 $\leq 20$ ,所以可以以每个叶子节点为根建 $Trie$ 树,建的时候需要注意插入一个点时,将 $lst$ 置为其父亲在 $SAM​$ 上对应的节点. 注意判重,即处理插入一个字符时, $lst$ 对应的转移边已经有点的情况.建好后就是问有多少个不同子串,每个点的贡献都是 $Max-Min+1$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=1e7+10;const int Siz=10;int n;struct SuffixAutoMation&#123; int idx,lst; SuffixAutoMation()&#123;lst=idx=1;&#125; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN]; int Extend(int p,int c) &#123; if(ch[p][c]) &#123; int q=ch[p][c]; if(len[q]==len[p]+1) lst=q; else &#123; int nq=++idx; lst=nq; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; else &#123; int np=++idx; lst=np; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; return lst; &#125; void solve() &#123; ll ans=0; for(int i=2;i&lt;=idx;++i) ans+=len[i]-len[fa[i]]; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;SAM;int ecnt=0,head[MAXN],to[MAXN],nx[MAXN],deg[MAXN];void addedge(int u,int v)&#123; ++deg[u]; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int col[MAXN];void dfs(int u,int fa,int lst)&#123; int newlst=SAM.Extend(lst,col[u]); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa) continue; dfs(v,u,newlst); &#125;&#125;int main()&#123; n=read(); int c=read(); for(int i=1;i&lt;=n;++i) col[i]=read(); for(int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); addedge(u,v); addedge(v,u); &#125; for(int i=1;i&lt;=n;++i) if(deg[i]==1) dfs(i,0,1); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
        <tag>广义SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TJOI2019 选做]]></title>
    <url>%2F2019%2F05%2F02%2FTJOI2019-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[向 $CQOI\ 2018$ 致敬? 甲苯先生的字符串 矩阵快速幂. 板子题.处理相邻两个字符时改一下转移矩阵里的系数就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=26;struct matrix&#123; int v[MAXN][MAXN]; matrix()&#123;memset(v,0,sizeof v);&#125; matrix operator * (const matrix &amp;rhs) const &#123; matrix res; for(int i=0;i&lt;MAXN;++i) for(int j=0;j&lt;MAXN;++j) for(int k=0;k&lt;MAXN;++k) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;matrix fpow(matrix a,ll b)&#123; matrix res; for(int i=0;i&lt;MAXN;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;(1LL)) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;ll n;char buf[100005];int main()&#123; scanf("%lld%s",&amp;n,buf); matrix st,trans; for(int i=0;i&lt;MAXN;++i) st.v[i][0]=1; for(int i=0;i&lt;MAXN;++i) for(int j=0;j&lt;MAXN;++j) trans.v[i][j]=1; int len=strlen(buf); for(int i=1;i&lt;len;++i) &#123; int p=buf[i-1]-'a'; int q=buf[i]-'a'; trans.v[q][p]=0; &#125; st=fpow(trans,n-1)*st; int ans=0; for(int i=0;i&lt;MAXN;++i) ans=add(ans,st.v[i][0]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 甲苯先生的滚榜 平衡树. 又是板子题.随便上个啥平衡树写一下插入,删除,查询排名. 唱、跳、rap 和篮球 顶风作案,律师函警告. 容斥原理+ $dp$ 计数. 为了方便,称题目中所说的一组同学为 位置 $k$ 在讨论蔡徐坤 ,要求出没有位置在讨论蔡徐坤的方案数. 显然可以容斥原理搞一搞,只需对每个 $i$ 求出钦定 $i$ 个位置在讨论蔡徐坤,其它不涉及的位置乱选的方案数. 其它位置乱选方案数就是有重复元素的排列数,但每个元素使用次数有限制.可以构造多项式 $(x+y+z+w)^{tot}$ , $tot=n-4i$ ,将次数符合要求的对应系数求和. 二项式定理套两次,多项式展开为$$(x+y+z+w)^{tot}=\sum C_{tot}^j (x+y)^j(z+w)^{tot-j}=\sum C_{tot}^j(\sum C_j^p x^p y^{j-p})(\sum C_{tot-j}^q z^q w^{tot-j-q})$$ 预处理组合数前缀和,把 $x,y,z,w​$ 系数都符合限制的那一段取出来计算即可. 考虑怎么求钦定 $i​$ 个位置在讨论蔡徐坤的方案数. 抽象一下就是选出 $i$ 个位置,相邻两个位置之差至少为 $4$ .需要求出每个 $i$ 的方案数. 可以设计一个三维的 $dp​$ ,状态需要记录考虑的数目,选的数目,最后一个选的位置. 注意到最后一个选的位置其实只有四种情况有区别,设 $f(j,i,0/1/2/3)$ 表示已经考虑了前 $j$ 个位置,选了 $i$ 个位置,最后选的位置分别是 $j,j-1,j-2,\leq j-3$ 时的方案数.将 $f(n-3,i,0/1/2/3)$ 求出即可. 时间复杂度 $O(n^2)​$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;void upd(int x,int &amp;y)&#123; y=add(x,y);&#125;const int MAXN=1e3+10;int n,mx;int C[MAXN][MAXN],sumc[MAXN][MAXN];int f[MAXN][MAXN][4];void init()&#123; for(int i=0;i&lt;=n;++i) C[i][0]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); for(int i=0;i&lt;=n;++i) &#123; sumc[i][0]=1; for(int j=1;j&lt;=i;++j) sumc[i][j]=add(sumc[i][j-1],C[i][j]); &#125; f[0][0][3]=1; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;=mx;++j) for(int k=0;k&lt;4;++k) &#123; if(!f[i][j][k]) continue; upd(f[i][j][k],f[i+1][j][k==3?k:k+1]); if(k==3) upd(f[i][j][k],f[i+1][j+1][0]); &#125;&#125;int lim[4];int main()&#123; n=read(); for(int i=0;i&lt;4;++i) lim[i]=read(); sort(lim,lim+4); mx=min(lim[0],n/4);//最多mx个位置讨论蔡徐坤 init(); int ans=0,sgn=1; for(int i=0;i&lt;=mx;++i) &#123; int res=0,tmp=0; if(n&lt;4) tmp=1; else &#123; for(int k=0;k&lt;4;++k) tmp=add(tmp,f[n-3][i][k]); &#125; for(int k=0;k&lt;4;++k) lim[k]-=i; int tot=n-i*4; for(int j=0;j&lt;=tot;++j) &#123; int lp=max(0,j-lim[1]); int rp=min(lim[0],j); int lk=max(0,tot-j-lim[3]); int rk=min(lim[2],tot-j); if(lp&gt;rp || lk&gt;rk) continue; int t1=lp?sumc[j][rp]-sumc[j][lp-1]:sumc[j][rp]; int t2=lk?sumc[tot-j][rk]-sumc[tot-j][lk-1]:sumc[tot-j][rk]; res=add(res,mul(C[tot][j],mul(t1,t2))); &#125; res=mul(res,tmp); ans=add(ans,res*sgn); for(int k=0;k&lt;4;++k) lim[k]+=i; sgn*=-1; &#125; cout&lt;&lt;add(ans,P)&lt;&lt;endl; return 0;&#125; 甲苯先生与线段树 位运算,数位 $dp$ . 大概是个原题. 甲苯先生和大中锋的字符串 $SAM$ + 差分. 建出 $SAM$ 后在 $parent$ 树上递推 $right$ 集合的大小,若其为 $k$ ,则对 $[Minlen,Maxlen]$ 内的计数器都加 $1$ . 最后询问一次计数器最大值.可以修改差分,最后求前缀和,就可以做到 $O(n)$ 了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26;const int MAXN=2e5+10;int n,k;int ans,mxt;int dif[MAXN];struct SuffixAutoMation&#123; int lst,idx; int fa[MAXN],siz[MAXN]; int ch[MAXN][Siz],len[MAXN]; int A[MAXN],t[MAXN]; SuffixAutoMation()&#123;lst=idx=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; fa[nq]=fa[q]; fa[q]=fa[np]=nq; for(int i=0;i&lt;Siz;++i) ch[nq][i]=ch[q][i]; len[nq]=len[p]+1; siz[nq]=0; while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=n;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; &#125; void solve() &#123; topsort(); for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; if(siz[u]==k &amp;&amp; u!=1) &#123; int mx=len[u],mi=len[fa[u]]+1; ++dif[mi]; --dif[mx+1]; &#125; &#125; int sum=0; for(int i=1;i&lt;=n;++i) &#123; sum+=dif[i]; if(sum&gt;=mxt) mxt=sum,ans=i; &#125; printf("%d\n",mxt==0?-1:ans); &#125; void reset() &#123; for(int i=1;i&lt;=n+1;++i) dif[i]=0; for(int i=0;i&lt;=n;++i) t[i]=0; for(int i=1;i&lt;=idx;++i) memset(ch[i],0,sizeof ch[i]); mxt=0; lst=idx=1; &#125;&#125;SAM;char buf[MAXN];int main()&#123; int T=read(); while(T--) &#123; scanf("%s",buf); n=strlen(buf); scanf("%d",&amp;k); cout&lt;&lt;k&lt;&lt;endl; for(int i=0;i&lt;n;++i) SAM.Extend(buf[i]-'a'); SAM.solve(); SAM.reset(); &#125; return 0;&#125; 读入格式很诡异.用快读读 $k​$ 会炸两个点,原因不明. 大中锋的游乐场 最短路. 记 $dis[i][j]$ 表示从起点出发到节点 $i$ ,经过的 $1$ 减去经过的 $2$ 的数目为 $j$ 时的最短路长度. 用 $Dijkstra$ 进行转移即可.]]></content>
      <tags>
        <tag>平衡树</tag>
        <tag>dp计数</tag>
        <tag>位运算</tag>
        <tag>最短路</tag>
        <tag>SAM</tag>
        <tag>差分</tag>
        <tag>容斥原理</tag>
        <tag>矩阵加速</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1137]]></title>
    <url>%2F2019%2F04%2F28%2FCF1137%2F</url>
    <content type="text"><![CDATA[$Div.1​$ CF1137A Skyscrapers 二分. 通过观察可以发现,对于每个询问,如果交点位置的值是 $x$ ,那么答案就是该列比 $x$ 小的数字种数与该行比 $x$ 小的数字种数的较大值+该列比 $x$ 小的数字种数与该行比 $x$ 小的数字种数的较大值 + $1$ . 离散化后二分一下就可以求出了. CF1137B Camp Schedule 贪心 + $kmp$ . 这个东西显然可以贪心,构造字符串时先放一个目标串,然后后面从最长 $border$ 那里接上去继续放,直到放完或者 $0/1$ 不够用. 用 $kmp$ 搞一下最长 $border$ 长度就好了. CF1137C Museums Tour $tarjan$ 缩点, $DAG$ 上 $dp$ . 注意到 $d$ 较小,所以首先可以把原来的每个点拆成 $d$ 个点,并连上合法的转移边.这样每个点有两个值 $(x,t)$ ,如果城市 $x$ 在当天有展览,这个点权值为 $1$ ,否则为 $0$ . 用 $tarjan$ 搞出每个强连通分量,缩成一个点,那么这个新点的权值就是这个 $SCC$ 内有展览的城市数目和. 注意到同一个城市拆出来的点 $(x,t)$ 与 $(x,t’)$ 路径可逆(连续走 $d-1$ 次),要么彼此都不可达,对应的两个 $SCC$ 不连通;要么彼此都可达.在同一个 $SCC$ 内. 所以在 $DAG$ 上 $dp$ 的话,两个 $SCC$ 内相同城市拆出来的点贡献不会叠加. 那么就可以直接从 $(1,0)$ 所在的强连通分量出发,在 $DAG$ 上找一条点权和最大的路径,可以 $dp$ 解决. 时间复杂度 $O(nd)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int N=1e5+10;const int MAXN=5e6+10;int n,m,d;vector&lt;int&gt; graph[MAXN];int eu[N],ev[N];int on_display[MAXN];char schedule[51];bool vis[N];int low[MAXN],dfn[MAXN],idx=0;int stk[MAXN],tp=0;int scc[MAXN],scc_cnt=0,sccval[MAXN];void tarjan(int u)&#123; stk[++tp]=u; dfn[u]=low[u]=++idx; for(auto v:graph[u]) &#123; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(!scc[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; ++scc_cnt; while(tp) &#123; int v=stk[tp--]; scc[v]=scc_cnt; if(on_display[v]) &#123; sccval[scc_cnt]+=(int)(!vis[(v/d)+1]); vis[(v/d)+1]=true; &#125; if(v==u) break; &#125; &#125;&#125;int f[MAXN];int dfs(int u)&#123; if(f[u]!=-1) return f[u]; f[u]=0; for(auto v:graph[u]) f[u]=max(f[u],dfs(v)); f[u]+=sccval[u]; return f[u];&#125;int main()&#123; n=read(),m=read(),d=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(); eu[i]=u,ev[i]=v; for(int ut=0;ut&lt;d;++ut) &#123; int vt=(ut+1)%d; graph[(u-1)*d+ut].push_back((v-1)*d+vt); &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; scanf("%s",schedule); for(int j=0;j&lt;d;++j) on_display[(i-1)*d+j]=schedule[j]-'0'; &#125; tarjan((1-1)*d+0); for(int i=0;i&lt;n*d;++i) graph[i].clear(); for(int i=1;i&lt;=m;++i) &#123; int u=eu[i],v=ev[i]; for(int ut=0;ut&lt;d;++ut) &#123; int vt=(ut+1)%d; if(scc[(u-1)*d+ut] &amp;&amp; scc[(u-1)*d+ut]!=scc[(v-1)*d+vt]) graph[scc[(u-1)*d+ut]].push_back(scc[(v-1)*d+vt]); &#125; &#125; memset(f,-1,sizeof f); int ans=dfs(scc[(1-1)*d+0]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 然而需要卡空间.懒得卡了. CF1137D Cooperative Game 交互题. 这个模型可以考虑 $floyd$ 判圈算法.即 $A$ 的速度是 $2$ , $B$ 的速度是 $1$ ,同时从起点出发,当两人重新相遇时,快的那个人比慢的那个人多走了 $k$ 圈,即 $k\cdot c$ 步.操作时可以让 $A,B$ 一起走一步,再让 $A$ 走一步. 相遇时, $B$ 肯定还没有走完一圈.记此时 $B$ 在圈内走了 $x$ 步( $x&lt;c$ ),那么 $B$ 一共走了 $t+x$ 步, $A$ 一共走了 $t+x+kc$ 步.而 $A$ 走的步数恰好是 $B$ 的二倍. 所以可以得到 $kc=t+x$ .那么此时这两个人再一起往前走 $t$ 步就可以一起到达环的起点. 而剩余的人还在出发点,也是再往前走 $t$ 步到达环的起点.于是相遇后所有人一起走,到达同一个位置时就结束了. 分析一下总步数. $A,B$ 相遇前要进行 $2(t+x)$ 个操作,相遇后要进行 $t$ 个操作.总操作数不会大于 $3(t+c)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;int groups;char buf[10][10];void getinfo()&#123; groups=read(); for(int i=0;i&lt;groups;++i) scanf("%s",buf[i]);&#125;void moveA()&#123; puts("next 0"); fflush(stdout);&#125;void moveAB()&#123; puts("next 0 1"); fflush(stdout);&#125;void moveAll()&#123; puts("next 0 1 2 3 4 5 6 7 8 9"); fflush(stdout);&#125;void Done()&#123; puts("done"); fflush(stdout);&#125;void stage_catch()&#123; while(1) &#123; moveAB(); getinfo(); moveA(); getinfo(); for(int i=0;i&lt;groups;++i) &#123; bool fa=false,fb=false; int len=strlen(buf[i]); for(int j=0;j&lt;len;++j) &#123; if(buf[i][j]=='0') fa=true; if(buf[i][j]=='1') fb=true; if(fa &amp;&amp; fb) return; &#125; &#125; &#125;&#125;void stage_meet()&#123; while(1) &#123; moveAll(); getinfo(); if(groups==1) &#123; Done(); return; &#125; &#125;&#125;int main()&#123; stage_catch(); stage_meet(); return 0;&#125; CF1137F Matches Are Not a Child’s Play 树剖 + 线段树. $compare$ 询问显然不用单独考虑,做两次 $when$ 询问就可以了. 初始的删点序列我们可以暴力搞出,只需要考虑每次 $up$ 操作带来的影响. 首先可以发现在一条路径上,只能从两边往中间删.,若 $up$ 当前权值最大的节点,就没有影响.否则,如果把 $u$ 改成了最大, $v$ 是原来最大的点, $v\not = u$ ,那么 $v-u$ 这条路径一定是最后被删除的,且删除顺序是严格按照 $v\rightarrow u$ 这条单向路径. 不在这条路径上的点被删除的相对顺序显然不会变.即, $up$ 操作一次之后,先删除不在这条路径上的点,顺序是操作前被删除的相对顺序,再沿路径 $v\rightarrow u$ 顺次删除. 实现可以通过染色,第 $i$ 次 $up$ 操作时把 $v_i\rightarrow u_i$ 这条路径上的点颜色染为 $i$ .那么询问 $when(x)$ 的答案就是颜色序号比 $col_x$ 小的节点数加上路径 $v_{colx} \rightarrow x$ 的节点数目.初始化可以看做进行了 $n$ 次 $up$ 操作. 染色用树剖+线段树实现,答案的两部分,前者用线段树维护每种颜色的节点数目,后者只需要记录每次的 $v_i$ ,利用树剖维护的 $dep,top$ 计算. 时间复杂度 $O(qlog^2n)$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>codeforces</tag>
        <tag>kmp</tag>
        <tag>tarjan</tag>
        <tag>DAG</tag>
        <tag>非传统题</tag>
        <tag>floyd判圈</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNA分子计数]]></title>
    <url>%2F2019%2F04%2F28%2FDNA%E5%88%86%E5%AD%90%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[怎么生物课也遇到计数题啊… 今天生物课老师直接说: $n$ 个碱基对的 $DNA$ 种类数目就是 $4^n$ ,如果还要考虑对称的话太麻烦了… 于是就想了一下考虑对称同构怎么算.讨论前后翻转,两条链交换,中心对称都算一种的话的情况. 考虑 $Burnside$ 引理,显然可以构造出置换群 ${ \text{不变,左右翻转,上下翻转,中心对称}}$ ,中心对称其实就是左右翻转与上下翻转都操作了一次. 那么现在只需要计算出每种变换的不动点数目,求其平均数即可. 不变 的不动点数目显然是 $4^n$ . 左右翻转 的不动点数目显然是 $0$ .因为碱基互补,不可能两条链相同. 上下翻转 的不动点数目其实就是回文串的数目. $n$ 为偶数时为 $2^n$ , $n$ 为奇数时为 $2^{n+1}$ . 中心对称 的不动点数目,其实就是第 $i$ 个位置恰好与第 $n+i-1$ 个位置互补的数目. $n$ 为偶数时为 $2^n$ . $n$ 为奇数时,中间那个位置要求与自己互补,这是不可能的,数目为 $0$ . 对 $4$ 种变换的不动点数目求平均值,得到答案 $4^{n-1}+2^{n-1}$ . 其实 $DNA$ 分子好像只有中心对称这一种变换?因为左右翻转和上下翻转后其实裸露的那两个磷酸分子旁边的东西的是不一样的???但总之无论考虑哪些变换都可以用 $Burnside$ 像上面那样直接搞吧…]]></content>
      <tags>
        <tag>Burnside/Polya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2946 公共串]]></title>
    <url>%2F2019%2F04%2F28%2Fbzoj-2946-%E5%85%AC%E5%85%B1%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ 解决多个串的最长公共子串. $SAM$. 显然可以 二分 + $hash$ 做,时间复杂度 $O(logL\cdot L \cdot n)$. 考虑 $SAM$ 的做法.对第一个串建个 $SAM$ ,然后每读入一个新串就把它放在自动机上匹配. 匹配时维护每个状态能与每个串都匹配的最大长度.最后的答案就是所有状态能匹配长度的最大值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=4e3+10;char buf[MAXN];int L,n;struct SuffixAutoMation&#123; int idx,lst; int fa[MAXN],ch[MAXN][Siz]; int len[MAXN],siz[MAXN]; int A[MAXN],t[MAXN]; int mxl[MAXN],res[MAXN]; SuffixAutoMation()&#123;idx=lst=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; res[np]=len[np]=len[p]+1; siz[np]=1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; res[nq]=len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void topsort() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; &#125; void solve() &#123; scanf("%s",buf+1); memset(mxl,0,sizeof mxl); L=strlen(buf+1); int p=1,tmp=0; for(int i=1;i&lt;=L;++i) &#123; int c=buf[i]-'a'; while(p &amp;&amp; ch[p][c]==0) p=fa[p]; if(p==0) p=1,tmp=0; else &#123; tmp=min(tmp,len[p])+1; p=ch[p][c]; &#125; mxl[p]=max(mxl[p],tmp); &#125; for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; mxl[fa[u]]=max(mxl[fa[u]],mxl[u]); &#125; for(int i=1;i&lt;=idx;++i) res[i]=min(res[i],mxl[i]); &#125; void pr() &#123; int ans=0; for(int i=1;i&lt;=idx;++i) ans=max(ans,res[i]); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;SAM;int main()&#123; n=read(); scanf("%s",buf+1); L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a'); SAM.topsort(); for(int i=1;i&lt;n;++i) SAM.solve(); SAM.pr(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1396 识别子串]]></title>
    <url>%2F2019%2F04%2F27%2Fbzoj-1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[$SAM$ + 线段树. 先建出 $parent$ 树,按照题意,我们只需要处理 $right$ 集合大小为 $1$ 的节点. 如下图,先算出这样的一个节点合法长度的 $max,min$ ( $min$ 可以用 $max(fa)+1$ 计算). 那么区域 $I$ 内每个点的贡献就是区域 $II$ 的长度加上这个点到区域 $II$ 的距离. 区域 $II$ 内每个点的贡献就是区间 $II$ 的长度.开两颗线段树分别修改就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e5+10;const int inf=1e9;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]struct SegTree&#123; struct node &#123; int l,r; int mi,tag; &#125;Tree[MAXN&lt;&lt;2]; void pushup(int o) &#123; root.mi=min(lson.mi,rson.mi); &#125; void modifiy(int o,int c) &#123; root.mi=min(root.mi,c); root.tag=min(root.tag,c); &#125; void pushdown(int o) &#123; if(root.tag&lt;inf) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=inf; &#125; &#125; void BuildTree(int o,int l,int r) &#123; root.mi=root.tag=inf; root.l=l,root.r=r; if(l==r) return; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); &#125; void update(int o,int L,int R,int c) &#123; int l=root.l,r=root.r; if(L&gt;r || l&gt;R || L&gt;R) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) update(o&lt;&lt;1,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,L,R,c); pushup(o); &#125;&#125;T1,T2;int ans[MAXN];void query(int o,int l,int r)&#123; if(l==r) &#123; int res=min(T1.Tree[o].mi-l,T2.Tree[o].mi); ans[l]=res; return; &#125; int mid=(l+r)&gt;&gt;1; T1.pushdown(o); T2.pushdown(o); query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r);&#125;char buf[MAXN];int L;int t[MAXN],A[MAXN];struct SuffixAutomation&#123; int lst,idx; int ch[MAXN][Siz],fa[MAXN]; int siz[MAXN],len[MAXN]; int pos[MAXN]; SuffixAutomation()&#123;lst=idx=1;&#125; void Extend(int c,int curl) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; pos[np]=curl; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void solve() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; T1.BuildTree(1,1,L); T2.BuildTree(1,1,L); for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; pos[fa[u]]=pos[u]; if(u==1 || siz[u]&gt;1) continue; int l=pos[u]-len[u]+1,r=pos[u]-(len[fa[u]]+1)+1; T1.update(1,l,r-1,pos[u]+1); T2.update(1,r,pos[u],pos[u]-r+1); &#125; query(1,1,L); for(int i=1;i&lt;=L;++i) printf("%d\n",ans[i]); &#125;&#125;SAM;int main()&#123; scanf("%s",buf+1); L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a',i); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3998 弦论]]></title>
    <url>%2F2019%2F04%2F27%2Fbzoj-3998-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[$SAM​$ 的入门练习题. 先把 $SAM​$ 建出来,每个节点的 $right​$ 集合大小就是走到这个节点时对应的子串出现次数. 如果 $t=0​$ ,那么这些位置只能被算一次,把每个点的 $right​$ 集合大小都置为 $1​$ ,否则就拓扑排序后(桶排),在$parent​$ 树上递推得出真正的 $right​$ 集合大小. 注意根节点处对应的子串都是空串,不能算入贡献,要把根节点的 $siz$ 置为 $0$ . 再在转移图中递推得到每个点能转移到的所有点的子串出现次数 $sum$ ,然后从根节点出发贪心走就好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longinline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int Siz=26,MAXN=2e6+10;int t[MAXN],A[MAXN];int T,K;struct SuffixAutomation&#123; int idx,lst; int ch[MAXN][Siz]; int siz[MAXN],len[MAXN]; int fa[MAXN]; int sum[MAXN]; SuffixAutomation()&#123;idx=lst=1;&#125; void Extend(int c) &#123; int p=lst,np=++idx; lst=np; siz[np]=1; len[np]=len[p]+1; while(p &amp;&amp; ch[p][c]==0) ch[p][c]=np,p=fa[p]; if(p==0) fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else &#123; int nq=++idx; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); while(p &amp;&amp; ch[p][c]==q) ch[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void solve() &#123; for(int i=1;i&lt;=idx;++i) ++t[len[i]]; for(int i=1;i&lt;=idx;++i) t[i]+=t[i-1]; for(int i=1;i&lt;=idx;++i) A[t[len[i]]--]=i; if(T==0) &#123; for(int i=1;i&lt;=idx;++i) siz[i]=1; &#125; else &#123; for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; siz[fa[u]]+=siz[u]; &#125; &#125; siz[1]=0;//在根节点处的串都是空串,不能计入 for(int i=idx;i&gt;=1;--i) &#123; int u=A[i]; sum[u]=siz[u]; for(int j=0;j&lt;26;++j) if(ch[u][j]) sum[u]+=sum[ch[u][j]]; &#125; int u=1; if(sum[u]&lt;K) &#123; puts("-1"); return; &#125; while(K) &#123; for(int i=0;i&lt;Siz;++i) &#123; if(K&lt;=sum[ch[u][i]]) &#123; putchar('a'+i); K-=siz[ch[u][i]]; u=ch[u][i]; break; &#125; else K-=sum[ch[u][i]]; &#125; &#125; puts(""); &#125;&#125;SAM;char buf[MAXN];int main()&#123; scanf("%s",buf+1); int L=strlen(buf+1); for(int i=1;i&lt;=L;++i) SAM.Extend(buf[i]-'a'); T=read(),K=read(); SAM.solve(); return 0;&#125;]]></content>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1151]]></title>
    <url>%2F2019%2F04%2F25%2FCF1151%2F</url>
    <content type="text"><![CDATA[一场难度略高于普及组的 $Div.2$ . CF1151C Problem for Nazar 二分. 转化成求前缀和 $sum(r)-sum(l-1)$ .算每个前缀和的时候二分出整的前 $2^k$ 个数,剩下的单独算就好了. CF1151D Stas and the Queue at the Buffet 贪心. 考虑当前的两个位置 $i,j\ (i&lt;j)$ , 有 $x,y$ 两个元素,若交换这两个元素,对答案的影响. 化简出来发现只需要将所有元素按 $a_i-b_i$ 从大到小排序就好了. 这种判定贪心的可行性及怎样贪心的方法很常见,就是考虑交换两个元素对答案的影响. CF1151E Number of Components 构造. 考虑若当前计算的权值区间是 $(l,r)$ ,那么把在这个范围内的点权值赋为 $1$ ,否则赋为 $0$. 再在位置 $0$ 处补上一个权值 $0$ ,可以发现此时对于这对 $(l,r)$ 的答案就是相邻的 $(0,1)$ 对数. 那么我们直接来算每两个相邻位置的贡献,即 $a_i,a_{i+1}$ 在多少组 $(l,r)$ 中被赋的权值不同就好了. CF1153F Sonya and Informatics 概率+矩阵快速幂. 设 $f(i,j)$ 表示操作了 $j$ 次,当前最后一个 $1$ 在位置 $i$ 的概率. 每次 $j\rightarrow j+1$ 转移的时候分类讨论一下选了哪两个位置,写出转移矩阵,转移 $k$ 次,矩阵快速幂加速即可. 时间复杂度 $O(n^3logk)$ .]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>codeforces</tag>
        <tag>构造</tag>
        <tag>概率/期望</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GXOI/GZOI2019 选做]]></title>
    <url>%2F2019%2F04%2F21%2FGXOI-GZOI2019-%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[广西/贵州 $OI$ . 题面Day 1Day 2 与或和 显然可以每一位分开做. 或就是用总子矩阵数目减去全 $0$ 子矩阵数目.与就是全 $1$ 子矩阵数目.单调栈经典问题. 时间复杂度 $O(32n^2)​$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7,inv2=(P+1)&gt;&gt;1;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=1e3+10;int n,a[MAXN][MAXN];int d[MAXN][MAXN];int ansand=0,ansor=0;int stk[MAXN],tp;int calc(int k,int v)//submatrix all of v&#123;#define val ((a[i][j]&gt;&gt;k)&amp;1) for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; if(val!=v) d[i][j]=0; else d[i][j]=d[i-1][j]+1; &#125; &#125; int s,res=0; for(int i=1;i&lt;=n;++i) &#123; tp=0; s=0; for(int j=1;j&lt;=n;++j) &#123; s=add(s,d[i][j]); while(tp &amp;&amp; d[i][stk[tp]]&gt;=d[i][j]) &#123; int del=mul(add(stk[tp],P-stk[tp-1]),add(d[i][stk[tp]],P-d[i][j])); s=add(s,P-del); --tp; &#125; res=add(res,s); stk[++tp]=j; &#125; &#125; return res;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) a[i][j]=read(); int tot=mul(n,n+1); tot=mul(tot,inv2); tot=mul(tot,tot); for(int k=0;k&lt;31;++k) &#123; int tmpand=calc(k,1); tmpand=mul(tmpand,1&lt;&lt;k); ansand=add(ansand,tmpand); int tmpor=add(tot,P-calc(k,0)); tmpor=mul(tmpor,1&lt;&lt;k); ansor=add(ansor,tmpor); &#125; cout&lt;&lt;ansand&lt;&lt;' '&lt;&lt;ansor&lt;&lt;endl; return 0;&#125; 宝牌一大堆 怎么又是 $mahjong$ …是不是可以专门出一类 麻将 $dp$ 啊. 七对子和国士无双可以单独做.七对子可以 $dp$ , $g(i,j)$ 表示考虑前 $i$ 种牌,组成 $j$ 个对子的最大得分.国士无双可以大力枚举一下哪张幺九牌有两张. 对于普通的 $3\times 4+2$ 的胡牌,把牌搞上标号,使得顺子的标号是连续的.记 $f[i][j][k][l][m][n]$ 表示考虑了前 $i$ 种牌,形成了 $j$ 个面子, $k$ 个雀头, $i-2,i-1,i$ 已经选了 $l,m,n$ 个时,前 $i-3$ 种牌能获得的最大得分. 转移时枚举一下 $i$ 这张牌不选/成刻子/成杠子/与 $i-2,i-1$ 成顺子的几种情况即可,注意判断合法性. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;ll g[35][35];ll f[35][5][2][5][5][5],ans;int a[35],c[5][5],d[35];bool shunend[]=&#123;0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0&#125;;void init()&#123; memset(f,0,sizeof f); memset(g,0,sizeof g); ans=0; for(int i=1;i&lt;=34;++i) d[i]=0,a[i]=4;&#125;// 1m 2m ... 9m 1p 2p ... 9p 1s 2s ... 9s E S W N Z B Fint id(char s[])&#123; if(s[0]=='E') return 28; if(s[0]=='S') return 29; if(s[0]=='W') return 30; if(s[0]=='N') return 31; if(s[0]=='Z') return 32; if(s[0]=='B') return 33; if(s[0]=='F') return 34; if(s[1]=='m') return s[0]-'0'; if(s[1]=='p') return s[0]-'0'+9; if(s[1]=='s') return s[0]-'0'+18; return 0;&#125;void upd(ll &amp;x,ll y)&#123; if(y&gt;x) x=y;&#125;ll dora(int idx,int cnt)&#123; if(d[idx]) return 1LL&lt;&lt;cnt; return 1LL;&#125;ll MaHu()&#123; ll res=0; f[1][0][0][0][0][0]=1; for(int i=1;i&lt;=34;++i) for(int j=0;j&lt;=4;++j) for(int k=0;k&lt;=1;++k) for(int l=0;l&lt;=4;++l) for(int m=0;m&lt;=4;++m) for(int n=0;n&lt;=4;++n) &#123; ll cur=f[i][j][k][l][m][n]; if(!cur) continue; if(i&lt;34) upd(f[i+1][j][k][m][n][0],cur*(i&gt;2?c[a[i-2]][l]*dora(i-2,l):1));//give up if(j&lt;4 &amp;&amp; a[i]-n&gt;=3) upd(f[i][j+1][k][l][m][n+3],cur);//kezi if(j&lt;4 &amp;&amp; a[i]-n&gt;=4) upd(f[i][j+1][k][l][m][n+4],cur);//gangzi if(j&lt;4 &amp;&amp; shunend[i] &amp;&amp; a[i]-n &amp;&amp; a[i-1]-m &amp;&amp; a[i-2]-l) upd(f[i][j+1][k][l+1][m+1][n+1],cur);//shunzi if(!k &amp;&amp; a[i]-n&gt;=2) upd(f[i][j][k+1][l][m][n+2],cur); if(i==34 &amp;&amp; j==4 &amp;&amp; k==1) &#123; ll s=cur*c[a[i]][n]*c[a[i-1]][m]*c[a[i-2]][l]; s*=dora(i,n)*dora(i-1,m)*dora(i-2,l); upd(res,s); &#125; &#125; return res;&#125;ll QiDuizi()&#123; g[0][0]=1; for(int i=1;i&lt;=34;++i) for(int j=0;j&lt;=7;++j) &#123; if(!g[i-1][j]) continue; upd(g[i][j],g[i-1][j]); if(j&lt;7) upd(g[i][j+1],g[i-1][j]*c[a[i]][2]*dora(i,2)); &#125; return g[34][7]*7;&#125;int yao[13]=&#123;1,9,10,18,19,27,28,29,30,31,32,33,34&#125;;ll GSWS()&#123; ll res=0; for(int i=0;i&lt;13;++i) &#123; if(a[yao[i]]==0) return 0; if(a[yao[i]]==1) continue; ll tmp=c[a[yao[i]]][2]*dora(yao[i],2); for(int j=0;j&lt;13;++j) &#123; if(i==j) continue; tmp*=c[a[yao[j]]][1]*dora(yao[j],1); &#125; upd(res,tmp); &#125; return res*13;&#125;int main()&#123; for(int i=0;i&lt;=4;++i) c[i][0]=1; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=4;++j) c[i][j]=c[i-1][j]+c[i-1][j-1]; int T=read(); while(T--) &#123; init(); char s[5]; while(1) &#123; scanf("%s",s); int x=id(s); if(x) --a[x]; else break; &#125; while(1) &#123; scanf("%s",s); int x=id(s); if(x) d[x]=1; else break; &#125; upd(ans,MaHu()); upd(ans,QiDuizi()); upd(ans,GSWS()); printf("%lld\n",ans); &#125; return 0;&#125; 特技飞行 无论怎样决策,所有交点的位置是确定的.所以 $c$ 的贡献可以和 $a,b$ 分开算. 所有合法决策最值,一定是一个使 对向交换 的次数最多,另一个使 对向交换 的次数最少. 计算 $a,b$ 的贡献时,交点的具体位置不重要,先只考虑 $y$ 的相对大小. 对于最多的情况,我们可以在 每个 交点处都选择 对向交换 .因为每个交点其实就是二元组 $(y_0,y_1)$ 的一个逆序对产生的.那么将每个逆序对的 $y_1$ 都交换,最后就不会有逆序对(交换排序),即满足要求. 对于最少的情况,可以发现对于 $y_1$ 中的每个置换,内部需要交换大小 $-1$ 次,各个置换独立,那么总交换次数为 $n-​$ 置换数目.找到的证明. 再来算 $c$ 的贡献.可以把所有点按 $y_1$ 从大到小依次加入 $set$ 中,以 $y_0$ 为关键字,这样能产生交点的点在 $set$ 中是一个前缀部分,合法就计算交点,不合法时就跳出,加入下一个点. 曼哈顿距离不太好搞,经典套路,转化成切比雪夫距离,就变成了问每个交点是否被一些矩形中的至少一个覆盖. 把点加入 $kdtree$ 中,每个矩形给其中的点打一打标记就好了.也可以离线后扫描线+树状数组. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const double eps=1e-10;int fcmp(double x)&#123; if(fabs(x)&lt;=eps) return 0; return x&gt;0?1:-1;&#125;const int MAXN=5e5+10;typedef pair&lt;int,int&gt; pii;#define mp make_pairint n,Y0[MAXN],Y1[MAXN],st,ed,is[MAXN],tot,id[MAXN],to[MAXN],k,vis[MAXN];ll A,B,C;double mn[MAXN][2],mx[MAXN][2];int flag[MAXN],D,ch[MAXN][2],marked[MAXN];// flag表示这个点以及其管辖的点都被标记了 marked表示这个点被标记了 set&lt;pii&gt; s;set&lt;pii&gt;::iterator it;struct point&#123; double p[2]; point()&#123;p[0]=p[1]=0;&#125; point(double x,double y)&#123;p[0]=x,p[1]=y;&#125; bool operator &lt; (const point &amp;rhs) const &#123; return p[D]==rhs.p[D]?p[D^1]&lt;rhs.p[D^1]:p[D]&lt;rhs.p[D]; &#125;&#125;a[MAXN];bool cmp(int a,int b)&#123; return Y1[a]&lt;Y1[b];&#125;void pushup(int o,int x)&#123; for(int i=0;i&lt;2;++i) &#123; mn[o][i]=min(mn[o][i],mn[x][i]); mx[o][i]=max(mx[o][i],mx[x][i]); &#125;&#125;int BuildTree(int l,int r,int d)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; D=d; nth_element(a+l,a+mid,a+r+1); int o=mid; for(int i=0;i&lt;2;++i) mn[o][i]=mx[o][i]=a[o].p[i]; if(l&lt;=mid-1) &#123; ch[o][0]=BuildTree(l,mid-1,d^1); pushup(o,ch[o][0]); &#125; if(mid+1&lt;=r) &#123; ch[o][1]=BuildTree(mid+1,r,d^1); pushup(o,ch[o][1]); &#125; return o;&#125;void update(int x,int y,int r,int o)&#123; if(!o || flag[o] || x+r&lt;mn[o][0] || x-r&gt;mx[o][0] || y+r&lt;mn[o][1] || y-r&gt;mx[o][1]) return; double mxd=0; mxd=max(mxd,fabs(x-mn[o][0])); mxd=max(mxd,fabs(x-mx[o][0])); mxd=max(mxd,fabs(y-mn[o][1])); mxd=max(mxd,fabs(y-mx[o][1])); if(fcmp(mxd-r)&lt;=0) &#123; flag[o]=1; return; &#125; double curd=max(fabs(x-a[o].p[0]),fabs(y-a[o].p[1])); if(!marked[o] &amp;&amp; fcmp(curd-r)&lt;=0) marked[o]=1; update(x,y,r,ch[o][0]); update(x,y,r,ch[o][1]);&#125;int dfs(int o)&#123; if(flag[o]) &#123; marked[o]=1; marked[ch[o][0]]=marked[ch[o][1]]=1; flag[ch[o][0]]=flag[ch[o][1]]=1; &#125; int res=marked[o]; if(ch[o][0]) res+=dfs(ch[o][0]); if(ch[o][1]) res+=dfs(ch[o][1]); return res;&#125;int main()&#123; n=read(),A=read(),B=read(),C=read(); st=read(),ed=read(); for(int i=1;i&lt;=n;++i) Y0[i]=read(); for(int i=1;i&lt;=n;++i) Y1[i]=read(); for(int i=n;i&gt;=1;--i) &#123; for(it=s.begin();it!=s.end() &amp;&amp; it-&gt;first &lt; Y1[i];++it) &#123; int j=it-&gt;second; double t=(double)(Y0[j]-Y0[i])/(Y1[i]-Y1[j]); double ox=(t*ed+st)/(t+1); double oy=(t*Y1[j]+Y0[j])/(t+1); double x=ox+oy,y=ox-oy; a[++tot]=point(x,y); &#125; s.insert(mp(Y1[i],i)); &#125; int rt=BuildTree(1,tot,0); k=read(); for(int i=1;i&lt;=k;++i) &#123; int ox=read(),oy=read(),r=read(); int x=ox+oy,y=ox-oy; update(x,y,r,rt); &#125; ll ans=dfs(rt)*C; ll ans1=ans+tot*A; for(int i=1;i&lt;=n;++i) id[i]=i; sort(id+1,id+1+n,cmp); ll rep=n; for(int i=1;i&lt;=n;++i) if(!vis[i]) &#123; --rep; for(int j=i;!vis[j];j=id[j]) vis[j]=1; &#125; ll ans2=ans1+(tot-rep)*(B-A); if(ans1&gt;ans2) swap(ans1,ans2); printf("%lld %lld\n",ans1,ans2); return 0;&#125; 逼死强迫症 求必须用两块 $1\times 1$ 的方案,转化一下,设 $f_i$ 表示任意用砖,铺满前 $i$ 列的方案数, $g_i$ 表示只用 $1\times 2$ 的砖铺满前 $i$ 列的方案数.那么最后的答案就是 $f_n-g_n$ . $g$ 的转移很简单, $g_i=g_{i-1}+g_{i-2},g_0=1,g_1=1​$ . $f$ 的转移呢?多出来一列时,若不在这一列用 $1\times 1$ 的砖,那么方案数为 $f_{i-1}+f_{i-2}$ . 若在这一列用 $1\times 1$ 的砖,那么为了填满前 $i$ 列,另外一块 $1\times 1$ 也必须用,并且只能放在第 $1\sim i-2​$ 列. 若这两块砖中间还有偶数列,那么它们只能在同一行,否则,只能在不同的一行.看下面的图片感性理解: 那么左边那块 $1\times 1$ 的左边只能用 $1\times 2$ 填满,方案数用 $g$ 计算,右边只能有 $1$ 种填法. 枚举右边那块 $1\times 1$放在第 $1,2$ 行,左边那块 $1\times 1$ 放在第 $j$ 列. 整理一下,就有 $f_i=f_{i-1}+f_{i-2}+2\times \sum_{j=1}^{i-2} g_{j-1}$ . 边界有 $f_1=1,f_2=2$ .把 $g$ 的前缀和, $g,f$ 一起用矩阵快速幂优化转移即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;struct matrix&#123; int v[6][6]; matrix()&#123;memset(v,0,sizeof v);&#125; matrix operator * (const matrix &amp;rhs) const &#123; matrix res; for(int i=0;i&lt;6;++i) for(int j=0;j&lt;6;++j) for(int k=0;k&lt;6;++k) res.v[i][j]=add(res.v[i][j],mul(v[i][k],rhs.v[k][j])); return res; &#125;&#125;;matrix fpow(matrix a,int b)&#123; matrix res; for(int i=0;i&lt;6;++i) res.v[i][i]=1; while(b) &#123; if(b&amp;1) res=res*a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;matrix trans,st;void setv(int x,int y)&#123; trans.v[x][y]+=1;&#125;void init()&#123; st.v[0][0]=5; st.v[1][0]=2; st.v[2][0]=3; st.v[3][0]=2; st.v[4][0]=1; st.v[5][0]=1;&#125;int main()&#123; setv(0,0),setv(0,1),setv(0,4),setv(0,5),setv(0,4),setv(0,5); setv(1,0); setv(2,2),setv(2,3); setv(3,2); setv(4,3); setv(5,4),setv(5,5); int T=read(); while(T--) &#123; int n=read(); if(n&lt;=3) &#123; if(n==1) cout&lt;&lt;0&lt;&lt;endl; else if(n==2) cout&lt;&lt;0&lt;&lt;endl; else if(n==3) cout&lt;&lt;2&lt;&lt;endl; continue; &#125; init(); st=fpow(trans,n-3)*st; printf("%d\n",add(st.v[0][0],P-st.v[2][0])); &#125; return 0;&#125; 旅行者 考虑将所有 感兴趣的城市 划分到两个集合 $A,B$ 中,从 $S$ 向 $A$ 中每个点连 $0$ 边,从 $B$ 中每个点向 $T$ 中连 $0$ 边. 这样从 $S$ 到 $T$ 的最短路长度就是 $A$ 与 $B$ 中两两最短路的最小值. 怎样划分才能使每对 感兴趣的城市 都被算入贡献中呢? 考虑划分 $logn$ 轮,每一轮将二进制第 $i$ 位上为 $0$ 的点划入 $A$ 中,否则划入 $B$ 中.这样两个不同的城市在至少一轮中被划分进了不同的集合,一定能产生贡献. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll inf=1e18;inline ll read()&#123; ll out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10,MAXM=7e5+10;int ecnt,head[MAXN],to[MAXM],nx[MAXM],val[MAXM];void addedge(int u,int v,int w)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; val[ecnt]=w; head[u]=ecnt;&#125;void init()&#123; ecnt=0; memset(head,0,sizeof head);&#125;int n,m,k;int city[MAXN],orghead[MAXN];ll dis[MAXN];bool vis[MAXN];typedef pair&lt;ll,int&gt; pli;#define mp make_pairll dij(int S,int T)&#123; for(int i=1;i&lt;=n+2;++i) &#123; dis[i]=inf; vis[i]=false; &#125; dis[S]=0; priority_queue&lt;pli&gt; q; q.push(mp(0,S)); while(!q.empty()) &#123; int u=(q.top()).second; q.pop(); if(vis[u]) continue; vis[u]=true; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(dis[u]+val[i]&lt;dis[v]) &#123; dis[v]=dis[u]+val[i]; q.push(mp(-dis[v],v)); &#125; &#125; &#125; return dis[T];&#125;int main()&#123; int Cases=read(); while(Cases--) &#123; init(); n=read(),m=read(),k=read(); for(int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); addedge(u,v,w); &#125; for(int i=1;i&lt;=k;++i) city[i]=read(); int rounds=1+(int)log2(n); int S=n+1,T=n+2; ll ans=inf; for(int p=0;p&lt;=rounds;++p) &#123; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) orghead[i]=head[city[i]]; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) addedge(city[i],T,0); else addedge(S,city[i],0); ans=min(ans,dij(S,T)); head[S]=0; for(int i=1;i&lt;=k;++i) if((city[i]&gt;&gt;p)&amp;1) head[city[i]]=orghead[i]; ecnt-=k; &#125; printf("%lld\n",ans); &#125; return 0;&#125; 旧词 先来考虑 $k=1$ 的部分,做法是将 $lca$ 处 $dep$ 的贡献摊到这个点到根的路径上. 具体来说将询问离线下来,按 $x$ 排序后就可以从小到大一个个加入点.每加入一个点的时候就把这个点到根的路径上点的权值都 $+1$ ,询问时就查询 $y$ 到根的路径上点的权值和. 考虑拓展到 $k&gt;1$ 的部分,沿用上面的思路,发现每次给路径上每个点权值 $+\ (dep_i^k-(dep_i-1)^k)$ 就好了. 这样就可以使 $lca$ 的权值恰好被摊到路径上,查询时仍然查询路径权值和就好了. 树剖+线段树维护一下,时间复杂度 $O(nlog^2n)$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b &gt;= P)? (a + b - P) : (a + b);&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;const int MAXN=5e4+10;int n,k,Q;int ecnt=0,head[MAXN],to[MAXN&lt;&lt;1],nx[MAXN&lt;&lt;1];inline void addedge(int u,int v)&#123; ++ecnt; to[ecnt]=v; nx[ecnt]=head[u]; head[u]=ecnt;&#125;int siz[MAXN],mxson[MAXN],top[MAXN],fa[MAXN],dep[MAXN],dfn[MAXN],rnk[MAXN],idx=0;void dfs1(int u,int Fa)&#123; dep[u]=dep[Fa]+1; siz[u]=1; fa[u]=Fa; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==Fa) continue; dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[mxson[u]]) mxson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; dfn[u]=++idx; rnk[idx]=u; if(mxson[u]) dfs2(mxson[u],tp); for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; if(v==fa[u] || v==mxson[u]) continue; dfs2(v,v); &#125;&#125;struct SegTree&#123; struct node &#123; int l,r; int sum,delta,tag; &#125;Tree[MAXN&lt;&lt;2];#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1] void pushup(int o) &#123; root.sum=add(lson.sum,rson.sum); &#125; void modifiy(int o,int c) &#123; root.tag=add(root.tag,c); root.sum=add(root.sum,mul(c,root.delta)); &#125; void pushdown(int o) &#123; if(root.tag) &#123; modifiy(o&lt;&lt;1,root.tag); modifiy(o&lt;&lt;1|1,root.tag); root.tag=0; &#125; &#125; void BuildTree(int o,int l,int r) &#123; root.l=l,root.r=r; root.tag=0; root.sum=0; if(l==r) &#123; root.delta=add(fpow(dep[rnk[l]],k),P-fpow(dep[rnk[l]]-1,k)); return; &#125; int mid=(l+r)&gt;&gt;1; BuildTree(o&lt;&lt;1,l,mid); BuildTree(o&lt;&lt;1|1,mid+1,r); root.delta=add(lson.delta,rson.delta); &#125; void update(int o,int L,int R,int c) &#123; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; modifiy(o,c); return; &#125; if(l&gt;R || L&gt;r) return; int mid=(l+r)&gt;&gt;1; pushdown(o); if(L&lt;=mid) update(o&lt;&lt;1,L,R,c); if(R&gt;mid) update(o&lt;&lt;1|1,L,R,c); pushup(o); &#125; int query(int o,int L,int R) &#123; int l=root.l,r=root.r; if(L&lt;=l &amp;&amp; r&lt;=R) return root.sum; if(l&gt;R || L&gt;r) return 0; int mid=(l+r)&gt;&gt;1; pushdown(o); int res=0; if(L&lt;=mid) res=add(res,query(o&lt;&lt;1,L,R)); if(R&gt;mid) res=add(res,query(o&lt;&lt;1|1,L,R)); return res; &#125;&#125;T;int ans[MAXN];struct query&#123; int x,y,id; bool operator &lt; (const query &amp;rhs) const &#123; return x&lt;rhs.x; &#125;&#125;q[MAXN];void path_upd(int x)&#123; while(top[x]!=1) &#123; T.update(1,dfn[top[x]],dfn[x],1); x=fa[top[x]]; &#125; T.update(1,dfn[top[x]],dfn[x],1);&#125;int path_query(int x)&#123; int res=0; while(top[x]!=1) &#123; res=add(res,T.query(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; res=add(res,T.query(1,dfn[top[x]],dfn[x])); return res;&#125;int main()&#123; n=read(),Q=read(),k=read(); for(int i=2;i&lt;=n;++i) &#123; int f=read(); addedge(f,i); &#125; for(int i=1;i&lt;=Q;++i) &#123; q[i].x=read(); q[i].y=read(); q[i].id=i; &#125; sort(q+1,q+1+Q); dfs1(1,0); dfs2(1,1); T.BuildTree(1,1,n); int lstx=0; for(int i=1;i&lt;=Q;++i) &#123; int x=q[i].x,y=q[i].y; for(int j=lstx+1;j&lt;=x;++j) path_upd(j); ans[q[i].id]=path_query(y); lstx=x; &#125; for(int i=1;i&lt;=Q;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>dp计数</tag>
        <tag>树链剖分</tag>
        <tag>矩阵优化</tag>
        <tag>位运算</tag>
        <tag>最短路</tag>
        <tag>差分</tag>
        <tag>单调栈</tag>
        <tag>棋牌</tag>
        <tag>kdtree</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest 2019]]></title>
    <url>%2F2019%2F04%2F21%2FTenka1-Programmer-Contest-2019%2F</url>
    <content type="text"><![CDATA[感觉这场打得好烂… C Stones 比较弱智.最后一定是连续一段黑之后连续一段白.枚举一下这个分界位置就好了. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=2e5+10;char s[MAXN];int sum1[MAXN],sum2[MAXN];int main()&#123; int n=read(); scanf("%s",s+1); int ans; for(int i=1;i&lt;=n;++i) &#123; if(s[i]=='.') ++sum1[i];//white else ++sum2[i]; sum1[i]+=sum1[i-1]; sum2[i]+=sum2[i-1]; &#125; ans=sum2[n]; for(int i=1;i&lt;=n;++i) ans=min(ans,i-sum1[i]+n-i-(sum2[n]-sum2[i-1])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D Three Colors 两个颜色一起 $dp$ 状态数目可能很大,考虑能不能每次只 $dp$ 一种颜色. 用所有染色方案 $3^n$ 减去不合法的方案数就好了. 记所有数的和为 $sum$ ,那么不合法的方案有 $R\geq sum/2,G\geq sum/2,B\geq sum/2$ 三种. 记 $f(i,j)$ 表示前 $i$ 个数,红色数之和为 $j$ 的方案数.另外两种颜色计算方法一样,直接 $\times 3$ . 注意若 $sum$ 为偶数,这里有两个颜色都恰好等于 $sum/2$ 的方案被减了两次,要加回来,这部分是 $g(n,sum/2)\cdot {3\choose 2}$ . $f$ 转移时可以填三种颜色,而 $g$ 只能填两种. 时间复杂度为 $O(n\cdot sum)$ ,实际肯定跑不满.空间可以滚动优化一下(其实 $f,g$ 用一个数组也就 $100\ MB$). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;void upd(int &amp;x,int y)&#123; x+=y; x=(x%P+P)%P;&#125;const int MAXN=329;int a[MAXN],sum[MAXN],n;int ans=0;int f[2][MAXN*MAXN],g[2][MAXN*MAXN];int main()&#123; n=read(); for(int i=1; i&lt;=n; ++i) sum[i]=sum[i-1]+(a[i]=read()); ans=fpow(3,n); int cur=0; g[cur][0]=f[cur][0]=1; for(int i=1;i&lt;=n;++i) &#123; for(int j=0;j&lt;=sum[i];++j) f[cur^1][j]=g[cur^1][j]=0; for(int j=0;j&lt;=sum[i-1];++j) if(f[cur][j]) &#123; upd(f[cur^1][j+a[i]],f[cur][j]); upd(f[cur^1][j],mul(2,f[cur][j])); upd(g[cur^1][j+a[i]],g[cur][j]); upd(g[cur^1][j],g[cur][j]); &#125; cur^=1; &#125; for(int i=(sum[n]+1)&gt;&gt;1;i&lt;=sum[n];++i) upd(ans,-mul(3,f[cur][i])); if(!(sum[n]&amp;1)) upd(ans,mul(3,g[cur][sum[n]&gt;&gt;1])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E Polynomial Divisors 比赛时一直 $WA$ 后面几个点.心态有些崩.后来改了些莫名其妙的地方就过了??? 结论:题述性质成立当且仅当这个多项式在模 $p$ 意义下能被 $x^p-x$ 整除.于是只需要验证 $[2,n]$ 以内的质数,再加上所有 $a_i$ 的 $gcd$ 的质因数就好了. 证明:充分性显然.必要性:在模 $p$ 意义下, $0,1,\dots p-1$ 都是 $f$ 的根. 那么这个多项式一定有因式 $x(x-1)(x-2)\dots (x-(p-1))$. 这个因式的根与 $x^p-x$ 的根完全相同,而它们最高项系数也相同,在模 $p$ 意义下这两个式子是等价的.于是多项式 $f$ 就一定有因式 $x^p-x$ . 这部分的证明好像在 $math$ 那个题里面有? F Banned X 咕了.]]></content>
      <tags>
        <tag>数学</tag>
        <tag>dp计数</tag>
        <tag>atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烷烃计数]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%83%B7%E7%83%83%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[大概 $OIer$ 上化学课都会想到这个吧? 今天化学课教烷烃的同分异构体,我:这烷烃不就是颗树嘛?同分异构体数目不就是无标号树的个数嘛? $prufer$ 序列随便搞一下就能算吧??? 然后发现一个碳旁边最多连四个碳,度数还要 $\leq 4$. 然后我就问旁边数竞小哥:你知道这个东西的通项嘛?他:我来找下规律.我:这东西(指数树)的规律大概率找不出来吧…他不信邪,结果找了一节课,未果,寻病终… 然后在 $dalao$ 们的博客中学习了一下.记 $f(i,j)$ 表示 $i$ 个点的有根树,根节点的度数为 $j$ 的方案数目. 在枚举儿子节点时,为了避免算重,按照子树大小从大到小来枚举.先枚举儿子中最大的子树大小 $size$ ,再枚举有 $k$ 个这样大小的儿子.记 $s=\sum_{i=0}^{j-1} f(size,i)$ ,即每个这样的子树都有 $s$ 种方案可选.那么给 $k$ 个子树安排一下方案,就相当于把 $k$ 个球放入 $s$ 个无差别盒子中,方案数为 ${s+k-1\choose k}$ . 那么转移方程就有 $f(i,j)=\sum f(i-k\times size,j-k)\cdot {s+k-1\choose k}$ . 如果是数烷基,就是无根树,直接就像上面这样算, $ans=\sum_{k=0}^3 f(n,k).​$ 如果数的是烷烃,就是无根树,所以钦定树的重心作为根节点.那么在转移时就要注意 $2\cdot size&lt;i$ ,保证根为重心. 另外,在最后计算答案时,注意到当 $n$ 为偶数时,它有两个重心,那么两边的子树可以交换,多乘上 $p_k={\sum_{k’=0}^{k-1}f(\frac n 2,k’)+1\choose 2}$. 最后就有 $ans=\sum_{k=0}^3 f(n,k)+[n\equiv 0\mod2]\cdot p_k$ .]]></content>
      <tags>
        <tag>dp计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1140]]></title>
    <url>%2F2019%2F04%2F18%2FCF1140%2F</url>
    <content type="text"><![CDATA[$Div.2$ CF1140C Playlist 将元素按 $b$ 从大到小排序,然后从后往前依次加入,每加入一个元素时它的 $b$ 都是当前最小的. 此时需要钦定选择这个元素作为最小的 $b$ ,并在已有元素中选出 $k-1$ 个 $t$ 值最大的. 这个东西用个堆维护一下当前前 $k-1$ 大的 $t$ 值就好了. CF1140D Minimum Triangulation 肯定会有一个很直观的想法:全部都以 $1$ 为一个顶点,然后 $(1,2,3),(1,3,4) \dots (1,n-1,n)$ 这样来剖. 这样做的确是正确的,即权值一定是最小的.为什么呢? 考虑若有 $x&lt;y$ ,那么把方案 $(1,n,x),(n,x,y)$ 换成 $(1,n,y),(1,x,y)$ ,总权值会减小. 于是可以直接将 $x$ 换到 $n-1$ ,然后将 $(1,n-1,n)$ 这个三角形直接割掉,对剩下的 $n-1$ 边形继续做上述操作. 这样做的话,所有的方案就一定是 $(1,2,3),(1,3,4) \dots (1,n-1,n)$ 这样的形式了. 另一个做法是 $O(n^3)$ 的区间 $dp$ ? CF1140E Palindrome-less Arrays 任意位置都不能出现长度 $\geq 3$ 的奇回文串,其实也就等价于不出现长度为 $3$ 的回文串. 也就是说总有 $a_i\not=a_{i+2}$ .这样显然可以奇偶分开算,将两个序列各自的合法方案数目乘起来. 把奇(偶)数位置拿出来,就是要求相邻两个位置都不同的方案数. 把连续的一段 $-1$ 看成一块,考虑每一块 $(a,-1,-1,\dots,-1,b)$ 怎么算方案数.首尾可能会出现没有 $a,b$ 的情况,枚举第一个/最后一个元素,算中间的就可以了(其实这部分细节挺多的?).所以下面都假定 $a,b$ 存在. 每块的方案数只与 $-1$ 的个数 $x$ 以及 $a,b$ 是否相等有关.记 $f(x)$ 表示 $a\not =b$ 时的方案数, $g(x)$ 表示相等时. 若 $x$ 为奇,枚举最中间的元素,就有:$g(x)=g(x/2)^2+(k-1)f(x/2)^2,f(x)=2f(x/2)g(x/2) + (k-2)f(x/2)^2$ . 若 $x$ 为偶,枚举第一个元素即可将 $x$ 变为奇.$g(x)=(k-1)f(x-1),f(x)=g(x-1)+(k-2)f(x-1)$ . 边界显然有 $f(0)=1,g(0)=0$ . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;const int MAXN=2e5+10;int k;int f[MAXN],g[MAXN];int F(int);int G(int);int calc(int l,int r,int *a,int n)&#123; if(r&gt;=n) &#123; int len=r-l-1,res=1; if(l&lt;0) --len,res=k; if(len==0) return res; int fx=F(len-1),gx=G(len-1); return mul(res,add(gx,mul(k-1,fx))); &#125; if(l&lt;0) &#123; if(r-l==1) return 1; int fx=F(r-l-2),gx=G(r-l-2); return add(gx,mul(k-1,fx)); &#125; return a[l]==a[r]?G(r-l-1):F(r-l-1);&#125;int solve(int *a,int n)&#123; int res=1,lst=-1; for(int i=0;i&lt;n;++i) &#123; if(a[i]==-1) continue; res=mul(res,calc(lst,i,a,n)); lst=i; &#125; res=mul(res,calc(lst,n,a,n)); return res;&#125;int n,a[MAXN],b[MAXN],siza,sizb;int main()&#123; n=read(); k=read(); for(int i=1;i&lt;=n;++i) &#123; f[i]=g[i]=-1; int x=read(); if(i&amp;1) a[siza++]=x; else b[sizb++]=x; &#125; int ans=1; ans=mul(ans,solve(a,siza)); if(ans) ans=mul(ans,solve(b,sizb)); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;int F(int x)&#123; if(!x) return 1; if(f[x]!=-1) return f[x]; int &amp;res=f[x]; if(x&amp;1) &#123; res=mul(2,mul(F(x&gt;&gt;1),G(x&gt;&gt;1))); res=add(res,mul(k-2,mul(F(x&gt;&gt;1),F(x&gt;&gt;1)))); return res; &#125; else return res=add(G(x-1),mul(k-2,F(x-1))); &#125;int G(int x)&#123; if(!x) return 0; if(g[x]!=-1) return g[x]; int &amp;res=g[x]; if(x&amp;1) &#123; res=mul(G(x&gt;&gt;1),G(x&gt;&gt;1)); res=add(res,mul(k-1,mul(F(x&gt;&gt;1),F(x&gt;&gt;1)))); return res; &#125; else return res=mul(k-1,F(x-1));&#125; CF1140F Extending Set of Points 可以发现它的 $Extend$ 操作就是将每三个点加一个点补成一个矩形,直到每个可补的位置都有点为止.这里的三个点必须要有两个点的连线是平行于坐标轴的. 给每个 $x,y$ 坐标都建一个节点,加入 $(x,y)$ 就将对应的两个节点连起来,容易发现每个连通分量的贡献为不同的 $x$ 坐标个数乘上不同的 $y$ 坐标个数,此时的答案就是每个连通分量的贡献之和. 这个东西用个并查集维护,插入点很简单,删除点似乎不太好做?此时可以想到线段树分治,用线段树给每个点影响的时间区间 $(l,r)$ 打上对应的标记就好了. 打好标记,算答案的时候,递归到一个节点时,就让上面的所有标记生效,退出时再撤销就好了. 注意这里有撤销操作,需要避免路径压缩的使用.用按秩合并优化就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;typedef pair&lt;int,int&gt; pii;const int MAXN=6e5+10;int siz[MAXN],sizx[MAXN],sizy[MAXN];#define tot(x) 1LL*sizx[x]*sizy[x]int fa[MAXN];int Find(int x)&#123; return x==fa[x]?x:Find(fa[x]);&#125;pii stk[MAXN];int tp=0;ll ans=0;void Merge(int x,int y)&#123; x=Find(x),y=Find(y); if(x==y) return; if(siz[x]&lt;siz[y]) swap(x,y); ans-=tot(x); ans-=tot(y); fa[y]=x; siz[x]+=siz[y],sizx[x]+=sizx[y],sizy[x]+=sizy[y]; ans+=tot(x); stk[++tp]=make_pair(x,y);&#125;void Split(int x,int y)&#123; ans-=tot(x); fa[y]=y; siz[x]-=siz[y],sizx[x]-=sizx[y],sizy[x]-=sizy[y]; ans+=tot(x); ans+=tot(y);&#125;int n;map&lt;pii,int&gt; mp;vector&lt;pii&gt; Tree[MAXN&lt;&lt;1];set&lt;pii&gt; s;#define root Tree[o]#define lson Tree[o&lt;&lt;1]#define rson Tree[o&lt;&lt;1|1]void modifiy(int o,int l,int r,int L,int R,pii c)&#123; if(l&gt;R || L&gt;r) return; if(L&lt;=l &amp;&amp; r&lt;=R) &#123; root.push_back(c); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) modifiy(o&lt;&lt;1,l,mid,L,R,c); if(R&gt;mid) modifiy(o&lt;&lt;1|1,mid+1,r,L,R,c);&#125;void solve(int o,int l,int r)&#123; int curt=tp; int sz=root.size(); for(int i=0;i&lt;sz;++i) Merge(root[i].first,root[i].second); if(l==r) printf("%I64d ",ans); else &#123; int mid=(l+r)&gt;&gt;1; solve(o&lt;&lt;1,l,mid); solve(o&lt;&lt;1|1,mid+1,r); &#125; while(tp&gt;curt) &#123; Split(stk[tp].first,stk[tp].second); --tp; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) &#123; int x=read(),y=read()+300001; fa[x]=x,siz[x]=1,sizx[x]=1; fa[y]=y,siz[y]=1,sizy[y]=1; pii k=make_pair(x,y); if(s.find(k)==s.end()) &#123; mp[k]=i; s.insert(k); &#125; else &#123; modifiy(1,1,n,mp[k],i-1,k); mp[k]=0; s.erase(k); &#125; &#125; set&lt;pii&gt;::iterator it; for(it=s.begin();it!=s.end();++it) &#123; pii k=*it; modifiy(1,1,n,mp[k],n,k); &#125; solve(1,1,n); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>codeforces</tag>
        <tag>dp计数</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190417]]></title>
    <url>%2F2019%2F04%2F18%2Ftest20190417%2F</url>
    <content type="text"><![CDATA[测试. $heap$ 有多少个节点数目为 $n​$ ,权值为 $1\sim n​$ 且互不相同的二叉堆?答案对 $10^9+7​$ 取模. $n\leq 10^9​$ . $O(n)$ 的做法十分简单, 先搞出每个节点的 $siz$ ,记 $f(i)$ 表示子树 $i$ 内用 $siz_i$ 个权值能形成的合法二叉堆数目. 转移显然有 $f(i)={siz_i\choose siz_{2i}}\cdot f(2i)\cdot f(2i+1)$ ,叶子节点 $f(i)=1$ . 把组合数拆开,算算贡献,可以发现 $f(1)=\frac {n!} {\prod siz_i}$ .考虑 $siz$ 连乘积怎么算. 注意到一个点的左右子树至少有一个是满的二叉树(每一层填满),那么就可以先求出每种满二叉树的答案,此时递归入另一个子树继续计算就可以了.这部分的时间复杂度为 $O(logn)​$ . 还有一个 $n!​$ 需要计算.分块打下表,就能很快求出啦. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=1e9+7;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;int m=1000000;int calcfac(int x) &#123; int pos=x/m; int s=blockfac[pos]; for(int i=pos*m+1;i&lt;=x;++i) s=mul(s,i); return s;&#125;int n;map&lt;int,int&gt; mp;int solve(int x)//x个点,x个互异权值,siz连乘积&#123; if(x&lt;=1) return 1; if(mp.find(x)!=mp.end()) return mp[x]; int z=(int)(log2(x)); z=1&lt;&lt;z; int y=min(z-1,x-z/2); return mp[x]=mul(x,mul(solve(y),solve(x-y-1)));&#125;int main()&#123; freopen("heap.in","r",stdin); freopen("heap.out","w",stdout); n=read(); cout&lt;&lt;mul(calcfac(n),(inv(solve(n))))&lt;&lt;endl; return 0;&#125; 这里用了另一种等价的做法,意义不是很明显?略去了表的数据. $secret$ 待更. $tree$ 待更.]]></content>
      <tags>
        <tag>dp计数</tag>
        <tag>test</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test20190416]]></title>
    <url>%2F2019%2F04%2F17%2Ftest20190416%2F</url>
    <content type="text"><![CDATA[来自 $GDOI​$ 的模拟题? 题面 $graph$ 貌似是第一次在考试中遇到提答题? 这题看上去十分正常,却出成提答,就是让你乱搞的…题解给的做法就是退火之类的乱搞. 随便估价乱搞一下就可以获得 $80+$ 的好成绩? $guess$ 自己的联想发散能力还是有问题,没看出可以建网络流模型,只会打暴力… 正解:要求的就是所有合法配对方案中,出现原来配对情况的最小数目. 先离散化一下数字大小,建一个费用流的模型,从 $S$ 向左边每个数字连其在 $x$ 坐标中出现的次数作为流量, $0$ 作为费用的边. $y$ 坐标连类似的边连向 $T$ .中间对于每个原来有的配对,连一条流量为 $1$ ,费用为 $1$ 的边.这样就限制了不会出现重复的配对. 跑一遍 $mcmf$ 即为答案. $room$ 最开始想到最小割去了..然后发现好像不太现实,暴力转移的 $dp$ 倒是很普及… 设 $f[i][j][k]$ 表示已经走了前 $i$ 层,第 $i$ 层开的门分别为 $j,k​$ 时的最小体力花费. 这个东西显然可以 $O(nm^4)$ 大力转移. $f[1][j][k]=t[1][j]+t[1][k]$$f[i][j][k]=\min_{x\not = y} f[i-1][x][y]+K\cdot (|j-x|+|k-y|),2\leq i \leq n.​$ 后两维交换是没有影响的,所以在枚举是可以直接钦定 $j&lt;k,x&lt;y$ ,优化了 $16$ 倍常数.这样就有 $60pts$ 了. $100pts?$ 转移时允许在同层转移,形成一个类似前缀 $\min$ 的优化,即可做到 $O(nm^2)$ . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define rg registerusing namespace std;typedef long long ll;const int inf=1e9;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=329;int n,m,K;int t[MAXN][MAXN];int f[MAXN][MAXN][MAXN];void solve()&#123; int ans=inf; memset(f,0x7f,sizeof f); for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) f[1][j][k]=t[1][j]+t[1][k]; for(rg int i=2;i&lt;=n;++i) &#123; for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) f[i][j][k]=min(K+min(f[i][j-1][k],f[i][j][k-1]),f[i-1][j][k]); for(rg int j=m-1;j&gt;=1;--j) for(int k=m;k&gt;j;--k) f[i][j][k]=min(f[i][j][k],K+min(f[i][j+1][k],f[i][j][k+1])); for(rg int j=1;j&lt;=m;++j) for(rg int k=j+1;k&lt;=m;++k) f[i][j][k]+=t[i][j]+t[i][k]; &#125; for(rg int j=1;j&lt;m;++j) for(rg int k=j+1;k&lt;=m;++k) ans=min(ans,f[n][j][k]); cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; freopen("room.in","r",stdin); freopen("room.out","w",stdout); n=read(),m=read(),K=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) t[i][j]=read(); solve(); return 0;&#125; 可以滚掉第一维?空间没卡的话就随便吧…]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>近似算法</tag>
        <tag>test</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1153]]></title>
    <url>%2F2019%2F04%2F16%2FCF1153%2F</url>
    <content type="text"><![CDATA[$Div.2$ CF1153B Serval and Toy Bricks 贪心+构造. 能放行 $\max$ 而不爆列 $\max$ 的位置都放行 $\max$ , 能放列 $\max$ 而不爆行 $\max$ 的位置都放列 $\max$ . 这样每个位置显然不会被定为两个不同的值.对于其他有而未放的位置直接都放 $1$ 就好了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=128;int n,m,H;int a[MAXN],b[MAXN];int c[MAXN][MAXN],h[MAXN][MAXN];int main()&#123; n=read(),m=read(),H=read(); for(int i=1;i&lt;=m;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) b[i]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) h[i][j]=read(); for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; if(h[i][j]) &#123; if(a[j]&lt;=b[i]) c[i][j]=a[j]; else c[i][j]=b[i]; &#125; printf("%d ",c[i][j]); &#125; puts(""); &#125; return 0;&#125; CF1153C Serval and Parenthesis Sequence 贪心+构造.显然可以将左括号,右括号的权值分别赋为 $1,-1$. 那么容易发现题中限制条件就是权值前缀和 $sum(n)=0,sum(i)&gt;0,\forall i&lt;n$. 将所有未确定的位置赋为 $1$ ,可以算出 $sum(n)=k$ ,需要将 $\frac k 2$ 个位置改为 $-1$. 从后往前贪心改,能改的位置就改.判一下不合法的情况, $k$ 为奇数,负数或不够改. 改完后再从前往后 $check$ 一次就可以了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define GG return puts(":("),0;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int n;char buf[MAXN];int a[MAXN];int main()&#123; n=read(); scanf("%s",buf+1); int k=0,tot=0; for(int i=1;i&lt;=n;++i) &#123; if(buf[i]==')') --k,a[i]=-1; else if(buf[i]=='(') ++k,a[i]=1; else ++k,a[i]=1,++tot; &#125; if(k&lt;0 || k%2==1 || k/2&gt;tot) GG for(int i=n;i&gt;=1 &amp;&amp; k&gt;0;--i) &#123; if(buf[i]=='?') a[i]=-1,k-=2; &#125; int sum=0; for(int i=1;i&lt;n;++i) &#123; sum+=a[i]; if(sum&lt;=0) GG &#125; for(int i=1;i&lt;=n;++i) &#123; if(a[i]==1) putchar('('); else putchar(')'); &#125; puts(""); return 0;&#125; CF1153D Serval and Rooted Tree 树形 $dp$ .(一定思维难度?) 考虑一颗子树,若其中有 $p$ 个叶子节点,任意选择 $p$ 个互不相同的权值,经过最优排列后,这个根节点的权值的相对大小,即排名,一定是确定的,即与选择了哪些权值无关. 那么记 $f_i$ 表示给子树 $i$ 中的叶子节点最优赋值后,节点 $i$ 上的权值是这些叶子节点权值中的第 $f_i$ 大. 对于叶子节点 ,显然 $f_u=1$ . 若操作符为 $\min$ ,可以证明感性理解, $f_u=\sum f_v$ .若操作符为 $\max$ ,可以证明感性理解, $f_u=\min f_v$ ,其中 $v$ 为 $u$ 的儿子. 共有 $k$ 个叶子节点,最后答案即为 $k+1-f_1$ ,即全部可用的权值的第 $f_1$ 大. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int MAXN=3e5+10;int head[MAXN],nx[MAXN],to[MAXN],ecnt=0;inline void addedge(int u,int v)&#123; ++ecnt; nx[ecnt]=head[u]; to[ecnt]=v; head[u]=ecnt;&#125;int n;int opt[MAXN],f[MAXN],outdeg[MAXN],k=0;void dfs(int u)&#123; if(!outdeg[u]) &#123; ++k; f[u]=1; return; &#125; if(opt[u]==1) f[u]=MAXN+1; for(int i=head[u];i;i=nx[i]) &#123; int v=to[i]; dfs(v); if(!opt[u]) f[u]+=f[v]; else f[u]=min(f[u],f[v]); &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i) opt[i]=read(); for(int i=2;i&lt;=n;++i) &#123; int fa=read(); addedge(fa,i); ++outdeg[fa]; &#125; dfs(1); cout&lt;&lt;k+1-f[1]&lt;&lt;endl; return 0;&#125; CF1153F Serval and Bonus Problem 概率/期望,计数, $dp$ . 随便在线段上钦定 $2n$ 个点,分割成 $2n+1$ 段区间,所以每段区间的期望长度就是 $\frac l {2n+1}$ .于是只需要再乘上一段区间至少被 $k$ 条线段覆盖的概率就好了. 设 $f(i,j)$ 表示考虑 $i$ 个端点,第 $i$ 个端点后面的区间恰好被 $j$ 条线段所覆盖的方案数.转移时枚举 $i$ 是作为左端点还是右端点, $O(n^2)$ 大力转移. 最后将所有合法方案数目求和,除以 $f(2n,0)$ 得到概率. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read()&#123; int out=0,fh=1; char jp=getchar(); while ((jp&gt;'9'||jp&lt;'0')&amp;&amp;jp!='-') jp=getchar(); if (jp=='-') fh=-1,jp=getchar(); while (jp&gt;='0'&amp;&amp;jp&lt;='9') out=out*10+jp-'0',jp=getchar(); return out*fh;&#125;const int P=998244353;inline int add(int a,int b)&#123; return (a + b) % P;&#125;inline int mul(int a,int b)&#123; return 1LL * a * b % P;&#125;int fpow(int a,int b)&#123; int res=1; while(b) &#123; if(b&amp;1) res=mul(res,a); a=mul(a,a); b&gt;&gt;=1; &#125; return res;&#125;int inv(int x)&#123; return fpow(x,P-2);&#125;const int MAXN=2019&lt;&lt;1;int n,l,k;int fac[MAXN];int f[MAXN][MAXN];int main()&#123; n=read(),k=read(); l=read(); int perl=mul(l,inv(2*n+1)); fac[0]=1; for(int i=1;i&lt;=n;++i) fac[i]=mul(fac[i-1],i); f[0][0]=1; for(int i=0;i&lt;2*n;++i) &#123; for(int j=n&lt;i?n:i;j&gt;=0;--j) &#123; f[i+1][j+1]=add(f[i+1][j+1],f[i][j]); if(j) f[i+1][j-1]=add(f[i+1][j-1],mul(f[i][j],j)); &#125; &#125; int ans=0; for(int i=1;i&lt;2*n;++i) for(int j=k;j&lt;=n;++j) &#123; int tmp=mul(f[i][j],f[2*n-i][j]); tmp=mul(tmp,fac[j]); ans=add(ans,tmp); &#125; cout&lt;&lt;mul(ans,mul(perl,inv(f[2*n][0]))); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>树形dp</tag>
        <tag>codeforces</tag>
        <tag>dp计数</tag>
        <tag>构造</tag>
        <tag>概率/期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2019游记]]></title>
    <url>%2F2019%2F04%2F11%2FSCOI2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[真游记. $Day\ -3$ $NamelessOIer$ 在写退役记 .毕姥爷:你写一篇退役记,进队了来看,岂不是很爽? 奶一口 NamelessOIer 进队. $Day\ -2$ 怎么回事啊,考前天天考一些奥妙重重的数学题,自闭了. 我:省选前打几道数据结构题练练手.旁边的 achen :我刚刚写到数据结构写多了让人退役. 被钦点退役了. $Day\ -1$ 背了背笔试,据说 $SCOI$ 不上机笔试?快捷键警告. $Day\ 0$ 早上破天荒地去食堂吃了顿饭,也遇到了很多熟人.但大家的心境似乎不太一样呢… $noip$ 考完后还说着有半年才省选,转眼间也就到了呢… $Day\ 1$ 看完题,啥思路都没有…先写了后两个题的暴力,然后再看第一题. 发现其实就是一个像九连环或者汉诺塔之类的递归式子的题目？迅速写完 $50$ 分,然后开始想后面的部分. 可能这就是思维江化吧,觉得输入可能很大,就以为是读入的时候取模,高精是啥?推了很久,感觉很不可做.(不是自己都说了像九连环嘛…) 于是又把后面的部分分写了一点,大概还有 $15$ 分钟下考的样子?发现 $T1$ 的复杂度跑所有点都是可以的,带个高精就好了… 于是迅速 $rush$ 了一个高精,并且和前面的部分分情况做,又过了一次大样例. 预计 $50/100+20+30=100/150$ ,下午看分: $0+20+20=40$. $T3$ 挂了 $10分$ ,$T1$ 直接 $fst$ 了???怎么目前为止每次 $D1T1$ 都 $fst$ 啊??? 心态有些炸裂. $Day\ 2$ 也不指望能翻盘了.把自己能打的打好就可以了吧. 开题之后,误以为 $T1$ 非常普及,打了将近个一小时后发现是假的… 迅速写了个最暴力的 $O(n^3)$ 暴力,去看后面两个题. 姿势水平不够,依然只能打暴力. $T2$ 的暴力写了 $6kb$ , $T3$ 写了个暴力+线性基的部分分. 回过来看 $T1$ ,发现直接用最大子段和做是 $O(nm)$ 的,但我觉得直接把前面的线段树改一下,也就多个 $log$ 啊? 写完之后才发现这一档是 $n,m\leq 10^4$…测了一下自己的 $O(nmlogn)$ ,跑了 $7s,O2\ 1.7s$ ,但 $T1$ 偏偏 $2s$ ,无优化? 钦定卡常可还行?觉得自己改成 $O(nm)$ 也不太稳,于是就没有写,把 $T2$ 的树剖+树状数组的暴力再看了几遍… 预估 $20+40+40=100$ ,实际: $20+40+20=80$. $T3$ 线性基求秩咋挂的啊…感觉暴力挂掉的可能更大啊… 后记 已编辑并删除部分过激言论. 今年我们学校 achen 以女选手的身份进队,虽然以她的水平这次其实也有一些失误的? NamelessOIer 和 autoint都在 $40$ 名左右,刚好可以买 $D$ 的样子??? 我两次比赛挂了两次 $D1T1$ ,不知道被踩到多少名去了.技不如人,甘拜下风. 也有想过要不要就此退役呢…毕竟我的文化课水平也不算太低吧?回去还是可以苟活的吧? 在 $OI$ 上,我究竟有什么资本去和他们竞争呢?论投入的时间,在本弱校,一周也就一天的竞赛课,还是拆开上的.天天被常规作业折磨得死去活来,每天 $6$ 节晚自习一上,直接自闭. 论个人水平,我现在的水平啥也不能算吧.论氛围,客观来讲,本校的竞赛氛围确实不咋地.对于一些自视甚高的所谓高人,我真的只能用无话可说来评价吧. 你们尽可以放肆嘲讽我,但在此之前还是先努力提高自己的水平比较重要吧,为什么一定要拿出一副胜者的姿态,占据着高地来批判我呢? 想了很久,也找人聊了一会.觉得自己还是得继续.何必畏首畏尾,投鼠忌器?爆了 $2$ 次 $fst$ 又怎样?没必要自己给自己设置心理障碍吧. 当然,自己也清楚,如果还是延续以前的节奏,继续在这种局面下挣扎,那还不如就此原地退役. 蚕食掉了别人的信任,就别再总当别人是笨蛋啊. 我可以承担善意的祝福与期望,但也奉劝部分人,别总是冠冕堂皇地把自己的梦做在别人的身上.任你徒耗口舌,我的水平也就在那里,不多也不少,还是我自己更清楚吧. 各位, $NOIP\ 2019$ ,有缘再会. 高处还有一丝微弱的亮色,便也要虔诚地奔往光明所在.没能踏足群山之巅又如何,那漫漫雪地上也留下了属于渺小攀登者自己的痕迹.]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
